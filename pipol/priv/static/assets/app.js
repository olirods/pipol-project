(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to2, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // vendor/topbar.js
  var require_topbar = __commonJS({
    "vendor/topbar.js"(exports, module) {
      (function(window2, document2) {
        "use strict";
        (function() {
          var lastTime = 0;
          var vendors = ["ms", "moz", "webkit", "o"];
          for (var x = 0; x < vendors.length && !window2.requestAnimationFrame; ++x) {
            window2.requestAnimationFrame = window2[vendors[x] + "RequestAnimationFrame"];
            window2.cancelAnimationFrame = window2[vendors[x] + "CancelAnimationFrame"] || window2[vendors[x] + "CancelRequestAnimationFrame"];
          }
          if (!window2.requestAnimationFrame)
            window2.requestAnimationFrame = function(callback2, element) {
              var currTime = (/* @__PURE__ */ new Date()).getTime();
              var timeToCall = Math.max(0, 16 - (currTime - lastTime));
              var id = window2.setTimeout(function() {
                callback2(currTime + timeToCall);
              }, timeToCall);
              lastTime = currTime + timeToCall;
              return id;
            };
          if (!window2.cancelAnimationFrame)
            window2.cancelAnimationFrame = function(id) {
              clearTimeout(id);
            };
        })();
        var canvas, currentProgress, showing, progressTimerId = null, fadeTimerId = null, delayTimerId = null, addEvent = function(elem, type, handler) {
          if (elem.addEventListener)
            elem.addEventListener(type, handler, false);
          else if (elem.attachEvent)
            elem.attachEvent("on" + type, handler);
          else
            elem["on" + type] = handler;
        }, options = {
          autoRun: true,
          barThickness: 3,
          barColors: {
            0: "rgba(26,  188, 156, .9)",
            ".25": "rgba(52,  152, 219, .9)",
            ".50": "rgba(241, 196, 15,  .9)",
            ".75": "rgba(230, 126, 34,  .9)",
            "1.0": "rgba(211, 84,  0,   .9)"
          },
          shadowBlur: 10,
          shadowColor: "rgba(0,   0,   0,   .6)",
          className: null
        }, repaint = function() {
          canvas.width = window2.innerWidth;
          canvas.height = options.barThickness * 5;
          var ctx = canvas.getContext("2d");
          ctx.shadowBlur = options.shadowBlur;
          ctx.shadowColor = options.shadowColor;
          var lineGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          for (var stop in options.barColors)
            lineGradient.addColorStop(stop, options.barColors[stop]);
          ctx.lineWidth = options.barThickness;
          ctx.beginPath();
          ctx.moveTo(0, options.barThickness / 2);
          ctx.lineTo(
            Math.ceil(currentProgress * canvas.width),
            options.barThickness / 2
          );
          ctx.strokeStyle = lineGradient;
          ctx.stroke();
        }, createCanvas = function() {
          canvas = document2.createElement("canvas");
          var style = canvas.style;
          style.position = "fixed";
          style.top = style.left = style.right = style.margin = style.padding = 0;
          style.zIndex = 100001;
          style.display = "none";
          if (options.className)
            canvas.classList.add(options.className);
          document2.body.appendChild(canvas);
          addEvent(window2, "resize", repaint);
        }, topbar2 = {
          config: function(opts) {
            for (var key in opts)
              if (options.hasOwnProperty(key))
                options[key] = opts[key];
          },
          show: function(delay) {
            if (showing)
              return;
            if (delay) {
              if (delayTimerId)
                return;
              delayTimerId = setTimeout(() => topbar2.show(), delay);
            } else {
              showing = true;
              if (fadeTimerId !== null)
                window2.cancelAnimationFrame(fadeTimerId);
              if (!canvas)
                createCanvas();
              canvas.style.opacity = 1;
              canvas.style.display = "block";
              topbar2.progress(0);
              if (options.autoRun) {
                (function loop() {
                  progressTimerId = window2.requestAnimationFrame(loop);
                  topbar2.progress(
                    "+" + 0.05 * Math.pow(1 - Math.sqrt(currentProgress), 2)
                  );
                })();
              }
            }
          },
          progress: function(to2) {
            if (typeof to2 === "undefined")
              return currentProgress;
            if (typeof to2 === "string") {
              to2 = (to2.indexOf("+") >= 0 || to2.indexOf("-") >= 0 ? currentProgress : 0) + parseFloat(to2);
            }
            currentProgress = to2 > 1 ? 1 : to2;
            repaint();
            return currentProgress;
          },
          hide: function() {
            clearTimeout(delayTimerId);
            delayTimerId = null;
            if (!showing)
              return;
            showing = false;
            if (progressTimerId != null) {
              window2.cancelAnimationFrame(progressTimerId);
              progressTimerId = null;
            }
            (function loop() {
              if (topbar2.progress("+.1") >= 1) {
                canvas.style.opacity -= 0.05;
                if (canvas.style.opacity <= 0.05) {
                  canvas.style.display = "none";
                  fadeTimerId = null;
                  return;
                }
              }
              fadeTimerId = window2.requestAnimationFrame(loop);
            })();
          }
        };
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = topbar2;
        } else if (typeof define === "function" && define.amd) {
          define(function() {
            return topbar2;
          });
        } else {
          this.topbar = topbar2;
        }
      }).call(exports, window, document);
    }
  });

  // ../deps/phoenix_html/priv/static/phoenix_html.js
  (function() {
    var PolyfillEvent = eventConstructor();
    function eventConstructor() {
      if (typeof window.CustomEvent === "function")
        return window.CustomEvent;
      function CustomEvent2(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: void 0 };
        var evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
      }
      CustomEvent2.prototype = window.Event.prototype;
      return CustomEvent2;
    }
    function buildHiddenInput(name, value) {
      var input = document.createElement("input");
      input.type = "hidden";
      input.name = name;
      input.value = value;
      return input;
    }
    function handleClick(element, targetModifierKey) {
      var to2 = element.getAttribute("data-to"), method = buildHiddenInput("_method", element.getAttribute("data-method")), csrf = buildHiddenInput("_csrf_token", element.getAttribute("data-csrf")), form = document.createElement("form"), submit = document.createElement("input"), target = element.getAttribute("target");
      form.method = element.getAttribute("data-method") === "get" ? "get" : "post";
      form.action = to2;
      form.style.display = "none";
      if (target)
        form.target = target;
      else if (targetModifierKey)
        form.target = "_blank";
      form.appendChild(csrf);
      form.appendChild(method);
      document.body.appendChild(form);
      submit.type = "submit";
      form.appendChild(submit);
      submit.click();
    }
    window.addEventListener("click", function(e) {
      var element = e.target;
      if (e.defaultPrevented)
        return;
      while (element && element.getAttribute) {
        var phoenixLinkEvent = new PolyfillEvent("phoenix.link.click", {
          "bubbles": true,
          "cancelable": true
        });
        if (!element.dispatchEvent(phoenixLinkEvent)) {
          e.preventDefault();
          e.stopImmediatePropagation();
          return false;
        }
        if (element.getAttribute("data-method") && element.getAttribute("data-to")) {
          handleClick(element, e.metaKey || e.shiftKey);
          e.preventDefault();
          return false;
        } else {
          element = element.parentNode;
        }
      }
    }, false);
    window.addEventListener("phoenix.link.click", function(e) {
      var message = e.target.getAttribute("data-confirm");
      if (message && !window.confirm(message)) {
        e.preventDefault();
      }
    }, false);
  })();

  // ../deps/phoenix/priv/static/phoenix.mjs
  var closure = (value) => {
    if (typeof value === "function") {
      return value;
    } else {
      let closure22 = function() {
        return value;
      };
      return closure22;
    }
  };
  var globalSelf = typeof self !== "undefined" ? self : null;
  var phxWindow = typeof window !== "undefined" ? window : null;
  var global = globalSelf || phxWindow || global;
  var DEFAULT_VSN = "2.0.0";
  var SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };
  var DEFAULT_TIMEOUT = 1e4;
  var WS_CLOSE_NORMAL = 1e3;
  var CHANNEL_STATES = {
    closed: "closed",
    errored: "errored",
    joined: "joined",
    joining: "joining",
    leaving: "leaving"
  };
  var CHANNEL_EVENTS = {
    close: "phx_close",
    error: "phx_error",
    join: "phx_join",
    reply: "phx_reply",
    leave: "phx_leave"
  };
  var TRANSPORTS = {
    longpoll: "longpoll",
    websocket: "websocket"
  };
  var XHR_STATES = {
    complete: 4
  };
  var Push = class {
    constructor(channel, event, payload, timeout) {
      this.channel = channel;
      this.event = event;
      this.payload = payload || function() {
        return {};
      };
      this.receivedResp = null;
      this.timeout = timeout;
      this.timeoutTimer = null;
      this.recHooks = [];
      this.sent = false;
    }
    /**
     *
     * @param {number} timeout
     */
    resend(timeout) {
      this.timeout = timeout;
      this.reset();
      this.send();
    }
    /**
     *
     */
    send() {
      if (this.hasReceived("timeout")) {
        return;
      }
      this.startTimeout();
      this.sent = true;
      this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload(),
        ref: this.ref,
        join_ref: this.channel.joinRef()
      });
    }
    /**
     *
     * @param {*} status
     * @param {*} callback
     */
    receive(status, callback2) {
      if (this.hasReceived(status)) {
        callback2(this.receivedResp.response);
      }
      this.recHooks.push({ status, callback: callback2 });
      return this;
    }
    /**
     * @private
     */
    reset() {
      this.cancelRefEvent();
      this.ref = null;
      this.refEvent = null;
      this.receivedResp = null;
      this.sent = false;
    }
    /**
     * @private
     */
    matchReceive({ status, response, _ref }) {
      this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
    }
    /**
     * @private
     */
    cancelRefEvent() {
      if (!this.refEvent) {
        return;
      }
      this.channel.off(this.refEvent);
    }
    /**
     * @private
     */
    cancelTimeout() {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = null;
    }
    /**
     * @private
     */
    startTimeout() {
      if (this.timeoutTimer) {
        this.cancelTimeout();
      }
      this.ref = this.channel.socket.makeRef();
      this.refEvent = this.channel.replyEventName(this.ref);
      this.channel.on(this.refEvent, (payload) => {
        this.cancelRefEvent();
        this.cancelTimeout();
        this.receivedResp = payload;
        this.matchReceive(payload);
      });
      this.timeoutTimer = setTimeout(() => {
        this.trigger("timeout", {});
      }, this.timeout);
    }
    /**
     * @private
     */
    hasReceived(status) {
      return this.receivedResp && this.receivedResp.status === status;
    }
    /**
     * @private
     */
    trigger(status, response) {
      this.channel.trigger(this.refEvent, { status, response });
    }
  };
  var Timer = class {
    constructor(callback2, timerCalc) {
      this.callback = callback2;
      this.timerCalc = timerCalc;
      this.timer = null;
      this.tries = 0;
    }
    reset() {
      this.tries = 0;
      clearTimeout(this.timer);
    }
    /**
     * Cancels any previous scheduleTimeout and schedules callback
     */
    scheduleTimeout() {
      clearTimeout(this.timer);
      this.timer = setTimeout(() => {
        this.tries = this.tries + 1;
        this.callback();
      }, this.timerCalc(this.tries + 1));
    }
  };
  var Channel = class {
    constructor(topic, params, socket) {
      this.state = CHANNEL_STATES.closed;
      this.topic = topic;
      this.params = closure(params || {});
      this.socket = socket;
      this.bindings = [];
      this.bindingRef = 0;
      this.timeout = this.socket.timeout;
      this.joinedOnce = false;
      this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
      this.pushBuffer = [];
      this.stateChangeRefs = [];
      this.rejoinTimer = new Timer(() => {
        if (this.socket.isConnected()) {
          this.rejoin();
        }
      }, this.socket.rejoinAfterMs);
      this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));
      this.stateChangeRefs.push(
        this.socket.onOpen(() => {
          this.rejoinTimer.reset();
          if (this.isErrored()) {
            this.rejoin();
          }
        })
      );
      this.joinPush.receive("ok", () => {
        this.state = CHANNEL_STATES.joined;
        this.rejoinTimer.reset();
        this.pushBuffer.forEach((pushEvent) => pushEvent.send());
        this.pushBuffer = [];
      });
      this.joinPush.receive("error", () => {
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.onClose(() => {
        this.rejoinTimer.reset();
        if (this.socket.hasLogger())
          this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`);
        this.state = CHANNEL_STATES.closed;
        this.socket.remove(this);
      });
      this.onError((reason) => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `error ${this.topic}`, reason);
        if (this.isJoining()) {
          this.joinPush.reset();
        }
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.joinPush.receive("timeout", () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);
        let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);
        leavePush.send();
        this.state = CHANNEL_STATES.errored;
        this.joinPush.reset();
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.on(CHANNEL_EVENTS.reply, (payload, ref) => {
        this.trigger(this.replyEventName(ref), payload);
      });
    }
    /**
     * Join the channel
     * @param {integer} timeout
     * @returns {Push}
     */
    join(timeout = this.timeout) {
      if (this.joinedOnce) {
        throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");
      } else {
        this.timeout = timeout;
        this.joinedOnce = true;
        this.rejoin();
        return this.joinPush;
      }
    }
    /**
     * Hook into channel close
     * @param {Function} callback
     */
    onClose(callback2) {
      this.on(CHANNEL_EVENTS.close, callback2);
    }
    /**
     * Hook into channel errors
     * @param {Function} callback
     */
    onError(callback2) {
      return this.on(CHANNEL_EVENTS.error, (reason) => callback2(reason));
    }
    /**
     * Subscribes on channel events
     *
     * Subscription returns a ref counter, which can be used later to
     * unsubscribe the exact event listener
     *
     * @example
     * const ref1 = channel.on("event", do_stuff)
     * const ref2 = channel.on("event", do_other_stuff)
     * channel.off("event", ref1)
     * // Since unsubscription, do_stuff won't fire,
     * // while do_other_stuff will keep firing on the "event"
     *
     * @param {string} event
     * @param {Function} callback
     * @returns {integer} ref
     */
    on(event, callback2) {
      let ref = this.bindingRef++;
      this.bindings.push({ event, ref, callback: callback2 });
      return ref;
    }
    /**
     * Unsubscribes off of channel events
     *
     * Use the ref returned from a channel.on() to unsubscribe one
     * handler, or pass nothing for the ref to unsubscribe all
     * handlers for the given event.
     *
     * @example
     * // Unsubscribe the do_stuff handler
     * const ref1 = channel.on("event", do_stuff)
     * channel.off("event", ref1)
     *
     * // Unsubscribe all handlers from event
     * channel.off("event")
     *
     * @param {string} event
     * @param {integer} ref
     */
    off(event, ref) {
      this.bindings = this.bindings.filter((bind) => {
        return !(bind.event === event && (typeof ref === "undefined" || ref === bind.ref));
      });
    }
    /**
     * @private
     */
    canPush() {
      return this.socket.isConnected() && this.isJoined();
    }
    /**
     * Sends a message `event` to phoenix with the payload `payload`.
     * Phoenix receives this in the `handle_in(event, payload, socket)`
     * function. if phoenix replies or it times out (default 10000ms),
     * then optionally the reply can be received.
     *
     * @example
     * channel.push("event")
     *   .receive("ok", payload => console.log("phoenix replied:", payload))
     *   .receive("error", err => console.log("phoenix errored", err))
     *   .receive("timeout", () => console.log("timed out pushing"))
     * @param {string} event
     * @param {Object} payload
     * @param {number} [timeout]
     * @returns {Push}
     */
    push(event, payload, timeout = this.timeout) {
      payload = payload || {};
      if (!this.joinedOnce) {
        throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);
      }
      let pushEvent = new Push(this, event, function() {
        return payload;
      }, timeout);
      if (this.canPush()) {
        pushEvent.send();
      } else {
        pushEvent.startTimeout();
        this.pushBuffer.push(pushEvent);
      }
      return pushEvent;
    }
    /** Leaves the channel
     *
     * Unsubscribes from server events, and
     * instructs channel to terminate on server
     *
     * Triggers onClose() hooks
     *
     * To receive leave acknowledgements, use the `receive`
     * hook to bind to the server ack, ie:
     *
     * @example
     * channel.leave().receive("ok", () => alert("left!") )
     *
     * @param {integer} timeout
     * @returns {Push}
     */
    leave(timeout = this.timeout) {
      this.rejoinTimer.reset();
      this.joinPush.cancelTimeout();
      this.state = CHANNEL_STATES.leaving;
      let onClose = () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `leave ${this.topic}`);
        this.trigger(CHANNEL_EVENTS.close, "leave");
      };
      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);
      leavePush.receive("ok", () => onClose()).receive("timeout", () => onClose());
      leavePush.send();
      if (!this.canPush()) {
        leavePush.trigger("ok", {});
      }
      return leavePush;
    }
    /**
     * Overridable message hook
     *
     * Receives all events for specialized message handling
     * before dispatching to the channel callbacks.
     *
     * Must return the payload, modified or unmodified
     * @param {string} event
     * @param {Object} payload
     * @param {integer} ref
     * @returns {Object}
     */
    onMessage(_event, payload, _ref) {
      return payload;
    }
    /**
     * @private
     */
    isMember(topic, event, payload, joinRef) {
      if (this.topic !== topic) {
        return false;
      }
      if (joinRef && joinRef !== this.joinRef()) {
        if (this.socket.hasLogger())
          this.socket.log("channel", "dropping outdated message", { topic, event, payload, joinRef });
        return false;
      } else {
        return true;
      }
    }
    /**
     * @private
     */
    joinRef() {
      return this.joinPush.ref;
    }
    /**
     * @private
     */
    rejoin(timeout = this.timeout) {
      if (this.isLeaving()) {
        return;
      }
      this.socket.leaveOpenTopic(this.topic);
      this.state = CHANNEL_STATES.joining;
      this.joinPush.resend(timeout);
    }
    /**
     * @private
     */
    trigger(event, payload, ref, joinRef) {
      let handledPayload = this.onMessage(event, payload, ref, joinRef);
      if (payload && !handledPayload) {
        throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");
      }
      let eventBindings = this.bindings.filter((bind) => bind.event === event);
      for (let i = 0; i < eventBindings.length; i++) {
        let bind = eventBindings[i];
        bind.callback(handledPayload, ref, joinRef || this.joinRef());
      }
    }
    /**
     * @private
     */
    replyEventName(ref) {
      return `chan_reply_${ref}`;
    }
    /**
     * @private
     */
    isClosed() {
      return this.state === CHANNEL_STATES.closed;
    }
    /**
     * @private
     */
    isErrored() {
      return this.state === CHANNEL_STATES.errored;
    }
    /**
     * @private
     */
    isJoined() {
      return this.state === CHANNEL_STATES.joined;
    }
    /**
     * @private
     */
    isJoining() {
      return this.state === CHANNEL_STATES.joining;
    }
    /**
     * @private
     */
    isLeaving() {
      return this.state === CHANNEL_STATES.leaving;
    }
  };
  var Ajax = class {
    static request(method, endPoint, accept, body, timeout, ontimeout, callback2) {
      if (global.XDomainRequest) {
        let req = new global.XDomainRequest();
        return this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback2);
      } else {
        let req = new global.XMLHttpRequest();
        return this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback2);
      }
    }
    static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback2) {
      req.timeout = timeout;
      req.open(method, endPoint);
      req.onload = () => {
        let response = this.parseJSON(req.responseText);
        callback2 && callback2(response);
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.onprogress = () => {
      };
      req.send(body);
      return req;
    }
    static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback2) {
      req.open(method, endPoint, true);
      req.timeout = timeout;
      req.setRequestHeader("Content-Type", accept);
      req.onerror = () => callback2 && callback2(null);
      req.onreadystatechange = () => {
        if (req.readyState === XHR_STATES.complete && callback2) {
          let response = this.parseJSON(req.responseText);
          callback2(response);
        }
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.send(body);
      return req;
    }
    static parseJSON(resp) {
      if (!resp || resp === "") {
        return null;
      }
      try {
        return JSON.parse(resp);
      } catch (e) {
        console && console.log("failed to parse JSON response", resp);
        return null;
      }
    }
    static serialize(obj, parentKey) {
      let queryStr = [];
      for (var key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) {
          continue;
        }
        let paramKey = parentKey ? `${parentKey}[${key}]` : key;
        let paramVal = obj[key];
        if (typeof paramVal === "object") {
          queryStr.push(this.serialize(paramVal, paramKey));
        } else {
          queryStr.push(encodeURIComponent(paramKey) + "=" + encodeURIComponent(paramVal));
        }
      }
      return queryStr.join("&");
    }
    static appendParams(url, params) {
      if (Object.keys(params).length === 0) {
        return url;
      }
      let prefix = url.match(/\?/) ? "&" : "?";
      return `${url}${prefix}${this.serialize(params)}`;
    }
  };
  var arrayBufferToBase64 = (buffer) => {
    let binary = "";
    let bytes = new Uint8Array(buffer);
    let len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  };
  var LongPoll = class {
    constructor(endPoint) {
      this.endPoint = null;
      this.token = null;
      this.skipHeartbeat = true;
      this.reqs = /* @__PURE__ */ new Set();
      this.awaitingBatchAck = false;
      this.currentBatch = null;
      this.currentBatchTimer = null;
      this.batchBuffer = [];
      this.onopen = function() {
      };
      this.onerror = function() {
      };
      this.onmessage = function() {
      };
      this.onclose = function() {
      };
      this.pollEndpoint = this.normalizeEndpoint(endPoint);
      this.readyState = SOCKET_STATES.connecting;
      setTimeout(() => this.poll(), 0);
    }
    normalizeEndpoint(endPoint) {
      return endPoint.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)/" + TRANSPORTS.websocket), "$1/" + TRANSPORTS.longpoll);
    }
    endpointURL() {
      return Ajax.appendParams(this.pollEndpoint, { token: this.token });
    }
    closeAndRetry(code, reason, wasClean) {
      this.close(code, reason, wasClean);
      this.readyState = SOCKET_STATES.connecting;
    }
    ontimeout() {
      this.onerror("timeout");
      this.closeAndRetry(1005, "timeout", false);
    }
    isActive() {
      return this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting;
    }
    poll() {
      this.ajax("GET", "application/json", null, () => this.ontimeout(), (resp) => {
        if (resp) {
          var { status, token, messages } = resp;
          this.token = token;
        } else {
          status = 0;
        }
        switch (status) {
          case 200:
            messages.forEach((msg) => {
              setTimeout(() => this.onmessage({ data: msg }), 0);
            });
            this.poll();
            break;
          case 204:
            this.poll();
            break;
          case 410:
            this.readyState = SOCKET_STATES.open;
            this.onopen({});
            this.poll();
            break;
          case 403:
            this.onerror(403);
            this.close(1008, "forbidden", false);
            break;
          case 0:
          case 500:
            this.onerror(500);
            this.closeAndRetry(1011, "internal server error", 500);
            break;
          default:
            throw new Error(`unhandled poll status ${status}`);
        }
      });
    }
    // we collect all pushes within the current event loop by
    // setTimeout 0, which optimizes back-to-back procedural
    // pushes against an empty buffer
    send(body) {
      if (typeof body !== "string") {
        body = arrayBufferToBase64(body);
      }
      if (this.currentBatch) {
        this.currentBatch.push(body);
      } else if (this.awaitingBatchAck) {
        this.batchBuffer.push(body);
      } else {
        this.currentBatch = [body];
        this.currentBatchTimer = setTimeout(() => {
          this.batchSend(this.currentBatch);
          this.currentBatch = null;
        }, 0);
      }
    }
    batchSend(messages) {
      this.awaitingBatchAck = true;
      this.ajax("POST", "application/x-ndjson", messages.join("\n"), () => this.onerror("timeout"), (resp) => {
        this.awaitingBatchAck = false;
        if (!resp || resp.status !== 200) {
          this.onerror(resp && resp.status);
          this.closeAndRetry(1011, "internal server error", false);
        } else if (this.batchBuffer.length > 0) {
          this.batchSend(this.batchBuffer);
          this.batchBuffer = [];
        }
      });
    }
    close(code, reason, wasClean) {
      for (let req of this.reqs) {
        req.abort();
      }
      this.readyState = SOCKET_STATES.closed;
      let opts = Object.assign({ code: 1e3, reason: void 0, wasClean: true }, { code, reason, wasClean });
      this.batchBuffer = [];
      clearTimeout(this.currentBatchTimer);
      this.currentBatchTimer = null;
      if (typeof CloseEvent !== "undefined") {
        this.onclose(new CloseEvent("close", opts));
      } else {
        this.onclose(opts);
      }
    }
    ajax(method, contentType, body, onCallerTimeout, callback2) {
      let req;
      let ontimeout = () => {
        this.reqs.delete(req);
        onCallerTimeout();
      };
      req = Ajax.request(method, this.endpointURL(), contentType, body, this.timeout, ontimeout, (resp) => {
        this.reqs.delete(req);
        if (this.isActive()) {
          callback2(resp);
        }
      });
      this.reqs.add(req);
    }
  };
  var serializer_default = {
    HEADER_LENGTH: 1,
    META_LENGTH: 4,
    KINDS: { push: 0, reply: 1, broadcast: 2 },
    encode(msg, callback2) {
      if (msg.payload.constructor === ArrayBuffer) {
        return callback2(this.binaryEncode(msg));
      } else {
        let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
        return callback2(JSON.stringify(payload));
      }
    },
    decode(rawPayload, callback2) {
      if (rawPayload.constructor === ArrayBuffer) {
        return callback2(this.binaryDecode(rawPayload));
      } else {
        let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);
        return callback2({ join_ref, ref, topic, event, payload });
      }
    },
    // private
    binaryEncode(message) {
      let { join_ref, ref, event, topic, payload } = message;
      let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;
      let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
      let view = new DataView(header);
      let offset = 0;
      view.setUint8(offset++, this.KINDS.push);
      view.setUint8(offset++, join_ref.length);
      view.setUint8(offset++, ref.length);
      view.setUint8(offset++, topic.length);
      view.setUint8(offset++, event.length);
      Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      var combined = new Uint8Array(header.byteLength + payload.byteLength);
      combined.set(new Uint8Array(header), 0);
      combined.set(new Uint8Array(payload), header.byteLength);
      return combined.buffer;
    },
    binaryDecode(buffer) {
      let view = new DataView(buffer);
      let kind = view.getUint8(0);
      let decoder = new TextDecoder();
      switch (kind) {
        case this.KINDS.push:
          return this.decodePush(buffer, view, decoder);
        case this.KINDS.reply:
          return this.decodeReply(buffer, view, decoder);
        case this.KINDS.broadcast:
          return this.decodeBroadcast(buffer, view, decoder);
      }
    },
    decodePush(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let topicSize = view.getUint8(2);
      let eventSize = view.getUint8(3);
      let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      return { join_ref: joinRef, ref: null, topic, event, payload: data };
    },
    decodeReply(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let refSize = view.getUint8(2);
      let topicSize = view.getUint8(3);
      let eventSize = view.getUint8(4);
      let offset = this.HEADER_LENGTH + this.META_LENGTH;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let ref = decoder.decode(buffer.slice(offset, offset + refSize));
      offset = offset + refSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      let payload = { status: event, response: data };
      return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };
    },
    decodeBroadcast(buffer, view, decoder) {
      let topicSize = view.getUint8(1);
      let eventSize = view.getUint8(2);
      let offset = this.HEADER_LENGTH + 2;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      return { join_ref: null, ref: null, topic, event, payload: data };
    }
  };
  var Socket = class {
    constructor(endPoint, opts = {}) {
      this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };
      this.channels = [];
      this.sendBuffer = [];
      this.ref = 0;
      this.timeout = opts.timeout || DEFAULT_TIMEOUT;
      this.transport = opts.transport || global.WebSocket || LongPoll;
      this.primaryPassedHealthCheck = false;
      this.longPollFallbackMs = opts.longPollFallbackMs;
      this.fallbackTimer = null;
      this.sessionStore = opts.sessionStorage || global.sessionStorage;
      this.establishedConnections = 0;
      this.defaultEncoder = serializer_default.encode.bind(serializer_default);
      this.defaultDecoder = serializer_default.decode.bind(serializer_default);
      this.closeWasClean = false;
      this.binaryType = opts.binaryType || "arraybuffer";
      this.connectClock = 1;
      if (this.transport !== LongPoll) {
        this.encode = opts.encode || this.defaultEncoder;
        this.decode = opts.decode || this.defaultDecoder;
      } else {
        this.encode = this.defaultEncoder;
        this.decode = this.defaultDecoder;
      }
      let awaitingConnectionOnPageShow = null;
      if (phxWindow && phxWindow.addEventListener) {
        phxWindow.addEventListener("pagehide", (_e) => {
          if (this.conn) {
            this.disconnect();
            awaitingConnectionOnPageShow = this.connectClock;
          }
        });
        phxWindow.addEventListener("pageshow", (_e) => {
          if (awaitingConnectionOnPageShow === this.connectClock) {
            awaitingConnectionOnPageShow = null;
            this.connect();
          }
        });
      }
      this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;
      this.rejoinAfterMs = (tries) => {
        if (opts.rejoinAfterMs) {
          return opts.rejoinAfterMs(tries);
        } else {
          return [1e3, 2e3, 5e3][tries - 1] || 1e4;
        }
      };
      this.reconnectAfterMs = (tries) => {
        if (opts.reconnectAfterMs) {
          return opts.reconnectAfterMs(tries);
        } else {
          return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;
        }
      };
      this.logger = opts.logger || null;
      if (!this.logger && opts.debug) {
        this.logger = (kind, msg, data) => {
          console.log(`${kind}: ${msg}`, data);
        };
      }
      this.longpollerTimeout = opts.longpollerTimeout || 2e4;
      this.params = closure(opts.params || {});
      this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
      this.vsn = opts.vsn || DEFAULT_VSN;
      this.heartbeatTimeoutTimer = null;
      this.heartbeatTimer = null;
      this.pendingHeartbeatRef = null;
      this.reconnectTimer = new Timer(() => {
        this.teardown(() => this.connect());
      }, this.reconnectAfterMs);
    }
    /**
     * Returns the LongPoll transport reference
     */
    getLongPollTransport() {
      return LongPoll;
    }
    /**
     * Disconnects and replaces the active transport
     *
     * @param {Function} newTransport - The new transport class to instantiate
     *
     */
    replaceTransport(newTransport) {
      this.connectClock++;
      this.closeWasClean = true;
      clearTimeout(this.fallbackTimer);
      this.reconnectTimer.reset();
      if (this.conn) {
        this.conn.close();
        this.conn = null;
      }
      this.transport = newTransport;
    }
    /**
     * Returns the socket protocol
     *
     * @returns {string}
     */
    protocol() {
      return location.protocol.match(/^https/) ? "wss" : "ws";
    }
    /**
     * The fully qualified socket url
     *
     * @returns {string}
     */
    endPointURL() {
      let uri = Ajax.appendParams(
        Ajax.appendParams(this.endPoint, this.params()),
        { vsn: this.vsn }
      );
      if (uri.charAt(0) !== "/") {
        return uri;
      }
      if (uri.charAt(1) === "/") {
        return `${this.protocol()}:${uri}`;
      }
      return `${this.protocol()}://${location.host}${uri}`;
    }
    /**
     * Disconnects the socket
     *
     * See https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes for valid status codes.
     *
     * @param {Function} callback - Optional callback which is called after socket is disconnected.
     * @param {integer} code - A status code for disconnection (Optional).
     * @param {string} reason - A textual description of the reason to disconnect. (Optional)
     */
    disconnect(callback2, code, reason) {
      this.connectClock++;
      this.closeWasClean = true;
      clearTimeout(this.fallbackTimer);
      this.reconnectTimer.reset();
      this.teardown(callback2, code, reason);
    }
    /**
     *
     * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`
     *
     * Passing params to connect is deprecated; pass them in the Socket constructor instead:
     * `new Socket("/socket", {params: {user_id: userToken}})`.
     */
    connect(params) {
      if (params) {
        console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor");
        this.params = closure(params);
      }
      if (this.conn) {
        return;
      }
      if (this.longPollFallbackMs && this.transport !== LongPoll) {
        this.connectWithFallback(LongPoll, this.longPollFallbackMs);
      } else {
        this.transportConnect();
      }
    }
    /**
     * Logs the message. Override `this.logger` for specialized logging. noops by default
     * @param {string} kind
     * @param {string} msg
     * @param {Object} data
     */
    log(kind, msg, data) {
      this.logger && this.logger(kind, msg, data);
    }
    /**
     * Returns true if a logger has been set on this socket.
     */
    hasLogger() {
      return this.logger !== null;
    }
    /**
     * Registers callbacks for connection open events
     *
     * @example socket.onOpen(function(){ console.info("the socket was opened") })
     *
     * @param {Function} callback
     */
    onOpen(callback2) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.open.push([ref, callback2]);
      return ref;
    }
    /**
     * Registers callbacks for connection close events
     * @param {Function} callback
     */
    onClose(callback2) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.close.push([ref, callback2]);
      return ref;
    }
    /**
     * Registers callbacks for connection error events
     *
     * @example socket.onError(function(error){ alert("An error occurred") })
     *
     * @param {Function} callback
     */
    onError(callback2) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.error.push([ref, callback2]);
      return ref;
    }
    /**
     * Registers callbacks for connection message events
     * @param {Function} callback
     */
    onMessage(callback2) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.message.push([ref, callback2]);
      return ref;
    }
    /**
     * Pings the server and invokes the callback with the RTT in milliseconds
     * @param {Function} callback
     *
     * Returns true if the ping was pushed or false if unable to be pushed.
     */
    ping(callback2) {
      if (!this.isConnected()) {
        return false;
      }
      let ref = this.makeRef();
      let startTime = Date.now();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref });
      let onMsgRef = this.onMessage((msg) => {
        if (msg.ref === ref) {
          this.off([onMsgRef]);
          callback2(Date.now() - startTime);
        }
      });
      return true;
    }
    /**
     * @private
     */
    transportConnect() {
      this.connectClock++;
      this.closeWasClean = false;
      this.conn = new this.transport(this.endPointURL());
      this.conn.binaryType = this.binaryType;
      this.conn.timeout = this.longpollerTimeout;
      this.conn.onopen = () => this.onConnOpen();
      this.conn.onerror = (error) => this.onConnError(error);
      this.conn.onmessage = (event) => this.onConnMessage(event);
      this.conn.onclose = (event) => this.onConnClose(event);
    }
    getSession(key) {
      return this.sessionStore && this.sessionStore.getItem(key);
    }
    storeSession(key, val) {
      this.sessionStore && this.sessionStore.setItem(key, val);
    }
    connectWithFallback(fallbackTransport, fallbackThreshold = 2500) {
      clearTimeout(this.fallbackTimer);
      let established = false;
      let primaryTransport = true;
      let openRef, errorRef;
      let fallback = (reason) => {
        this.log("transport", `falling back to ${fallbackTransport.name}...`, reason);
        this.off([openRef, errorRef]);
        primaryTransport = false;
        this.replaceTransport(fallbackTransport);
        this.transportConnect();
      };
      if (this.getSession(`phx:fallback:${fallbackTransport.name}`)) {
        return fallback("memorized");
      }
      this.fallbackTimer = setTimeout(fallback, fallbackThreshold);
      errorRef = this.onError((reason) => {
        this.log("transport", "error", reason);
        if (primaryTransport && !established) {
          clearTimeout(this.fallbackTimer);
          fallback(reason);
        }
      });
      this.onOpen(() => {
        established = true;
        if (!primaryTransport) {
          if (!this.primaryPassedHealthCheck) {
            this.storeSession(`phx:fallback:${fallbackTransport.name}`, "true");
          }
          return this.log("transport", `established ${fallbackTransport.name} fallback`);
        }
        clearTimeout(this.fallbackTimer);
        this.fallbackTimer = setTimeout(fallback, fallbackThreshold);
        this.ping((rtt) => {
          this.log("transport", "connected to primary after", rtt);
          this.primaryPassedHealthCheck = true;
          clearTimeout(this.fallbackTimer);
        });
      });
      this.transportConnect();
    }
    clearHeartbeats() {
      clearTimeout(this.heartbeatTimer);
      clearTimeout(this.heartbeatTimeoutTimer);
    }
    onConnOpen() {
      if (this.hasLogger())
        this.log("transport", `${this.transport.name} connected to ${this.endPointURL()}`);
      this.closeWasClean = false;
      this.establishedConnections++;
      this.flushSendBuffer();
      this.reconnectTimer.reset();
      this.resetHeartbeat();
      this.stateChangeCallbacks.open.forEach(([, callback2]) => callback2());
    }
    /**
     * @private
     */
    heartbeatTimeout() {
      if (this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
        if (this.hasLogger()) {
          this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
        }
        this.triggerChanError();
        this.closeWasClean = false;
        this.teardown(() => this.reconnectTimer.scheduleTimeout(), WS_CLOSE_NORMAL, "heartbeat timeout");
      }
    }
    resetHeartbeat() {
      if (this.conn && this.conn.skipHeartbeat) {
        return;
      }
      this.pendingHeartbeatRef = null;
      this.clearHeartbeats();
      this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    }
    teardown(callback2, code, reason) {
      if (!this.conn) {
        return callback2 && callback2();
      }
      this.waitForBufferDone(() => {
        if (this.conn) {
          if (code) {
            this.conn.close(code, reason || "");
          } else {
            this.conn.close();
          }
        }
        this.waitForSocketClosed(() => {
          if (this.conn) {
            this.conn.onopen = function() {
            };
            this.conn.onerror = function() {
            };
            this.conn.onmessage = function() {
            };
            this.conn.onclose = function() {
            };
            this.conn = null;
          }
          callback2 && callback2();
        });
      });
    }
    waitForBufferDone(callback2, tries = 1) {
      if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {
        callback2();
        return;
      }
      setTimeout(() => {
        this.waitForBufferDone(callback2, tries + 1);
      }, 150 * tries);
    }
    waitForSocketClosed(callback2, tries = 1) {
      if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {
        callback2();
        return;
      }
      setTimeout(() => {
        this.waitForSocketClosed(callback2, tries + 1);
      }, 150 * tries);
    }
    onConnClose(event) {
      let closeCode = event && event.code;
      if (this.hasLogger())
        this.log("transport", "close", event);
      this.triggerChanError();
      this.clearHeartbeats();
      if (!this.closeWasClean && closeCode !== 1e3) {
        this.reconnectTimer.scheduleTimeout();
      }
      this.stateChangeCallbacks.close.forEach(([, callback2]) => callback2(event));
    }
    /**
     * @private
     */
    onConnError(error) {
      if (this.hasLogger())
        this.log("transport", error);
      let transportBefore = this.transport;
      let establishedBefore = this.establishedConnections;
      this.stateChangeCallbacks.error.forEach(([, callback2]) => {
        callback2(error, transportBefore, establishedBefore);
      });
      if (transportBefore === this.transport || establishedBefore > 0) {
        this.triggerChanError();
      }
    }
    /**
     * @private
     */
    triggerChanError() {
      this.channels.forEach((channel) => {
        if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {
          channel.trigger(CHANNEL_EVENTS.error);
        }
      });
    }
    /**
     * @returns {string}
     */
    connectionState() {
      switch (this.conn && this.conn.readyState) {
        case SOCKET_STATES.connecting:
          return "connecting";
        case SOCKET_STATES.open:
          return "open";
        case SOCKET_STATES.closing:
          return "closing";
        default:
          return "closed";
      }
    }
    /**
     * @returns {boolean}
     */
    isConnected() {
      return this.connectionState() === "open";
    }
    /**
     * @private
     *
     * @param {Channel}
     */
    remove(channel) {
      this.off(channel.stateChangeRefs);
      this.channels = this.channels.filter((c) => c !== channel);
    }
    /**
     * Removes `onOpen`, `onClose`, `onError,` and `onMessage` registrations.
     *
     * @param {refs} - list of refs returned by calls to
     *                 `onOpen`, `onClose`, `onError,` and `onMessage`
     */
    off(refs) {
      for (let key in this.stateChangeCallbacks) {
        this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {
          return refs.indexOf(ref) === -1;
        });
      }
    }
    /**
     * Initiates a new channel for the given topic
     *
     * @param {string} topic
     * @param {Object} chanParams - Parameters for the channel
     * @returns {Channel}
     */
    channel(topic, chanParams = {}) {
      let chan = new Channel(topic, chanParams, this);
      this.channels.push(chan);
      return chan;
    }
    /**
     * @param {Object} data
     */
    push(data) {
      if (this.hasLogger()) {
        let { topic, event, payload, ref, join_ref } = data;
        this.log("push", `${topic} ${event} (${join_ref}, ${ref})`, payload);
      }
      if (this.isConnected()) {
        this.encode(data, (result) => this.conn.send(result));
      } else {
        this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));
      }
    }
    /**
     * Return the next message ref, accounting for overflows
     * @returns {string}
     */
    makeRef() {
      let newRef = this.ref + 1;
      if (newRef === this.ref) {
        this.ref = 0;
      } else {
        this.ref = newRef;
      }
      return this.ref.toString();
    }
    sendHeartbeat() {
      if (this.pendingHeartbeatRef && !this.isConnected()) {
        return;
      }
      this.pendingHeartbeatRef = this.makeRef();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef });
      this.heartbeatTimeoutTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);
    }
    flushSendBuffer() {
      if (this.isConnected() && this.sendBuffer.length > 0) {
        this.sendBuffer.forEach((callback2) => callback2());
        this.sendBuffer = [];
      }
    }
    onConnMessage(rawMessage) {
      this.decode(rawMessage.data, (msg) => {
        let { topic, event, payload, ref, join_ref } = msg;
        if (ref && ref === this.pendingHeartbeatRef) {
          this.clearHeartbeats();
          this.pendingHeartbeatRef = null;
          this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
        }
        if (this.hasLogger())
          this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
        for (let i = 0; i < this.channels.length; i++) {
          const channel = this.channels[i];
          if (!channel.isMember(topic, event, payload, join_ref)) {
            continue;
          }
          channel.trigger(event, payload, ref, join_ref);
        }
        for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {
          let [, callback2] = this.stateChangeCallbacks.message[i];
          callback2(msg);
        }
      });
    }
    leaveOpenTopic(topic) {
      let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));
      if (dupChannel) {
        if (this.hasLogger())
          this.log("transport", `leaving duplicate topic "${topic}"`);
        dupChannel.leave();
      }
    }
  };

  // ../deps/phoenix_live_view/priv/static/phoenix_live_view.esm.js
  var CONSECUTIVE_RELOADS = "consecutive-reloads";
  var MAX_RELOADS = 10;
  var RELOAD_JITTER_MIN = 5e3;
  var RELOAD_JITTER_MAX = 1e4;
  var FAILSAFE_JITTER = 3e4;
  var PHX_EVENT_CLASSES = [
    "phx-click-loading",
    "phx-change-loading",
    "phx-submit-loading",
    "phx-keydown-loading",
    "phx-keyup-loading",
    "phx-blur-loading",
    "phx-focus-loading",
    "phx-hook-loading"
  ];
  var PHX_COMPONENT = "data-phx-component";
  var PHX_LIVE_LINK = "data-phx-link";
  var PHX_TRACK_STATIC = "track-static";
  var PHX_LINK_STATE = "data-phx-link-state";
  var PHX_REF = "data-phx-ref";
  var PHX_REF_SRC = "data-phx-ref-src";
  var PHX_TRACK_UPLOADS = "track-uploads";
  var PHX_UPLOAD_REF = "data-phx-upload-ref";
  var PHX_PREFLIGHTED_REFS = "data-phx-preflighted-refs";
  var PHX_DONE_REFS = "data-phx-done-refs";
  var PHX_DROP_TARGET = "drop-target";
  var PHX_ACTIVE_ENTRY_REFS = "data-phx-active-refs";
  var PHX_LIVE_FILE_UPDATED = "phx:live-file:updated";
  var PHX_SKIP = "data-phx-skip";
  var PHX_MAGIC_ID = "data-phx-id";
  var PHX_PRUNE = "data-phx-prune";
  var PHX_PAGE_LOADING = "page-loading";
  var PHX_CONNECTED_CLASS = "phx-connected";
  var PHX_LOADING_CLASS = "phx-loading";
  var PHX_NO_FEEDBACK_CLASS = "phx-no-feedback";
  var PHX_ERROR_CLASS = "phx-error";
  var PHX_CLIENT_ERROR_CLASS = "phx-client-error";
  var PHX_SERVER_ERROR_CLASS = "phx-server-error";
  var PHX_PARENT_ID = "data-phx-parent-id";
  var PHX_MAIN = "data-phx-main";
  var PHX_ROOT_ID = "data-phx-root-id";
  var PHX_VIEWPORT_TOP = "viewport-top";
  var PHX_VIEWPORT_BOTTOM = "viewport-bottom";
  var PHX_TRIGGER_ACTION = "trigger-action";
  var PHX_FEEDBACK_FOR = "feedback-for";
  var PHX_FEEDBACK_GROUP = "feedback-group";
  var PHX_HAS_FOCUSED = "phx-has-focused";
  var FOCUSABLE_INPUTS = ["text", "textarea", "number", "email", "password", "search", "tel", "url", "date", "time", "datetime-local", "color", "range"];
  var CHECKABLE_INPUTS = ["checkbox", "radio"];
  var PHX_HAS_SUBMITTED = "phx-has-submitted";
  var PHX_SESSION = "data-phx-session";
  var PHX_VIEW_SELECTOR = `[${PHX_SESSION}]`;
  var PHX_STICKY = "data-phx-sticky";
  var PHX_STATIC = "data-phx-static";
  var PHX_READONLY = "data-phx-readonly";
  var PHX_DISABLED = "data-phx-disabled";
  var PHX_DISABLE_WITH = "disable-with";
  var PHX_DISABLE_WITH_RESTORE = "data-phx-disable-with-restore";
  var PHX_HOOK = "hook";
  var PHX_DEBOUNCE = "debounce";
  var PHX_THROTTLE = "throttle";
  var PHX_UPDATE = "update";
  var PHX_STREAM = "stream";
  var PHX_STREAM_REF = "data-phx-stream";
  var PHX_KEY = "key";
  var PHX_PRIVATE = "phxPrivate";
  var PHX_AUTO_RECOVER = "auto-recover";
  var PHX_LV_DEBUG = "phx:live-socket:debug";
  var PHX_LV_PROFILE = "phx:live-socket:profiling";
  var PHX_LV_LATENCY_SIM = "phx:live-socket:latency-sim";
  var PHX_PROGRESS = "progress";
  var PHX_MOUNTED = "mounted";
  var LOADER_TIMEOUT = 1;
  var BEFORE_UNLOAD_LOADER_TIMEOUT = 200;
  var BINDING_PREFIX = "phx-";
  var PUSH_TIMEOUT = 3e4;
  var DEBOUNCE_TRIGGER = "debounce-trigger";
  var THROTTLED = "throttled";
  var DEBOUNCE_PREV_KEY = "debounce-prev-key";
  var DEFAULTS = {
    debounce: 300,
    throttle: 300
  };
  var DYNAMICS = "d";
  var STATIC = "s";
  var ROOT = "r";
  var COMPONENTS = "c";
  var EVENTS = "e";
  var REPLY = "r";
  var TITLE = "t";
  var TEMPLATES = "p";
  var STREAM = "stream";
  var EntryUploader = class {
    constructor(entry, chunkSize, liveSocket2) {
      this.liveSocket = liveSocket2;
      this.entry = entry;
      this.offset = 0;
      this.chunkSize = chunkSize;
      this.chunkTimer = null;
      this.errored = false;
      this.uploadChannel = liveSocket2.channel(`lvu:${entry.ref}`, { token: entry.metadata() });
    }
    error(reason) {
      if (this.errored) {
        return;
      }
      this.uploadChannel.leave();
      this.errored = true;
      clearTimeout(this.chunkTimer);
      this.entry.error(reason);
    }
    upload() {
      this.uploadChannel.onError((reason) => this.error(reason));
      this.uploadChannel.join().receive("ok", (_data) => this.readNextChunk()).receive("error", (reason) => this.error(reason));
    }
    isDone() {
      return this.offset >= this.entry.file.size;
    }
    readNextChunk() {
      let reader = new window.FileReader();
      let blob = this.entry.file.slice(this.offset, this.chunkSize + this.offset);
      reader.onload = (e) => {
        if (e.target.error === null) {
          this.offset += e.target.result.byteLength;
          this.pushChunk(e.target.result);
        } else {
          return logError("Read error: " + e.target.error);
        }
      };
      reader.readAsArrayBuffer(blob);
    }
    pushChunk(chunk) {
      if (!this.uploadChannel.isJoined()) {
        return;
      }
      this.uploadChannel.push("chunk", chunk).receive("ok", () => {
        this.entry.progress(this.offset / this.entry.file.size * 100);
        if (!this.isDone()) {
          this.chunkTimer = setTimeout(() => this.readNextChunk(), this.liveSocket.getLatencySim() || 0);
        }
      }).receive("error", ({ reason }) => this.error(reason));
    }
  };
  var logError = (msg, obj) => console.error && console.error(msg, obj);
  var isCid = (cid) => {
    let type = typeof cid;
    return type === "number" || type === "string" && /^(0|[1-9]\d*)$/.test(cid);
  };
  function detectDuplicateIds() {
    let ids = /* @__PURE__ */ new Set();
    let elems = document.querySelectorAll("*[id]");
    for (let i = 0, len = elems.length; i < len; i++) {
      if (ids.has(elems[i].id)) {
        console.error(`Multiple IDs detected: ${elems[i].id}. Ensure unique element ids.`);
      } else {
        ids.add(elems[i].id);
      }
    }
  }
  var debug = (view, kind, msg, obj) => {
    if (view.liveSocket.isDebugEnabled()) {
      console.log(`${view.id} ${kind}: ${msg} - `, obj);
    }
  };
  var closure2 = (val) => typeof val === "function" ? val : function() {
    return val;
  };
  var clone = (obj) => {
    return JSON.parse(JSON.stringify(obj));
  };
  var closestPhxBinding = (el, binding, borderEl) => {
    do {
      if (el.matches(`[${binding}]`) && !el.disabled) {
        return el;
      }
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1 && !(borderEl && borderEl.isSameNode(el) || el.matches(PHX_VIEW_SELECTOR)));
    return null;
  };
  var isObject = (obj) => {
    return obj !== null && typeof obj === "object" && !(obj instanceof Array);
  };
  var isEqualObj = (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2);
  var isEmpty = (obj) => {
    for (let x in obj) {
      return false;
    }
    return true;
  };
  var maybe = (el, callback2) => el && callback2(el);
  var channelUploader = function(entries, onError, resp, liveSocket2) {
    entries.forEach((entry) => {
      let entryUploader = new EntryUploader(entry, resp.config.chunk_size, liveSocket2);
      entryUploader.upload();
    });
  };
  var Browser = {
    canPushState() {
      return typeof history.pushState !== "undefined";
    },
    dropLocal(localStorage, namespace, subkey) {
      return localStorage.removeItem(this.localKey(namespace, subkey));
    },
    updateLocal(localStorage, namespace, subkey, initial, func) {
      let current = this.getLocal(localStorage, namespace, subkey);
      let key = this.localKey(namespace, subkey);
      let newVal = current === null ? initial : func(current);
      localStorage.setItem(key, JSON.stringify(newVal));
      return newVal;
    },
    getLocal(localStorage, namespace, subkey) {
      return JSON.parse(localStorage.getItem(this.localKey(namespace, subkey)));
    },
    updateCurrentState(callback2) {
      if (!this.canPushState()) {
        return;
      }
      history.replaceState(callback2(history.state || {}), "", window.location.href);
    },
    pushState(kind, meta, to2) {
      if (this.canPushState()) {
        if (to2 !== window.location.href) {
          if (meta.type == "redirect" && meta.scroll) {
            let currentState = history.state || {};
            currentState.scroll = meta.scroll;
            history.replaceState(currentState, "", window.location.href);
          }
          delete meta.scroll;
          history[kind + "State"](meta, "", to2 || null);
          let hashEl = this.getHashTargetEl(window.location.hash);
          if (hashEl) {
            hashEl.scrollIntoView();
          } else if (meta.type === "redirect") {
            window.scroll(0, 0);
          }
        }
      } else {
        this.redirect(to2);
      }
    },
    setCookie(name, value) {
      document.cookie = `${name}=${value}`;
    },
    getCookie(name) {
      return document.cookie.replace(new RegExp(`(?:(?:^|.*;s*)${name}s*=s*([^;]*).*$)|^.*$`), "$1");
    },
    redirect(toURL, flash) {
      if (flash) {
        Browser.setCookie("__phoenix_flash__", flash + "; max-age=60000; path=/");
      }
      window.location = toURL;
    },
    localKey(namespace, subkey) {
      return `${namespace}-${subkey}`;
    },
    getHashTargetEl(maybeHash) {
      let hash = maybeHash.toString().substring(1);
      if (hash === "") {
        return;
      }
      return document.getElementById(hash) || document.querySelector(`a[name="${hash}"]`);
    }
  };
  var browser_default = Browser;
  var ARIA = {
    focusMain() {
      let target = document.querySelector("main h1, main, h1");
      if (target) {
        let origTabIndex = target.tabIndex;
        target.tabIndex = -1;
        target.focus();
        target.tabIndex = origTabIndex;
      }
    },
    anyOf(instance, classes) {
      return classes.find((name) => instance instanceof name);
    },
    isFocusable(el, interactiveOnly) {
      return el instanceof HTMLAnchorElement && el.rel !== "ignore" || el instanceof HTMLAreaElement && el.href !== void 0 || !el.disabled && this.anyOf(el, [HTMLInputElement, HTMLSelectElement, HTMLTextAreaElement, HTMLButtonElement]) || el instanceof HTMLIFrameElement || (el.tabIndex > 0 || !interactiveOnly && el.getAttribute("tabindex") !== null && el.getAttribute("aria-hidden") !== "true");
    },
    attemptFocus(el, interactiveOnly) {
      if (this.isFocusable(el, interactiveOnly)) {
        try {
          el.focus();
        } catch (e) {
        }
      }
      return !!document.activeElement && document.activeElement.isSameNode(el);
    },
    focusFirstInteractive(el) {
      let child = el.firstElementChild;
      while (child) {
        if (this.attemptFocus(child, true) || this.focusFirstInteractive(child, true)) {
          return true;
        }
        child = child.nextElementSibling;
      }
    },
    focusFirst(el) {
      let child = el.firstElementChild;
      while (child) {
        if (this.attemptFocus(child) || this.focusFirst(child)) {
          return true;
        }
        child = child.nextElementSibling;
      }
    },
    focusLast(el) {
      let child = el.lastElementChild;
      while (child) {
        if (this.attemptFocus(child) || this.focusLast(child)) {
          return true;
        }
        child = child.previousElementSibling;
      }
    }
  };
  var aria_default = ARIA;
  var focusStack = null;
  var default_transition_time = 200;
  var JS = {
    exec(eventType, phxEvent, view, sourceEl, defaults2) {
      let [defaultKind, defaultArgs] = defaults2 || [null, { callback: defaults2 && defaults2.callback }];
      let commands = phxEvent.charAt(0) === "[" ? JSON.parse(phxEvent) : [[defaultKind, defaultArgs]];
      commands.forEach(([kind, args]) => {
        if (kind === defaultKind && defaultArgs.data) {
          args.data = Object.assign(args.data || {}, defaultArgs.data);
          args.callback = args.callback || defaultArgs.callback;
        }
        this.filterToEls(sourceEl, args).forEach((el) => {
          this[`exec_${kind}`](eventType, phxEvent, view, sourceEl, el, args);
        });
      });
    },
    isVisible(el) {
      return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length > 0);
    },
    isInViewport(el) {
      const rect = el.getBoundingClientRect();
      const windowHeight = window.innerHeight || document.documentElement.clientHeight;
      const windowWidth = window.innerWidth || document.documentElement.clientWidth;
      return rect.right > 0 && rect.bottom > 0 && rect.left < windowWidth && rect.top < windowHeight;
    },
    exec_exec(eventType, phxEvent, view, sourceEl, el, { attr, to: to2 }) {
      let nodes = to2 ? dom_default.all(document, to2) : [sourceEl];
      nodes.forEach((node) => {
        let encodedJS = node.getAttribute(attr);
        if (!encodedJS) {
          throw new Error(`expected ${attr} to contain JS command on "${to2}"`);
        }
        view.liveSocket.execJS(node, encodedJS, eventType);
      });
    },
    exec_dispatch(eventType, phxEvent, view, sourceEl, el, { to: to2, event, detail, bubbles }) {
      detail = detail || {};
      detail.dispatcher = sourceEl;
      dom_default.dispatchEvent(el, event, { detail, bubbles });
    },
    exec_push(eventType, phxEvent, view, sourceEl, el, args) {
      let { event, data, target, page_loading, loading, value, dispatcher, callback: callback2 } = args;
      let pushOpts = { loading, value, target, page_loading: !!page_loading };
      let targetSrc = eventType === "change" && dispatcher ? dispatcher : sourceEl;
      let phxTarget = target || targetSrc.getAttribute(view.binding("target")) || targetSrc;
      view.withinTargets(phxTarget, (targetView, targetCtx) => {
        if (!targetView.isConnected()) {
          return;
        }
        if (eventType === "change") {
          let { newCid, _target } = args;
          _target = _target || (dom_default.isFormInput(sourceEl) ? sourceEl.name : void 0);
          if (_target) {
            pushOpts._target = _target;
          }
          targetView.pushInput(sourceEl, targetCtx, newCid, event || phxEvent, pushOpts, callback2);
        } else if (eventType === "submit") {
          let { submitter } = args;
          targetView.submitForm(sourceEl, targetCtx, event || phxEvent, submitter, pushOpts, callback2);
        } else {
          targetView.pushEvent(eventType, sourceEl, targetCtx, event || phxEvent, data, pushOpts, callback2);
        }
      });
    },
    exec_navigate(eventType, phxEvent, view, sourceEl, el, { href, replace }) {
      view.liveSocket.historyRedirect(href, replace ? "replace" : "push");
    },
    exec_patch(eventType, phxEvent, view, sourceEl, el, { href, replace }) {
      view.liveSocket.pushHistoryPatch(href, replace ? "replace" : "push", sourceEl);
    },
    exec_focus(eventType, phxEvent, view, sourceEl, el) {
      window.requestAnimationFrame(() => aria_default.attemptFocus(el));
    },
    exec_focus_first(eventType, phxEvent, view, sourceEl, el) {
      window.requestAnimationFrame(() => aria_default.focusFirstInteractive(el) || aria_default.focusFirst(el));
    },
    exec_push_focus(eventType, phxEvent, view, sourceEl, el) {
      window.requestAnimationFrame(() => focusStack = el || sourceEl);
    },
    exec_pop_focus(eventType, phxEvent, view, sourceEl, el) {
      window.requestAnimationFrame(() => {
        if (focusStack) {
          focusStack.focus();
        }
        focusStack = null;
      });
    },
    exec_add_class(eventType, phxEvent, view, sourceEl, el, { names: names2, transition, time }) {
      this.addOrRemoveClasses(el, names2, [], transition, time, view);
    },
    exec_remove_class(eventType, phxEvent, view, sourceEl, el, { names: names2, transition, time }) {
      this.addOrRemoveClasses(el, [], names2, transition, time, view);
    },
    exec_toggle_class(eventType, phxEvent, view, sourceEl, el, { to: to2, names: names2, transition, time }) {
      this.toggleClasses(el, names2, transition, view);
    },
    exec_toggle_attr(eventType, phxEvent, view, sourceEl, el, { attr: [attr, val1, val2] }) {
      if (el.hasAttribute(attr)) {
        if (val2 !== void 0) {
          if (el.getAttribute(attr) === val1) {
            this.setOrRemoveAttrs(el, [[attr, val2]], []);
          } else {
            this.setOrRemoveAttrs(el, [[attr, val1]], []);
          }
        } else {
          this.setOrRemoveAttrs(el, [], [attr]);
        }
      } else {
        this.setOrRemoveAttrs(el, [[attr, val1]], []);
      }
    },
    exec_transition(eventType, phxEvent, view, sourceEl, el, { time, transition }) {
      this.addOrRemoveClasses(el, [], [], transition, time, view);
    },
    exec_toggle(eventType, phxEvent, view, sourceEl, el, { display, ins, outs, time }) {
      this.toggle(eventType, view, el, display, ins, outs, time);
    },
    exec_show(eventType, phxEvent, view, sourceEl, el, { display, transition, time }) {
      this.show(eventType, view, el, display, transition, time);
    },
    exec_hide(eventType, phxEvent, view, sourceEl, el, { display, transition, time }) {
      this.hide(eventType, view, el, display, transition, time);
    },
    exec_set_attr(eventType, phxEvent, view, sourceEl, el, { attr: [attr, val] }) {
      this.setOrRemoveAttrs(el, [[attr, val]], []);
    },
    exec_remove_attr(eventType, phxEvent, view, sourceEl, el, { attr }) {
      this.setOrRemoveAttrs(el, [], [attr]);
    },
    show(eventType, view, el, display, transition, time) {
      if (!this.isVisible(el)) {
        this.toggle(eventType, view, el, display, transition, null, time);
      }
    },
    hide(eventType, view, el, display, transition, time) {
      if (this.isVisible(el)) {
        this.toggle(eventType, view, el, display, null, transition, time);
      }
    },
    toggle(eventType, view, el, display, ins, outs, time) {
      time = time || default_transition_time;
      let [inClasses, inStartClasses, inEndClasses] = ins || [[], [], []];
      let [outClasses, outStartClasses, outEndClasses] = outs || [[], [], []];
      if (inClasses.length > 0 || outClasses.length > 0) {
        if (this.isVisible(el)) {
          let onStart = () => {
            this.addOrRemoveClasses(el, outStartClasses, inClasses.concat(inStartClasses).concat(inEndClasses));
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, outClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, outEndClasses, outStartClasses));
            });
          };
          el.dispatchEvent(new Event("phx:hide-start"));
          view.transition(time, onStart, () => {
            this.addOrRemoveClasses(el, [], outClasses.concat(outEndClasses));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          });
        } else {
          if (eventType === "remove") {
            return;
          }
          let onStart = () => {
            this.addOrRemoveClasses(el, inStartClasses, outClasses.concat(outStartClasses).concat(outEndClasses));
            let stickyDisplay = display || this.defaultDisplay(el);
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = stickyDisplay);
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, inClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, inEndClasses, inStartClasses));
            });
          };
          el.dispatchEvent(new Event("phx:show-start"));
          view.transition(time, onStart, () => {
            this.addOrRemoveClasses(el, [], inClasses.concat(inEndClasses));
            el.dispatchEvent(new Event("phx:show-end"));
          });
        }
      } else {
        if (this.isVisible(el)) {
          window.requestAnimationFrame(() => {
            el.dispatchEvent(new Event("phx:hide-start"));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          });
        } else {
          window.requestAnimationFrame(() => {
            el.dispatchEvent(new Event("phx:show-start"));
            let stickyDisplay = display || this.defaultDisplay(el);
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = stickyDisplay);
            el.dispatchEvent(new Event("phx:show-end"));
          });
        }
      }
    },
    toggleClasses(el, classes, transition, time, view) {
      window.requestAnimationFrame(() => {
        let [prevAdds, prevRemoves] = dom_default.getSticky(el, "classes", [[], []]);
        let newAdds = classes.filter((name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name));
        let newRemoves = classes.filter((name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name));
        this.addOrRemoveClasses(el, newAdds, newRemoves, transition, time, view);
      });
    },
    addOrRemoveClasses(el, adds, removes, transition, time, view) {
      time = time || default_transition_time;
      let [transitionRun, transitionStart, transitionEnd] = transition || [[], [], []];
      if (transitionRun.length > 0) {
        let onStart = () => {
          this.addOrRemoveClasses(el, transitionStart, [].concat(transitionRun).concat(transitionEnd));
          window.requestAnimationFrame(() => {
            this.addOrRemoveClasses(el, transitionRun, []);
            window.requestAnimationFrame(() => this.addOrRemoveClasses(el, transitionEnd, transitionStart));
          });
        };
        let onDone = () => this.addOrRemoveClasses(el, adds.concat(transitionEnd), removes.concat(transitionRun).concat(transitionStart));
        return view.transition(time, onStart, onDone);
      }
      window.requestAnimationFrame(() => {
        let [prevAdds, prevRemoves] = dom_default.getSticky(el, "classes", [[], []]);
        let keepAdds = adds.filter((name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name));
        let keepRemoves = removes.filter((name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name));
        let newAdds = prevAdds.filter((name) => removes.indexOf(name) < 0).concat(keepAdds);
        let newRemoves = prevRemoves.filter((name) => adds.indexOf(name) < 0).concat(keepRemoves);
        dom_default.putSticky(el, "classes", (currentEl) => {
          currentEl.classList.remove(...newRemoves);
          currentEl.classList.add(...newAdds);
          return [newAdds, newRemoves];
        });
      });
    },
    setOrRemoveAttrs(el, sets, removes) {
      let [prevSets, prevRemoves] = dom_default.getSticky(el, "attrs", [[], []]);
      let alteredAttrs = sets.map(([attr, _val]) => attr).concat(removes);
      let newSets = prevSets.filter(([attr, _val]) => !alteredAttrs.includes(attr)).concat(sets);
      let newRemoves = prevRemoves.filter((attr) => !alteredAttrs.includes(attr)).concat(removes);
      dom_default.putSticky(el, "attrs", (currentEl) => {
        newRemoves.forEach((attr) => currentEl.removeAttribute(attr));
        newSets.forEach(([attr, val]) => currentEl.setAttribute(attr, val));
        return [newSets, newRemoves];
      });
    },
    hasAllClasses(el, classes) {
      return classes.every((name) => el.classList.contains(name));
    },
    isToggledOut(el, outClasses) {
      return !this.isVisible(el) || this.hasAllClasses(el, outClasses);
    },
    filterToEls(sourceEl, { to: to2 }) {
      return to2 ? dom_default.all(document, to2) : [sourceEl];
    },
    defaultDisplay(el) {
      return { tr: "table-row", td: "table-cell" }[el.tagName.toLowerCase()] || "block";
    }
  };
  var js_default = JS;
  var DOM = {
    byId(id) {
      return document.getElementById(id) || logError(`no id found for ${id}`);
    },
    removeClass(el, className) {
      el.classList.remove(className);
      if (el.classList.length === 0) {
        el.removeAttribute("class");
      }
    },
    all(node, query, callback2) {
      if (!node) {
        return [];
      }
      let array = Array.from(node.querySelectorAll(query));
      return callback2 ? array.forEach(callback2) : array;
    },
    childNodeLength(html) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return template.content.childElementCount;
    },
    isUploadInput(el) {
      return el.type === "file" && el.getAttribute(PHX_UPLOAD_REF) !== null;
    },
    isAutoUpload(inputEl) {
      return inputEl.hasAttribute("data-phx-auto-upload");
    },
    findUploadInputs(node) {
      const formId = node.id;
      const inputsOutsideForm = this.all(document, `input[type="file"][${PHX_UPLOAD_REF}][form="${formId}"]`);
      return this.all(node, `input[type="file"][${PHX_UPLOAD_REF}]`).concat(inputsOutsideForm);
    },
    findComponentNodeList(node, cid) {
      return this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}="${cid}"]`), node);
    },
    isPhxDestroyed(node) {
      return node.id && DOM.private(node, "destroyed") ? true : false;
    },
    wantsNewTab(e) {
      let wantsNewTab = e.ctrlKey || e.shiftKey || e.metaKey || e.button && e.button === 1;
      let isDownload = e.target instanceof HTMLAnchorElement && e.target.hasAttribute("download");
      let isTargetBlank = e.target.hasAttribute("target") && e.target.getAttribute("target").toLowerCase() === "_blank";
      return wantsNewTab || isTargetBlank || isDownload;
    },
    isUnloadableFormSubmit(e) {
      let isDialogSubmit = e.target && e.target.getAttribute("method") === "dialog" || e.submitter && e.submitter.getAttribute("formmethod") === "dialog";
      if (isDialogSubmit) {
        return false;
      } else {
        return !e.defaultPrevented && !this.wantsNewTab(e);
      }
    },
    isNewPageClick(e, currentLocation) {
      let href = e.target instanceof HTMLAnchorElement ? e.target.getAttribute("href") : null;
      let url;
      if (e.defaultPrevented || href === null || this.wantsNewTab(e)) {
        return false;
      }
      if (href.startsWith("mailto:") || href.startsWith("tel:")) {
        return false;
      }
      if (e.target.isContentEditable) {
        return false;
      }
      try {
        url = new URL(href);
      } catch (e2) {
        try {
          url = new URL(href, currentLocation);
        } catch (e3) {
          return true;
        }
      }
      if (url.host === currentLocation.host && url.protocol === currentLocation.protocol) {
        if (url.pathname === currentLocation.pathname && url.search === currentLocation.search) {
          return url.hash === "" && !url.href.endsWith("#");
        }
      }
      return url.protocol.startsWith("http");
    },
    markPhxChildDestroyed(el) {
      if (this.isPhxChild(el)) {
        el.setAttribute(PHX_SESSION, "");
      }
      this.putPrivate(el, "destroyed", true);
    },
    findPhxChildrenInFragment(html, parentId) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return this.findPhxChildren(template.content, parentId);
    },
    isIgnored(el, phxUpdate) {
      return (el.getAttribute(phxUpdate) || el.getAttribute("data-phx-update")) === "ignore";
    },
    isPhxUpdate(el, phxUpdate, updateTypes) {
      return el.getAttribute && updateTypes.indexOf(el.getAttribute(phxUpdate)) >= 0;
    },
    findPhxSticky(el) {
      return this.all(el, `[${PHX_STICKY}]`);
    },
    findPhxChildren(el, parentId) {
      return this.all(el, `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}="${parentId}"]`);
    },
    findExistingParentCIDs(node, cids) {
      let parentCids = /* @__PURE__ */ new Set();
      let childrenCids = /* @__PURE__ */ new Set();
      cids.forEach((cid) => {
        this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}="${cid}"]`), node).forEach((parent) => {
          parentCids.add(cid);
          this.all(parent, `[${PHX_COMPONENT}]`).map((el) => parseInt(el.getAttribute(PHX_COMPONENT))).forEach((childCID) => childrenCids.add(childCID));
        });
      });
      childrenCids.forEach((childCid) => parentCids.delete(childCid));
      return parentCids;
    },
    filterWithinSameLiveView(nodes, parent) {
      if (parent.querySelector(PHX_VIEW_SELECTOR)) {
        return nodes.filter((el) => this.withinSameLiveView(el, parent));
      } else {
        return nodes;
      }
    },
    withinSameLiveView(node, parent) {
      while (node = node.parentNode) {
        if (node.isSameNode(parent)) {
          return true;
        }
        if (node.getAttribute(PHX_SESSION) !== null) {
          return false;
        }
      }
    },
    private(el, key) {
      return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];
    },
    deletePrivate(el, key) {
      el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];
    },
    putPrivate(el, key, value) {
      if (!el[PHX_PRIVATE]) {
        el[PHX_PRIVATE] = {};
      }
      el[PHX_PRIVATE][key] = value;
    },
    updatePrivate(el, key, defaultVal, updateFunc) {
      let existing = this.private(el, key);
      if (existing === void 0) {
        this.putPrivate(el, key, updateFunc(defaultVal));
      } else {
        this.putPrivate(el, key, updateFunc(existing));
      }
    },
    copyPrivates(target, source) {
      if (source[PHX_PRIVATE]) {
        target[PHX_PRIVATE] = source[PHX_PRIVATE];
      }
    },
    putTitle(str) {
      let titleEl = document.querySelector("title");
      if (titleEl) {
        let { prefix, suffix } = titleEl.dataset;
        document.title = `${prefix || ""}${str}${suffix || ""}`;
      } else {
        document.title = str;
      }
    },
    debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, callback2) {
      let debounce2 = el.getAttribute(phxDebounce);
      let throttle = el.getAttribute(phxThrottle);
      if (debounce2 === "") {
        debounce2 = defaultDebounce;
      }
      if (throttle === "") {
        throttle = defaultThrottle;
      }
      let value = debounce2 || throttle;
      switch (value) {
        case null:
          return callback2();
        case "blur":
          if (this.once(el, "debounce-blur")) {
            el.addEventListener("blur", () => callback2());
          }
          return;
        default:
          let timeout = parseInt(value);
          let trigger = () => throttle ? this.deletePrivate(el, THROTTLED) : callback2();
          let currentCycle = this.incCycle(el, DEBOUNCE_TRIGGER, trigger);
          if (isNaN(timeout)) {
            return logError(`invalid throttle/debounce value: ${value}`);
          }
          if (throttle) {
            let newKeyDown = false;
            if (event.type === "keydown") {
              let prevKey = this.private(el, DEBOUNCE_PREV_KEY);
              this.putPrivate(el, DEBOUNCE_PREV_KEY, event.key);
              newKeyDown = prevKey !== event.key;
            }
            if (!newKeyDown && this.private(el, THROTTLED)) {
              return false;
            } else {
              callback2();
              const t = setTimeout(() => {
                if (asyncFilter()) {
                  this.triggerCycle(el, DEBOUNCE_TRIGGER);
                }
              }, timeout);
              this.putPrivate(el, THROTTLED, t);
            }
          } else {
            setTimeout(() => {
              if (asyncFilter()) {
                this.triggerCycle(el, DEBOUNCE_TRIGGER, currentCycle);
              }
            }, timeout);
          }
          let form = el.form;
          if (form && this.once(form, "bind-debounce")) {
            form.addEventListener("submit", () => {
              Array.from(new FormData(form).entries(), ([name]) => {
                let input = form.querySelector(`[name="${name}"]`);
                this.incCycle(input, DEBOUNCE_TRIGGER);
                this.deletePrivate(input, THROTTLED);
              });
            });
          }
          if (this.once(el, "bind-debounce")) {
            el.addEventListener("blur", () => {
              clearTimeout(this.private(el, THROTTLED));
              this.triggerCycle(el, DEBOUNCE_TRIGGER);
            });
          }
      }
    },
    triggerCycle(el, key, currentCycle) {
      let [cycle, trigger] = this.private(el, key);
      if (!currentCycle) {
        currentCycle = cycle;
      }
      if (currentCycle === cycle) {
        this.incCycle(el, key);
        trigger();
      }
    },
    once(el, key) {
      if (this.private(el, key) === true) {
        return false;
      }
      this.putPrivate(el, key, true);
      return true;
    },
    incCycle(el, key, trigger = function() {
    }) {
      let [currentCycle] = this.private(el, key) || [0, trigger];
      currentCycle++;
      this.putPrivate(el, key, [currentCycle, trigger]);
      return currentCycle;
    },
    maybeAddPrivateHooks(el, phxViewportTop, phxViewportBottom) {
      if (el.hasAttribute && (el.hasAttribute(phxViewportTop) || el.hasAttribute(phxViewportBottom))) {
        el.setAttribute("data-phx-hook", "Phoenix.InfiniteScroll");
      }
    },
    isFeedbackContainer(el, phxFeedbackFor) {
      return el.hasAttribute && el.hasAttribute(phxFeedbackFor);
    },
    maybeHideFeedback(container, feedbackContainers, phxFeedbackFor, phxFeedbackGroup) {
      const feedbackResults = {};
      feedbackContainers.forEach((el) => {
        if (!container.contains(el))
          return;
        const feedback = el.getAttribute(phxFeedbackFor);
        if (!feedback) {
          js_default.addOrRemoveClasses(el, [], [PHX_NO_FEEDBACK_CLASS]);
          return;
        }
        if (feedbackResults[feedback] === true) {
          this.hideFeedback(el);
          return;
        }
        feedbackResults[feedback] = this.shouldHideFeedback(container, feedback, phxFeedbackGroup);
        if (feedbackResults[feedback] === true) {
          this.hideFeedback(el);
        }
      });
    },
    hideFeedback(container) {
      js_default.addOrRemoveClasses(container, [PHX_NO_FEEDBACK_CLASS], []);
    },
    shouldHideFeedback(container, nameOrGroup, phxFeedbackGroup) {
      const query = `[name="${nameOrGroup}"],
                   [name="${nameOrGroup}[]"],
                   [${phxFeedbackGroup}="${nameOrGroup}"]`;
      let focused = false;
      DOM.all(container, query, (input) => {
        if (this.private(input, PHX_HAS_FOCUSED) || this.private(input, PHX_HAS_SUBMITTED)) {
          focused = true;
        }
      });
      return !focused;
    },
    feedbackSelector(input, phxFeedbackFor, phxFeedbackGroup) {
      let query = `[${phxFeedbackFor}="${input.name}"],
                 [${phxFeedbackFor}="${input.name.replace(/\[\]$/, "")}"]`;
      if (input.getAttribute(phxFeedbackGroup)) {
        query += `,[${phxFeedbackFor}="${input.getAttribute(phxFeedbackGroup)}"]`;
      }
      return query;
    },
    resetForm(form, phxFeedbackFor, phxFeedbackGroup) {
      Array.from(form.elements).forEach((input) => {
        let query = this.feedbackSelector(input, phxFeedbackFor, phxFeedbackGroup);
        this.deletePrivate(input, PHX_HAS_FOCUSED);
        this.deletePrivate(input, PHX_HAS_SUBMITTED);
        this.all(document, query, (feedbackEl) => {
          js_default.addOrRemoveClasses(feedbackEl, [PHX_NO_FEEDBACK_CLASS], []);
        });
      });
    },
    showError(inputEl, phxFeedbackFor, phxFeedbackGroup) {
      if (inputEl.name) {
        let query = this.feedbackSelector(inputEl, phxFeedbackFor, phxFeedbackGroup);
        this.all(document, query, (el) => {
          js_default.addOrRemoveClasses(el, [], [PHX_NO_FEEDBACK_CLASS]);
        });
      }
    },
    isPhxChild(node) {
      return node.getAttribute && node.getAttribute(PHX_PARENT_ID);
    },
    isPhxSticky(node) {
      return node.getAttribute && node.getAttribute(PHX_STICKY) !== null;
    },
    isChildOfAny(el, parents) {
      return !!parents.find((parent) => parent.contains(el));
    },
    firstPhxChild(el) {
      return this.isPhxChild(el) ? el : this.all(el, `[${PHX_PARENT_ID}]`)[0];
    },
    dispatchEvent(target, name, opts = {}) {
      let defaultBubble = true;
      let isUploadTarget = target.nodeName === "INPUT" && target.type === "file";
      if (isUploadTarget && name === "click") {
        defaultBubble = false;
      }
      let bubbles = opts.bubbles === void 0 ? defaultBubble : !!opts.bubbles;
      let eventOpts = { bubbles, cancelable: true, detail: opts.detail || {} };
      let event = name === "click" ? new MouseEvent("click", eventOpts) : new CustomEvent(name, eventOpts);
      target.dispatchEvent(event);
    },
    cloneNode(node, html) {
      if (typeof html === "undefined") {
        return node.cloneNode(true);
      } else {
        let cloned = node.cloneNode(false);
        cloned.innerHTML = html;
        return cloned;
      }
    },
    mergeAttrs(target, source, opts = {}) {
      let exclude = new Set(opts.exclude || []);
      let isIgnored = opts.isIgnored;
      let sourceAttrs = source.attributes;
      for (let i = sourceAttrs.length - 1; i >= 0; i--) {
        let name = sourceAttrs[i].name;
        if (!exclude.has(name)) {
          const sourceValue = source.getAttribute(name);
          if (target.getAttribute(name) !== sourceValue && (!isIgnored || isIgnored && name.startsWith("data-"))) {
            target.setAttribute(name, sourceValue);
          }
        } else {
          if (name === "value" && target.value === source.value) {
            target.setAttribute("value", source.getAttribute(name));
          }
        }
      }
      let targetAttrs = target.attributes;
      for (let i = targetAttrs.length - 1; i >= 0; i--) {
        let name = targetAttrs[i].name;
        if (isIgnored) {
          if (name.startsWith("data-") && !source.hasAttribute(name) && ![PHX_REF, PHX_REF_SRC].includes(name)) {
            target.removeAttribute(name);
          }
        } else {
          if (!source.hasAttribute(name)) {
            target.removeAttribute(name);
          }
        }
      }
    },
    mergeFocusedInput(target, source) {
      if (!(target instanceof HTMLSelectElement)) {
        DOM.mergeAttrs(target, source, { exclude: ["value"] });
      }
      if (source.readOnly) {
        target.setAttribute("readonly", true);
      } else {
        target.removeAttribute("readonly");
      }
    },
    hasSelectionRange(el) {
      return el.setSelectionRange && (el.type === "text" || el.type === "textarea");
    },
    restoreFocus(focused, selectionStart, selectionEnd) {
      if (focused instanceof HTMLSelectElement) {
        focused.focus();
      }
      if (!DOM.isTextualInput(focused)) {
        return;
      }
      let wasFocused = focused.matches(":focus");
      if (focused.readOnly) {
        focused.blur();
      }
      if (!wasFocused) {
        focused.focus();
      }
      if (this.hasSelectionRange(focused)) {
        focused.setSelectionRange(selectionStart, selectionEnd);
      }
    },
    isFormInput(el) {
      return /^(?:input|select|textarea)$/i.test(el.tagName) && el.type !== "button";
    },
    syncAttrsToProps(el) {
      if (el instanceof HTMLInputElement && CHECKABLE_INPUTS.indexOf(el.type.toLocaleLowerCase()) >= 0) {
        el.checked = el.getAttribute("checked") !== null;
      }
    },
    isTextualInput(el) {
      return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;
    },
    isNowTriggerFormExternal(el, phxTriggerExternal) {
      return el.getAttribute && el.getAttribute(phxTriggerExternal) !== null;
    },
    syncPendingRef(fromEl, toEl, disableWith) {
      let ref = fromEl.getAttribute(PHX_REF);
      if (ref === null) {
        return true;
      }
      let refSrc = fromEl.getAttribute(PHX_REF_SRC);
      if (DOM.isFormInput(fromEl) || fromEl.getAttribute(disableWith) !== null) {
        if (DOM.isUploadInput(fromEl)) {
          DOM.mergeAttrs(fromEl, toEl, { isIgnored: true });
        }
        DOM.putPrivate(fromEl, PHX_REF, toEl);
        return false;
      } else {
        PHX_EVENT_CLASSES.forEach((className) => {
          fromEl.classList.contains(className) && toEl.classList.add(className);
        });
        toEl.setAttribute(PHX_REF, ref);
        toEl.setAttribute(PHX_REF_SRC, refSrc);
        return true;
      }
    },
    cleanChildNodes(container, phxUpdate) {
      if (DOM.isPhxUpdate(container, phxUpdate, ["append", "prepend"])) {
        let toRemove = [];
        container.childNodes.forEach((childNode) => {
          if (!childNode.id) {
            let isEmptyTextNode = childNode.nodeType === Node.TEXT_NODE && childNode.nodeValue.trim() === "";
            if (!isEmptyTextNode) {
              logError(`only HTML element tags with an id are allowed inside containers with phx-update.

removing illegal node: "${(childNode.outerHTML || childNode.nodeValue).trim()}"

`);
            }
            toRemove.push(childNode);
          }
        });
        toRemove.forEach((childNode) => childNode.remove());
      }
    },
    replaceRootContainer(container, tagName, attrs) {
      let retainedAttrs = /* @__PURE__ */ new Set(["id", PHX_SESSION, PHX_STATIC, PHX_MAIN, PHX_ROOT_ID]);
      if (container.tagName.toLowerCase() === tagName.toLowerCase()) {
        Array.from(container.attributes).filter((attr) => !retainedAttrs.has(attr.name.toLowerCase())).forEach((attr) => container.removeAttribute(attr.name));
        Object.keys(attrs).filter((name) => !retainedAttrs.has(name.toLowerCase())).forEach((attr) => container.setAttribute(attr, attrs[attr]));
        return container;
      } else {
        let newContainer = document.createElement(tagName);
        Object.keys(attrs).forEach((attr) => newContainer.setAttribute(attr, attrs[attr]));
        retainedAttrs.forEach((attr) => newContainer.setAttribute(attr, container.getAttribute(attr)));
        newContainer.innerHTML = container.innerHTML;
        container.replaceWith(newContainer);
        return newContainer;
      }
    },
    getSticky(el, name, defaultVal) {
      let op = (DOM.private(el, "sticky") || []).find(([existingName]) => name === existingName);
      if (op) {
        let [_name, _op, stashedResult] = op;
        return stashedResult;
      } else {
        return typeof defaultVal === "function" ? defaultVal() : defaultVal;
      }
    },
    deleteSticky(el, name) {
      this.updatePrivate(el, "sticky", [], (ops) => {
        return ops.filter(([existingName, _]) => existingName !== name);
      });
    },
    putSticky(el, name, op) {
      let stashedResult = op(el);
      this.updatePrivate(el, "sticky", [], (ops) => {
        let existingIndex = ops.findIndex(([existingName]) => name === existingName);
        if (existingIndex >= 0) {
          ops[existingIndex] = [name, op, stashedResult];
        } else {
          ops.push([name, op, stashedResult]);
        }
        return ops;
      });
    },
    applyStickyOperations(el) {
      let ops = DOM.private(el, "sticky");
      if (!ops) {
        return;
      }
      ops.forEach(([name, op, _stashed]) => this.putSticky(el, name, op));
    }
  };
  var dom_default = DOM;
  var UploadEntry = class {
    static isActive(fileEl, file) {
      let isNew = file._phxRef === void 0;
      let activeRefs = fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      let isActive = activeRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return file.size > 0 && (isNew || isActive);
    }
    static isPreflighted(fileEl, file) {
      let preflightedRefs = fileEl.getAttribute(PHX_PREFLIGHTED_REFS).split(",");
      let isPreflighted = preflightedRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return isPreflighted && this.isActive(fileEl, file);
    }
    static isPreflightInProgress(file) {
      return file._preflightInProgress === true;
    }
    static markPreflightInProgress(file) {
      file._preflightInProgress = true;
    }
    constructor(fileEl, file, view, autoUpload) {
      this.ref = LiveUploader.genFileRef(file);
      this.fileEl = fileEl;
      this.file = file;
      this.view = view;
      this.meta = null;
      this._isCancelled = false;
      this._isDone = false;
      this._progress = 0;
      this._lastProgressSent = -1;
      this._onDone = function() {
      };
      this._onElUpdated = this.onElUpdated.bind(this);
      this.fileEl.addEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
      this.autoUpload = autoUpload;
    }
    metadata() {
      return this.meta;
    }
    progress(progress) {
      this._progress = Math.floor(progress);
      if (this._progress > this._lastProgressSent) {
        if (this._progress >= 100) {
          this._progress = 100;
          this._lastProgressSent = 100;
          this._isDone = true;
          this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {
            LiveUploader.untrackFile(this.fileEl, this.file);
            this._onDone();
          });
        } else {
          this._lastProgressSent = this._progress;
          this.view.pushFileProgress(this.fileEl, this.ref, this._progress);
        }
      }
    }
    isCancelled() {
      return this._isCancelled;
    }
    cancel() {
      this.file._preflightInProgress = false;
      this._isCancelled = true;
      this._isDone = true;
      this._onDone();
    }
    isDone() {
      return this._isDone;
    }
    error(reason = "failed") {
      this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
      this.view.pushFileProgress(this.fileEl, this.ref, { error: reason });
      if (!this.isAutoUpload()) {
        LiveUploader.clearFiles(this.fileEl);
      }
    }
    isAutoUpload() {
      return this.autoUpload;
    }
    onDone(callback2) {
      this._onDone = () => {
        this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
        callback2();
      };
    }
    onElUpdated() {
      let activeRefs = this.fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      if (activeRefs.indexOf(this.ref) === -1) {
        LiveUploader.untrackFile(this.fileEl, this.file);
        this.cancel();
      }
    }
    toPreflightPayload() {
      return {
        last_modified: this.file.lastModified,
        name: this.file.name,
        relative_path: this.file.webkitRelativePath,
        size: this.file.size,
        type: this.file.type,
        ref: this.ref,
        meta: typeof this.file.meta === "function" ? this.file.meta() : void 0
      };
    }
    uploader(uploaders) {
      if (this.meta.uploader) {
        let callback2 = uploaders[this.meta.uploader] || logError(`no uploader configured for ${this.meta.uploader}`);
        return { name: this.meta.uploader, callback: callback2 };
      } else {
        return { name: "channel", callback: channelUploader };
      }
    }
    zipPostFlight(resp) {
      this.meta = resp.entries[this.ref];
      if (!this.meta) {
        logError(`no preflight upload response returned with ref ${this.ref}`, { input: this.fileEl, response: resp });
      }
    }
  };
  var liveUploaderFileRef = 0;
  var LiveUploader = class {
    static genFileRef(file) {
      let ref = file._phxRef;
      if (ref !== void 0) {
        return ref;
      } else {
        file._phxRef = (liveUploaderFileRef++).toString();
        return file._phxRef;
      }
    }
    static getEntryDataURL(inputEl, ref, callback2) {
      let file = this.activeFiles(inputEl).find((file2) => this.genFileRef(file2) === ref);
      callback2(URL.createObjectURL(file));
    }
    static hasUploadsInProgress(formEl) {
      let active = 0;
      dom_default.findUploadInputs(formEl).forEach((input) => {
        if (input.getAttribute(PHX_PREFLIGHTED_REFS) !== input.getAttribute(PHX_DONE_REFS)) {
          active++;
        }
      });
      return active > 0;
    }
    static serializeUploads(inputEl) {
      let files = this.activeFiles(inputEl);
      let fileData = {};
      files.forEach((file) => {
        let entry = { path: inputEl.name };
        let uploadRef = inputEl.getAttribute(PHX_UPLOAD_REF);
        fileData[uploadRef] = fileData[uploadRef] || [];
        entry.ref = this.genFileRef(file);
        entry.last_modified = file.lastModified;
        entry.name = file.name || entry.ref;
        entry.relative_path = file.webkitRelativePath;
        entry.type = file.type;
        entry.size = file.size;
        if (typeof file.meta === "function") {
          entry.meta = file.meta();
        }
        fileData[uploadRef].push(entry);
      });
      return fileData;
    }
    static clearFiles(inputEl) {
      inputEl.value = null;
      inputEl.removeAttribute(PHX_UPLOAD_REF);
      dom_default.putPrivate(inputEl, "files", []);
    }
    static untrackFile(inputEl, file) {
      dom_default.putPrivate(inputEl, "files", dom_default.private(inputEl, "files").filter((f) => !Object.is(f, file)));
    }
    static trackFiles(inputEl, files, dataTransfer) {
      if (inputEl.getAttribute("multiple") !== null) {
        let newFiles = files.filter((file) => !this.activeFiles(inputEl).find((f) => Object.is(f, file)));
        dom_default.updatePrivate(inputEl, "files", [], (existing) => existing.concat(newFiles));
        inputEl.value = null;
      } else {
        if (dataTransfer && dataTransfer.files.length > 0) {
          inputEl.files = dataTransfer.files;
        }
        dom_default.putPrivate(inputEl, "files", files);
      }
    }
    static activeFileInputs(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((el) => el.files && this.activeFiles(el).length > 0);
    }
    static activeFiles(input) {
      return (dom_default.private(input, "files") || []).filter((f) => UploadEntry.isActive(input, f));
    }
    static inputsAwaitingPreflight(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((input) => this.filesAwaitingPreflight(input).length > 0);
    }
    static filesAwaitingPreflight(input) {
      return this.activeFiles(input).filter((f) => !UploadEntry.isPreflighted(input, f) && !UploadEntry.isPreflightInProgress(f));
    }
    static markPreflightInProgress(entries) {
      entries.forEach((entry) => UploadEntry.markPreflightInProgress(entry.file));
    }
    constructor(inputEl, view, onComplete) {
      this.autoUpload = dom_default.isAutoUpload(inputEl);
      this.view = view;
      this.onComplete = onComplete;
      this._entries = Array.from(LiveUploader.filesAwaitingPreflight(inputEl) || []).map((file) => new UploadEntry(inputEl, file, view, this.autoUpload));
      LiveUploader.markPreflightInProgress(this._entries);
      this.numEntriesInProgress = this._entries.length;
    }
    isAutoUpload() {
      return this.autoUpload;
    }
    entries() {
      return this._entries;
    }
    initAdapterUpload(resp, onError, liveSocket2) {
      this._entries = this._entries.map((entry) => {
        if (entry.isCancelled()) {
          this.numEntriesInProgress--;
          if (this.numEntriesInProgress === 0) {
            this.onComplete();
          }
        } else {
          entry.zipPostFlight(resp);
          entry.onDone(() => {
            this.numEntriesInProgress--;
            if (this.numEntriesInProgress === 0) {
              this.onComplete();
            }
          });
        }
        return entry;
      });
      let groupedEntries = this._entries.reduce((acc, entry) => {
        if (!entry.meta) {
          return acc;
        }
        let { name, callback: callback2 } = entry.uploader(liveSocket2.uploaders);
        acc[name] = acc[name] || { callback: callback2, entries: [] };
        acc[name].entries.push(entry);
        return acc;
      }, {});
      for (let name in groupedEntries) {
        let { callback: callback2, entries } = groupedEntries[name];
        callback2(entries, onError, resp, liveSocket2);
      }
    }
  };
  var Hooks = {
    LiveFileUpload: {
      activeRefs() {
        return this.el.getAttribute(PHX_ACTIVE_ENTRY_REFS);
      },
      preflightedRefs() {
        return this.el.getAttribute(PHX_PREFLIGHTED_REFS);
      },
      mounted() {
        this.preflightedWas = this.preflightedRefs();
      },
      updated() {
        let newPreflights = this.preflightedRefs();
        if (this.preflightedWas !== newPreflights) {
          this.preflightedWas = newPreflights;
          if (newPreflights === "") {
            this.__view.cancelSubmit(this.el.form);
          }
        }
        if (this.activeRefs() === "") {
          this.el.value = null;
        }
        this.el.dispatchEvent(new CustomEvent(PHX_LIVE_FILE_UPDATED));
      }
    },
    LiveImgPreview: {
      mounted() {
        this.ref = this.el.getAttribute("data-phx-entry-ref");
        this.inputEl = document.getElementById(this.el.getAttribute(PHX_UPLOAD_REF));
        LiveUploader.getEntryDataURL(this.inputEl, this.ref, (url) => {
          this.url = url;
          this.el.src = url;
        });
      },
      destroyed() {
        URL.revokeObjectURL(this.url);
      }
    },
    FocusWrap: {
      mounted() {
        this.focusStart = this.el.firstElementChild;
        this.focusEnd = this.el.lastElementChild;
        this.focusStart.addEventListener("focus", () => aria_default.focusLast(this.el));
        this.focusEnd.addEventListener("focus", () => aria_default.focusFirst(this.el));
        this.el.addEventListener("phx:show-end", () => this.el.focus());
        if (window.getComputedStyle(this.el).display !== "none") {
          aria_default.focusFirst(this.el);
        }
      }
    }
  };
  var findScrollContainer = (el) => {
    if (["scroll", "auto"].indexOf(getComputedStyle(el).overflowY) >= 0)
      return el;
    if (document.documentElement === el)
      return null;
    return findScrollContainer(el.parentElement);
  };
  var scrollTop = (scrollContainer) => {
    if (scrollContainer) {
      return scrollContainer.scrollTop;
    } else {
      return document.documentElement.scrollTop || document.body.scrollTop;
    }
  };
  var bottom = (scrollContainer) => {
    if (scrollContainer) {
      return scrollContainer.getBoundingClientRect().bottom;
    } else {
      return window.innerHeight || document.documentElement.clientHeight;
    }
  };
  var top = (scrollContainer) => {
    if (scrollContainer) {
      return scrollContainer.getBoundingClientRect().top;
    } else {
      return 0;
    }
  };
  var isAtViewportTop = (el, scrollContainer) => {
    let rect = el.getBoundingClientRect();
    return rect.top >= top(scrollContainer) && rect.left >= 0 && rect.top <= bottom(scrollContainer);
  };
  var isAtViewportBottom = (el, scrollContainer) => {
    let rect = el.getBoundingClientRect();
    return rect.right >= top(scrollContainer) && rect.left >= 0 && rect.bottom <= bottom(scrollContainer);
  };
  var isWithinViewport = (el, scrollContainer) => {
    let rect = el.getBoundingClientRect();
    return rect.top >= top(scrollContainer) && rect.left >= 0 && rect.top <= bottom(scrollContainer);
  };
  Hooks.InfiniteScroll = {
    mounted() {
      this.scrollContainer = findScrollContainer(this.el);
      let scrollBefore = scrollTop(this.scrollContainer);
      let topOverran = false;
      let throttleInterval = 500;
      let pendingOp = null;
      let onTopOverrun = this.throttle(throttleInterval, (topEvent, firstChild) => {
        pendingOp = () => true;
        this.liveSocket.execJSHookPush(this.el, topEvent, { id: firstChild.id, _overran: true }, () => {
          pendingOp = null;
        });
      });
      let onFirstChildAtTop = this.throttle(throttleInterval, (topEvent, firstChild) => {
        pendingOp = () => firstChild.scrollIntoView({ block: "start" });
        this.liveSocket.execJSHookPush(this.el, topEvent, { id: firstChild.id }, () => {
          pendingOp = null;
          window.requestAnimationFrame(() => {
            if (!isWithinViewport(firstChild, this.scrollContainer)) {
              firstChild.scrollIntoView({ block: "start" });
            }
          });
        });
      });
      let onLastChildAtBottom = this.throttle(throttleInterval, (bottomEvent, lastChild) => {
        pendingOp = () => lastChild.scrollIntoView({ block: "end" });
        this.liveSocket.execJSHookPush(this.el, bottomEvent, { id: lastChild.id }, () => {
          pendingOp = null;
          window.requestAnimationFrame(() => {
            if (!isWithinViewport(lastChild, this.scrollContainer)) {
              lastChild.scrollIntoView({ block: "end" });
            }
          });
        });
      });
      this.onScroll = (_e) => {
        let scrollNow = scrollTop(this.scrollContainer);
        if (pendingOp) {
          scrollBefore = scrollNow;
          return pendingOp();
        }
        let rect = this.el.getBoundingClientRect();
        let topEvent = this.el.getAttribute(this.liveSocket.binding("viewport-top"));
        let bottomEvent = this.el.getAttribute(this.liveSocket.binding("viewport-bottom"));
        let lastChild = this.el.lastElementChild;
        let firstChild = this.el.firstElementChild;
        let isScrollingUp = scrollNow < scrollBefore;
        let isScrollingDown = scrollNow > scrollBefore;
        if (isScrollingUp && topEvent && !topOverran && rect.top >= 0) {
          topOverran = true;
          onTopOverrun(topEvent, firstChild);
        } else if (isScrollingDown && topOverran && rect.top <= 0) {
          topOverran = false;
        }
        if (topEvent && isScrollingUp && isAtViewportTop(firstChild, this.scrollContainer)) {
          onFirstChildAtTop(topEvent, firstChild);
        } else if (bottomEvent && isScrollingDown && isAtViewportBottom(lastChild, this.scrollContainer)) {
          onLastChildAtBottom(bottomEvent, lastChild);
        }
        scrollBefore = scrollNow;
      };
      if (this.scrollContainer) {
        this.scrollContainer.addEventListener("scroll", this.onScroll);
      } else {
        window.addEventListener("scroll", this.onScroll);
      }
    },
    destroyed() {
      if (this.scrollContainer) {
        this.scrollContainer.removeEventListener("scroll", this.onScroll);
      } else {
        window.removeEventListener("scroll", this.onScroll);
      }
    },
    throttle(interval, callback2) {
      let lastCallAt = 0;
      let timer;
      return (...args) => {
        let now = Date.now();
        let remainingTime = interval - (now - lastCallAt);
        if (remainingTime <= 0 || remainingTime > interval) {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
          lastCallAt = now;
          callback2(...args);
        } else if (!timer) {
          timer = setTimeout(() => {
            lastCallAt = Date.now();
            timer = null;
            callback2(...args);
          }, remainingTime);
        }
      };
    }
  };
  var hooks_default = Hooks;
  var DOMPostMorphRestorer = class {
    constructor(containerBefore, containerAfter, updateType) {
      let idsBefore = /* @__PURE__ */ new Set();
      let idsAfter = new Set([...containerAfter.children].map((child) => child.id));
      let elementsToModify = [];
      Array.from(containerBefore.children).forEach((child) => {
        if (child.id) {
          idsBefore.add(child.id);
          if (idsAfter.has(child.id)) {
            let previousElementId = child.previousElementSibling && child.previousElementSibling.id;
            elementsToModify.push({ elementId: child.id, previousElementId });
          }
        }
      });
      this.containerId = containerAfter.id;
      this.updateType = updateType;
      this.elementsToModify = elementsToModify;
      this.elementIdsToAdd = [...idsAfter].filter((id) => !idsBefore.has(id));
    }
    perform() {
      let container = dom_default.byId(this.containerId);
      this.elementsToModify.forEach((elementToModify) => {
        if (elementToModify.previousElementId) {
          maybe(document.getElementById(elementToModify.previousElementId), (previousElem) => {
            maybe(document.getElementById(elementToModify.elementId), (elem) => {
              let isInRightPlace = elem.previousElementSibling && elem.previousElementSibling.id == previousElem.id;
              if (!isInRightPlace) {
                previousElem.insertAdjacentElement("afterend", elem);
              }
            });
          });
        } else {
          maybe(document.getElementById(elementToModify.elementId), (elem) => {
            let isInRightPlace = elem.previousElementSibling == null;
            if (!isInRightPlace) {
              container.insertAdjacentElement("afterbegin", elem);
            }
          });
        }
      });
      if (this.updateType == "prepend") {
        this.elementIdsToAdd.reverse().forEach((elemId) => {
          maybe(document.getElementById(elemId), (elem) => container.insertAdjacentElement("afterbegin", elem));
        });
      }
    }
  };
  var DOCUMENT_FRAGMENT_NODE = 11;
  function morphAttrs(fromNode, toNode) {
    var toNodeAttrs = toNode.attributes;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;
    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return;
    }
    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {
      attr = toNodeAttrs[i];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      attrValue = attr.value;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);
        if (fromValue !== attrValue) {
          if (attr.prefix === "xmlns") {
            attrName = attr.name;
          }
          fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
        }
      } else {
        fromValue = fromNode.getAttribute(attrName);
        if (fromValue !== attrValue) {
          fromNode.setAttribute(attrName, attrValue);
        }
      }
    }
    var fromNodeAttrs = fromNode.attributes;
    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {
      attr = fromNodeAttrs[d];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          fromNode.removeAttributeNS(attrNamespaceURI, attrName);
        }
      } else {
        if (!toNode.hasAttribute(attrName)) {
          fromNode.removeAttribute(attrName);
        }
      }
    }
  }
  var range;
  var NS_XHTML = "http://www.w3.org/1999/xhtml";
  var doc = typeof document === "undefined" ? void 0 : document;
  var HAS_TEMPLATE_SUPPORT = !!doc && "content" in doc.createElement("template");
  var HAS_RANGE_SUPPORT = !!doc && doc.createRange && "createContextualFragment" in doc.createRange();
  function createFragmentFromTemplate(str) {
    var template = doc.createElement("template");
    template.innerHTML = str;
    return template.content.childNodes[0];
  }
  function createFragmentFromRange(str) {
    if (!range) {
      range = doc.createRange();
      range.selectNode(doc.body);
    }
    var fragment = range.createContextualFragment(str);
    return fragment.childNodes[0];
  }
  function createFragmentFromWrap(str) {
    var fragment = doc.createElement("body");
    fragment.innerHTML = str;
    return fragment.childNodes[0];
  }
  function toElement(str) {
    str = str.trim();
    if (HAS_TEMPLATE_SUPPORT) {
      return createFragmentFromTemplate(str);
    } else if (HAS_RANGE_SUPPORT) {
      return createFragmentFromRange(str);
    }
    return createFragmentFromWrap(str);
  }
  function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;
    var fromCodeStart, toCodeStart;
    if (fromNodeName === toNodeName) {
      return true;
    }
    fromCodeStart = fromNodeName.charCodeAt(0);
    toCodeStart = toNodeName.charCodeAt(0);
    if (fromCodeStart <= 90 && toCodeStart >= 97) {
      return fromNodeName === toNodeName.toUpperCase();
    } else if (toCodeStart <= 90 && fromCodeStart >= 97) {
      return toNodeName === fromNodeName.toUpperCase();
    } else {
      return false;
    }
  }
  function createElementNS(name, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);
  }
  function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
      var nextChild = curChild.nextSibling;
      toEl.appendChild(curChild);
      curChild = nextChild;
    }
    return toEl;
  }
  function syncBooleanAttrProp(fromEl, toEl, name) {
    if (fromEl[name] !== toEl[name]) {
      fromEl[name] = toEl[name];
      if (fromEl[name]) {
        fromEl.setAttribute(name, "");
      } else {
        fromEl.removeAttribute(name);
      }
    }
  }
  var specialElHandlers = {
    OPTION: function(fromEl, toEl) {
      var parentNode = fromEl.parentNode;
      if (parentNode) {
        var parentName = parentNode.nodeName.toUpperCase();
        if (parentName === "OPTGROUP") {
          parentNode = parentNode.parentNode;
          parentName = parentNode && parentNode.nodeName.toUpperCase();
        }
        if (parentName === "SELECT" && !parentNode.hasAttribute("multiple")) {
          if (fromEl.hasAttribute("selected") && !toEl.selected) {
            fromEl.setAttribute("selected", "selected");
            fromEl.removeAttribute("selected");
          }
          parentNode.selectedIndex = -1;
        }
      }
      syncBooleanAttrProp(fromEl, toEl, "selected");
    },
    INPUT: function(fromEl, toEl) {
      syncBooleanAttrProp(fromEl, toEl, "checked");
      syncBooleanAttrProp(fromEl, toEl, "disabled");
      if (fromEl.value !== toEl.value) {
        fromEl.value = toEl.value;
      }
      if (!toEl.hasAttribute("value")) {
        fromEl.removeAttribute("value");
      }
    },
    TEXTAREA: function(fromEl, toEl) {
      var newValue = toEl.value;
      if (fromEl.value !== newValue) {
        fromEl.value = newValue;
      }
      var firstChild = fromEl.firstChild;
      if (firstChild) {
        var oldValue = firstChild.nodeValue;
        if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {
          return;
        }
        firstChild.nodeValue = newValue;
      }
    },
    SELECT: function(fromEl, toEl) {
      if (!toEl.hasAttribute("multiple")) {
        var selectedIndex = -1;
        var i = 0;
        var curChild = fromEl.firstChild;
        var optgroup;
        var nodeName;
        while (curChild) {
          nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
          if (nodeName === "OPTGROUP") {
            optgroup = curChild;
            curChild = optgroup.firstChild;
          } else {
            if (nodeName === "OPTION") {
              if (curChild.hasAttribute("selected")) {
                selectedIndex = i;
                break;
              }
              i++;
            }
            curChild = curChild.nextSibling;
            if (!curChild && optgroup) {
              curChild = optgroup.nextSibling;
              optgroup = null;
            }
          }
        }
        fromEl.selectedIndex = selectedIndex;
      }
    }
  };
  var ELEMENT_NODE = 1;
  var DOCUMENT_FRAGMENT_NODE$1 = 11;
  var TEXT_NODE = 3;
  var COMMENT_NODE = 8;
  function noop() {
  }
  function defaultGetNodeKey(node) {
    if (node) {
      return node.getAttribute && node.getAttribute("id") || node.id;
    }
  }
  function morphdomFactory(morphAttrs2) {
    return function morphdom2(fromNode, toNode, options) {
      if (!options) {
        options = {};
      }
      if (typeof toNode === "string") {
        if (fromNode.nodeName === "#document" || fromNode.nodeName === "HTML" || fromNode.nodeName === "BODY") {
          var toNodeHtml = toNode;
          toNode = doc.createElement("html");
          toNode.innerHTML = toNodeHtml;
        } else {
          toNode = toElement(toNode);
        }
      } else if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
        toNode = toNode.firstElementChild;
      }
      var getNodeKey = options.getNodeKey || defaultGetNodeKey;
      var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
      var onNodeAdded = options.onNodeAdded || noop;
      var onBeforeElUpdated = options.onBeforeElUpdated || noop;
      var onElUpdated = options.onElUpdated || noop;
      var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
      var onNodeDiscarded = options.onNodeDiscarded || noop;
      var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
      var skipFromChildren = options.skipFromChildren || noop;
      var addChild = options.addChild || function(parent, child) {
        return parent.appendChild(child);
      };
      var childrenOnly = options.childrenOnly === true;
      var fromNodesLookup = /* @__PURE__ */ Object.create(null);
      var keyedRemovalList = [];
      function addKeyedRemoval(key) {
        keyedRemovalList.push(key);
      }
      function walkDiscardedChildNodes(node, skipKeyedNodes) {
        if (node.nodeType === ELEMENT_NODE) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = void 0;
            if (skipKeyedNodes && (key = getNodeKey(curChild))) {
              addKeyedRemoval(key);
            } else {
              onNodeDiscarded(curChild);
              if (curChild.firstChild) {
                walkDiscardedChildNodes(curChild, skipKeyedNodes);
              }
            }
            curChild = curChild.nextSibling;
          }
        }
      }
      function removeNode(node, parentNode, skipKeyedNodes) {
        if (onBeforeNodeDiscarded(node) === false) {
          return;
        }
        if (parentNode) {
          parentNode.removeChild(node);
        }
        onNodeDiscarded(node);
        walkDiscardedChildNodes(node, skipKeyedNodes);
      }
      function indexTree(node) {
        if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = getNodeKey(curChild);
            if (key) {
              fromNodesLookup[key] = curChild;
            }
            indexTree(curChild);
            curChild = curChild.nextSibling;
          }
        }
      }
      indexTree(fromNode);
      function handleNodeAdded(el) {
        onNodeAdded(el);
        var curChild = el.firstChild;
        while (curChild) {
          var nextSibling = curChild.nextSibling;
          var key = getNodeKey(curChild);
          if (key) {
            var unmatchedFromEl = fromNodesLookup[key];
            if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
              curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
              morphEl(unmatchedFromEl, curChild);
            } else {
              handleNodeAdded(curChild);
            }
          } else {
            handleNodeAdded(curChild);
          }
          curChild = nextSibling;
        }
      }
      function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
        while (curFromNodeChild) {
          var fromNextSibling = curFromNodeChild.nextSibling;
          if (curFromNodeKey = getNodeKey(curFromNodeChild)) {
            addKeyedRemoval(curFromNodeKey);
          } else {
            removeNode(curFromNodeChild, fromEl, true);
          }
          curFromNodeChild = fromNextSibling;
        }
      }
      function morphEl(fromEl, toEl, childrenOnly2) {
        var toElKey = getNodeKey(toEl);
        if (toElKey) {
          delete fromNodesLookup[toElKey];
        }
        if (!childrenOnly2) {
          if (onBeforeElUpdated(fromEl, toEl) === false) {
            return;
          }
          morphAttrs2(fromEl, toEl);
          onElUpdated(fromEl);
          if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
            return;
          }
        }
        if (fromEl.nodeName !== "TEXTAREA") {
          morphChildren(fromEl, toEl);
        } else {
          specialElHandlers.TEXTAREA(fromEl, toEl);
        }
      }
      function morphChildren(fromEl, toEl) {
        var skipFrom = skipFromChildren(fromEl, toEl);
        var curToNodeChild = toEl.firstChild;
        var curFromNodeChild = fromEl.firstChild;
        var curToNodeKey;
        var curFromNodeKey;
        var fromNextSibling;
        var toNextSibling;
        var matchingFromEl;
        outer:
          while (curToNodeChild) {
            toNextSibling = curToNodeChild.nextSibling;
            curToNodeKey = getNodeKey(curToNodeChild);
            while (!skipFrom && curFromNodeChild) {
              fromNextSibling = curFromNodeChild.nextSibling;
              if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              curFromNodeKey = getNodeKey(curFromNodeChild);
              var curFromNodeType = curFromNodeChild.nodeType;
              var isCompatible = void 0;
              if (curFromNodeType === curToNodeChild.nodeType) {
                if (curFromNodeType === ELEMENT_NODE) {
                  if (curToNodeKey) {
                    if (curToNodeKey !== curFromNodeKey) {
                      if (matchingFromEl = fromNodesLookup[curToNodeKey]) {
                        if (fromNextSibling === matchingFromEl) {
                          isCompatible = false;
                        } else {
                          fromEl.insertBefore(matchingFromEl, curFromNodeChild);
                          if (curFromNodeKey) {
                            addKeyedRemoval(curFromNodeKey);
                          } else {
                            removeNode(curFromNodeChild, fromEl, true);
                          }
                          curFromNodeChild = matchingFromEl;
                          curFromNodeKey = getNodeKey(curFromNodeChild);
                        }
                      } else {
                        isCompatible = false;
                      }
                    }
                  } else if (curFromNodeKey) {
                    isCompatible = false;
                  }
                  isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                  if (isCompatible) {
                    morphEl(curFromNodeChild, curToNodeChild);
                  }
                } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                  isCompatible = true;
                  if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                  }
                }
              }
              if (isCompatible) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              if (curFromNodeKey) {
                addKeyedRemoval(curFromNodeKey);
              } else {
                removeNode(curFromNodeChild, fromEl, true);
              }
              curFromNodeChild = fromNextSibling;
            }
            if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
              if (!skipFrom) {
                addChild(fromEl, matchingFromEl);
              }
              morphEl(matchingFromEl, curToNodeChild);
            } else {
              var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
              if (onBeforeNodeAddedResult !== false) {
                if (onBeforeNodeAddedResult) {
                  curToNodeChild = onBeforeNodeAddedResult;
                }
                if (curToNodeChild.actualize) {
                  curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
                }
                addChild(fromEl, curToNodeChild);
                handleNodeAdded(curToNodeChild);
              }
            }
            curToNodeChild = toNextSibling;
            curFromNodeChild = fromNextSibling;
          }
        cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);
        var specialElHandler = specialElHandlers[fromEl.nodeName];
        if (specialElHandler) {
          specialElHandler(fromEl, toEl);
        }
      }
      var morphedNode = fromNode;
      var morphedNodeType = morphedNode.nodeType;
      var toNodeType = toNode.nodeType;
      if (!childrenOnly) {
        if (morphedNodeType === ELEMENT_NODE) {
          if (toNodeType === ELEMENT_NODE) {
            if (!compareNodeNames(fromNode, toNode)) {
              onNodeDiscarded(fromNode);
              morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
            }
          } else {
            morphedNode = toNode;
          }
        } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {
          if (toNodeType === morphedNodeType) {
            if (morphedNode.nodeValue !== toNode.nodeValue) {
              morphedNode.nodeValue = toNode.nodeValue;
            }
            return morphedNode;
          } else {
            morphedNode = toNode;
          }
        }
      }
      if (morphedNode === toNode) {
        onNodeDiscarded(fromNode);
      } else {
        if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
          return;
        }
        morphEl(morphedNode, toNode, childrenOnly);
        if (keyedRemovalList) {
          for (var i = 0, len = keyedRemovalList.length; i < len; i++) {
            var elToRemove = fromNodesLookup[keyedRemovalList[i]];
            if (elToRemove) {
              removeNode(elToRemove, elToRemove.parentNode, false);
            }
          }
        }
      }
      if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
        if (morphedNode.actualize) {
          morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
        }
        fromNode.parentNode.replaceChild(morphedNode, fromNode);
      }
      return morphedNode;
    };
  }
  var morphdom = morphdomFactory(morphAttrs);
  var morphdom_esm_default = morphdom;
  var DOMPatch = class {
    static patchEl(fromEl, toEl, activeElement) {
      morphdom_esm_default(fromEl, toEl, {
        childrenOnly: false,
        onBeforeElUpdated: (fromEl2, toEl2) => {
          if (activeElement && activeElement.isSameNode(fromEl2) && dom_default.isFormInput(fromEl2)) {
            dom_default.mergeFocusedInput(fromEl2, toEl2);
            return false;
          }
        }
      });
    }
    constructor(view, container, id, html, streams, targetCID) {
      this.view = view;
      this.liveSocket = view.liveSocket;
      this.container = container;
      this.id = id;
      this.rootID = view.root.id;
      this.html = html;
      this.streams = streams;
      this.streamInserts = {};
      this.streamComponentRestore = {};
      this.targetCID = targetCID;
      this.cidPatch = isCid(this.targetCID);
      this.pendingRemoves = [];
      this.phxRemove = this.liveSocket.binding("remove");
      this.callbacks = {
        beforeadded: [],
        beforeupdated: [],
        beforephxChildAdded: [],
        afteradded: [],
        afterupdated: [],
        afterdiscarded: [],
        afterphxChildAdded: [],
        aftertransitionsDiscarded: []
      };
    }
    before(kind, callback2) {
      this.callbacks[`before${kind}`].push(callback2);
    }
    after(kind, callback2) {
      this.callbacks[`after${kind}`].push(callback2);
    }
    trackBefore(kind, ...args) {
      this.callbacks[`before${kind}`].forEach((callback2) => callback2(...args));
    }
    trackAfter(kind, ...args) {
      this.callbacks[`after${kind}`].forEach((callback2) => callback2(...args));
    }
    markPrunableContentForRemoval() {
      let phxUpdate = this.liveSocket.binding(PHX_UPDATE);
      dom_default.all(this.container, `[${phxUpdate}=append] > *, [${phxUpdate}=prepend] > *`, (el) => {
        el.setAttribute(PHX_PRUNE, "");
      });
    }
    perform(isJoinPatch) {
      let { view, liveSocket: liveSocket2, container, html } = this;
      let targetContainer = this.isCIDPatch() ? this.targetCIDContainer(html) : container;
      if (this.isCIDPatch() && !targetContainer) {
        return;
      }
      let focused = liveSocket2.getActiveElement();
      let { selectionStart, selectionEnd } = focused && dom_default.hasSelectionRange(focused) ? focused : {};
      let phxUpdate = liveSocket2.binding(PHX_UPDATE);
      let phxFeedbackFor = liveSocket2.binding(PHX_FEEDBACK_FOR);
      let phxFeedbackGroup = liveSocket2.binding(PHX_FEEDBACK_GROUP);
      let disableWith = liveSocket2.binding(PHX_DISABLE_WITH);
      let phxViewportTop = liveSocket2.binding(PHX_VIEWPORT_TOP);
      let phxViewportBottom = liveSocket2.binding(PHX_VIEWPORT_BOTTOM);
      let phxTriggerExternal = liveSocket2.binding(PHX_TRIGGER_ACTION);
      let added = [];
      let feedbackContainers = [];
      let updates = [];
      let appendPrependUpdates = [];
      let externalFormTriggered = null;
      function morph(targetContainer2, source) {
        morphdom_esm_default(targetContainer2, source, {
          childrenOnly: targetContainer2.getAttribute(PHX_COMPONENT) === null,
          getNodeKey: (node) => {
            if (dom_default.isPhxDestroyed(node)) {
              return null;
            }
            if (isJoinPatch) {
              return node.id;
            }
            return node.id || node.getAttribute && node.getAttribute(PHX_MAGIC_ID);
          },
          skipFromChildren: (from2) => {
            return from2.getAttribute(phxUpdate) === PHX_STREAM;
          },
          addChild: (parent, child) => {
            let { ref, streamAt } = this.getStreamInsert(child);
            if (ref === void 0) {
              return parent.appendChild(child);
            }
            this.setStreamRef(child, ref);
            if (streamAt === 0) {
              parent.insertAdjacentElement("afterbegin", child);
            } else if (streamAt === -1) {
              parent.appendChild(child);
            } else if (streamAt > 0) {
              let sibling = Array.from(parent.children)[streamAt];
              parent.insertBefore(child, sibling);
            }
          },
          onBeforeNodeAdded: (el) => {
            dom_default.maybeAddPrivateHooks(el, phxViewportTop, phxViewportBottom);
            this.trackBefore("added", el);
            let morphedEl = el;
            if (!isJoinPatch && this.streamComponentRestore[el.id]) {
              morphedEl = this.streamComponentRestore[el.id];
              delete this.streamComponentRestore[el.id];
              morph.bind(this)(morphedEl, el);
            }
            return morphedEl;
          },
          onNodeAdded: (el) => {
            if (el.getAttribute) {
              this.maybeReOrderStream(el, true);
            }
            if (dom_default.isFeedbackContainer(el, phxFeedbackFor))
              feedbackContainers.push(el);
            if (el instanceof HTMLImageElement && el.srcset) {
              el.srcset = el.srcset;
            } else if (el instanceof HTMLVideoElement && el.autoplay) {
              el.play();
            }
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            if (dom_default.isPhxChild(el) && view.ownsElement(el) || dom_default.isPhxSticky(el) && view.ownsElement(el.parentNode)) {
              this.trackAfter("phxChildAdded", el);
            }
            added.push(el);
          },
          onNodeDiscarded: (el) => this.onNodeDiscarded(el),
          onBeforeNodeDiscarded: (el) => {
            if (el.getAttribute && el.getAttribute(PHX_PRUNE) !== null) {
              return true;
            }
            if (el.parentElement !== null && el.id && dom_default.isPhxUpdate(el.parentElement, phxUpdate, [PHX_STREAM, "append", "prepend"])) {
              return false;
            }
            if (this.maybePendingRemove(el)) {
              return false;
            }
            if (this.skipCIDSibling(el)) {
              return false;
            }
            return true;
          },
          onElUpdated: (el) => {
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            updates.push(el);
            this.maybeReOrderStream(el, false);
          },
          onBeforeElUpdated: (fromEl, toEl) => {
            dom_default.maybeAddPrivateHooks(toEl, phxViewportTop, phxViewportBottom);
            if (dom_default.isFeedbackContainer(fromEl, phxFeedbackFor) || dom_default.isFeedbackContainer(toEl, phxFeedbackFor)) {
              feedbackContainers.push(fromEl);
              feedbackContainers.push(toEl);
            }
            dom_default.cleanChildNodes(toEl, phxUpdate);
            if (this.skipCIDSibling(toEl)) {
              this.maybeReOrderStream(fromEl);
              return false;
            }
            if (dom_default.isPhxSticky(fromEl)) {
              return false;
            }
            if (dom_default.isIgnored(fromEl, phxUpdate) || fromEl.form && fromEl.form.isSameNode(externalFormTriggered)) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeAttrs(fromEl, toEl, { isIgnored: true });
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (fromEl.type === "number" && (fromEl.validity && fromEl.validity.badInput)) {
              return false;
            }
            if (!dom_default.syncPendingRef(fromEl, toEl, disableWith)) {
              if (dom_default.isUploadInput(fromEl)) {
                this.trackBefore("updated", fromEl, toEl);
                updates.push(fromEl);
              }
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (dom_default.isPhxChild(toEl)) {
              let prevSession = fromEl.getAttribute(PHX_SESSION);
              dom_default.mergeAttrs(fromEl, toEl, { exclude: [PHX_STATIC] });
              if (prevSession !== "") {
                fromEl.setAttribute(PHX_SESSION, prevSession);
              }
              fromEl.setAttribute(PHX_ROOT_ID, this.rootID);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            dom_default.copyPrivates(toEl, fromEl);
            let isFocusedFormEl = focused && fromEl.isSameNode(focused) && dom_default.isFormInput(fromEl);
            let focusedSelectChanged = isFocusedFormEl && this.isChangedSelect(fromEl, toEl);
            if (isFocusedFormEl && fromEl.type !== "hidden" && !focusedSelectChanged) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeFocusedInput(fromEl, toEl);
              dom_default.syncAttrsToProps(fromEl);
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            } else {
              if (focusedSelectChanged) {
                fromEl.blur();
              }
              if (dom_default.isPhxUpdate(toEl, phxUpdate, ["append", "prepend"])) {
                appendPrependUpdates.push(new DOMPostMorphRestorer(fromEl, toEl, toEl.getAttribute(phxUpdate)));
              }
              dom_default.syncAttrsToProps(toEl);
              dom_default.applyStickyOperations(toEl);
              this.trackBefore("updated", fromEl, toEl);
              return true;
            }
          }
        });
      }
      this.trackBefore("added", container);
      this.trackBefore("updated", container, container);
      liveSocket2.time("morphdom", () => {
        this.streams.forEach(([ref, inserts, deleteIds, reset]) => {
          inserts.forEach(([key, streamAt, limit]) => {
            this.streamInserts[key] = { ref, streamAt, limit, reset };
          });
          if (reset !== void 0) {
            dom_default.all(container, `[${PHX_STREAM_REF}="${ref}"]`, (child) => {
              this.removeStreamChildElement(child);
            });
          }
          deleteIds.forEach((id) => {
            let child = container.querySelector(`[id="${id}"]`);
            if (child) {
              this.removeStreamChildElement(child);
            }
          });
        });
        if (isJoinPatch) {
          dom_default.all(this.container, `[${phxUpdate}=${PHX_STREAM}]`, (el) => {
            this.liveSocket.owner(el, (view2) => {
              if (view2 === this.view) {
                Array.from(el.children).forEach((child) => {
                  this.removeStreamChildElement(child);
                });
              }
            });
          });
        }
        morph.bind(this)(targetContainer, html);
      });
      if (liveSocket2.isDebugEnabled()) {
        detectDuplicateIds();
      }
      if (appendPrependUpdates.length > 0) {
        liveSocket2.time("post-morph append/prepend restoration", () => {
          appendPrependUpdates.forEach((update) => update.perform());
        });
      }
      dom_default.maybeHideFeedback(targetContainer, feedbackContainers, phxFeedbackFor, phxFeedbackGroup);
      liveSocket2.silenceEvents(() => dom_default.restoreFocus(focused, selectionStart, selectionEnd));
      dom_default.dispatchEvent(document, "phx:update");
      added.forEach((el) => this.trackAfter("added", el));
      updates.forEach((el) => this.trackAfter("updated", el));
      this.transitionPendingRemoves();
      if (externalFormTriggered) {
        liveSocket2.unload();
        Object.getPrototypeOf(externalFormTriggered).submit.call(externalFormTriggered);
      }
      return true;
    }
    onNodeDiscarded(el) {
      if (dom_default.isPhxChild(el) || dom_default.isPhxSticky(el)) {
        this.liveSocket.destroyViewByEl(el);
      }
      this.trackAfter("discarded", el);
    }
    maybePendingRemove(node) {
      if (node.getAttribute && node.getAttribute(this.phxRemove) !== null) {
        this.pendingRemoves.push(node);
        return true;
      } else {
        return false;
      }
    }
    removeStreamChildElement(child) {
      if (this.streamInserts[child.id]) {
        this.streamComponentRestore[child.id] = child;
        child.remove();
      } else {
        if (!this.maybePendingRemove(child)) {
          child.remove();
          this.onNodeDiscarded(child);
        }
      }
    }
    getStreamInsert(el) {
      let insert = el.id ? this.streamInserts[el.id] : {};
      return insert || {};
    }
    setStreamRef(el, ref) {
      dom_default.putSticky(el, PHX_STREAM_REF, (el2) => el2.setAttribute(PHX_STREAM_REF, ref));
    }
    maybeReOrderStream(el, isNew) {
      let { ref, streamAt, reset } = this.getStreamInsert(el);
      if (streamAt === void 0) {
        return;
      }
      this.setStreamRef(el, ref);
      if (!reset && !isNew) {
        return;
      }
      if (!el.parentElement) {
        return;
      }
      if (streamAt === 0) {
        el.parentElement.insertBefore(el, el.parentElement.firstElementChild);
      } else if (streamAt > 0) {
        let children = Array.from(el.parentElement.children);
        let oldIndex = children.indexOf(el);
        if (streamAt >= children.length - 1) {
          el.parentElement.appendChild(el);
        } else {
          let sibling = children[streamAt];
          if (oldIndex > streamAt) {
            el.parentElement.insertBefore(el, sibling);
          } else {
            el.parentElement.insertBefore(el, sibling.nextElementSibling);
          }
        }
      }
      this.maybeLimitStream(el);
    }
    maybeLimitStream(el) {
      let { limit } = this.getStreamInsert(el);
      let children = limit !== null && Array.from(el.parentElement.children);
      if (limit && limit < 0 && children.length > limit * -1) {
        children.slice(0, children.length + limit).forEach((child) => this.removeStreamChildElement(child));
      } else if (limit && limit >= 0 && children.length > limit) {
        children.slice(limit).forEach((child) => this.removeStreamChildElement(child));
      }
    }
    transitionPendingRemoves() {
      let { pendingRemoves, liveSocket: liveSocket2 } = this;
      if (pendingRemoves.length > 0) {
        liveSocket2.transitionRemoves(pendingRemoves);
        liveSocket2.requestDOMUpdate(() => {
          pendingRemoves.forEach((el) => {
            let child = dom_default.firstPhxChild(el);
            if (child) {
              liveSocket2.destroyViewByEl(child);
            }
            el.remove();
          });
          this.trackAfter("transitionsDiscarded", pendingRemoves);
        });
      }
    }
    isChangedSelect(fromEl, toEl) {
      if (!(fromEl instanceof HTMLSelectElement) || fromEl.multiple) {
        return false;
      }
      if (fromEl.options.length !== toEl.options.length) {
        return true;
      }
      let fromSelected = fromEl.selectedOptions[0];
      let toSelected = toEl.selectedOptions[0];
      if (fromSelected && fromSelected.hasAttribute("selected")) {
        toSelected.setAttribute("selected", fromSelected.getAttribute("selected"));
      }
      return !fromEl.isEqualNode(toEl);
    }
    isCIDPatch() {
      return this.cidPatch;
    }
    skipCIDSibling(el) {
      return el.nodeType === Node.ELEMENT_NODE && el.hasAttribute(PHX_SKIP);
    }
    targetCIDContainer(html) {
      if (!this.isCIDPatch()) {
        return;
      }
      let [first, ...rest] = dom_default.findComponentNodeList(this.container, this.targetCID);
      if (rest.length === 0 && dom_default.childNodeLength(html) === 1) {
        return first;
      } else {
        return first && first.parentNode;
      }
    }
    indexOf(parent, child) {
      return Array.from(parent.children).indexOf(child);
    }
  };
  var VOID_TAGS = /* @__PURE__ */ new Set([
    "area",
    "base",
    "br",
    "col",
    "command",
    "embed",
    "hr",
    "img",
    "input",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  var quoteChars = /* @__PURE__ */ new Set(["'", '"']);
  var modifyRoot = (html, attrs, clearInnerHTML) => {
    let i = 0;
    let insideComment = false;
    let beforeTag, afterTag, tag, tagNameEndsAt, id, newHTML;
    let lookahead = html.match(/^(\s*(?:<!--.*?-->\s*)*)<([^\s\/>]+)/);
    if (lookahead === null) {
      throw new Error(`malformed html ${html}`);
    }
    i = lookahead[0].length;
    beforeTag = lookahead[1];
    tag = lookahead[2];
    tagNameEndsAt = i;
    for (i; i < html.length; i++) {
      if (html.charAt(i) === ">") {
        break;
      }
      if (html.charAt(i) === "=") {
        let isId = html.slice(i - 3, i) === " id";
        i++;
        let char = html.charAt(i);
        if (quoteChars.has(char)) {
          let attrStartsAt = i;
          i++;
          for (i; i < html.length; i++) {
            if (html.charAt(i) === char) {
              break;
            }
          }
          if (isId) {
            id = html.slice(attrStartsAt + 1, i);
            break;
          }
        }
      }
    }
    let closeAt = html.length - 1;
    insideComment = false;
    while (closeAt >= beforeTag.length + tag.length) {
      let char = html.charAt(closeAt);
      if (insideComment) {
        if (char === "-" && html.slice(closeAt - 3, closeAt) === "<!-") {
          insideComment = false;
          closeAt -= 4;
        } else {
          closeAt -= 1;
        }
      } else if (char === ">" && html.slice(closeAt - 2, closeAt) === "--") {
        insideComment = true;
        closeAt -= 3;
      } else if (char === ">") {
        break;
      } else {
        closeAt -= 1;
      }
    }
    afterTag = html.slice(closeAt + 1, html.length);
    let attrsStr = Object.keys(attrs).map((attr) => attrs[attr] === true ? attr : `${attr}="${attrs[attr]}"`).join(" ");
    if (clearInnerHTML) {
      let idAttrStr = id ? ` id="${id}"` : "";
      if (VOID_TAGS.has(tag)) {
        newHTML = `<${tag}${idAttrStr}${attrsStr === "" ? "" : " "}${attrsStr}/>`;
      } else {
        newHTML = `<${tag}${idAttrStr}${attrsStr === "" ? "" : " "}${attrsStr}></${tag}>`;
      }
    } else {
      let rest = html.slice(tagNameEndsAt, closeAt + 1);
      newHTML = `<${tag}${attrsStr === "" ? "" : " "}${attrsStr}${rest}`;
    }
    return [newHTML, beforeTag, afterTag];
  };
  var Rendered = class {
    static extract(diff) {
      let { [REPLY]: reply, [EVENTS]: events, [TITLE]: title } = diff;
      delete diff[REPLY];
      delete diff[EVENTS];
      delete diff[TITLE];
      return { diff, title, reply: reply || null, events: events || [] };
    }
    constructor(viewId, rendered) {
      this.viewId = viewId;
      this.rendered = {};
      this.magicId = 0;
      this.mergeDiff(rendered);
    }
    parentViewId() {
      return this.viewId;
    }
    toString(onlyCids) {
      let [str, streams] = this.recursiveToString(this.rendered, this.rendered[COMPONENTS], onlyCids, true, {});
      return [str, streams];
    }
    recursiveToString(rendered, components = rendered[COMPONENTS], onlyCids, changeTracking, rootAttrs) {
      onlyCids = onlyCids ? new Set(onlyCids) : null;
      let output = { buffer: "", components, onlyCids, streams: /* @__PURE__ */ new Set() };
      this.toOutputBuffer(rendered, null, output, changeTracking, rootAttrs);
      return [output.buffer, output.streams];
    }
    componentCIDs(diff) {
      return Object.keys(diff[COMPONENTS] || {}).map((i) => parseInt(i));
    }
    isComponentOnlyDiff(diff) {
      if (!diff[COMPONENTS]) {
        return false;
      }
      return Object.keys(diff).length === 1;
    }
    getComponent(diff, cid) {
      return diff[COMPONENTS][cid];
    }
    resetRender(cid) {
      if (this.rendered[COMPONENTS][cid]) {
        this.rendered[COMPONENTS][cid].reset = true;
      }
    }
    mergeDiff(diff) {
      let newc = diff[COMPONENTS];
      let cache = {};
      delete diff[COMPONENTS];
      this.rendered = this.mutableMerge(this.rendered, diff);
      this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};
      if (newc) {
        let oldc = this.rendered[COMPONENTS];
        for (let cid in newc) {
          newc[cid] = this.cachedFindComponent(cid, newc[cid], oldc, newc, cache);
        }
        for (let cid in newc) {
          oldc[cid] = newc[cid];
        }
        diff[COMPONENTS] = newc;
      }
    }
    cachedFindComponent(cid, cdiff, oldc, newc, cache) {
      if (cache[cid]) {
        return cache[cid];
      } else {
        let ndiff, stat, scid = cdiff[STATIC];
        if (isCid(scid)) {
          let tdiff;
          if (scid > 0) {
            tdiff = this.cachedFindComponent(scid, newc[scid], oldc, newc, cache);
          } else {
            tdiff = oldc[-scid];
          }
          stat = tdiff[STATIC];
          ndiff = this.cloneMerge(tdiff, cdiff, true);
          ndiff[STATIC] = stat;
        } else {
          ndiff = cdiff[STATIC] !== void 0 || oldc[cid] === void 0 ? cdiff : this.cloneMerge(oldc[cid], cdiff, false);
        }
        cache[cid] = ndiff;
        return ndiff;
      }
    }
    mutableMerge(target, source) {
      if (source[STATIC] !== void 0) {
        return source;
      } else {
        this.doMutableMerge(target, source);
        return target;
      }
    }
    doMutableMerge(target, source) {
      for (let key in source) {
        let val = source[key];
        let targetVal = target[key];
        let isObjVal = isObject(val);
        if (isObjVal && val[STATIC] === void 0 && isObject(targetVal)) {
          this.doMutableMerge(targetVal, val);
        } else {
          target[key] = val;
        }
      }
      if (target[ROOT]) {
        target.newRender = true;
      }
    }
    cloneMerge(target, source, pruneMagicId) {
      let merged = __spreadValues(__spreadValues({}, target), source);
      for (let key in merged) {
        let val = source[key];
        let targetVal = target[key];
        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {
          merged[key] = this.cloneMerge(targetVal, val, pruneMagicId);
        } else if (val === void 0 && isObject(targetVal)) {
          merged[key] = this.cloneMerge(targetVal, {}, pruneMagicId);
        }
      }
      if (pruneMagicId) {
        delete merged.magicId;
        delete merged.newRender;
      } else if (target[ROOT]) {
        merged.newRender = true;
      }
      return merged;
    }
    componentToString(cid) {
      let [str, streams] = this.recursiveCIDToString(this.rendered[COMPONENTS], cid, null);
      let [strippedHTML, _before, _after] = modifyRoot(str, {});
      return [strippedHTML, streams];
    }
    pruneCIDs(cids) {
      cids.forEach((cid) => delete this.rendered[COMPONENTS][cid]);
    }
    get() {
      return this.rendered;
    }
    isNewFingerprint(diff = {}) {
      return !!diff[STATIC];
    }
    templateStatic(part, templates) {
      if (typeof part === "number") {
        return templates[part];
      } else {
        return part;
      }
    }
    nextMagicID() {
      this.magicId++;
      return `m${this.magicId}-${this.parentViewId()}`;
    }
    toOutputBuffer(rendered, templates, output, changeTracking, rootAttrs = {}) {
      if (rendered[DYNAMICS]) {
        return this.comprehensionToBuffer(rendered, templates, output);
      }
      let { [STATIC]: statics } = rendered;
      statics = this.templateStatic(statics, templates);
      let isRoot = rendered[ROOT];
      let prevBuffer = output.buffer;
      if (isRoot) {
        output.buffer = "";
      }
      if (changeTracking && isRoot && !rendered.magicId) {
        rendered.newRender = true;
        rendered.magicId = this.nextMagicID();
      }
      output.buffer += statics[0];
      for (let i = 1; i < statics.length; i++) {
        this.dynamicToBuffer(rendered[i - 1], templates, output, changeTracking);
        output.buffer += statics[i];
      }
      if (isRoot) {
        let skip2 = false;
        let attrs;
        if (changeTracking || rendered.magicId) {
          skip2 = changeTracking && !rendered.newRender;
          attrs = __spreadValues({ [PHX_MAGIC_ID]: rendered.magicId }, rootAttrs);
        } else {
          attrs = rootAttrs;
        }
        if (skip2) {
          attrs[PHX_SKIP] = true;
        }
        let [newRoot, commentBefore, commentAfter] = modifyRoot(output.buffer, attrs, skip2);
        rendered.newRender = false;
        output.buffer = prevBuffer + commentBefore + newRoot + commentAfter;
      }
    }
    comprehensionToBuffer(rendered, templates, output) {
      let { [DYNAMICS]: dynamics, [STATIC]: statics, [STREAM]: stream } = rendered;
      let [_ref, _inserts, deleteIds, reset] = stream || [null, {}, [], null];
      statics = this.templateStatic(statics, templates);
      let compTemplates = templates || rendered[TEMPLATES];
      for (let d = 0; d < dynamics.length; d++) {
        let dynamic = dynamics[d];
        output.buffer += statics[0];
        for (let i = 1; i < statics.length; i++) {
          let changeTracking = false;
          this.dynamicToBuffer(dynamic[i - 1], compTemplates, output, changeTracking);
          output.buffer += statics[i];
        }
      }
      if (stream !== void 0 && (rendered[DYNAMICS].length > 0 || deleteIds.length > 0 || reset)) {
        delete rendered[STREAM];
        rendered[DYNAMICS] = [];
        output.streams.add(stream);
      }
    }
    dynamicToBuffer(rendered, templates, output, changeTracking) {
      if (typeof rendered === "number") {
        let [str, streams] = this.recursiveCIDToString(output.components, rendered, output.onlyCids);
        output.buffer += str;
        output.streams = /* @__PURE__ */ new Set([...output.streams, ...streams]);
      } else if (isObject(rendered)) {
        this.toOutputBuffer(rendered, templates, output, changeTracking, {});
      } else {
        output.buffer += rendered;
      }
    }
    recursiveCIDToString(components, cid, onlyCids) {
      let component = components[cid] || logError(`no component for CID ${cid}`, components);
      let attrs = { [PHX_COMPONENT]: cid };
      let skip2 = onlyCids && !onlyCids.has(cid);
      component.newRender = !skip2;
      component.magicId = `c${cid}-${this.parentViewId()}`;
      let changeTracking = !component.reset;
      let [html, streams] = this.recursiveToString(component, components, onlyCids, changeTracking, attrs);
      delete component.reset;
      return [html, streams];
    }
  };
  var viewHookID = 1;
  var ViewHook = class {
    static makeID() {
      return viewHookID++;
    }
    static elementID(el) {
      return el.phxHookId;
    }
    constructor(view, el, callbacks) {
      this.__view = view;
      this.liveSocket = view.liveSocket;
      this.__callbacks = callbacks;
      this.__listeners = /* @__PURE__ */ new Set();
      this.__isDisconnected = false;
      this.el = el;
      this.el.phxHookId = this.constructor.makeID();
      for (let key in this.__callbacks) {
        this[key] = this.__callbacks[key];
      }
    }
    __mounted() {
      this.mounted && this.mounted();
    }
    __updated() {
      this.updated && this.updated();
    }
    __beforeUpdate() {
      this.beforeUpdate && this.beforeUpdate();
    }
    __destroyed() {
      this.destroyed && this.destroyed();
    }
    __reconnected() {
      if (this.__isDisconnected) {
        this.__isDisconnected = false;
        this.reconnected && this.reconnected();
      }
    }
    __disconnected() {
      this.__isDisconnected = true;
      this.disconnected && this.disconnected();
    }
    pushEvent(event, payload = {}, onReply = function() {
    }) {
      return this.__view.pushHookEvent(this.el, null, event, payload, onReply);
    }
    pushEventTo(phxTarget, event, payload = {}, onReply = function() {
    }) {
      return this.__view.withinTargets(phxTarget, (view, targetCtx) => {
        return view.pushHookEvent(this.el, targetCtx, event, payload, onReply);
      });
    }
    handleEvent(event, callback2) {
      let callbackRef = (customEvent, bypass) => bypass ? event : callback2(customEvent.detail);
      window.addEventListener(`phx:${event}`, callbackRef);
      this.__listeners.add(callbackRef);
      return callbackRef;
    }
    removeHandleEvent(callbackRef) {
      let event = callbackRef(null, true);
      window.removeEventListener(`phx:${event}`, callbackRef);
      this.__listeners.delete(callbackRef);
    }
    upload(name, files) {
      return this.__view.dispatchUploads(null, name, files);
    }
    uploadTo(phxTarget, name, files) {
      return this.__view.withinTargets(phxTarget, (view, targetCtx) => {
        view.dispatchUploads(targetCtx, name, files);
      });
    }
    __cleanup__() {
      this.__listeners.forEach((callbackRef) => this.removeHandleEvent(callbackRef));
    }
  };
  var serializeForm = (form, metadata, onlyNames = []) => {
    const _a = metadata, { submitter } = _a, meta = __objRest(_a, ["submitter"]);
    let injectedElement;
    if (submitter && submitter.name) {
      const input = document.createElement("input");
      input.type = "hidden";
      const formId = submitter.getAttribute("form");
      if (formId) {
        input.setAttribute("form", formId);
      }
      input.name = submitter.name;
      input.value = submitter.value;
      submitter.parentElement.insertBefore(input, submitter);
      injectedElement = input;
    }
    const formData = new FormData(form);
    const toRemove = [];
    formData.forEach((val, key, _index) => {
      if (val instanceof File) {
        toRemove.push(key);
      }
    });
    toRemove.forEach((key) => formData.delete(key));
    const params = new URLSearchParams();
    for (let [key, val] of formData.entries()) {
      if (onlyNames.length === 0 || onlyNames.indexOf(key) >= 0) {
        params.append(key, val);
      }
    }
    if (submitter && injectedElement) {
      submitter.parentElement.removeChild(injectedElement);
    }
    for (let metaKey in meta) {
      params.append(metaKey, meta[metaKey]);
    }
    return params.toString();
  };
  var View = class {
    constructor(el, liveSocket2, parentView, flash, liveReferer) {
      this.isDead = false;
      this.liveSocket = liveSocket2;
      this.flash = flash;
      this.parent = parentView;
      this.root = parentView ? parentView.root : this;
      this.el = el;
      this.id = this.el.id;
      this.ref = 0;
      this.childJoins = 0;
      this.loaderTimer = null;
      this.pendingDiffs = [];
      this.pendingForms = /* @__PURE__ */ new Set();
      this.redirect = false;
      this.href = null;
      this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;
      this.joinPending = true;
      this.destroyed = false;
      this.joinCallback = function(onDone) {
        onDone && onDone();
      };
      this.stopCallback = function() {
      };
      this.pendingJoinOps = this.parent ? null : [];
      this.viewHooks = {};
      this.formSubmits = [];
      this.children = this.parent ? null : {};
      this.root.children[this.id] = {};
      this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {
        let url = this.href && this.expandURL(this.href);
        return {
          redirect: this.redirect ? url : void 0,
          url: this.redirect ? void 0 : url || void 0,
          params: this.connectParams(liveReferer),
          session: this.getSession(),
          static: this.getStatic(),
          flash: this.flash
        };
      });
    }
    setHref(href) {
      this.href = href;
    }
    setRedirect(href) {
      this.redirect = true;
      this.href = href;
    }
    isMain() {
      return this.el.hasAttribute(PHX_MAIN);
    }
    connectParams(liveReferer) {
      let params = this.liveSocket.params(this.el);
      let manifest = dom_default.all(document, `[${this.binding(PHX_TRACK_STATIC)}]`).map((node) => node.src || node.href).filter((url) => typeof url === "string");
      if (manifest.length > 0) {
        params["_track_static"] = manifest;
      }
      params["_mounts"] = this.joinCount;
      params["_live_referer"] = liveReferer;
      return params;
    }
    isConnected() {
      return this.channel.canPush();
    }
    getSession() {
      return this.el.getAttribute(PHX_SESSION);
    }
    getStatic() {
      let val = this.el.getAttribute(PHX_STATIC);
      return val === "" ? null : val;
    }
    destroy(callback2 = function() {
    }) {
      this.destroyAllChildren();
      this.destroyed = true;
      delete this.root.children[this.id];
      if (this.parent) {
        delete this.root.children[this.parent.id][this.id];
      }
      clearTimeout(this.loaderTimer);
      let onFinished = () => {
        callback2();
        for (let id in this.viewHooks) {
          this.destroyHook(this.viewHooks[id]);
        }
      };
      dom_default.markPhxChildDestroyed(this.el);
      this.log("destroyed", () => ["the child has been removed from the parent"]);
      this.channel.leave().receive("ok", onFinished).receive("error", onFinished).receive("timeout", onFinished);
    }
    setContainerClasses(...classes) {
      this.el.classList.remove(PHX_CONNECTED_CLASS, PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_CLIENT_ERROR_CLASS, PHX_SERVER_ERROR_CLASS);
      this.el.classList.add(...classes);
    }
    showLoader(timeout) {
      clearTimeout(this.loaderTimer);
      if (timeout) {
        this.loaderTimer = setTimeout(() => this.showLoader(), timeout);
      } else {
        for (let id in this.viewHooks) {
          this.viewHooks[id].__disconnected();
        }
        this.setContainerClasses(PHX_LOADING_CLASS);
      }
    }
    execAll(binding) {
      dom_default.all(this.el, `[${binding}]`, (el) => this.liveSocket.execJS(el, el.getAttribute(binding)));
    }
    hideLoader() {
      clearTimeout(this.loaderTimer);
      this.setContainerClasses(PHX_CONNECTED_CLASS);
      this.execAll(this.binding("connected"));
    }
    triggerReconnected() {
      for (let id in this.viewHooks) {
        this.viewHooks[id].__reconnected();
      }
    }
    log(kind, msgCallback) {
      this.liveSocket.log(this, kind, msgCallback);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.liveSocket.transition(time, onStart, onDone);
    }
    withinTargets(phxTarget, callback2) {
      if (phxTarget instanceof HTMLElement || phxTarget instanceof SVGElement) {
        return this.liveSocket.owner(phxTarget, (view) => callback2(view, phxTarget));
      }
      if (isCid(phxTarget)) {
        let targets = dom_default.findComponentNodeList(this.el, phxTarget);
        if (targets.length === 0) {
          logError(`no component found matching phx-target of ${phxTarget}`);
        } else {
          callback2(this, parseInt(phxTarget));
        }
      } else {
        let targets = Array.from(document.querySelectorAll(phxTarget));
        if (targets.length === 0) {
          logError(`nothing found matching the phx-target selector "${phxTarget}"`);
        }
        targets.forEach((target) => this.liveSocket.owner(target, (view) => callback2(view, target)));
      }
    }
    applyDiff(type, rawDiff, callback2) {
      this.log(type, () => ["", clone(rawDiff)]);
      let { diff, reply, events, title } = Rendered.extract(rawDiff);
      callback2({ diff, reply, events });
      if (title) {
        window.requestAnimationFrame(() => dom_default.putTitle(title));
      }
    }
    onJoin(resp) {
      let { rendered, container } = resp;
      if (container) {
        let [tag, attrs] = container;
        this.el = dom_default.replaceRootContainer(this.el, tag, attrs);
      }
      this.childJoins = 0;
      this.joinPending = true;
      this.flash = null;
      browser_default.dropLocal(this.liveSocket.localStorage, window.location.pathname, CONSECUTIVE_RELOADS);
      this.applyDiff("mount", rendered, ({ diff, events }) => {
        this.rendered = new Rendered(this.id, diff);
        let [html, streams] = this.renderContainer(null, "join");
        this.dropPendingRefs();
        let forms = this.formsForRecovery(html).filter(([form, newForm, newCid]) => {
          return !this.pendingForms.has(form.id);
        });
        this.joinCount++;
        if (forms.length > 0) {
          forms.forEach(([form, newForm, newCid], i) => {
            this.pendingForms.add(form.id);
            this.pushFormRecovery(form, newCid, (resp2) => {
              this.pendingForms.delete(form.id);
              if (i === forms.length - 1) {
                this.onJoinComplete(resp2, html, streams, events);
              }
            });
          });
        } else {
          this.onJoinComplete(resp, html, streams, events);
        }
      });
    }
    dropPendingRefs() {
      dom_default.all(document, `[${PHX_REF_SRC}="${this.id}"][${PHX_REF}]`, (el) => {
        el.removeAttribute(PHX_REF);
        el.removeAttribute(PHX_REF_SRC);
      });
    }
    onJoinComplete({ live_patch }, html, streams, events) {
      this.pendingForms.clear();
      if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) {
        return this.applyJoinPatch(live_patch, html, streams, events);
      }
      let newChildren = dom_default.findPhxChildrenInFragment(html, this.id).filter((toEl) => {
        let fromEl = toEl.id && this.el.querySelector(`[id="${toEl.id}"]`);
        let phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);
        if (phxStatic) {
          toEl.setAttribute(PHX_STATIC, phxStatic);
        }
        if (fromEl) {
          fromEl.setAttribute(PHX_ROOT_ID, this.root.id);
        }
        return this.joinChild(toEl);
      });
      if (newChildren.length === 0) {
        if (this.parent) {
          this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, streams, events)]);
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
          this.applyJoinPatch(live_patch, html, streams, events);
        }
      } else {
        this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, streams, events)]);
      }
    }
    attachTrueDocEl() {
      this.el = dom_default.byId(this.id);
      this.el.setAttribute(PHX_ROOT_ID, this.root.id);
    }
    execNewMounted() {
      let phxViewportTop = this.binding(PHX_VIEWPORT_TOP);
      let phxViewportBottom = this.binding(PHX_VIEWPORT_BOTTOM);
      dom_default.all(this.el, `[${phxViewportTop}], [${phxViewportBottom}]`, (hookEl) => {
        dom_default.maybeAddPrivateHooks(hookEl, phxViewportTop, phxViewportBottom);
        this.maybeAddNewHook(hookEl);
      });
      dom_default.all(this.el, `[${this.binding(PHX_HOOK)}], [data-phx-${PHX_HOOK}]`, (hookEl) => {
        this.maybeAddNewHook(hookEl);
      });
      dom_default.all(this.el, `[${this.binding(PHX_MOUNTED)}]`, (el) => this.maybeMounted(el));
    }
    applyJoinPatch(live_patch, html, streams, events) {
      this.attachTrueDocEl();
      let patch = new DOMPatch(this, this.el, this.id, html, streams, null);
      patch.markPrunableContentForRemoval();
      this.performPatch(patch, false, true);
      this.joinNewChildren();
      this.execNewMounted();
      this.joinPending = false;
      this.liveSocket.dispatchEvents(events);
      this.applyPendingUpdates();
      if (live_patch) {
        let { kind, to: to2 } = live_patch;
        this.liveSocket.historyPatch(to2, kind);
      }
      this.hideLoader();
      if (this.joinCount > 1) {
        this.triggerReconnected();
      }
      this.stopCallback();
    }
    triggerBeforeUpdateHook(fromEl, toEl) {
      this.liveSocket.triggerDOM("onBeforeElUpdated", [fromEl, toEl]);
      let hook = this.getHook(fromEl);
      let isIgnored = hook && dom_default.isIgnored(fromEl, this.binding(PHX_UPDATE));
      if (hook && !fromEl.isEqualNode(toEl) && !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))) {
        hook.__beforeUpdate();
        return hook;
      }
    }
    maybeMounted(el) {
      let phxMounted = el.getAttribute(this.binding(PHX_MOUNTED));
      let hasBeenInvoked = phxMounted && dom_default.private(el, "mounted");
      if (phxMounted && !hasBeenInvoked) {
        this.liveSocket.execJS(el, phxMounted);
        dom_default.putPrivate(el, "mounted", true);
      }
    }
    maybeAddNewHook(el, force) {
      let newHook = this.addHook(el);
      if (newHook) {
        newHook.__mounted();
      }
    }
    performPatch(patch, pruneCids, isJoinPatch = false) {
      let removedEls = [];
      let phxChildrenAdded = false;
      let updatedHookIds = /* @__PURE__ */ new Set();
      patch.after("added", (el) => {
        this.liveSocket.triggerDOM("onNodeAdded", [el]);
        let phxViewportTop = this.binding(PHX_VIEWPORT_TOP);
        let phxViewportBottom = this.binding(PHX_VIEWPORT_BOTTOM);
        dom_default.maybeAddPrivateHooks(el, phxViewportTop, phxViewportBottom);
        this.maybeAddNewHook(el);
        if (el.getAttribute) {
          this.maybeMounted(el);
        }
      });
      patch.after("phxChildAdded", (el) => {
        if (dom_default.isPhxSticky(el)) {
          this.liveSocket.joinRootViews();
        } else {
          phxChildrenAdded = true;
        }
      });
      patch.before("updated", (fromEl, toEl) => {
        let hook = this.triggerBeforeUpdateHook(fromEl, toEl);
        if (hook) {
          updatedHookIds.add(fromEl.id);
        }
      });
      patch.after("updated", (el) => {
        if (updatedHookIds.has(el.id)) {
          this.getHook(el).__updated();
        }
      });
      patch.after("discarded", (el) => {
        if (el.nodeType === Node.ELEMENT_NODE) {
          removedEls.push(el);
        }
      });
      patch.after("transitionsDiscarded", (els) => this.afterElementsRemoved(els, pruneCids));
      patch.perform(isJoinPatch);
      this.afterElementsRemoved(removedEls, pruneCids);
      return phxChildrenAdded;
    }
    afterElementsRemoved(elements2, pruneCids) {
      let destroyedCIDs = [];
      elements2.forEach((parent) => {
        let components = dom_default.all(parent, `[${PHX_COMPONENT}]`);
        let hooks2 = dom_default.all(parent, `[${this.binding(PHX_HOOK)}]`);
        components.concat(parent).forEach((el) => {
          let cid = this.componentID(el);
          if (isCid(cid) && destroyedCIDs.indexOf(cid) === -1) {
            destroyedCIDs.push(cid);
          }
        });
        hooks2.concat(parent).forEach((hookEl) => {
          let hook = this.getHook(hookEl);
          hook && this.destroyHook(hook);
        });
      });
      if (pruneCids) {
        this.maybePushComponentsDestroyed(destroyedCIDs);
      }
    }
    joinNewChildren() {
      dom_default.findPhxChildren(this.el, this.id).forEach((el) => this.joinChild(el));
    }
    getChildById(id) {
      return this.root.children[this.id][id];
    }
    getDescendentByEl(el) {
      if (el.id === this.id) {
        return this;
      } else {
        return this.children[el.getAttribute(PHX_PARENT_ID)][el.id];
      }
    }
    destroyDescendent(id) {
      for (let parentId in this.root.children) {
        for (let childId in this.root.children[parentId]) {
          if (childId === id) {
            return this.root.children[parentId][childId].destroy();
          }
        }
      }
    }
    joinChild(el) {
      let child = this.getChildById(el.id);
      if (!child) {
        let view = new View(el, this.liveSocket, this);
        this.root.children[this.id][view.id] = view;
        view.join();
        this.childJoins++;
        return true;
      }
    }
    isJoinPending() {
      return this.joinPending;
    }
    ackJoin(_child) {
      this.childJoins--;
      if (this.childJoins === 0) {
        if (this.parent) {
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
        }
      }
    }
    onAllChildJoinsComplete() {
      this.joinCallback(() => {
        this.pendingJoinOps.forEach(([view, op]) => {
          if (!view.isDestroyed()) {
            op();
          }
        });
        this.pendingJoinOps = [];
      });
    }
    update(diff, events) {
      if (this.isJoinPending() || this.liveSocket.hasPendingLink() && this.root.isMain()) {
        return this.pendingDiffs.push({ diff, events });
      }
      this.rendered.mergeDiff(diff);
      let phxChildrenAdded = false;
      if (this.rendered.isComponentOnlyDiff(diff)) {
        this.liveSocket.time("component patch complete", () => {
          let parentCids = dom_default.findExistingParentCIDs(this.el, this.rendered.componentCIDs(diff));
          parentCids.forEach((parentCID) => {
            if (this.componentPatch(this.rendered.getComponent(diff, parentCID), parentCID)) {
              phxChildrenAdded = true;
            }
          });
        });
      } else if (!isEmpty(diff)) {
        this.liveSocket.time("full patch complete", () => {
          let [html, streams] = this.renderContainer(diff, "update");
          let patch = new DOMPatch(this, this.el, this.id, html, streams, null);
          phxChildrenAdded = this.performPatch(patch, true);
        });
      }
      this.liveSocket.dispatchEvents(events);
      if (phxChildrenAdded) {
        this.joinNewChildren();
      }
    }
    renderContainer(diff, kind) {
      return this.liveSocket.time(`toString diff (${kind})`, () => {
        let tag = this.el.tagName;
        let cids = diff ? this.rendered.componentCIDs(diff) : null;
        let [html, streams] = this.rendered.toString(cids);
        return [`<${tag}>${html}</${tag}>`, streams];
      });
    }
    componentPatch(diff, cid) {
      if (isEmpty(diff))
        return false;
      let [html, streams] = this.rendered.componentToString(cid);
      let patch = new DOMPatch(this, this.el, this.id, html, streams, cid);
      let childrenAdded = this.performPatch(patch, true);
      return childrenAdded;
    }
    getHook(el) {
      return this.viewHooks[ViewHook.elementID(el)];
    }
    addHook(el) {
      if (ViewHook.elementID(el) || !el.getAttribute) {
        return;
      }
      let hookName = el.getAttribute(`data-phx-${PHX_HOOK}`) || el.getAttribute(this.binding(PHX_HOOK));
      if (hookName && !this.ownsElement(el)) {
        return;
      }
      let callbacks = this.liveSocket.getHookCallbacks(hookName);
      if (callbacks) {
        if (!el.id) {
          logError(`no DOM ID for hook "${hookName}". Hooks require a unique ID on each element.`, el);
        }
        let hook = new ViewHook(this, el, callbacks);
        this.viewHooks[ViewHook.elementID(hook.el)] = hook;
        return hook;
      } else if (hookName !== null) {
        logError(`unknown hook found for "${hookName}"`, el);
      }
    }
    destroyHook(hook) {
      hook.__destroyed();
      hook.__cleanup__();
      delete this.viewHooks[ViewHook.elementID(hook.el)];
    }
    applyPendingUpdates() {
      this.pendingDiffs.forEach(({ diff, events }) => this.update(diff, events));
      this.pendingDiffs = [];
      this.eachChild((child) => child.applyPendingUpdates());
    }
    eachChild(callback2) {
      let children = this.root.children[this.id] || {};
      for (let id in children) {
        callback2(this.getChildById(id));
      }
    }
    onChannel(event, cb) {
      this.liveSocket.onChannel(this.channel, event, (resp) => {
        if (this.isJoinPending()) {
          this.root.pendingJoinOps.push([this, () => cb(resp)]);
        } else {
          this.liveSocket.requestDOMUpdate(() => cb(resp));
        }
      });
    }
    bindChannel() {
      this.liveSocket.onChannel(this.channel, "diff", (rawDiff) => {
        this.liveSocket.requestDOMUpdate(() => {
          this.applyDiff("update", rawDiff, ({ diff, events }) => this.update(diff, events));
        });
      });
      this.onChannel("redirect", ({ to: to2, flash }) => this.onRedirect({ to: to2, flash }));
      this.onChannel("live_patch", (redir) => this.onLivePatch(redir));
      this.onChannel("live_redirect", (redir) => this.onLiveRedirect(redir));
      this.channel.onError((reason) => this.onError(reason));
      this.channel.onClose((reason) => this.onClose(reason));
    }
    destroyAllChildren() {
      this.eachChild((child) => child.destroy());
    }
    onLiveRedirect(redir) {
      let { to: to2, kind, flash } = redir;
      let url = this.expandURL(to2);
      this.liveSocket.historyRedirect(url, kind, flash);
    }
    onLivePatch(redir) {
      let { to: to2, kind } = redir;
      this.href = this.expandURL(to2);
      this.liveSocket.historyPatch(to2, kind);
    }
    expandURL(to2) {
      return to2.startsWith("/") ? `${window.location.protocol}//${window.location.host}${to2}` : to2;
    }
    onRedirect({ to: to2, flash }) {
      this.liveSocket.redirect(to2, flash);
    }
    isDestroyed() {
      return this.destroyed;
    }
    joinDead() {
      this.isDead = true;
    }
    join(callback2) {
      this.showLoader(this.liveSocket.loaderTimeout);
      this.bindChannel();
      if (this.isMain()) {
        this.stopCallback = this.liveSocket.withPageLoading({ to: this.href, kind: "initial" });
      }
      this.joinCallback = (onDone) => {
        onDone = onDone || function() {
        };
        callback2 ? callback2(this.joinCount, onDone) : onDone();
      };
      this.liveSocket.wrapPush(this, { timeout: false }, () => {
        return this.channel.join().receive("ok", (data) => {
          if (!this.isDestroyed()) {
            this.liveSocket.requestDOMUpdate(() => this.onJoin(data));
          }
        }).receive("error", (resp) => !this.isDestroyed() && this.onJoinError(resp)).receive("timeout", () => !this.isDestroyed() && this.onJoinError({ reason: "timeout" }));
      });
    }
    onJoinError(resp) {
      if (resp.reason === "reload") {
        this.log("error", () => [`failed mount with ${resp.status}. Falling back to page request`, resp]);
        if (this.isMain()) {
          this.onRedirect({ to: this.href });
        }
        return;
      } else if (resp.reason === "unauthorized" || resp.reason === "stale") {
        this.log("error", () => ["unauthorized live_redirect. Falling back to page request", resp]);
        if (this.isMain()) {
          this.onRedirect({ to: this.href });
        }
        return;
      }
      if (resp.redirect || resp.live_redirect) {
        this.joinPending = false;
        this.channel.leave();
      }
      if (resp.redirect) {
        return this.onRedirect(resp.redirect);
      }
      if (resp.live_redirect) {
        return this.onLiveRedirect(resp.live_redirect);
      }
      this.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_SERVER_ERROR_CLASS]);
      this.log("error", () => ["unable to join", resp]);
      if (this.liveSocket.isConnected()) {
        this.liveSocket.reloadWithJitter(this);
      }
    }
    onClose(reason) {
      if (this.isDestroyed()) {
        return;
      }
      if (this.liveSocket.hasPendingLink() && reason !== "leave") {
        return this.liveSocket.reloadWithJitter(this);
      }
      this.destroyAllChildren();
      this.liveSocket.dropActiveElement(this);
      if (document.activeElement) {
        document.activeElement.blur();
      }
      if (this.liveSocket.isUnloaded()) {
        this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);
      }
    }
    onError(reason) {
      this.onClose(reason);
      if (this.liveSocket.isConnected()) {
        this.log("error", () => ["view crashed", reason]);
      }
      if (!this.liveSocket.isUnloaded()) {
        if (this.liveSocket.isConnected()) {
          this.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_SERVER_ERROR_CLASS]);
        } else {
          this.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_CLIENT_ERROR_CLASS]);
        }
      }
    }
    displayError(classes) {
      if (this.isMain()) {
        dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: { to: this.href, kind: "error" } });
      }
      this.showLoader();
      this.setContainerClasses(...classes);
      this.execAll(this.binding("disconnected"));
    }
    pushWithReply(refGenerator, event, payload, onReply = function() {
    }) {
      if (!this.isConnected()) {
        return;
      }
      let [ref, [el], opts] = refGenerator ? refGenerator() : [null, [], {}];
      let onLoadingDone = function() {
      };
      if (opts.page_loading || el && el.getAttribute(this.binding(PHX_PAGE_LOADING)) !== null) {
        onLoadingDone = this.liveSocket.withPageLoading({ kind: "element", target: el });
      }
      if (typeof payload.cid !== "number") {
        delete payload.cid;
      }
      return this.liveSocket.wrapPush(this, { timeout: true }, () => {
        return this.channel.push(event, payload, PUSH_TIMEOUT).receive("ok", (resp) => {
          let finish = (hookReply) => {
            if (resp.redirect) {
              this.onRedirect(resp.redirect);
            }
            if (resp.live_patch) {
              this.onLivePatch(resp.live_patch);
            }
            if (resp.live_redirect) {
              this.onLiveRedirect(resp.live_redirect);
            }
            onLoadingDone();
            onReply(resp, hookReply);
          };
          if (resp.diff) {
            this.liveSocket.requestDOMUpdate(() => {
              this.applyDiff("update", resp.diff, ({ diff, reply, events }) => {
                if (ref !== null) {
                  this.undoRefs(ref);
                }
                this.update(diff, events);
                finish(reply);
              });
            });
          } else {
            if (ref !== null) {
              this.undoRefs(ref);
            }
            finish(null);
          }
        });
      });
    }
    undoRefs(ref) {
      if (!this.isConnected()) {
        return;
      }
      dom_default.all(document, `[${PHX_REF_SRC}="${this.id}"][${PHX_REF}="${ref}"]`, (el) => {
        let disabledVal = el.getAttribute(PHX_DISABLED);
        let readOnlyVal = el.getAttribute(PHX_READONLY);
        el.removeAttribute(PHX_REF);
        el.removeAttribute(PHX_REF_SRC);
        if (readOnlyVal !== null) {
          el.readOnly = readOnlyVal === "true" ? true : false;
          el.removeAttribute(PHX_READONLY);
        }
        if (disabledVal !== null) {
          el.disabled = disabledVal === "true" ? true : false;
          el.removeAttribute(PHX_DISABLED);
        }
        PHX_EVENT_CLASSES.forEach((className) => dom_default.removeClass(el, className));
        let disableRestore = el.getAttribute(PHX_DISABLE_WITH_RESTORE);
        if (disableRestore !== null) {
          el.innerText = disableRestore;
          el.removeAttribute(PHX_DISABLE_WITH_RESTORE);
        }
        let toEl = dom_default.private(el, PHX_REF);
        if (toEl) {
          let hook = this.triggerBeforeUpdateHook(el, toEl);
          DOMPatch.patchEl(el, toEl, this.liveSocket.getActiveElement());
          if (hook) {
            hook.__updated();
          }
          dom_default.deletePrivate(el, PHX_REF);
        }
      });
    }
    putRef(elements2, event, opts = {}) {
      let newRef = this.ref++;
      let disableWith = this.binding(PHX_DISABLE_WITH);
      if (opts.loading) {
        elements2 = elements2.concat(dom_default.all(document, opts.loading));
      }
      elements2.forEach((el) => {
        el.classList.add(`phx-${event}-loading`);
        el.setAttribute(PHX_REF, newRef);
        el.setAttribute(PHX_REF_SRC, this.el.id);
        let disableText = el.getAttribute(disableWith);
        if (disableText !== null) {
          if (!el.getAttribute(PHX_DISABLE_WITH_RESTORE)) {
            el.setAttribute(PHX_DISABLE_WITH_RESTORE, el.innerText);
          }
          if (disableText !== "") {
            el.innerText = disableText;
          }
          el.setAttribute(PHX_DISABLED, el.getAttribute(PHX_DISABLED) || el.disabled);
          el.setAttribute("disabled", "");
        }
      });
      return [newRef, elements2, opts];
    }
    componentID(el) {
      let cid = el.getAttribute && el.getAttribute(PHX_COMPONENT);
      return cid ? parseInt(cid) : null;
    }
    targetComponentID(target, targetCtx, opts = {}) {
      if (isCid(targetCtx)) {
        return targetCtx;
      }
      let cidOrSelector = opts.target || target.getAttribute(this.binding("target"));
      if (isCid(cidOrSelector)) {
        return parseInt(cidOrSelector);
      } else if (targetCtx && (cidOrSelector !== null || opts.target)) {
        return this.closestComponentID(targetCtx);
      } else {
        return null;
      }
    }
    closestComponentID(targetCtx) {
      if (isCid(targetCtx)) {
        return targetCtx;
      } else if (targetCtx) {
        return maybe(targetCtx.closest(`[${PHX_COMPONENT}]`), (el) => this.ownsElement(el) && this.componentID(el));
      } else {
        return null;
      }
    }
    pushHookEvent(el, targetCtx, event, payload, onReply) {
      if (!this.isConnected()) {
        this.log("hook", () => ["unable to push hook event. LiveView not connected", event, payload]);
        return false;
      }
      let [ref, els, opts] = this.putRef([el], "hook");
      this.pushWithReply(() => [ref, els, opts], "event", {
        type: "hook",
        event,
        value: payload,
        cid: this.closestComponentID(targetCtx)
      }, (resp, reply) => onReply(reply, ref));
      return ref;
    }
    extractMeta(el, meta, value) {
      let prefix = this.binding("value-");
      for (let i = 0; i < el.attributes.length; i++) {
        if (!meta) {
          meta = {};
        }
        let name = el.attributes[i].name;
        if (name.startsWith(prefix)) {
          meta[name.replace(prefix, "")] = el.getAttribute(name);
        }
      }
      if (el.value !== void 0 && !(el instanceof HTMLFormElement)) {
        if (!meta) {
          meta = {};
        }
        meta.value = el.value;
        if (el.tagName === "INPUT" && CHECKABLE_INPUTS.indexOf(el.type) >= 0 && !el.checked) {
          delete meta.value;
        }
      }
      if (value) {
        if (!meta) {
          meta = {};
        }
        for (let key in value) {
          meta[key] = value[key];
        }
      }
      return meta;
    }
    pushEvent(type, el, targetCtx, phxEvent, meta, opts = {}, onReply) {
      this.pushWithReply(() => this.putRef([el], type, opts), "event", {
        type,
        event: phxEvent,
        value: this.extractMeta(el, meta, opts.value),
        cid: this.targetComponentID(el, targetCtx, opts)
      }, (resp, reply) => onReply && onReply(reply));
    }
    pushFileProgress(fileEl, entryRef, progress, onReply = function() {
    }) {
      this.liveSocket.withinOwners(fileEl.form, (view, targetCtx) => {
        view.pushWithReply(null, "progress", {
          event: fileEl.getAttribute(view.binding(PHX_PROGRESS)),
          ref: fileEl.getAttribute(PHX_UPLOAD_REF),
          entry_ref: entryRef,
          progress,
          cid: view.targetComponentID(fileEl.form, targetCtx)
        }, onReply);
      });
    }
    pushInput(inputEl, targetCtx, forceCid, phxEvent, opts, callback2) {
      let uploads;
      let cid = isCid(forceCid) ? forceCid : this.targetComponentID(inputEl.form, targetCtx, opts);
      let refGenerator = () => this.putRef([inputEl, inputEl.form], "change", opts);
      let formData;
      let meta = this.extractMeta(inputEl.form);
      if (inputEl instanceof HTMLButtonElement) {
        meta.submitter = inputEl;
      }
      if (inputEl.getAttribute(this.binding("change"))) {
        formData = serializeForm(inputEl.form, __spreadValues({ _target: opts._target }, meta), [inputEl.name]);
      } else {
        formData = serializeForm(inputEl.form, __spreadValues({ _target: opts._target }, meta));
      }
      if (dom_default.isUploadInput(inputEl) && inputEl.files && inputEl.files.length > 0) {
        LiveUploader.trackFiles(inputEl, Array.from(inputEl.files));
      }
      uploads = LiveUploader.serializeUploads(inputEl);
      let event = {
        type: "form",
        event: phxEvent,
        value: formData,
        uploads,
        cid
      };
      this.pushWithReply(refGenerator, "event", event, (resp) => {
        dom_default.showError(inputEl, this.liveSocket.binding(PHX_FEEDBACK_FOR), this.liveSocket.binding(PHX_FEEDBACK_GROUP));
        if (dom_default.isUploadInput(inputEl) && dom_default.isAutoUpload(inputEl)) {
          if (LiveUploader.filesAwaitingPreflight(inputEl).length > 0) {
            let [ref, _els] = refGenerator();
            this.uploadFiles(inputEl.form, targetCtx, ref, cid, (_uploads) => {
              callback2 && callback2(resp);
              this.triggerAwaitingSubmit(inputEl.form);
              this.undoRefs(ref);
            });
          }
        } else {
          callback2 && callback2(resp);
        }
      });
    }
    triggerAwaitingSubmit(formEl) {
      let awaitingSubmit = this.getScheduledSubmit(formEl);
      if (awaitingSubmit) {
        let [_el, _ref, _opts, callback2] = awaitingSubmit;
        this.cancelSubmit(formEl);
        callback2();
      }
    }
    getScheduledSubmit(formEl) {
      return this.formSubmits.find(([el, _ref, _opts, _callback]) => el.isSameNode(formEl));
    }
    scheduleSubmit(formEl, ref, opts, callback2) {
      if (this.getScheduledSubmit(formEl)) {
        return true;
      }
      this.formSubmits.push([formEl, ref, opts, callback2]);
    }
    cancelSubmit(formEl) {
      this.formSubmits = this.formSubmits.filter(([el, ref, _callback]) => {
        if (el.isSameNode(formEl)) {
          this.undoRefs(ref);
          return false;
        } else {
          return true;
        }
      });
    }
    disableForm(formEl, opts = {}) {
      let filterIgnored = (el) => {
        let userIgnored = closestPhxBinding(el, `${this.binding(PHX_UPDATE)}=ignore`, el.form);
        return !(userIgnored || closestPhxBinding(el, "data-phx-update=ignore", el.form));
      };
      let filterDisables = (el) => {
        return el.hasAttribute(this.binding(PHX_DISABLE_WITH));
      };
      let filterButton = (el) => el.tagName == "BUTTON";
      let filterInput = (el) => ["INPUT", "TEXTAREA", "SELECT"].includes(el.tagName);
      let formElements = Array.from(formEl.elements);
      let disables = formElements.filter(filterDisables);
      let buttons = formElements.filter(filterButton).filter(filterIgnored);
      let inputs = formElements.filter(filterInput).filter(filterIgnored);
      buttons.forEach((button) => {
        button.setAttribute(PHX_DISABLED, button.disabled);
        button.disabled = true;
      });
      inputs.forEach((input) => {
        input.setAttribute(PHX_READONLY, input.readOnly);
        input.readOnly = true;
        if (input.files) {
          input.setAttribute(PHX_DISABLED, input.disabled);
          input.disabled = true;
        }
      });
      formEl.setAttribute(this.binding(PHX_PAGE_LOADING), "");
      return this.putRef([formEl].concat(disables).concat(buttons).concat(inputs), "submit", opts);
    }
    pushFormSubmit(formEl, targetCtx, phxEvent, submitter, opts, onReply) {
      let refGenerator = () => this.disableForm(formEl, opts);
      let cid = this.targetComponentID(formEl, targetCtx);
      if (LiveUploader.hasUploadsInProgress(formEl)) {
        let [ref, _els] = refGenerator();
        let push = () => this.pushFormSubmit(formEl, targetCtx, phxEvent, submitter, opts, onReply);
        return this.scheduleSubmit(formEl, ref, opts, push);
      } else if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {
        let [ref, els] = refGenerator();
        let proxyRefGen = () => [ref, els, opts];
        this.uploadFiles(formEl, targetCtx, ref, cid, (uploads) => {
          if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {
            return this.undoRefs(ref);
          }
          let meta = this.extractMeta(formEl);
          let formData = serializeForm(formEl, __spreadValues({ submitter }, meta));
          this.pushWithReply(proxyRefGen, "event", {
            type: "form",
            event: phxEvent,
            value: formData,
            cid
          }, onReply);
        });
      } else if (!(formEl.hasAttribute(PHX_REF) && formEl.classList.contains("phx-submit-loading"))) {
        let meta = this.extractMeta(formEl);
        let formData = serializeForm(formEl, __spreadValues({ submitter }, meta));
        this.pushWithReply(refGenerator, "event", {
          type: "form",
          event: phxEvent,
          value: formData,
          cid
        }, onReply);
      }
    }
    uploadFiles(formEl, targetCtx, ref, cid, onComplete) {
      let joinCountAtUpload = this.joinCount;
      let inputEls = LiveUploader.activeFileInputs(formEl);
      let numFileInputsInProgress = inputEls.length;
      inputEls.forEach((inputEl) => {
        let uploader = new LiveUploader(inputEl, this, () => {
          numFileInputsInProgress--;
          if (numFileInputsInProgress === 0) {
            onComplete();
          }
        });
        let entries = uploader.entries().map((entry) => entry.toPreflightPayload());
        if (entries.length === 0) {
          numFileInputsInProgress--;
          return;
        }
        let payload = {
          ref: inputEl.getAttribute(PHX_UPLOAD_REF),
          entries,
          cid: this.targetComponentID(inputEl.form, targetCtx)
        };
        this.log("upload", () => ["sending preflight request", payload]);
        this.pushWithReply(null, "allow_upload", payload, (resp) => {
          this.log("upload", () => ["got preflight response", resp]);
          uploader.entries().forEach((entry) => {
            if (resp.entries && !resp.entries[entry.ref]) {
              this.handleFailedEntryPreflight(entry.ref, "failed preflight", uploader);
            }
          });
          if (resp.error || Object.keys(resp.entries).length === 0) {
            this.undoRefs(ref);
            let errors = resp.error || [];
            errors.map(([entry_ref, reason]) => {
              this.handleFailedEntryPreflight(entry_ref, reason, uploader);
            });
          } else {
            let onError = (callback2) => {
              this.channel.onError(() => {
                if (this.joinCount === joinCountAtUpload) {
                  callback2();
                }
              });
            };
            uploader.initAdapterUpload(resp, onError, this.liveSocket);
          }
        });
      });
    }
    handleFailedEntryPreflight(uploadRef, reason, uploader) {
      if (uploader.isAutoUpload()) {
        let entry = uploader.entries().find((entry2) => entry2.ref === uploadRef.toString());
        if (entry) {
          entry.cancel();
        }
      } else {
        uploader.entries().map((entry) => entry.cancel());
      }
      this.log("upload", () => [`error for entry ${uploadRef}`, reason]);
    }
    dispatchUploads(targetCtx, name, filesOrBlobs) {
      let targetElement = this.targetCtxElement(targetCtx) || this.el;
      let inputs = dom_default.findUploadInputs(targetElement).filter((el) => el.name === name);
      if (inputs.length === 0) {
        logError(`no live file inputs found matching the name "${name}"`);
      } else if (inputs.length > 1) {
        logError(`duplicate live file inputs found matching the name "${name}"`);
      } else {
        dom_default.dispatchEvent(inputs[0], PHX_TRACK_UPLOADS, { detail: { files: filesOrBlobs } });
      }
    }
    targetCtxElement(targetCtx) {
      if (isCid(targetCtx)) {
        let [target] = dom_default.findComponentNodeList(this.el, targetCtx);
        return target;
      } else if (targetCtx) {
        return targetCtx;
      } else {
        return null;
      }
    }
    pushFormRecovery(form, newCid, callback2) {
      this.liveSocket.withinOwners(form, (view, targetCtx) => {
        let phxChange = this.binding("change");
        let inputs = Array.from(form.elements).filter((el) => dom_default.isFormInput(el) && el.name && !el.hasAttribute(phxChange));
        if (inputs.length === 0) {
          return;
        }
        inputs.forEach((input2) => input2.hasAttribute(PHX_UPLOAD_REF) && LiveUploader.clearFiles(input2));
        let input = inputs.find((el) => el.type !== "hidden") || inputs[0];
        let phxEvent = form.getAttribute(this.binding(PHX_AUTO_RECOVER)) || form.getAttribute(this.binding("change"));
        js_default.exec("change", phxEvent, view, input, ["push", { _target: input.name, newCid, callback: callback2 }]);
      });
    }
    pushLinkPatch(href, targetEl, callback2) {
      let linkRef = this.liveSocket.setPendingLink(href);
      let refGen = targetEl ? () => this.putRef([targetEl], "click") : null;
      let fallback = () => this.liveSocket.redirect(window.location.href);
      let url = href.startsWith("/") ? `${location.protocol}//${location.host}${href}` : href;
      let push = this.pushWithReply(refGen, "live_patch", { url }, (resp) => {
        this.liveSocket.requestDOMUpdate(() => {
          if (resp.link_redirect) {
            this.liveSocket.replaceMain(href, null, callback2, linkRef);
          } else {
            if (this.liveSocket.commitPendingLink(linkRef)) {
              this.href = href;
            }
            this.applyPendingUpdates();
            callback2 && callback2(linkRef);
          }
        });
      });
      if (push) {
        push.receive("timeout", fallback);
      } else {
        fallback();
      }
    }
    formsForRecovery(html) {
      if (this.joinCount === 0) {
        return [];
      }
      let phxChange = this.binding("change");
      let template = document.createElement("template");
      template.innerHTML = html;
      return dom_default.all(this.el, `form[${phxChange}]`).filter((form) => form.id && this.ownsElement(form)).filter((form) => form.elements.length > 0).filter((form) => form.getAttribute(this.binding(PHX_AUTO_RECOVER)) !== "ignore").map((form) => {
        const phxChangeValue = CSS.escape(form.getAttribute(phxChange));
        let newForm = template.content.querySelector(`form[id="${form.id}"][${phxChange}="${phxChangeValue}"]`);
        if (newForm) {
          return [form, newForm, this.targetComponentID(newForm)];
        } else {
          return [form, form, this.targetComponentID(form)];
        }
      }).filter(([form, newForm, newCid]) => newForm);
    }
    maybePushComponentsDestroyed(destroyedCIDs) {
      let willDestroyCIDs = destroyedCIDs.filter((cid) => {
        return dom_default.findComponentNodeList(this.el, cid).length === 0;
      });
      if (willDestroyCIDs.length > 0) {
        willDestroyCIDs.forEach((cid) => this.rendered.resetRender(cid));
        this.pushWithReply(null, "cids_will_destroy", { cids: willDestroyCIDs }, () => {
          let completelyDestroyCIDs = willDestroyCIDs.filter((cid) => {
            return dom_default.findComponentNodeList(this.el, cid).length === 0;
          });
          if (completelyDestroyCIDs.length > 0) {
            this.pushWithReply(null, "cids_destroyed", { cids: completelyDestroyCIDs }, (resp) => {
              this.rendered.pruneCIDs(resp.cids);
            });
          }
        });
      }
    }
    ownsElement(el) {
      let parentViewEl = el.closest(PHX_VIEW_SELECTOR);
      return el.getAttribute(PHX_PARENT_ID) === this.id || parentViewEl && parentViewEl.id === this.id || !parentViewEl && this.isDead;
    }
    submitForm(form, targetCtx, phxEvent, submitter, opts = {}) {
      dom_default.putPrivate(form, PHX_HAS_SUBMITTED, true);
      const phxFeedbackFor = this.liveSocket.binding(PHX_FEEDBACK_FOR);
      const phxFeedbackGroup = this.liveSocket.binding(PHX_FEEDBACK_GROUP);
      const inputs = Array.from(form.elements);
      inputs.forEach((input) => dom_default.putPrivate(input, PHX_HAS_SUBMITTED, true));
      this.liveSocket.blurActiveElement(this);
      this.pushFormSubmit(form, targetCtx, phxEvent, submitter, opts, () => {
        inputs.forEach((input) => dom_default.showError(input, phxFeedbackFor, phxFeedbackGroup));
        this.liveSocket.restorePreviouslyActiveFocus();
      });
    }
    binding(kind) {
      return this.liveSocket.binding(kind);
    }
  };
  var LiveSocket = class {
    constructor(url, phxSocket, opts = {}) {
      this.unloaded = false;
      if (!phxSocket || phxSocket.constructor.name === "Object") {
        throw new Error(`
      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:

          import {Socket} from "phoenix"
          import {LiveSocket} from "phoenix_live_view"
          let liveSocket = new LiveSocket("/live", Socket, {...})
      `);
      }
      this.socket = new phxSocket(url, opts);
      this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;
      this.opts = opts;
      this.params = closure2(opts.params || {});
      this.viewLogger = opts.viewLogger;
      this.metadataCallbacks = opts.metadata || {};
      this.defaults = Object.assign(clone(DEFAULTS), opts.defaults || {});
      this.activeElement = null;
      this.prevActive = null;
      this.silenced = false;
      this.main = null;
      this.outgoingMainEl = null;
      this.clickStartedAtTarget = null;
      this.linkRef = 1;
      this.roots = {};
      this.href = window.location.href;
      this.pendingLink = null;
      this.currentLocation = clone(window.location);
      this.hooks = opts.hooks || {};
      this.uploaders = opts.uploaders || {};
      this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;
      this.reloadWithJitterTimer = null;
      this.maxReloads = opts.maxReloads || MAX_RELOADS;
      this.reloadJitterMin = opts.reloadJitterMin || RELOAD_JITTER_MIN;
      this.reloadJitterMax = opts.reloadJitterMax || RELOAD_JITTER_MAX;
      this.failsafeJitter = opts.failsafeJitter || FAILSAFE_JITTER;
      this.localStorage = opts.localStorage || window.localStorage;
      this.sessionStorage = opts.sessionStorage || window.sessionStorage;
      this.boundTopLevelEvents = false;
      this.domCallbacks = Object.assign({ onNodeAdded: closure2(), onBeforeElUpdated: closure2() }, opts.dom || {});
      this.transitions = new TransitionSet();
      window.addEventListener("pagehide", (_e) => {
        this.unloaded = true;
      });
      this.socket.onOpen(() => {
        if (this.isUnloaded()) {
          window.location.reload();
        }
      });
    }
    isProfileEnabled() {
      return this.sessionStorage.getItem(PHX_LV_PROFILE) === "true";
    }
    isDebugEnabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "true";
    }
    isDebugDisabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "false";
    }
    enableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "true");
    }
    enableProfiling() {
      this.sessionStorage.setItem(PHX_LV_PROFILE, "true");
    }
    disableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "false");
    }
    disableProfiling() {
      this.sessionStorage.removeItem(PHX_LV_PROFILE);
    }
    enableLatencySim(upperBoundMs) {
      this.enableDebug();
      console.log("latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable");
      this.sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);
    }
    disableLatencySim() {
      this.sessionStorage.removeItem(PHX_LV_LATENCY_SIM);
    }
    getLatencySim() {
      let str = this.sessionStorage.getItem(PHX_LV_LATENCY_SIM);
      return str ? parseInt(str) : null;
    }
    getSocket() {
      return this.socket;
    }
    connect() {
      if (window.location.hostname === "localhost" && !this.isDebugDisabled()) {
        this.enableDebug();
      }
      let doConnect = () => {
        if (this.joinRootViews()) {
          this.bindTopLevelEvents();
          this.socket.connect();
        } else if (this.main) {
          this.socket.connect();
        } else {
          this.bindTopLevelEvents({ dead: true });
        }
        this.joinDeadView();
      };
      if (["complete", "loaded", "interactive"].indexOf(document.readyState) >= 0) {
        doConnect();
      } else {
        document.addEventListener("DOMContentLoaded", () => doConnect());
      }
    }
    disconnect(callback2) {
      clearTimeout(this.reloadWithJitterTimer);
      this.socket.disconnect(callback2);
    }
    replaceTransport(transport) {
      clearTimeout(this.reloadWithJitterTimer);
      this.socket.replaceTransport(transport);
      this.connect();
    }
    execJS(el, encodedJS, eventType = null) {
      this.owner(el, (view) => js_default.exec(eventType, encodedJS, view, el));
    }
    execJSHookPush(el, phxEvent, data, callback2) {
      this.withinOwners(el, (view) => {
        js_default.exec("hook", phxEvent, view, el, ["push", { data, callback: callback2 }]);
      });
    }
    unload() {
      if (this.unloaded) {
        return;
      }
      if (this.main && this.isConnected()) {
        this.log(this.main, "socket", () => ["disconnect for page nav"]);
      }
      this.unloaded = true;
      this.destroyAllViews();
      this.disconnect();
    }
    triggerDOM(kind, args) {
      this.domCallbacks[kind](...args);
    }
    time(name, func) {
      if (!this.isProfileEnabled() || !console.time) {
        return func();
      }
      console.time(name);
      let result = func();
      console.timeEnd(name);
      return result;
    }
    log(view, kind, msgCallback) {
      if (this.viewLogger) {
        let [msg, obj] = msgCallback();
        this.viewLogger(view, kind, msg, obj);
      } else if (this.isDebugEnabled()) {
        let [msg, obj] = msgCallback();
        debug(view, kind, msg, obj);
      }
    }
    requestDOMUpdate(callback2) {
      this.transitions.after(callback2);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.transitions.addTransition(time, onStart, onDone);
    }
    onChannel(channel, event, cb) {
      channel.on(event, (data) => {
        let latency = this.getLatencySim();
        if (!latency) {
          cb(data);
        } else {
          setTimeout(() => cb(data), latency);
        }
      });
    }
    wrapPush(view, opts, push) {
      let latency = this.getLatencySim();
      let oldJoinCount = view.joinCount;
      if (!latency) {
        if (this.isConnected() && opts.timeout) {
          return push().receive("timeout", () => {
            if (view.joinCount === oldJoinCount && !view.isDestroyed()) {
              this.reloadWithJitter(view, () => {
                this.log(view, "timeout", () => ["received timeout while communicating with server. Falling back to hard refresh for recovery"]);
              });
            }
          });
        } else {
          return push();
        }
      }
      let fakePush = {
        receives: [],
        receive(kind, cb) {
          this.receives.push([kind, cb]);
        }
      };
      setTimeout(() => {
        if (view.isDestroyed()) {
          return;
        }
        fakePush.receives.reduce((acc, [kind, cb]) => acc.receive(kind, cb), push());
      }, latency);
      return fakePush;
    }
    reloadWithJitter(view, log) {
      clearTimeout(this.reloadWithJitterTimer);
      this.disconnect();
      let minMs = this.reloadJitterMin;
      let maxMs = this.reloadJitterMax;
      let afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;
      let tries = browser_default.updateLocal(this.localStorage, window.location.pathname, CONSECUTIVE_RELOADS, 0, (count) => count + 1);
      if (tries > this.maxReloads) {
        afterMs = this.failsafeJitter;
      }
      this.reloadWithJitterTimer = setTimeout(() => {
        if (view.isDestroyed() || view.isConnected()) {
          return;
        }
        view.destroy();
        log ? log() : this.log(view, "join", () => [`encountered ${tries} consecutive reloads`]);
        if (tries > this.maxReloads) {
          this.log(view, "join", () => [`exceeded ${this.maxReloads} consecutive reloads. Entering failsafe mode`]);
        }
        if (this.hasPendingLink()) {
          window.location = this.pendingLink;
        } else {
          window.location.reload();
        }
      }, afterMs);
    }
    getHookCallbacks(name) {
      return name && name.startsWith("Phoenix.") ? hooks_default[name.split(".")[1]] : this.hooks[name];
    }
    isUnloaded() {
      return this.unloaded;
    }
    isConnected() {
      return this.socket.isConnected();
    }
    getBindingPrefix() {
      return this.bindingPrefix;
    }
    binding(kind) {
      return `${this.getBindingPrefix()}${kind}`;
    }
    channel(topic, params) {
      return this.socket.channel(topic, params);
    }
    joinDeadView() {
      let body = document.body;
      if (body && !this.isPhxView(body) && !this.isPhxView(document.firstElementChild)) {
        let view = this.newRootView(body);
        view.setHref(this.getHref());
        view.joinDead();
        if (!this.main) {
          this.main = view;
        }
        window.requestAnimationFrame(() => view.execNewMounted());
      }
    }
    joinRootViews() {
      let rootsFound = false;
      dom_default.all(document, `${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`, (rootEl) => {
        if (!this.getRootById(rootEl.id)) {
          let view = this.newRootView(rootEl);
          view.setHref(this.getHref());
          view.join();
          if (rootEl.hasAttribute(PHX_MAIN)) {
            this.main = view;
          }
        }
        rootsFound = true;
      });
      return rootsFound;
    }
    redirect(to2, flash) {
      this.unload();
      browser_default.redirect(to2, flash);
    }
    replaceMain(href, flash, callback2 = null, linkRef = this.setPendingLink(href)) {
      let liveReferer = this.currentLocation.href;
      this.outgoingMainEl = this.outgoingMainEl || this.main.el;
      let newMainEl = dom_default.cloneNode(this.outgoingMainEl, "");
      this.main.showLoader(this.loaderTimeout);
      this.main.destroy();
      this.main = this.newRootView(newMainEl, flash, liveReferer);
      this.main.setRedirect(href);
      this.transitionRemoves(null, true);
      this.main.join((joinCount, onDone) => {
        if (joinCount === 1 && this.commitPendingLink(linkRef)) {
          this.requestDOMUpdate(() => {
            dom_default.findPhxSticky(document).forEach((el) => newMainEl.appendChild(el));
            this.outgoingMainEl.replaceWith(newMainEl);
            this.outgoingMainEl = null;
            callback2 && callback2(linkRef);
            onDone();
          });
        }
      });
    }
    transitionRemoves(elements2, skipSticky) {
      let removeAttr = this.binding("remove");
      elements2 = elements2 || dom_default.all(document, `[${removeAttr}]`);
      if (skipSticky) {
        const stickies = dom_default.findPhxSticky(document) || [];
        elements2 = elements2.filter((el) => !dom_default.isChildOfAny(el, stickies));
      }
      elements2.forEach((el) => {
        this.execJS(el, el.getAttribute(removeAttr), "remove");
      });
    }
    isPhxView(el) {
      return el.getAttribute && el.getAttribute(PHX_SESSION) !== null;
    }
    newRootView(el, flash, liveReferer) {
      let view = new View(el, this, null, flash, liveReferer);
      this.roots[view.id] = view;
      return view;
    }
    owner(childEl, callback2) {
      let view = maybe(childEl.closest(PHX_VIEW_SELECTOR), (el) => this.getViewByEl(el)) || this.main;
      if (view) {
        callback2(view);
      }
    }
    withinOwners(childEl, callback2) {
      this.owner(childEl, (view) => callback2(view, childEl));
    }
    getViewByEl(el) {
      let rootId = el.getAttribute(PHX_ROOT_ID);
      return maybe(this.getRootById(rootId), (root) => root.getDescendentByEl(el));
    }
    getRootById(id) {
      return this.roots[id];
    }
    destroyAllViews() {
      for (let id in this.roots) {
        this.roots[id].destroy();
        delete this.roots[id];
      }
      this.main = null;
    }
    destroyViewByEl(el) {
      let root = this.getRootById(el.getAttribute(PHX_ROOT_ID));
      if (root && root.id === el.id) {
        root.destroy();
        delete this.roots[root.id];
      } else if (root) {
        root.destroyDescendent(el.id);
      }
    }
    setActiveElement(target) {
      if (this.activeElement === target) {
        return;
      }
      this.activeElement = target;
      let cancel = () => {
        if (target === this.activeElement) {
          this.activeElement = null;
        }
        target.removeEventListener("mouseup", this);
        target.removeEventListener("touchend", this);
      };
      target.addEventListener("mouseup", cancel);
      target.addEventListener("touchend", cancel);
    }
    getActiveElement() {
      if (document.activeElement === document.body) {
        return this.activeElement || document.activeElement;
      } else {
        return document.activeElement || document.body;
      }
    }
    dropActiveElement(view) {
      if (this.prevActive && view.ownsElement(this.prevActive)) {
        this.prevActive = null;
      }
    }
    restorePreviouslyActiveFocus() {
      if (this.prevActive && this.prevActive !== document.body) {
        this.prevActive.focus();
      }
    }
    blurActiveElement() {
      this.prevActive = this.getActiveElement();
      if (this.prevActive !== document.body) {
        this.prevActive.blur();
      }
    }
    bindTopLevelEvents({ dead } = {}) {
      if (this.boundTopLevelEvents) {
        return;
      }
      this.boundTopLevelEvents = true;
      this.socket.onClose((event) => {
        if (event && event.code === 1e3 && this.main) {
          return this.reloadWithJitter(this.main);
        }
      });
      document.body.addEventListener("click", function() {
      });
      window.addEventListener("pageshow", (e) => {
        if (e.persisted) {
          this.getSocket().disconnect();
          this.withPageLoading({ to: window.location.href, kind: "redirect" });
          window.location.reload();
        }
      }, true);
      if (!dead) {
        this.bindNav();
      }
      this.bindClicks();
      if (!dead) {
        this.bindForms();
      }
      this.bind({ keyup: "keyup", keydown: "keydown" }, (e, type, view, targetEl, phxEvent, phxTarget) => {
        let matchKey = targetEl.getAttribute(this.binding(PHX_KEY));
        let pressedKey = e.key && e.key.toLowerCase();
        if (matchKey && matchKey.toLowerCase() !== pressedKey) {
          return;
        }
        let data = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
        js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
      });
      this.bind({ blur: "focusout", focus: "focusin" }, (e, type, view, targetEl, phxEvent, phxTarget) => {
        if (!phxTarget) {
          let data = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
          js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
        }
      });
      this.bind({ blur: "blur", focus: "focus" }, (e, type, view, targetEl, phxEvent, phxTarget) => {
        if (phxTarget === "window") {
          let data = this.eventMeta(type, e, targetEl);
          js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
        }
      });
      window.addEventListener("dragover", (e) => e.preventDefault());
      window.addEventListener("drop", (e) => {
        e.preventDefault();
        let dropTargetId = maybe(closestPhxBinding(e.target, this.binding(PHX_DROP_TARGET)), (trueTarget) => {
          return trueTarget.getAttribute(this.binding(PHX_DROP_TARGET));
        });
        let dropTarget = dropTargetId && document.getElementById(dropTargetId);
        let files = Array.from(e.dataTransfer.files || []);
        if (!dropTarget || dropTarget.disabled || files.length === 0 || !(dropTarget.files instanceof FileList)) {
          return;
        }
        LiveUploader.trackFiles(dropTarget, files, e.dataTransfer);
        dropTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
      this.on(PHX_TRACK_UPLOADS, (e) => {
        let uploadTarget = e.target;
        if (!dom_default.isUploadInput(uploadTarget)) {
          return;
        }
        let files = Array.from(e.detail.files || []).filter((f) => f instanceof File || f instanceof Blob);
        LiveUploader.trackFiles(uploadTarget, files);
        uploadTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
    }
    eventMeta(eventName, e, targetEl) {
      let callback2 = this.metadataCallbacks[eventName];
      return callback2 ? callback2(e, targetEl) : {};
    }
    setPendingLink(href) {
      this.linkRef++;
      this.pendingLink = href;
      return this.linkRef;
    }
    commitPendingLink(linkRef) {
      if (this.linkRef !== linkRef) {
        return false;
      } else {
        this.href = this.pendingLink;
        this.pendingLink = null;
        return true;
      }
    }
    getHref() {
      return this.href;
    }
    hasPendingLink() {
      return !!this.pendingLink;
    }
    bind(events, callback2) {
      for (let event in events) {
        let browserEventName = events[event];
        this.on(browserEventName, (e) => {
          let binding = this.binding(event);
          let windowBinding = this.binding(`window-${event}`);
          let targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);
          if (targetPhxEvent) {
            this.debounce(e.target, e, browserEventName, () => {
              this.withinOwners(e.target, (view) => {
                callback2(e, event, view, e.target, targetPhxEvent, null);
              });
            });
          } else {
            dom_default.all(document, `[${windowBinding}]`, (el) => {
              let phxEvent = el.getAttribute(windowBinding);
              this.debounce(el, e, browserEventName, () => {
                this.withinOwners(el, (view) => {
                  callback2(e, event, view, el, phxEvent, "window");
                });
              });
            });
          }
        });
      }
    }
    bindClicks() {
      window.addEventListener("mousedown", (e) => this.clickStartedAtTarget = e.target);
      this.bindClick("click", "click", false);
      this.bindClick("mousedown", "capture-click", true);
    }
    bindClick(eventName, bindingName, capture) {
      let click = this.binding(bindingName);
      window.addEventListener(eventName, (e) => {
        let target = null;
        if (capture) {
          target = e.target.matches(`[${click}]`) ? e.target : e.target.querySelector(`[${click}]`);
        } else {
          if (e.detail === 0)
            this.clickStartedAtTarget = e.target;
          let clickStartedAtTarget = this.clickStartedAtTarget || e.target;
          target = closestPhxBinding(clickStartedAtTarget, click);
          this.dispatchClickAway(e, clickStartedAtTarget);
          this.clickStartedAtTarget = null;
        }
        let phxEvent = target && target.getAttribute(click);
        if (!phxEvent) {
          if (!capture && dom_default.isNewPageClick(e, window.location)) {
            this.unload();
          }
          return;
        }
        if (target.getAttribute("href") === "#") {
          e.preventDefault();
        }
        if (target.hasAttribute(PHX_REF)) {
          return;
        }
        this.debounce(target, e, "click", () => {
          this.withinOwners(target, (view) => {
            js_default.exec("click", phxEvent, view, target, ["push", { data: this.eventMeta("click", e, target) }]);
          });
        });
      }, capture);
    }
    dispatchClickAway(e, clickStartedAt) {
      let phxClickAway = this.binding("click-away");
      dom_default.all(document, `[${phxClickAway}]`, (el) => {
        if (!(el.isSameNode(clickStartedAt) || el.contains(clickStartedAt))) {
          this.withinOwners(el, (view) => {
            let phxEvent = el.getAttribute(phxClickAway);
            if (js_default.isVisible(el) && js_default.isInViewport(el)) {
              js_default.exec("click", phxEvent, view, el, ["push", { data: this.eventMeta("click", e, e.target) }]);
            }
          });
        }
      });
    }
    bindNav() {
      if (!browser_default.canPushState()) {
        return;
      }
      if (history.scrollRestoration) {
        history.scrollRestoration = "manual";
      }
      let scrollTimer = null;
      window.addEventListener("scroll", (_e) => {
        clearTimeout(scrollTimer);
        scrollTimer = setTimeout(() => {
          browser_default.updateCurrentState((state) => Object.assign(state, { scroll: window.scrollY }));
        }, 100);
      });
      window.addEventListener("popstate", (event) => {
        if (!this.registerNewLocation(window.location)) {
          return;
        }
        let { type, id, root, scroll } = event.state || {};
        let href = window.location.href;
        dom_default.dispatchEvent(window, "phx:navigate", { detail: { href, patch: type === "patch", pop: true } });
        this.requestDOMUpdate(() => {
          if (this.main.isConnected() && (type === "patch" && id === this.main.id)) {
            this.main.pushLinkPatch(href, null, () => {
              this.maybeScroll(scroll);
            });
          } else {
            this.replaceMain(href, null, () => {
              if (root) {
                this.replaceRootHistory();
              }
              this.maybeScroll(scroll);
            });
          }
        });
      }, false);
      window.addEventListener("click", (e) => {
        let target = closestPhxBinding(e.target, PHX_LIVE_LINK);
        let type = target && target.getAttribute(PHX_LIVE_LINK);
        if (!type || !this.isConnected() || !this.main || dom_default.wantsNewTab(e)) {
          return;
        }
        let href = target.href instanceof SVGAnimatedString ? target.href.baseVal : target.href;
        let linkState = target.getAttribute(PHX_LINK_STATE);
        e.preventDefault();
        e.stopImmediatePropagation();
        if (this.pendingLink === href) {
          return;
        }
        this.requestDOMUpdate(() => {
          if (type === "patch") {
            this.pushHistoryPatch(href, linkState, target);
          } else if (type === "redirect") {
            this.historyRedirect(href, linkState);
          } else {
            throw new Error(`expected ${PHX_LIVE_LINK} to be "patch" or "redirect", got: ${type}`);
          }
          let phxClick = target.getAttribute(this.binding("click"));
          if (phxClick) {
            this.requestDOMUpdate(() => this.execJS(target, phxClick, "click"));
          }
        });
      }, false);
    }
    maybeScroll(scroll) {
      if (typeof scroll === "number") {
        requestAnimationFrame(() => {
          window.scrollTo(0, scroll);
        });
      }
    }
    dispatchEvent(event, payload = {}) {
      dom_default.dispatchEvent(window, `phx:${event}`, { detail: payload });
    }
    dispatchEvents(events) {
      events.forEach(([event, payload]) => this.dispatchEvent(event, payload));
    }
    withPageLoading(info, callback2) {
      dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: info });
      let done = () => dom_default.dispatchEvent(window, "phx:page-loading-stop", { detail: info });
      return callback2 ? callback2(done) : done;
    }
    pushHistoryPatch(href, linkState, targetEl) {
      if (!this.isConnected() || !this.main.isMain()) {
        return browser_default.redirect(href);
      }
      this.withPageLoading({ to: href, kind: "patch" }, (done) => {
        this.main.pushLinkPatch(href, targetEl, (linkRef) => {
          this.historyPatch(href, linkState, linkRef);
          done();
        });
      });
    }
    historyPatch(href, linkState, linkRef = this.setPendingLink(href)) {
      if (!this.commitPendingLink(linkRef)) {
        return;
      }
      browser_default.pushState(linkState, { type: "patch", id: this.main.id }, href);
      dom_default.dispatchEvent(window, "phx:navigate", { detail: { patch: true, href, pop: false } });
      this.registerNewLocation(window.location);
    }
    historyRedirect(href, linkState, flash) {
      if (!this.isConnected() || !this.main.isMain()) {
        return browser_default.redirect(href, flash);
      }
      if (/^\/$|^\/[^\/]+.*$/.test(href)) {
        let { protocol, host } = window.location;
        href = `${protocol}//${host}${href}`;
      }
      let scroll = window.scrollY;
      this.withPageLoading({ to: href, kind: "redirect" }, (done) => {
        this.replaceMain(href, flash, (linkRef) => {
          if (linkRef === this.linkRef) {
            browser_default.pushState(linkState, { type: "redirect", id: this.main.id, scroll }, href);
            dom_default.dispatchEvent(window, "phx:navigate", { detail: { href, patch: false, pop: false } });
            this.registerNewLocation(window.location);
          }
          done();
        });
      });
    }
    replaceRootHistory() {
      browser_default.pushState("replace", { root: true, type: "patch", id: this.main.id });
    }
    registerNewLocation(newLocation) {
      let { pathname, search } = this.currentLocation;
      if (pathname + search === newLocation.pathname + newLocation.search) {
        return false;
      } else {
        this.currentLocation = clone(newLocation);
        return true;
      }
    }
    bindForms() {
      let iterations = 0;
      let externalFormSubmitted = false;
      this.on("submit", (e) => {
        let phxSubmit = e.target.getAttribute(this.binding("submit"));
        let phxChange = e.target.getAttribute(this.binding("change"));
        if (!externalFormSubmitted && phxChange && !phxSubmit) {
          externalFormSubmitted = true;
          e.preventDefault();
          this.withinOwners(e.target, (view) => {
            view.disableForm(e.target);
            window.requestAnimationFrame(() => {
              if (dom_default.isUnloadableFormSubmit(e)) {
                this.unload();
              }
              e.target.submit();
            });
          });
        }
      }, true);
      this.on("submit", (e) => {
        let phxEvent = e.target.getAttribute(this.binding("submit"));
        if (!phxEvent) {
          if (dom_default.isUnloadableFormSubmit(e)) {
            this.unload();
          }
          return;
        }
        e.preventDefault();
        e.target.disabled = true;
        this.withinOwners(e.target, (view) => {
          js_default.exec("submit", phxEvent, view, e.target, ["push", { submitter: e.submitter }]);
        });
      }, false);
      for (let type of ["change", "input"]) {
        this.on(type, (e) => {
          let phxChange = this.binding("change");
          let input = e.target;
          let inputEvent = input.getAttribute(phxChange);
          let formEvent = input.form && input.form.getAttribute(phxChange);
          let phxEvent = inputEvent || formEvent;
          if (!phxEvent) {
            return;
          }
          if (input.type === "number" && input.validity && input.validity.badInput) {
            return;
          }
          let dispatcher = inputEvent ? input : input.form;
          let currentIterations = iterations;
          iterations++;
          let { at, type: lastType } = dom_default.private(input, "prev-iteration") || {};
          if (at === currentIterations - 1 && type === "change" && lastType === "input") {
            return;
          }
          dom_default.putPrivate(input, "prev-iteration", { at: currentIterations, type });
          this.debounce(input, e, type, () => {
            this.withinOwners(dispatcher, (view) => {
              dom_default.putPrivate(input, PHX_HAS_FOCUSED, true);
              if (!dom_default.isTextualInput(input)) {
                this.setActiveElement(input);
              }
              js_default.exec("change", phxEvent, view, input, ["push", { _target: e.target.name, dispatcher }]);
            });
          });
        }, false);
      }
      this.on("reset", (e) => {
        let form = e.target;
        dom_default.resetForm(form, this.binding(PHX_FEEDBACK_FOR), this.binding(PHX_FEEDBACK_GROUP));
        let input = Array.from(form.elements).find((el) => el.type === "reset");
        if (input) {
          window.requestAnimationFrame(() => {
            input.dispatchEvent(new Event("input", { bubbles: true, cancelable: false }));
          });
        }
      });
    }
    debounce(el, event, eventType, callback2) {
      if (eventType === "blur" || eventType === "focusout") {
        return callback2();
      }
      let phxDebounce = this.binding(PHX_DEBOUNCE);
      let phxThrottle = this.binding(PHX_THROTTLE);
      let defaultDebounce = this.defaults.debounce.toString();
      let defaultThrottle = this.defaults.throttle.toString();
      this.withinOwners(el, (view) => {
        let asyncFilter = () => !view.isDestroyed() && document.body.contains(el);
        dom_default.debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, () => {
          callback2();
        });
      });
    }
    silenceEvents(callback2) {
      this.silenced = true;
      callback2();
      this.silenced = false;
    }
    on(event, callback2) {
      window.addEventListener(event, (e) => {
        if (!this.silenced) {
          callback2(e);
        }
      });
    }
  };
  var TransitionSet = class {
    constructor() {
      this.transitions = /* @__PURE__ */ new Set();
      this.pendingOps = [];
    }
    reset() {
      this.transitions.forEach((timer) => {
        clearTimeout(timer);
        this.transitions.delete(timer);
      });
      this.flushPendingOps();
    }
    after(callback2) {
      if (this.size() === 0) {
        callback2();
      } else {
        this.pushPendingOp(callback2);
      }
    }
    addTransition(time, onStart, onDone) {
      onStart();
      let timer = setTimeout(() => {
        this.transitions.delete(timer);
        onDone();
        this.flushPendingOps();
      }, time);
      this.transitions.add(timer);
    }
    pushPendingOp(op) {
      this.pendingOps.push(op);
    }
    size() {
      return this.transitions.size;
    }
    flushPendingOps() {
      if (this.size() > 0) {
        return;
      }
      let op = this.pendingOps.shift();
      if (op) {
        op();
        this.flushPendingOps();
      }
    }
  };

  // js/app.js
  var import_topbar = __toESM(require_topbar());

  // node_modules/@kurkle/color/dist/color.esm.js
  function round(v) {
    return v + 0.5 | 0;
  }
  var lim = (v, l, h) => Math.max(Math.min(v, h), l);
  function p2b(v) {
    return lim(round(v * 2.55), 0, 255);
  }
  function n2b(v) {
    return lim(round(v * 255), 0, 255);
  }
  function b2n(v) {
    return lim(round(v / 2.55) / 100, 0, 1);
  }
  function n2p(v) {
    return lim(round(v * 100), 0, 100);
  }
  var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
  var hex = [..."0123456789ABCDEF"];
  var h1 = (b) => hex[b & 15];
  var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
  var eq = (b) => (b & 240) >> 4 === (b & 15);
  var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
  function hexParse(str) {
    var len = str.length;
    var ret;
    if (str[0] === "#") {
      if (len === 4 || len === 5) {
        ret = {
          r: 255 & map$1[str[1]] * 17,
          g: 255 & map$1[str[2]] * 17,
          b: 255 & map$1[str[3]] * 17,
          a: len === 5 ? map$1[str[4]] * 17 : 255
        };
      } else if (len === 7 || len === 9) {
        ret = {
          r: map$1[str[1]] << 4 | map$1[str[2]],
          g: map$1[str[3]] << 4 | map$1[str[4]],
          b: map$1[str[5]] << 4 | map$1[str[6]],
          a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
        };
      }
    }
    return ret;
  }
  var alpha = (a, f) => a < 255 ? f(a) : "";
  function hexString(v) {
    var f = isShort(v) ? h1 : h2;
    return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
  }
  var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
  function hsl2rgbn(h, s, l) {
    const a = s * Math.min(l, 1 - l);
    const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return [f(0), f(8), f(4)];
  }
  function hsv2rgbn(h, s, v) {
    const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
    return [f(5), f(3), f(1)];
  }
  function hwb2rgbn(h, w, b) {
    const rgb = hsl2rgbn(h, 1, 0.5);
    let i;
    if (w + b > 1) {
      i = 1 / (w + b);
      w *= i;
      b *= i;
    }
    for (i = 0; i < 3; i++) {
      rgb[i] *= 1 - w - b;
      rgb[i] += w;
    }
    return rgb;
  }
  function hueValue(r, g, b, d, max) {
    if (r === max) {
      return (g - b) / d + (g < b ? 6 : 0);
    }
    if (g === max) {
      return (b - r) / d + 2;
    }
    return (r - g) / d + 4;
  }
  function rgb2hsl(v) {
    const range2 = 255;
    const r = v.r / range2;
    const g = v.g / range2;
    const b = v.b / range2;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const l = (max + min) / 2;
    let h, s, d;
    if (max !== min) {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = hueValue(r, g, b, d, max);
      h = h * 60 + 0.5;
    }
    return [h | 0, s || 0, l];
  }
  function calln(f, a, b, c) {
    return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
  }
  function hsl2rgb(h, s, l) {
    return calln(hsl2rgbn, h, s, l);
  }
  function hwb2rgb(h, w, b) {
    return calln(hwb2rgbn, h, w, b);
  }
  function hsv2rgb(h, s, v) {
    return calln(hsv2rgbn, h, s, v);
  }
  function hue(h) {
    return (h % 360 + 360) % 360;
  }
  function hueParse(str) {
    const m = HUE_RE.exec(str);
    let a = 255;
    let v;
    if (!m) {
      return;
    }
    if (m[5] !== v) {
      a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
    }
    const h = hue(+m[2]);
    const p1 = +m[3] / 100;
    const p2 = +m[4] / 100;
    if (m[1] === "hwb") {
      v = hwb2rgb(h, p1, p2);
    } else if (m[1] === "hsv") {
      v = hsv2rgb(h, p1, p2);
    } else {
      v = hsl2rgb(h, p1, p2);
    }
    return {
      r: v[0],
      g: v[1],
      b: v[2],
      a
    };
  }
  function rotate(v, deg) {
    var h = rgb2hsl(v);
    h[0] = hue(h[0] + deg);
    h = hsl2rgb(h);
    v.r = h[0];
    v.g = h[1];
    v.b = h[2];
  }
  function hslString(v) {
    if (!v) {
      return;
    }
    const a = rgb2hsl(v);
    const h = a[0];
    const s = n2p(a[1]);
    const l = n2p(a[2]);
    return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
  }
  var map = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh"
  };
  var names$1 = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32"
  };
  function unpack() {
    const unpacked = {};
    const keys = Object.keys(names$1);
    const tkeys = Object.keys(map);
    let i, j, k, ok, nk;
    for (i = 0; i < keys.length; i++) {
      ok = nk = keys[i];
      for (j = 0; j < tkeys.length; j++) {
        k = tkeys[j];
        nk = nk.replace(k, map[k]);
      }
      k = parseInt(names$1[ok], 16);
      unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
    }
    return unpacked;
  }
  var names;
  function nameParse(str) {
    if (!names) {
      names = unpack();
      names.transparent = [0, 0, 0, 0];
    }
    const a = names[str.toLowerCase()];
    return a && {
      r: a[0],
      g: a[1],
      b: a[2],
      a: a.length === 4 ? a[3] : 255
    };
  }
  var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
  function rgbParse(str) {
    const m = RGB_RE.exec(str);
    let a = 255;
    let r, g, b;
    if (!m) {
      return;
    }
    if (m[7] !== r) {
      const v = +m[7];
      a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
    }
    r = +m[1];
    g = +m[3];
    b = +m[5];
    r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
    g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
    b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
    return {
      r,
      g,
      b,
      a
    };
  }
  function rgbString(v) {
    return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
  }
  var to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
  var from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  function interpolate(rgb1, rgb2, t) {
    const r = from(b2n(rgb1.r));
    const g = from(b2n(rgb1.g));
    const b = from(b2n(rgb1.b));
    return {
      r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
      g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
      b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
      a: rgb1.a + t * (rgb2.a - rgb1.a)
    };
  }
  function modHSL(v, i, ratio) {
    if (v) {
      let tmp = rgb2hsl(v);
      tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
      tmp = hsl2rgb(tmp);
      v.r = tmp[0];
      v.g = tmp[1];
      v.b = tmp[2];
    }
  }
  function clone2(v, proto) {
    return v ? Object.assign(proto || {}, v) : v;
  }
  function fromObject(input) {
    var v = { r: 0, g: 0, b: 0, a: 255 };
    if (Array.isArray(input)) {
      if (input.length >= 3) {
        v = { r: input[0], g: input[1], b: input[2], a: 255 };
        if (input.length > 3) {
          v.a = n2b(input[3]);
        }
      }
    } else {
      v = clone2(input, { r: 0, g: 0, b: 0, a: 1 });
      v.a = n2b(v.a);
    }
    return v;
  }
  function functionParse(str) {
    if (str.charAt(0) === "r") {
      return rgbParse(str);
    }
    return hueParse(str);
  }
  var Color = class {
    constructor(input) {
      if (input instanceof Color) {
        return input;
      }
      const type = typeof input;
      let v;
      if (type === "object") {
        v = fromObject(input);
      } else if (type === "string") {
        v = hexParse(input) || nameParse(input) || functionParse(input);
      }
      this._rgb = v;
      this._valid = !!v;
    }
    get valid() {
      return this._valid;
    }
    get rgb() {
      var v = clone2(this._rgb);
      if (v) {
        v.a = b2n(v.a);
      }
      return v;
    }
    set rgb(obj) {
      this._rgb = fromObject(obj);
    }
    rgbString() {
      return this._valid ? rgbString(this._rgb) : void 0;
    }
    hexString() {
      return this._valid ? hexString(this._rgb) : void 0;
    }
    hslString() {
      return this._valid ? hslString(this._rgb) : void 0;
    }
    mix(color2, weight) {
      if (color2) {
        const c1 = this.rgb;
        const c2 = color2.rgb;
        let w2;
        const p = weight === w2 ? 0.5 : weight;
        const w = 2 * p - 1;
        const a = c1.a - c2.a;
        const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        w2 = 1 - w1;
        c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
        c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
        c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
        c1.a = p * c1.a + (1 - p) * c2.a;
        this.rgb = c1;
      }
      return this;
    }
    interpolate(color2, t) {
      if (color2) {
        this._rgb = interpolate(this._rgb, color2._rgb, t);
      }
      return this;
    }
    clone() {
      return new Color(this.rgb);
    }
    alpha(a) {
      this._rgb.a = n2b(a);
      return this;
    }
    clearer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 - ratio;
      return this;
    }
    greyscale() {
      const rgb = this._rgb;
      const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
      rgb.r = rgb.g = rgb.b = val;
      return this;
    }
    opaquer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 + ratio;
      return this;
    }
    negate() {
      const v = this._rgb;
      v.r = 255 - v.r;
      v.g = 255 - v.g;
      v.b = 255 - v.b;
      return this;
    }
    lighten(ratio) {
      modHSL(this._rgb, 2, ratio);
      return this;
    }
    darken(ratio) {
      modHSL(this._rgb, 2, -ratio);
      return this;
    }
    saturate(ratio) {
      modHSL(this._rgb, 1, ratio);
      return this;
    }
    desaturate(ratio) {
      modHSL(this._rgb, 1, -ratio);
      return this;
    }
    rotate(deg) {
      rotate(this._rgb, deg);
      return this;
    }
  };

  // node_modules/chart.js/dist/chunks/helpers.segment.js
  function noop2() {
  }
  var uid = (() => {
    let id = 0;
    return () => id++;
  })();
  function isNullOrUndef(value) {
    return value === null || typeof value === "undefined";
  }
  function isArray(value) {
    if (Array.isArray && Array.isArray(value)) {
      return true;
    }
    const type = Object.prototype.toString.call(value);
    if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
      return true;
    }
    return false;
  }
  function isObject2(value) {
    return value !== null && Object.prototype.toString.call(value) === "[object Object]";
  }
  function isNumberFinite(value) {
    return (typeof value === "number" || value instanceof Number) && isFinite(+value);
  }
  function finiteOrDefault(value, defaultValue) {
    return isNumberFinite(value) ? value : defaultValue;
  }
  function valueOrDefault(value, defaultValue) {
    return typeof value === "undefined" ? defaultValue : value;
  }
  var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
  var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
  function callback(fn, args, thisArg) {
    if (fn && typeof fn.call === "function") {
      return fn.apply(thisArg, args);
    }
  }
  function each(loopable, fn, thisArg, reverse) {
    let i, len, keys;
    if (isArray(loopable)) {
      len = loopable.length;
      if (reverse) {
        for (i = len - 1; i >= 0; i--) {
          fn.call(thisArg, loopable[i], i);
        }
      } else {
        for (i = 0; i < len; i++) {
          fn.call(thisArg, loopable[i], i);
        }
      }
    } else if (isObject2(loopable)) {
      keys = Object.keys(loopable);
      len = keys.length;
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[keys[i]], keys[i]);
      }
    }
  }
  function _elementsEqual(a0, a1) {
    let i, ilen, v0, v1;
    if (!a0 || !a1 || a0.length !== a1.length) {
      return false;
    }
    for (i = 0, ilen = a0.length; i < ilen; ++i) {
      v0 = a0[i];
      v1 = a1[i];
      if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
        return false;
      }
    }
    return true;
  }
  function clone3(source) {
    if (isArray(source)) {
      return source.map(clone3);
    }
    if (isObject2(source)) {
      const target = /* @__PURE__ */ Object.create(null);
      const keys = Object.keys(source);
      const klen = keys.length;
      let k = 0;
      for (; k < klen; ++k) {
        target[keys[k]] = clone3(source[keys[k]]);
      }
      return target;
    }
    return source;
  }
  function isValidKey(key) {
    return [
      "__proto__",
      "prototype",
      "constructor"
    ].indexOf(key) === -1;
  }
  function _merger(key, target, source, options) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject2(tval) && isObject2(sval)) {
      merge(tval, sval, options);
    } else {
      target[key] = clone3(sval);
    }
  }
  function merge(target, source, options) {
    const sources = isArray(source) ? source : [
      source
    ];
    const ilen = sources.length;
    if (!isObject2(target)) {
      return target;
    }
    options = options || {};
    const merger = options.merger || _merger;
    let current;
    for (let i = 0; i < ilen; ++i) {
      current = sources[i];
      if (!isObject2(current)) {
        continue;
      }
      const keys = Object.keys(current);
      for (let k = 0, klen = keys.length; k < klen; ++k) {
        merger(keys[k], target, current, options);
      }
    }
    return target;
  }
  function mergeIf(target, source) {
    return merge(target, source, {
      merger: _mergerIf
    });
  }
  function _mergerIf(key, target, source) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject2(tval) && isObject2(sval)) {
      mergeIf(tval, sval);
    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
      target[key] = clone3(sval);
    }
  }
  var keyResolvers = {
    // Chart.helpers.core resolveObjectKey should resolve empty key to root object
    "": (v) => v,
    // default resolvers
    x: (o) => o.x,
    y: (o) => o.y
  };
  function _splitKey(key) {
    const parts = key.split(".");
    const keys = [];
    let tmp = "";
    for (const part of parts) {
      tmp += part;
      if (tmp.endsWith("\\")) {
        tmp = tmp.slice(0, -1) + ".";
      } else {
        keys.push(tmp);
        tmp = "";
      }
    }
    return keys;
  }
  function _getKeyResolver(key) {
    const keys = _splitKey(key);
    return (obj) => {
      for (const k of keys) {
        if (k === "") {
          break;
        }
        obj = obj && obj[k];
      }
      return obj;
    };
  }
  function resolveObjectKey(obj, key) {
    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
    return resolver(obj);
  }
  function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  var defined = (value) => typeof value !== "undefined";
  var isFunction = (value) => typeof value === "function";
  var setsEqual = (a, b) => {
    if (a.size !== b.size) {
      return false;
    }
    for (const item of a) {
      if (!b.has(item)) {
        return false;
      }
    }
    return true;
  };
  function _isClickEvent(e) {
    return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
  }
  var PI = Math.PI;
  var TAU = 2 * PI;
  var PITAU = TAU + PI;
  var INFINITY = Number.POSITIVE_INFINITY;
  var RAD_PER_DEG = PI / 180;
  var HALF_PI = PI / 2;
  var QUARTER_PI = PI / 4;
  var TWO_THIRDS_PI = PI * 2 / 3;
  var log10 = Math.log10;
  var sign = Math.sign;
  function almostEquals(x, y, epsilon) {
    return Math.abs(x - y) < epsilon;
  }
  function niceNum(range2) {
    const roundedRange = Math.round(range2);
    range2 = almostEquals(range2, roundedRange, range2 / 1e3) ? roundedRange : range2;
    const niceRange = Math.pow(10, Math.floor(log10(range2)));
    const fraction = range2 / niceRange;
    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
    return niceFraction * niceRange;
  }
  function _factorize(value) {
    const result = [];
    const sqrt = Math.sqrt(value);
    let i;
    for (i = 1; i < sqrt; i++) {
      if (value % i === 0) {
        result.push(i);
        result.push(value / i);
      }
    }
    if (sqrt === (sqrt | 0)) {
      result.push(sqrt);
    }
    result.sort((a, b) => a - b).pop();
    return result;
  }
  function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }
  function almostWhole(x, epsilon) {
    const rounded = Math.round(x);
    return rounded - epsilon <= x && rounded + epsilon >= x;
  }
  function _setMinAndMaxByKey(array, target, property) {
    let i, ilen, value;
    for (i = 0, ilen = array.length; i < ilen; i++) {
      value = array[i][property];
      if (!isNaN(value)) {
        target.min = Math.min(target.min, value);
        target.max = Math.max(target.max, value);
      }
    }
  }
  function toRadians(degrees) {
    return degrees * (PI / 180);
  }
  function toDegrees(radians) {
    return radians * (180 / PI);
  }
  function _decimalPlaces(x) {
    if (!isNumberFinite(x)) {
      return;
    }
    let e = 1;
    let p = 0;
    while (Math.round(x * e) / e !== x) {
      e *= 10;
      p++;
    }
    return p;
  }
  function getAngleFromPoint(centrePoint, anglePoint) {
    const distanceFromXCenter = anglePoint.x - centrePoint.x;
    const distanceFromYCenter = anglePoint.y - centrePoint.y;
    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
    if (angle < -0.5 * PI) {
      angle += TAU;
    }
    return {
      angle,
      distance: radialDistanceFromCenter
    };
  }
  function distanceBetweenPoints(pt1, pt2) {
    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
  }
  function _angleDiff(a, b) {
    return (a - b + PITAU) % TAU - PI;
  }
  function _normalizeAngle(a) {
    return (a % TAU + TAU) % TAU;
  }
  function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
    const a = _normalizeAngle(angle);
    const s = _normalizeAngle(start);
    const e = _normalizeAngle(end);
    const angleToStart = _normalizeAngle(s - a);
    const angleToEnd = _normalizeAngle(e - a);
    const startToAngle = _normalizeAngle(a - s);
    const endToAngle = _normalizeAngle(a - e);
    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
  }
  function _limitValue(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  function _int16Range(value) {
    return _limitValue(value, -32768, 32767);
  }
  function _isBetween(value, start, end, epsilon = 1e-6) {
    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
  }
  function _lookup(table, value, cmp) {
    cmp = cmp || ((index2) => table[index2] < value);
    let hi = table.length - 1;
    let lo = 0;
    let mid;
    while (hi - lo > 1) {
      mid = lo + hi >> 1;
      if (cmp(mid)) {
        lo = mid;
      } else {
        hi = mid;
      }
    }
    return {
      lo,
      hi
    };
  }
  var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => {
    const ti = table[index2][key];
    return ti < value || ti === value && table[index2 + 1][key] === value;
  } : (index2) => table[index2][key] < value);
  var _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
  function _filterBetween(values, min, max) {
    let start = 0;
    let end = values.length;
    while (start < end && values[start] < min) {
      start++;
    }
    while (end > start && values[end - 1] > max) {
      end--;
    }
    return start > 0 || end < values.length ? values.slice(start, end) : values;
  }
  var arrayEvents = [
    "push",
    "pop",
    "shift",
    "splice",
    "unshift"
  ];
  function listenArrayEvents(array, listener) {
    if (array._chartjs) {
      array._chartjs.listeners.push(listener);
      return;
    }
    Object.defineProperty(array, "_chartjs", {
      configurable: true,
      enumerable: false,
      value: {
        listeners: [
          listener
        ]
      }
    });
    arrayEvents.forEach((key) => {
      const method = "_onData" + _capitalize(key);
      const base = array[key];
      Object.defineProperty(array, key, {
        configurable: true,
        enumerable: false,
        value(...args) {
          const res = base.apply(this, args);
          array._chartjs.listeners.forEach((object) => {
            if (typeof object[method] === "function") {
              object[method](...args);
            }
          });
          return res;
        }
      });
    });
  }
  function unlistenArrayEvents(array, listener) {
    const stub = array._chartjs;
    if (!stub) {
      return;
    }
    const listeners = stub.listeners;
    const index2 = listeners.indexOf(listener);
    if (index2 !== -1) {
      listeners.splice(index2, 1);
    }
    if (listeners.length > 0) {
      return;
    }
    arrayEvents.forEach((key) => {
      delete array[key];
    });
    delete array._chartjs;
  }
  function _arrayUnique(items) {
    const set2 = new Set(items);
    if (set2.size === items.length) {
      return items;
    }
    return Array.from(set2);
  }
  var requestAnimFrame = function() {
    if (typeof window === "undefined") {
      return function(callback2) {
        return callback2();
      };
    }
    return window.requestAnimationFrame;
  }();
  function throttled(fn, thisArg) {
    let argsToUse = [];
    let ticking = false;
    return function(...args) {
      argsToUse = args;
      if (!ticking) {
        ticking = true;
        requestAnimFrame.call(window, () => {
          ticking = false;
          fn.apply(thisArg, argsToUse);
        });
      }
    };
  }
  function debounce(fn, delay) {
    let timeout;
    return function(...args) {
      if (delay) {
        clearTimeout(timeout);
        timeout = setTimeout(fn, delay, args);
      } else {
        fn.apply(this, args);
      }
      return delay;
    };
  }
  var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
  var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
  var _textX = (align, left, right, rtl) => {
    const check = rtl ? "left" : "right";
    return align === check ? right : align === "center" ? (left + right) / 2 : left;
  };
  function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
    const pointCount = points.length;
    let start = 0;
    let count = pointCount;
    if (meta._sorted) {
      const { iScale, _parsed } = meta;
      const axis = iScale.axis;
      const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
      if (minDefined) {
        start = _limitValue(Math.min(
          // @ts-expect-error Need to type _parsed
          _lookupByKey(_parsed, axis, min).lo,
          // @ts-expect-error Need to fix types on _lookupByKey
          animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
        ), 0, pointCount - 1);
      }
      if (maxDefined) {
        count = _limitValue(Math.max(
          // @ts-expect-error Need to type _parsed
          _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,
          // @ts-expect-error Need to fix types on _lookupByKey
          animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1
        ), start, pointCount) - start;
      } else {
        count = pointCount - start;
      }
    }
    return {
      start,
      count
    };
  }
  function _scaleRangesChanged(meta) {
    const { xScale, yScale, _scaleRanges } = meta;
    const newRanges = {
      xmin: xScale.min,
      xmax: xScale.max,
      ymin: yScale.min,
      ymax: yScale.max
    };
    if (!_scaleRanges) {
      meta._scaleRanges = newRanges;
      return true;
    }
    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
    Object.assign(_scaleRanges, newRanges);
    return changed;
  }
  var atEdge = (t) => t === 0 || t === 1;
  var elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
  var elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
  var effects = {
    linear: (t) => t,
    easeInQuad: (t) => t * t,
    easeOutQuad: (t) => -t * (t - 2),
    easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
    easeInCubic: (t) => t * t * t,
    easeOutCubic: (t) => (t -= 1) * t * t + 1,
    easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
    easeInQuart: (t) => t * t * t * t,
    easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
    easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
    easeInQuint: (t) => t * t * t * t * t,
    easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
    easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
    easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
    easeOutSine: (t) => Math.sin(t * HALF_PI),
    easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
    easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
    easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
    easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
    easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
    easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
    easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
    easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
    easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
    easeInOutElastic(t) {
      const s = 0.1125;
      const p = 0.45;
      return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
    },
    easeInBack(t) {
      const s = 1.70158;
      return t * t * ((s + 1) * t - s);
    },
    easeOutBack(t) {
      const s = 1.70158;
      return (t -= 1) * t * ((s + 1) * t + s) + 1;
    },
    easeInOutBack(t) {
      let s = 1.70158;
      if ((t /= 0.5) < 1) {
        return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
      }
      return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
    },
    easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
    easeOutBounce(t) {
      const m = 7.5625;
      const d = 2.75;
      if (t < 1 / d) {
        return m * t * t;
      }
      if (t < 2 / d) {
        return m * (t -= 1.5 / d) * t + 0.75;
      }
      if (t < 2.5 / d) {
        return m * (t -= 2.25 / d) * t + 0.9375;
      }
      return m * (t -= 2.625 / d) * t + 0.984375;
    },
    easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
  };
  function isPatternOrGradient(value) {
    if (value && typeof value === "object") {
      const type = value.toString();
      return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
    }
    return false;
  }
  function color(value) {
    return isPatternOrGradient(value) ? value : new Color(value);
  }
  function getHoverColor(value) {
    return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
  }
  var numbers = [
    "x",
    "y",
    "borderWidth",
    "radius",
    "tension"
  ];
  var colors = [
    "color",
    "borderColor",
    "backgroundColor"
  ];
  function applyAnimationsDefaults(defaults2) {
    defaults2.set("animation", {
      delay: void 0,
      duration: 1e3,
      easing: "easeOutQuart",
      fn: void 0,
      from: void 0,
      loop: void 0,
      to: void 0,
      type: void 0
    });
    defaults2.describe("animation", {
      _fallback: false,
      _indexable: false,
      _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
    });
    defaults2.set("animations", {
      colors: {
        type: "color",
        properties: colors
      },
      numbers: {
        type: "number",
        properties: numbers
      }
    });
    defaults2.describe("animations", {
      _fallback: "animation"
    });
    defaults2.set("transitions", {
      active: {
        animation: {
          duration: 400
        }
      },
      resize: {
        animation: {
          duration: 0
        }
      },
      show: {
        animations: {
          colors: {
            from: "transparent"
          },
          visible: {
            type: "boolean",
            duration: 0
          }
        }
      },
      hide: {
        animations: {
          colors: {
            to: "transparent"
          },
          visible: {
            type: "boolean",
            easing: "linear",
            fn: (v) => v | 0
          }
        }
      }
    });
  }
  function applyLayoutsDefaults(defaults2) {
    defaults2.set("layout", {
      autoPadding: true,
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    });
  }
  var intlCache = /* @__PURE__ */ new Map();
  function getNumberFormat(locale, options) {
    options = options || {};
    const cacheKey = locale + JSON.stringify(options);
    let formatter = intlCache.get(cacheKey);
    if (!formatter) {
      formatter = new Intl.NumberFormat(locale, options);
      intlCache.set(cacheKey, formatter);
    }
    return formatter;
  }
  function formatNumber(num, locale, options) {
    return getNumberFormat(locale, options).format(num);
  }
  var formatters = {
    values(value) {
      return isArray(value) ? value : "" + value;
    },
    numeric(tickValue, index2, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const locale = this.chart.options.locale;
      let notation;
      let delta = tickValue;
      if (ticks.length > 1) {
        const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
        if (maxTick < 1e-4 || maxTick > 1e15) {
          notation = "scientific";
        }
        delta = calculateDelta(tickValue, ticks);
      }
      const logDelta = log10(Math.abs(delta));
      const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
      const options = {
        notation,
        minimumFractionDigits: numDecimal,
        maximumFractionDigits: numDecimal
      };
      Object.assign(options, this.options.ticks.format);
      return formatNumber(tickValue, locale, options);
    },
    logarithmic(tickValue, index2, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const remain = ticks[index2].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
      if ([
        1,
        2,
        3,
        5,
        10,
        15
      ].includes(remain) || index2 > 0.8 * ticks.length) {
        return formatters.numeric.call(this, tickValue, index2, ticks);
      }
      return "";
    }
  };
  function calculateDelta(tickValue, ticks) {
    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
      delta = tickValue - Math.floor(tickValue);
    }
    return delta;
  }
  var Ticks = {
    formatters
  };
  function applyScaleDefaults(defaults2) {
    defaults2.set("scale", {
      display: true,
      offset: false,
      reverse: false,
      beginAtZero: false,
      bounds: "ticks",
      clip: true,
      grace: 0,
      grid: {
        display: true,
        lineWidth: 1,
        drawOnChartArea: true,
        drawTicks: true,
        tickLength: 8,
        tickWidth: (_ctx, options) => options.lineWidth,
        tickColor: (_ctx, options) => options.color,
        offset: false
      },
      border: {
        display: true,
        dash: [],
        dashOffset: 0,
        width: 1
      },
      title: {
        display: false,
        text: "",
        padding: {
          top: 4,
          bottom: 4
        }
      },
      ticks: {
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        textStrokeWidth: 0,
        textStrokeColor: "",
        padding: 3,
        display: true,
        autoSkip: true,
        autoSkipPadding: 3,
        labelOffset: 0,
        callback: Ticks.formatters.values,
        minor: {},
        major: {},
        align: "center",
        crossAlign: "near",
        showLabelBackdrop: false,
        backdropColor: "rgba(255, 255, 255, 0.75)",
        backdropPadding: 2
      }
    });
    defaults2.route("scale.ticks", "color", "", "color");
    defaults2.route("scale.grid", "color", "", "borderColor");
    defaults2.route("scale.border", "color", "", "borderColor");
    defaults2.route("scale.title", "color", "", "color");
    defaults2.describe("scale", {
      _fallback: false,
      _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
      _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
    });
    defaults2.describe("scales", {
      _fallback: "scale"
    });
    defaults2.describe("scale.ticks", {
      _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
      _indexable: (name) => name !== "backdropPadding"
    });
  }
  var overrides = /* @__PURE__ */ Object.create(null);
  var descriptors = /* @__PURE__ */ Object.create(null);
  function getScope$1(node, key) {
    if (!key) {
      return node;
    }
    const keys = key.split(".");
    for (let i = 0, n = keys.length; i < n; ++i) {
      const k = keys[i];
      node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
    }
    return node;
  }
  function set(root, scope, values) {
    if (typeof scope === "string") {
      return merge(getScope$1(root, scope), values);
    }
    return merge(getScope$1(root, ""), scope);
  }
  var Defaults = class {
    constructor(_descriptors2, _appliers) {
      this.animation = void 0;
      this.backgroundColor = "rgba(0,0,0,0.1)";
      this.borderColor = "rgba(0,0,0,0.1)";
      this.color = "#666";
      this.datasets = {};
      this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
      this.elements = {};
      this.events = [
        "mousemove",
        "mouseout",
        "click",
        "touchstart",
        "touchmove"
      ];
      this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: "normal",
        lineHeight: 1.2,
        weight: null
      };
      this.hover = {};
      this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
      this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
      this.hoverColor = (ctx, options) => getHoverColor(options.color);
      this.indexAxis = "x";
      this.interaction = {
        mode: "nearest",
        intersect: true,
        includeInvisible: false
      };
      this.maintainAspectRatio = true;
      this.onHover = null;
      this.onClick = null;
      this.parsing = true;
      this.plugins = {};
      this.responsive = true;
      this.scale = void 0;
      this.scales = {};
      this.showLine = true;
      this.drawActiveElementsOnTop = true;
      this.describe(_descriptors2);
      this.apply(_appliers);
    }
    set(scope, values) {
      return set(this, scope, values);
    }
    get(scope) {
      return getScope$1(this, scope);
    }
    describe(scope, values) {
      return set(descriptors, scope, values);
    }
    override(scope, values) {
      return set(overrides, scope, values);
    }
    route(scope, name, targetScope, targetName) {
      const scopeObject = getScope$1(this, scope);
      const targetScopeObject = getScope$1(this, targetScope);
      const privateName = "_" + name;
      Object.defineProperties(scopeObject, {
        [privateName]: {
          value: scopeObject[name],
          writable: true
        },
        [name]: {
          enumerable: true,
          get() {
            const local = this[privateName];
            const target = targetScopeObject[targetName];
            if (isObject2(local)) {
              return Object.assign({}, target, local);
            }
            return valueOrDefault(local, target);
          },
          set(value) {
            this[privateName] = value;
          }
        }
      });
    }
    apply(appliers) {
      appliers.forEach((apply) => apply(this));
    }
  };
  var defaults = /* @__PURE__ */ new Defaults({
    _scriptable: (name) => !name.startsWith("on"),
    _indexable: (name) => name !== "events",
    hover: {
      _fallback: "interaction"
    },
    interaction: {
      _scriptable: false,
      _indexable: false
    }
  }, [
    applyAnimationsDefaults,
    applyLayoutsDefaults,
    applyScaleDefaults
  ]);
  function toFontString(font) {
    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
      return null;
    }
    return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
  }
  function _measureText(ctx, data, gc, longest, string) {
    let textWidth = data[string];
    if (!textWidth) {
      textWidth = data[string] = ctx.measureText(string).width;
      gc.push(string);
    }
    if (textWidth > longest) {
      longest = textWidth;
    }
    return longest;
  }
  function _longestText(ctx, font, arrayOfThings, cache) {
    cache = cache || {};
    let data = cache.data = cache.data || {};
    let gc = cache.garbageCollect = cache.garbageCollect || [];
    if (cache.font !== font) {
      data = cache.data = {};
      gc = cache.garbageCollect = [];
      cache.font = font;
    }
    ctx.save();
    ctx.font = font;
    let longest = 0;
    const ilen = arrayOfThings.length;
    let i, j, jlen, thing, nestedThing;
    for (i = 0; i < ilen; i++) {
      thing = arrayOfThings[i];
      if (thing !== void 0 && thing !== null && !isArray(thing)) {
        longest = _measureText(ctx, data, gc, longest, thing);
      } else if (isArray(thing)) {
        for (j = 0, jlen = thing.length; j < jlen; j++) {
          nestedThing = thing[j];
          if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
            longest = _measureText(ctx, data, gc, longest, nestedThing);
          }
        }
      }
    }
    ctx.restore();
    const gcLen = gc.length / 2;
    if (gcLen > arrayOfThings.length) {
      for (i = 0; i < gcLen; i++) {
        delete data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
    return longest;
  }
  function _alignPixel(chart, pixel, width) {
    const devicePixelRatio = chart.currentDevicePixelRatio;
    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
  }
  function clearCanvas(canvas, ctx) {
    ctx = ctx || canvas.getContext("2d");
    ctx.save();
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }
  function drawPoint(ctx, options, x, y) {
    drawPointLegend(ctx, options, x, y, null);
  }
  function drawPointLegend(ctx, options, x, y, w) {
    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
    const style = options.pointStyle;
    const rotation = options.rotation;
    const radius = options.radius;
    let rad = (rotation || 0) * RAD_PER_DEG;
    if (style && typeof style === "object") {
      type = style.toString();
      if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rad);
        ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
        ctx.restore();
        return;
      }
    }
    if (isNaN(radius) || radius <= 0) {
      return;
    }
    ctx.beginPath();
    switch (style) {
      default:
        if (w) {
          ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
        } else {
          ctx.arc(x, y, radius, 0, TAU);
        }
        ctx.closePath();
        break;
      case "triangle":
        width = w ? w / 2 : radius;
        ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
        ctx.closePath();
        break;
      case "rectRounded":
        cornerRadius = radius * 0.516;
        size = radius - cornerRadius;
        xOffset = Math.cos(rad + QUARTER_PI) * size;
        xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
        yOffset = Math.sin(rad + QUARTER_PI) * size;
        yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
        ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
        ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
        ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
        ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
        ctx.closePath();
        break;
      case "rect":
        if (!rotation) {
          size = Math.SQRT1_2 * radius;
          width = w ? w / 2 : size;
          ctx.rect(x - width, y - size, 2 * width, 2 * size);
          break;
        }
        rad += QUARTER_PI;
      case "rectRot":
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y - yOffset);
        ctx.lineTo(x + yOffsetW, y - xOffset);
        ctx.lineTo(x + xOffsetW, y + yOffset);
        ctx.lineTo(x - yOffsetW, y + xOffset);
        ctx.closePath();
        break;
      case "crossRot":
        rad += QUARTER_PI;
      case "cross":
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y - yOffset);
        ctx.lineTo(x + xOffsetW, y + yOffset);
        ctx.moveTo(x + yOffsetW, y - xOffset);
        ctx.lineTo(x - yOffsetW, y + xOffset);
        break;
      case "star":
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y - yOffset);
        ctx.lineTo(x + xOffsetW, y + yOffset);
        ctx.moveTo(x + yOffsetW, y - xOffset);
        ctx.lineTo(x - yOffsetW, y + xOffset);
        rad += QUARTER_PI;
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y - yOffset);
        ctx.lineTo(x + xOffsetW, y + yOffset);
        ctx.moveTo(x + yOffsetW, y - xOffset);
        ctx.lineTo(x - yOffsetW, y + xOffset);
        break;
      case "line":
        xOffset = w ? w / 2 : Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y - yOffset);
        ctx.lineTo(x + xOffset, y + yOffset);
        break;
      case "dash":
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
        break;
      case false:
        ctx.closePath();
        break;
    }
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  function _isPointInArea(point, area, margin) {
    margin = margin || 0.5;
    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
  }
  function clipArea(ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
  }
  function unclipArea(ctx) {
    ctx.restore();
  }
  function _steppedLineTo(ctx, previous, target, flip, mode) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    if (mode === "middle") {
      const midpoint = (previous.x + target.x) / 2;
      ctx.lineTo(midpoint, previous.y);
      ctx.lineTo(midpoint, target.y);
    } else if (mode === "after" !== !!flip) {
      ctx.lineTo(previous.x, target.y);
    } else {
      ctx.lineTo(target.x, previous.y);
    }
    ctx.lineTo(target.x, target.y);
  }
  function _bezierCurveTo(ctx, previous, target, flip) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
  }
  function setRenderOpts(ctx, opts) {
    if (opts.translation) {
      ctx.translate(opts.translation[0], opts.translation[1]);
    }
    if (!isNullOrUndef(opts.rotation)) {
      ctx.rotate(opts.rotation);
    }
    if (opts.color) {
      ctx.fillStyle = opts.color;
    }
    if (opts.textAlign) {
      ctx.textAlign = opts.textAlign;
    }
    if (opts.textBaseline) {
      ctx.textBaseline = opts.textBaseline;
    }
  }
  function decorateText(ctx, x, y, line, opts) {
    if (opts.strikethrough || opts.underline) {
      const metrics = ctx.measureText(line);
      const left = x - metrics.actualBoundingBoxLeft;
      const right = x + metrics.actualBoundingBoxRight;
      const top2 = y - metrics.actualBoundingBoxAscent;
      const bottom2 = y + metrics.actualBoundingBoxDescent;
      const yDecoration = opts.strikethrough ? (top2 + bottom2) / 2 : bottom2;
      ctx.strokeStyle = ctx.fillStyle;
      ctx.beginPath();
      ctx.lineWidth = opts.decorationWidth || 2;
      ctx.moveTo(left, yDecoration);
      ctx.lineTo(right, yDecoration);
      ctx.stroke();
    }
  }
  function drawBackdrop(ctx, opts) {
    const oldColor = ctx.fillStyle;
    ctx.fillStyle = opts.color;
    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
    ctx.fillStyle = oldColor;
  }
  function renderText(ctx, text, x, y, font, opts = {}) {
    const lines = isArray(text) ? text : [
      text
    ];
    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
    let i, line;
    ctx.save();
    ctx.font = font.string;
    setRenderOpts(ctx, opts);
    for (i = 0; i < lines.length; ++i) {
      line = lines[i];
      if (opts.backdrop) {
        drawBackdrop(ctx, opts.backdrop);
      }
      if (stroke) {
        if (opts.strokeColor) {
          ctx.strokeStyle = opts.strokeColor;
        }
        if (!isNullOrUndef(opts.strokeWidth)) {
          ctx.lineWidth = opts.strokeWidth;
        }
        ctx.strokeText(line, x, y, opts.maxWidth);
      }
      ctx.fillText(line, x, y, opts.maxWidth);
      decorateText(ctx, x, y, line, opts);
      y += Number(font.lineHeight);
    }
    ctx.restore();
  }
  function addRoundedRectPath(ctx, rect) {
    const { x, y, w, h, radius } = rect;
    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
    ctx.lineTo(x, y + h - radius.bottomLeft);
    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
    ctx.lineTo(x + w - radius.bottomRight, y + h);
    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
    ctx.lineTo(x + w, y + radius.topRight);
    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
    ctx.lineTo(x + radius.topLeft, y);
  }
  var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
  var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
  function toLineHeight(value, size) {
    const matches = ("" + value).match(LINE_HEIGHT);
    if (!matches || matches[1] === "normal") {
      return size * 1.2;
    }
    value = +matches[2];
    switch (matches[3]) {
      case "px":
        return value;
      case "%":
        value /= 100;
        break;
    }
    return size * value;
  }
  var numberOrZero = (v) => +v || 0;
  function _readValueToProps(value, props) {
    const ret = {};
    const objProps = isObject2(props);
    const keys = objProps ? Object.keys(props) : props;
    const read = isObject2(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
    for (const prop of keys) {
      ret[prop] = numberOrZero(read(prop));
    }
    return ret;
  }
  function toTRBL(value) {
    return _readValueToProps(value, {
      top: "y",
      right: "x",
      bottom: "y",
      left: "x"
    });
  }
  function toTRBLCorners(value) {
    return _readValueToProps(value, [
      "topLeft",
      "topRight",
      "bottomLeft",
      "bottomRight"
    ]);
  }
  function toPadding(value) {
    const obj = toTRBL(value);
    obj.width = obj.left + obj.right;
    obj.height = obj.top + obj.bottom;
    return obj;
  }
  function toFont(options, fallback) {
    options = options || {};
    fallback = fallback || defaults.font;
    let size = valueOrDefault(options.size, fallback.size);
    if (typeof size === "string") {
      size = parseInt(size, 10);
    }
    let style = valueOrDefault(options.style, fallback.style);
    if (style && !("" + style).match(FONT_STYLE)) {
      console.warn('Invalid font style specified: "' + style + '"');
      style = void 0;
    }
    const font = {
      family: valueOrDefault(options.family, fallback.family),
      lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
      size,
      style,
      weight: valueOrDefault(options.weight, fallback.weight),
      string: ""
    };
    font.string = toFontString(font);
    return font;
  }
  function resolve(inputs, context, index2, info) {
    let cacheable = true;
    let i, ilen, value;
    for (i = 0, ilen = inputs.length; i < ilen; ++i) {
      value = inputs[i];
      if (value === void 0) {
        continue;
      }
      if (context !== void 0 && typeof value === "function") {
        value = value(context);
        cacheable = false;
      }
      if (index2 !== void 0 && isArray(value)) {
        value = value[index2 % value.length];
        cacheable = false;
      }
      if (value !== void 0) {
        if (info && !cacheable) {
          info.cacheable = false;
        }
        return value;
      }
    }
  }
  function _addGrace(minmax, grace, beginAtZero) {
    const { min, max } = minmax;
    const change = toDimension(grace, (max - min) / 2);
    const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
    return {
      min: keepZero(min, -Math.abs(change)),
      max: keepZero(max, change)
    };
  }
  function createContext(parentContext, context) {
    return Object.assign(Object.create(parentContext), context);
  }
  function _createResolver(scopes, prefixes = [
    ""
  ], rootScopes, fallback, getTarget = () => scopes[0]) {
    const finalRootScopes = rootScopes || scopes;
    if (typeof fallback === "undefined") {
      fallback = _resolve("_fallback", scopes);
    }
    const cache = {
      [Symbol.toStringTag]: "Object",
      _cacheable: true,
      _scopes: scopes,
      _rootScopes: finalRootScopes,
      _fallback: fallback,
      _getTarget: getTarget,
      override: (scope) => _createResolver([
        scope,
        ...scopes
      ], prefixes, finalRootScopes, fallback)
    };
    return new Proxy(cache, {
      /**
      * A trap for the delete operator.
      */
      deleteProperty(target, prop) {
        delete target[prop];
        delete target._keys;
        delete scopes[0][prop];
        return true;
      },
      /**
      * A trap for getting property values.
      */
      get(target, prop) {
        return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
      },
      /**
      * A trap for Object.getOwnPropertyDescriptor.
      * Also used by Object.hasOwnProperty.
      */
      getOwnPropertyDescriptor(target, prop) {
        return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
      },
      /**
      * A trap for Object.getPrototypeOf.
      */
      getPrototypeOf() {
        return Reflect.getPrototypeOf(scopes[0]);
      },
      /**
      * A trap for the in operator.
      */
      has(target, prop) {
        return getKeysFromAllScopes(target).includes(prop);
      },
      /**
      * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
      */
      ownKeys(target) {
        return getKeysFromAllScopes(target);
      },
      /**
      * A trap for setting property values.
      */
      set(target, prop, value) {
        const storage = target._storage || (target._storage = getTarget());
        target[prop] = storage[prop] = value;
        delete target._keys;
        return true;
      }
    });
  }
  function _attachContext(proxy, context, subProxy, descriptorDefaults) {
    const cache = {
      _cacheable: false,
      _proxy: proxy,
      _context: context,
      _subProxy: subProxy,
      _stack: /* @__PURE__ */ new Set(),
      _descriptors: _descriptors(proxy, descriptorDefaults),
      setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
      override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
    };
    return new Proxy(cache, {
      /**
      * A trap for the delete operator.
      */
      deleteProperty(target, prop) {
        delete target[prop];
        delete proxy[prop];
        return true;
      },
      /**
      * A trap for getting property values.
      */
      get(target, prop, receiver) {
        return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
      },
      /**
      * A trap for Object.getOwnPropertyDescriptor.
      * Also used by Object.hasOwnProperty.
      */
      getOwnPropertyDescriptor(target, prop) {
        return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
          enumerable: true,
          configurable: true
        } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
      },
      /**
      * A trap for Object.getPrototypeOf.
      */
      getPrototypeOf() {
        return Reflect.getPrototypeOf(proxy);
      },
      /**
      * A trap for the in operator.
      */
      has(target, prop) {
        return Reflect.has(proxy, prop);
      },
      /**
      * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
      */
      ownKeys() {
        return Reflect.ownKeys(proxy);
      },
      /**
      * A trap for setting property values.
      */
      set(target, prop, value) {
        proxy[prop] = value;
        delete target[prop];
        return true;
      }
    });
  }
  function _descriptors(proxy, defaults2 = {
    scriptable: true,
    indexable: true
  }) {
    const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
    return {
      allKeys: _allKeys,
      scriptable: _scriptable,
      indexable: _indexable,
      isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
      isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
    };
  }
  var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
  var needsSubResolver = (prop, value) => isObject2(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
  function _cached(target, prop, resolve2) {
    if (Object.prototype.hasOwnProperty.call(target, prop)) {
      return target[prop];
    }
    const value = resolve2();
    target[prop] = value;
    return value;
  }
  function _resolveWithContext(target, prop, receiver) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    let value = _proxy[prop];
    if (isFunction(value) && descriptors2.isScriptable(prop)) {
      value = _resolveScriptable(prop, value, target, receiver);
    }
    if (isArray(value) && value.length) {
      value = _resolveArray(prop, value, target, descriptors2.isIndexable);
    }
    if (needsSubResolver(prop, value)) {
      value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
    }
    return value;
  }
  function _resolveScriptable(prop, getValue, target, receiver) {
    const { _proxy, _context, _subProxy, _stack } = target;
    if (_stack.has(prop)) {
      throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
    }
    _stack.add(prop);
    let value = getValue(_context, _subProxy || receiver);
    _stack.delete(prop);
    if (needsSubResolver(prop, value)) {
      value = createSubResolver(_proxy._scopes, _proxy, prop, value);
    }
    return value;
  }
  function _resolveArray(prop, value, target, isIndexable) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    if (typeof _context.index !== "undefined" && isIndexable(prop)) {
      return value[_context.index % value.length];
    } else if (isObject2(value[0])) {
      const arr = value;
      const scopes = _proxy._scopes.filter((s) => s !== arr);
      value = [];
      for (const item of arr) {
        const resolver = createSubResolver(scopes, _proxy, prop, item);
        value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
      }
    }
    return value;
  }
  function resolveFallback(fallback, prop, value) {
    return isFunction(fallback) ? fallback(prop, value) : fallback;
  }
  var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
  function addScopes(set2, parentScopes, key, parentFallback, value) {
    for (const parent of parentScopes) {
      const scope = getScope(key, parent);
      if (scope) {
        set2.add(scope);
        const fallback = resolveFallback(scope._fallback, key, value);
        if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
          return fallback;
        }
      } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
        return null;
      }
    }
    return false;
  }
  function createSubResolver(parentScopes, resolver, prop, value) {
    const rootScopes = resolver._rootScopes;
    const fallback = resolveFallback(resolver._fallback, prop, value);
    const allScopes = [
      ...parentScopes,
      ...rootScopes
    ];
    const set2 = /* @__PURE__ */ new Set();
    set2.add(value);
    let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
    if (key === null) {
      return false;
    }
    if (typeof fallback !== "undefined" && fallback !== prop) {
      key = addScopesFromKey(set2, allScopes, fallback, key, value);
      if (key === null) {
        return false;
      }
    }
    return _createResolver(Array.from(set2), [
      ""
    ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
  }
  function addScopesFromKey(set2, allScopes, key, fallback, item) {
    while (key) {
      key = addScopes(set2, allScopes, key, fallback, item);
    }
    return key;
  }
  function subGetTarget(resolver, prop, value) {
    const parent = resolver._getTarget();
    if (!(prop in parent)) {
      parent[prop] = {};
    }
    const target = parent[prop];
    if (isArray(target) && isObject2(value)) {
      return value;
    }
    return target || {};
  }
  function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
    let value;
    for (const prefix of prefixes) {
      value = _resolve(readKey(prefix, prop), scopes);
      if (typeof value !== "undefined") {
        return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
      }
    }
  }
  function _resolve(key, scopes) {
    for (const scope of scopes) {
      if (!scope) {
        continue;
      }
      const value = scope[key];
      if (typeof value !== "undefined") {
        return value;
      }
    }
  }
  function getKeysFromAllScopes(target) {
    let keys = target._keys;
    if (!keys) {
      keys = target._keys = resolveKeysFromAllScopes(target._scopes);
    }
    return keys;
  }
  function resolveKeysFromAllScopes(scopes) {
    const set2 = /* @__PURE__ */ new Set();
    for (const scope of scopes) {
      for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
        set2.add(key);
      }
    }
    return Array.from(set2);
  }
  function _parseObjectDataRadialScale(meta, data, start, count) {
    const { iScale } = meta;
    const { key = "r" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data[index2];
      parsed[i] = {
        r: iScale.parse(resolveObjectKey(item, key), index2)
      };
    }
    return parsed;
  }
  var EPSILON = Number.EPSILON || 1e-14;
  var getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
  var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
  function splineCurve(firstPoint, middlePoint, afterPoint, t) {
    const previous = firstPoint.skip ? middlePoint : firstPoint;
    const current = middlePoint;
    const next = afterPoint.skip ? middlePoint : afterPoint;
    const d01 = distanceBetweenPoints(current, previous);
    const d12 = distanceBetweenPoints(next, current);
    let s01 = d01 / (d01 + d12);
    let s12 = d12 / (d01 + d12);
    s01 = isNaN(s01) ? 0 : s01;
    s12 = isNaN(s12) ? 0 : s12;
    const fa = t * s01;
    const fb = t * s12;
    return {
      previous: {
        x: current.x - fa * (next.x - previous.x),
        y: current.y - fa * (next.y - previous.y)
      },
      next: {
        x: current.x + fb * (next.x - previous.x),
        y: current.y + fb * (next.y - previous.y)
      }
    };
  }
  function monotoneAdjust(points, deltaK, mK) {
    const pointsLen = points.length;
    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i = 0; i < pointsLen - 1; ++i) {
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i + 1);
      if (!pointCurrent || !pointAfter) {
        continue;
      }
      if (almostEquals(deltaK[i], 0, EPSILON)) {
        mK[i] = mK[i + 1] = 0;
        continue;
      }
      alphaK = mK[i] / deltaK[i];
      betaK = mK[i + 1] / deltaK[i];
      squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
      if (squaredMagnitude <= 9) {
        continue;
      }
      tauK = 3 / Math.sqrt(squaredMagnitude);
      mK[i] = alphaK * tauK * deltaK[i];
      mK[i + 1] = betaK * tauK * deltaK[i];
    }
  }
  function monotoneCompute(points, mK, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    let delta, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i = 0; i < pointsLen; ++i) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i + 1);
      if (!pointCurrent) {
        continue;
      }
      const iPixel = pointCurrent[indexAxis];
      const vPixel = pointCurrent[valueAxis];
      if (pointBefore) {
        delta = (iPixel - pointBefore[indexAxis]) / 3;
        pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
        pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
      }
      if (pointAfter) {
        delta = (pointAfter[indexAxis] - iPixel) / 3;
        pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
        pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
      }
    }
  }
  function splineCurveMonotone(points, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    const deltaK = Array(pointsLen).fill(0);
    const mK = Array(pointsLen);
    let i, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (i = 0; i < pointsLen; ++i) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i + 1);
      if (!pointCurrent) {
        continue;
      }
      if (pointAfter) {
        const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
        deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
      }
      mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
    }
    monotoneAdjust(points, deltaK, mK);
    monotoneCompute(points, mK, indexAxis);
  }
  function capControlPoint(pt, min, max) {
    return Math.max(Math.min(pt, max), min);
  }
  function capBezierPoints(points, area) {
    let i, ilen, point, inArea, inAreaPrev;
    let inAreaNext = _isPointInArea(points[0], area);
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      inAreaPrev = inArea;
      inArea = inAreaNext;
      inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
      if (!inArea) {
        continue;
      }
      point = points[i];
      if (inAreaPrev) {
        point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
        point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
      }
      if (inAreaNext) {
        point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
        point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
      }
    }
  }
  function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
    let i, ilen, point, controlPoints;
    if (options.spanGaps) {
      points = points.filter((pt) => !pt.skip);
    }
    if (options.cubicInterpolationMode === "monotone") {
      splineCurveMonotone(points, indexAxis);
    } else {
      let prev = loop ? points[points.length - 1] : points[0];
      for (i = 0, ilen = points.length; i < ilen; ++i) {
        point = points[i];
        controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
        point.cp1x = controlPoints.previous.x;
        point.cp1y = controlPoints.previous.y;
        point.cp2x = controlPoints.next.x;
        point.cp2y = controlPoints.next.y;
        prev = point;
      }
    }
    if (options.capBezierPoints) {
      capBezierPoints(points, area);
    }
  }
  function _isDomSupported() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function _getParentNode(domNode) {
    let parent = domNode.parentNode;
    if (parent && parent.toString() === "[object ShadowRoot]") {
      parent = parent.host;
    }
    return parent;
  }
  function parseMaxStyle(styleValue, node, parentProperty) {
    let valueInPixels;
    if (typeof styleValue === "string") {
      valueInPixels = parseInt(styleValue, 10);
      if (styleValue.indexOf("%") !== -1) {
        valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
      }
    } else {
      valueInPixels = styleValue;
    }
    return valueInPixels;
  }
  var getComputedStyle2 = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
  function getStyle(el, property) {
    return getComputedStyle2(el).getPropertyValue(property);
  }
  var positions = [
    "top",
    "right",
    "bottom",
    "left"
  ];
  function getPositionedStyle(styles, style, suffix) {
    const result = {};
    suffix = suffix ? "-" + suffix : "";
    for (let i = 0; i < 4; i++) {
      const pos = positions[i];
      result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
    }
    result.width = result.left + result.right;
    result.height = result.top + result.bottom;
    return result;
  }
  var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
  function getCanvasPosition(e, canvas) {
    const touches = e.touches;
    const source = touches && touches.length ? touches[0] : e;
    const { offsetX, offsetY } = source;
    let box = false;
    let x, y;
    if (useOffsetPos(offsetX, offsetY, e.target)) {
      x = offsetX;
      y = offsetY;
    } else {
      const rect = canvas.getBoundingClientRect();
      x = source.clientX - rect.left;
      y = source.clientY - rect.top;
      box = true;
    }
    return {
      x,
      y,
      box
    };
  }
  function getRelativePosition(event, chart) {
    if ("native" in event) {
      return event;
    }
    const { canvas, currentDevicePixelRatio } = chart;
    const style = getComputedStyle2(canvas);
    const borderBox = style.boxSizing === "border-box";
    const paddings = getPositionedStyle(style, "padding");
    const borders = getPositionedStyle(style, "border", "width");
    const { x, y, box } = getCanvasPosition(event, canvas);
    const xOffset = paddings.left + (box && borders.left);
    const yOffset = paddings.top + (box && borders.top);
    let { width, height } = chart;
    if (borderBox) {
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    return {
      x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
      y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
    };
  }
  function getContainerSize(canvas, width, height) {
    let maxWidth, maxHeight;
    if (width === void 0 || height === void 0) {
      const container = _getParentNode(canvas);
      if (!container) {
        width = canvas.clientWidth;
        height = canvas.clientHeight;
      } else {
        const rect = container.getBoundingClientRect();
        const containerStyle = getComputedStyle2(container);
        const containerBorder = getPositionedStyle(containerStyle, "border", "width");
        const containerPadding = getPositionedStyle(containerStyle, "padding");
        width = rect.width - containerPadding.width - containerBorder.width;
        height = rect.height - containerPadding.height - containerBorder.height;
        maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
        maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
      }
    }
    return {
      width,
      height,
      maxWidth: maxWidth || INFINITY,
      maxHeight: maxHeight || INFINITY
    };
  }
  var round1 = (v) => Math.round(v * 10) / 10;
  function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
    const style = getComputedStyle2(canvas);
    const margins = getPositionedStyle(style, "margin");
    const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
    const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
    let { width, height } = containerSize;
    if (style.boxSizing === "content-box") {
      const borders = getPositionedStyle(style, "border", "width");
      const paddings = getPositionedStyle(style, "padding");
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    width = Math.max(0, width - margins.width);
    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
    if (width && !height) {
      height = round1(width / 2);
    }
    const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
      height = containerSize.height;
      width = round1(Math.floor(height * aspectRatio));
    }
    return {
      width,
      height
    };
  }
  function retinaScale(chart, forceRatio, forceStyle) {
    const pixelRatio = forceRatio || 1;
    const deviceHeight = Math.floor(chart.height * pixelRatio);
    const deviceWidth = Math.floor(chart.width * pixelRatio);
    chart.height = Math.floor(chart.height);
    chart.width = Math.floor(chart.width);
    const canvas = chart.canvas;
    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
      canvas.style.height = `${chart.height}px`;
      canvas.style.width = `${chart.width}px`;
    }
    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
      chart.currentDevicePixelRatio = pixelRatio;
      canvas.height = deviceHeight;
      canvas.width = deviceWidth;
      chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      return true;
    }
    return false;
  }
  var supportsEventListenerOptions = function() {
    let passiveSupported = false;
    try {
      const options = {
        get passive() {
          passiveSupported = true;
          return false;
        }
      };
      if (_isDomSupported()) {
        window.addEventListener("test", null, options);
        window.removeEventListener("test", null, options);
      }
    } catch (e) {
    }
    return passiveSupported;
  }();
  function readUsedSize(element, property) {
    const value = getStyle(element, property);
    const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches ? +matches[1] : void 0;
  }
  function _pointInLine(p1, p2, t, mode) {
    return {
      x: p1.x + t * (p2.x - p1.x),
      y: p1.y + t * (p2.y - p1.y)
    };
  }
  function _steppedInterpolation(p1, p2, t, mode) {
    return {
      x: p1.x + t * (p2.x - p1.x),
      y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
    };
  }
  function _bezierInterpolation(p1, p2, t, mode) {
    const cp1 = {
      x: p1.cp2x,
      y: p1.cp2y
    };
    const cp2 = {
      x: p2.cp1x,
      y: p2.cp1y
    };
    const a = _pointInLine(p1, cp1, t);
    const b = _pointInLine(cp1, cp2, t);
    const c = _pointInLine(cp2, p2, t);
    const d = _pointInLine(a, b, t);
    const e = _pointInLine(b, c, t);
    return _pointInLine(d, e, t);
  }
  var getRightToLeftAdapter = function(rectX, width) {
    return {
      x(x) {
        return rectX + rectX + width - x;
      },
      setWidth(w) {
        width = w;
      },
      textAlign(align) {
        if (align === "center") {
          return align;
        }
        return align === "right" ? "left" : "right";
      },
      xPlus(x, value) {
        return x - value;
      },
      leftForLtr(x, itemWidth) {
        return x - itemWidth;
      }
    };
  };
  var getLeftToRightAdapter = function() {
    return {
      x(x) {
        return x;
      },
      setWidth(w) {
      },
      textAlign(align) {
        return align;
      },
      xPlus(x, value) {
        return x + value;
      },
      leftForLtr(x, _itemWidth) {
        return x;
      }
    };
  };
  function getRtlAdapter(rtl, rectX, width) {
    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
  }
  function overrideTextDirection(ctx, direction) {
    let style, original;
    if (direction === "ltr" || direction === "rtl") {
      style = ctx.canvas.style;
      original = [
        style.getPropertyValue("direction"),
        style.getPropertyPriority("direction")
      ];
      style.setProperty("direction", direction, "important");
      ctx.prevTextDirection = original;
    }
  }
  function restoreTextDirection(ctx, original) {
    if (original !== void 0) {
      delete ctx.prevTextDirection;
      ctx.canvas.style.setProperty("direction", original[0], original[1]);
    }
  }
  function propertyFn(property) {
    if (property === "angle") {
      return {
        between: _angleBetween,
        compare: _angleDiff,
        normalize: _normalizeAngle
      };
    }
    return {
      between: _isBetween,
      compare: (a, b) => a - b,
      normalize: (x) => x
    };
  }
  function normalizeSegment({ start, end, count, loop, style }) {
    return {
      start: start % count,
      end: end % count,
      loop: loop && (end - start + 1) % count === 0,
      style
    };
  }
  function getSegment(segment, points, bounds) {
    const { property, start: startBound, end: endBound } = bounds;
    const { between, normalize } = propertyFn(property);
    const count = points.length;
    let { start, end, loop } = segment;
    let i, ilen;
    if (loop) {
      start += count;
      end += count;
      for (i = 0, ilen = count; i < ilen; ++i) {
        if (!between(normalize(points[start % count][property]), startBound, endBound)) {
          break;
        }
        start--;
        end--;
      }
      start %= count;
      end %= count;
    }
    if (end < start) {
      end += count;
    }
    return {
      start,
      end,
      loop,
      style: segment.style
    };
  }
  function _boundSegment(segment, points, bounds) {
    if (!bounds) {
      return [
        segment
      ];
    }
    const { property, start: startBound, end: endBound } = bounds;
    const count = points.length;
    const { compare, between, normalize } = propertyFn(property);
    const { start, end, loop, style } = getSegment(segment, points, bounds);
    const result = [];
    let inside = false;
    let subStart = null;
    let value, point, prevValue;
    const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
    const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
    const shouldStart = () => inside || startIsBefore();
    const shouldStop = () => !inside || endIsBefore();
    for (let i = start, prev = start; i <= end; ++i) {
      point = points[i % count];
      if (point.skip) {
        continue;
      }
      value = normalize(point[property]);
      if (value === prevValue) {
        continue;
      }
      inside = between(value, startBound, endBound);
      if (subStart === null && shouldStart()) {
        subStart = compare(value, startBound) === 0 ? i : prev;
      }
      if (subStart !== null && shouldStop()) {
        result.push(normalizeSegment({
          start: subStart,
          end: i,
          loop,
          count,
          style
        }));
        subStart = null;
      }
      prev = i;
      prevValue = value;
    }
    if (subStart !== null) {
      result.push(normalizeSegment({
        start: subStart,
        end,
        loop,
        count,
        style
      }));
    }
    return result;
  }
  function _boundSegments(line, bounds) {
    const result = [];
    const segments = line.segments;
    for (let i = 0; i < segments.length; i++) {
      const sub = _boundSegment(segments[i], line.points, bounds);
      if (sub.length) {
        result.push(...sub);
      }
    }
    return result;
  }
  function findStartAndEnd(points, count, loop, spanGaps) {
    let start = 0;
    let end = count - 1;
    if (loop && !spanGaps) {
      while (start < count && !points[start].skip) {
        start++;
      }
    }
    while (start < count && points[start].skip) {
      start++;
    }
    start %= count;
    if (loop) {
      end += start;
    }
    while (end > start && points[end % count].skip) {
      end--;
    }
    end %= count;
    return {
      start,
      end
    };
  }
  function solidSegments(points, start, max, loop) {
    const count = points.length;
    const result = [];
    let last = start;
    let prev = points[start];
    let end;
    for (end = start + 1; end <= max; ++end) {
      const cur = points[end % count];
      if (cur.skip || cur.stop) {
        if (!prev.skip) {
          loop = false;
          result.push({
            start: start % count,
            end: (end - 1) % count,
            loop
          });
          start = last = cur.stop ? end : null;
        }
      } else {
        last = end;
        if (prev.skip) {
          start = end;
        }
      }
      prev = cur;
    }
    if (last !== null) {
      result.push({
        start: start % count,
        end: last % count,
        loop
      });
    }
    return result;
  }
  function _computeSegments(line, segmentOptions) {
    const points = line.points;
    const spanGaps = line.options.spanGaps;
    const count = points.length;
    if (!count) {
      return [];
    }
    const loop = !!line._loop;
    const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
    if (spanGaps === true) {
      return splitByStyles(line, [
        {
          start,
          end,
          loop
        }
      ], points, segmentOptions);
    }
    const max = end < start ? end + count : end;
    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
  }
  function splitByStyles(line, segments, points, segmentOptions) {
    if (!segmentOptions || !segmentOptions.setContext || !points) {
      return segments;
    }
    return doSplitByStyles(line, segments, points, segmentOptions);
  }
  function doSplitByStyles(line, segments, points, segmentOptions) {
    const chartContext = line._chart.getContext();
    const baseStyle = readStyle(line.options);
    const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
    const count = points.length;
    const result = [];
    let prevStyle = baseStyle;
    let start = segments[0].start;
    let i = start;
    function addStyle(s, e, l, st) {
      const dir = spanGaps ? -1 : 1;
      if (s === e) {
        return;
      }
      s += count;
      while (points[s % count].skip) {
        s -= dir;
      }
      while (points[e % count].skip) {
        e += dir;
      }
      if (s % count !== e % count) {
        result.push({
          start: s % count,
          end: e % count,
          loop: l,
          style: st
        });
        prevStyle = st;
        start = e % count;
      }
    }
    for (const segment of segments) {
      start = spanGaps ? start : segment.start;
      let prev = points[start % count];
      let style;
      for (i = start + 1; i <= segment.end; i++) {
        const pt = points[i % count];
        style = readStyle(segmentOptions.setContext(createContext(chartContext, {
          type: "segment",
          p0: prev,
          p1: pt,
          p0DataIndex: (i - 1) % count,
          p1DataIndex: i % count,
          datasetIndex
        })));
        if (styleChanged(style, prevStyle)) {
          addStyle(start, i - 1, segment.loop, prevStyle);
        }
        prev = pt;
        prevStyle = style;
      }
      if (start < i - 1) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
    }
    return result;
  }
  function readStyle(options) {
    return {
      backgroundColor: options.backgroundColor,
      borderCapStyle: options.borderCapStyle,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderJoinStyle: options.borderJoinStyle,
      borderWidth: options.borderWidth,
      borderColor: options.borderColor
    };
  }
  function styleChanged(style, prevStyle) {
    if (!prevStyle) {
      return false;
    }
    const cache = [];
    const replacer = function(key, value) {
      if (!isPatternOrGradient(value)) {
        return value;
      }
      if (!cache.includes(value)) {
        cache.push(value);
      }
      return cache.indexOf(value);
    };
    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
  }

  // node_modules/chart.js/dist/chart.js
  var Animator = class {
    constructor() {
      this._request = null;
      this._charts = /* @__PURE__ */ new Map();
      this._running = false;
      this._lastDate = void 0;
    }
    _notify(chart, anims, date, type) {
      const callbacks = anims.listeners[type];
      const numSteps = anims.duration;
      callbacks.forEach((fn) => fn({
        chart,
        initial: anims.initial,
        numSteps,
        currentStep: Math.min(date - anims.start, numSteps)
      }));
    }
    _refresh() {
      if (this._request) {
        return;
      }
      this._running = true;
      this._request = requestAnimFrame.call(window, () => {
        this._update();
        this._request = null;
        if (this._running) {
          this._refresh();
        }
      });
    }
    _update(date = Date.now()) {
      let remaining = 0;
      this._charts.forEach((anims, chart) => {
        if (!anims.running || !anims.items.length) {
          return;
        }
        const items = anims.items;
        let i = items.length - 1;
        let draw2 = false;
        let item;
        for (; i >= 0; --i) {
          item = items[i];
          if (item._active) {
            if (item._total > anims.duration) {
              anims.duration = item._total;
            }
            item.tick(date);
            draw2 = true;
          } else {
            items[i] = items[items.length - 1];
            items.pop();
          }
        }
        if (draw2) {
          chart.draw();
          this._notify(chart, anims, date, "progress");
        }
        if (!items.length) {
          anims.running = false;
          this._notify(chart, anims, date, "complete");
          anims.initial = false;
        }
        remaining += items.length;
      });
      this._lastDate = date;
      if (remaining === 0) {
        this._running = false;
      }
    }
    _getAnims(chart) {
      const charts = this._charts;
      let anims = charts.get(chart);
      if (!anims) {
        anims = {
          running: false,
          initial: true,
          items: [],
          listeners: {
            complete: [],
            progress: []
          }
        };
        charts.set(chart, anims);
      }
      return anims;
    }
    listen(chart, event, cb) {
      this._getAnims(chart).listeners[event].push(cb);
    }
    add(chart, items) {
      if (!items || !items.length) {
        return;
      }
      this._getAnims(chart).items.push(...items);
    }
    has(chart) {
      return this._getAnims(chart).items.length > 0;
    }
    start(chart) {
      const anims = this._charts.get(chart);
      if (!anims) {
        return;
      }
      anims.running = true;
      anims.start = Date.now();
      anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
      this._refresh();
    }
    running(chart) {
      if (!this._running) {
        return false;
      }
      const anims = this._charts.get(chart);
      if (!anims || !anims.running || !anims.items.length) {
        return false;
      }
      return true;
    }
    stop(chart) {
      const anims = this._charts.get(chart);
      if (!anims || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      for (; i >= 0; --i) {
        items[i].cancel();
      }
      anims.items = [];
      this._notify(chart, anims, Date.now(), "complete");
    }
    remove(chart) {
      return this._charts.delete(chart);
    }
  };
  var animator = /* @__PURE__ */ new Animator();
  var transparent = "transparent";
  var interpolators = {
    boolean(from2, to2, factor) {
      return factor > 0.5 ? to2 : from2;
    },
    color(from2, to2, factor) {
      const c0 = color(from2 || transparent);
      const c1 = c0.valid && color(to2 || transparent);
      return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
    },
    number(from2, to2, factor) {
      return from2 + (to2 - from2) * factor;
    }
  };
  var Animation = class {
    constructor(cfg, target, prop, to2) {
      const currentValue = target[prop];
      to2 = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      const from2 = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
      this._active = true;
      this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
      this._easing = effects[cfg.easing] || effects.linear;
      this._start = Math.floor(Date.now() + (cfg.delay || 0));
      this._duration = this._total = Math.floor(cfg.duration);
      this._loop = !!cfg.loop;
      this._target = target;
      this._prop = prop;
      this._from = from2;
      this._to = to2;
      this._promises = void 0;
    }
    active() {
      return this._active;
    }
    update(cfg, to2, date) {
      if (this._active) {
        this._notify(false);
        const currentValue = this._target[this._prop];
        const elapsed = date - this._start;
        const remain = this._duration - elapsed;
        this._start = date;
        this._duration = Math.floor(Math.max(remain, cfg.duration));
        this._total += elapsed;
        this._loop = !!cfg.loop;
        this._to = resolve([
          cfg.to,
          to2,
          currentValue,
          cfg.from
        ]);
        this._from = resolve([
          cfg.from,
          currentValue,
          to2
        ]);
      }
    }
    cancel() {
      if (this._active) {
        this.tick(Date.now());
        this._active = false;
        this._notify(false);
      }
    }
    tick(date) {
      const elapsed = date - this._start;
      const duration = this._duration;
      const prop = this._prop;
      const from2 = this._from;
      const loop = this._loop;
      const to2 = this._to;
      let factor;
      this._active = from2 !== to2 && (loop || elapsed < duration);
      if (!this._active) {
        this._target[prop] = to2;
        this._notify(true);
        return;
      }
      if (elapsed < 0) {
        this._target[prop] = from2;
        return;
      }
      factor = elapsed / duration % 2;
      factor = loop && factor > 1 ? 2 - factor : factor;
      factor = this._easing(Math.min(1, Math.max(0, factor)));
      this._target[prop] = this._fn(from2, to2, factor);
    }
    wait() {
      const promises = this._promises || (this._promises = []);
      return new Promise((res, rej) => {
        promises.push({
          res,
          rej
        });
      });
    }
    _notify(resolved) {
      const method = resolved ? "res" : "rej";
      const promises = this._promises || [];
      for (let i = 0; i < promises.length; i++) {
        promises[i][method]();
      }
    }
  };
  var Animations = class {
    constructor(chart, config) {
      this._chart = chart;
      this._properties = /* @__PURE__ */ new Map();
      this.configure(config);
    }
    configure(config) {
      if (!isObject2(config)) {
        return;
      }
      const animationOptions = Object.keys(defaults.animation);
      const animatedProps = this._properties;
      Object.getOwnPropertyNames(config).forEach((key) => {
        const cfg = config[key];
        if (!isObject2(cfg)) {
          return;
        }
        const resolved = {};
        for (const option of animationOptions) {
          resolved[option] = cfg[option];
        }
        (isArray(cfg.properties) && cfg.properties || [
          key
        ]).forEach((prop) => {
          if (prop === key || !animatedProps.has(prop)) {
            animatedProps.set(prop, resolved);
          }
        });
      });
    }
    _animateOptions(target, values) {
      const newOptions = values.options;
      const options = resolveTargetOptions(target, newOptions);
      if (!options) {
        return [];
      }
      const animations = this._createAnimations(options, newOptions);
      if (newOptions.$shared) {
        awaitAll(target.options.$animations, newOptions).then(() => {
          target.options = newOptions;
        }, () => {
        });
      }
      return animations;
    }
    _createAnimations(target, values) {
      const animatedProps = this._properties;
      const animations = [];
      const running = target.$animations || (target.$animations = {});
      const props = Object.keys(values);
      const date = Date.now();
      let i;
      for (i = props.length - 1; i >= 0; --i) {
        const prop = props[i];
        if (prop.charAt(0) === "$") {
          continue;
        }
        if (prop === "options") {
          animations.push(...this._animateOptions(target, values));
          continue;
        }
        const value = values[prop];
        let animation = running[prop];
        const cfg = animatedProps.get(prop);
        if (animation) {
          if (cfg && animation.active()) {
            animation.update(cfg, value, date);
            continue;
          } else {
            animation.cancel();
          }
        }
        if (!cfg || !cfg.duration) {
          target[prop] = value;
          continue;
        }
        running[prop] = animation = new Animation(cfg, target, prop, value);
        animations.push(animation);
      }
      return animations;
    }
    update(target, values) {
      if (this._properties.size === 0) {
        Object.assign(target, values);
        return;
      }
      const animations = this._createAnimations(target, values);
      if (animations.length) {
        animator.add(this._chart, animations);
        return true;
      }
    }
  };
  function awaitAll(animations, properties) {
    const running = [];
    const keys = Object.keys(properties);
    for (let i = 0; i < keys.length; i++) {
      const anim = animations[keys[i]];
      if (anim && anim.active()) {
        running.push(anim.wait());
      }
    }
    return Promise.all(running);
  }
  function resolveTargetOptions(target, newOptions) {
    if (!newOptions) {
      return;
    }
    let options = target.options;
    if (!options) {
      target.options = newOptions;
      return;
    }
    if (options.$shared) {
      target.options = options = Object.assign({}, options, {
        $shared: false,
        $animations: {}
      });
    }
    return options;
  }
  function scaleClip(scale, allowedOverflow) {
    const opts = scale && scale.options || {};
    const reverse = opts.reverse;
    const min = opts.min === void 0 ? allowedOverflow : 0;
    const max = opts.max === void 0 ? allowedOverflow : 0;
    return {
      start: reverse ? max : min,
      end: reverse ? min : max
    };
  }
  function defaultClip(xScale, yScale, allowedOverflow) {
    if (allowedOverflow === false) {
      return false;
    }
    const x = scaleClip(xScale, allowedOverflow);
    const y = scaleClip(yScale, allowedOverflow);
    return {
      top: y.end,
      right: x.end,
      bottom: y.start,
      left: x.start
    };
  }
  function toClip(value) {
    let t, r, b, l;
    if (isObject2(value)) {
      t = value.top;
      r = value.right;
      b = value.bottom;
      l = value.left;
    } else {
      t = r = b = l = value;
    }
    return {
      top: t,
      right: r,
      bottom: b,
      left: l,
      disabled: value === false
    };
  }
  function getSortedDatasetIndices(chart, filterVisible) {
    const keys = [];
    const metasets = chart._getSortedDatasetMetas(filterVisible);
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      keys.push(metasets[i].index);
    }
    return keys;
  }
  function applyStack(stack, value, dsIndex, options = {}) {
    const keys = stack.keys;
    const singleMode = options.mode === "single";
    let i, ilen, datasetIndex, otherValue;
    if (value === null) {
      return;
    }
    for (i = 0, ilen = keys.length; i < ilen; ++i) {
      datasetIndex = +keys[i];
      if (datasetIndex === dsIndex) {
        if (options.all) {
          continue;
        }
        break;
      }
      otherValue = stack.values[datasetIndex];
      if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
        value += otherValue;
      }
    }
    return value;
  }
  function convertObjectDataToArray(data) {
    const keys = Object.keys(data);
    const adata = new Array(keys.length);
    let i, ilen, key;
    for (i = 0, ilen = keys.length; i < ilen; ++i) {
      key = keys[i];
      adata[i] = {
        x: key,
        y: data[key]
      };
    }
    return adata;
  }
  function isStacked(scale, meta) {
    const stacked = scale && scale.options.stacked;
    return stacked || stacked === void 0 && meta.stack !== void 0;
  }
  function getStackKey(indexScale, valueScale, meta) {
    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
  }
  function getUserBounds(scale) {
    const { min, max, minDefined, maxDefined } = scale.getUserBounds();
    return {
      min: minDefined ? min : Number.NEGATIVE_INFINITY,
      max: maxDefined ? max : Number.POSITIVE_INFINITY
    };
  }
  function getOrCreateStack(stacks, stackKey, indexValue) {
    const subStack = stacks[stackKey] || (stacks[stackKey] = {});
    return subStack[indexValue] || (subStack[indexValue] = {});
  }
  function getLastIndexInStack(stack, vScale, positive, type) {
    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
      const value = stack[meta.index];
      if (positive && value > 0 || !positive && value < 0) {
        return meta.index;
      }
    }
    return null;
  }
  function updateStacks(controller, parsed) {
    const { chart, _cachedMeta: meta } = controller;
    const stacks = chart._stacks || (chart._stacks = {});
    const { iScale, vScale, index: datasetIndex } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const key = getStackKey(iScale, vScale, meta);
    const ilen = parsed.length;
    let stack;
    for (let i = 0; i < ilen; ++i) {
      const item = parsed[i];
      const { [iAxis]: index2, [vAxis]: value } = item;
      const itemStacks = item._stacks || (item._stacks = {});
      stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
      stack[datasetIndex] = value;
      stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
      stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
      const visualValues = stack._visualValues || (stack._visualValues = {});
      visualValues[datasetIndex] = value;
    }
  }
  function getFirstScaleId(chart, axis) {
    const scales2 = chart.scales;
    return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
  }
  function createDatasetContext(parent, index2) {
    return createContext(parent, {
      active: false,
      dataset: void 0,
      datasetIndex: index2,
      index: index2,
      mode: "default",
      type: "dataset"
    });
  }
  function createDataContext(parent, index2, element) {
    return createContext(parent, {
      active: false,
      dataIndex: index2,
      parsed: void 0,
      raw: void 0,
      element,
      index: index2,
      mode: "default",
      type: "data"
    });
  }
  function clearStacks(meta, items) {
    const datasetIndex = meta.controller.index;
    const axis = meta.vScale && meta.vScale.axis;
    if (!axis) {
      return;
    }
    items = items || meta._parsed;
    for (const parsed of items) {
      const stacks = parsed._stacks;
      if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
        return;
      }
      delete stacks[axis][datasetIndex];
      if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
        delete stacks[axis]._visualValues[datasetIndex];
      }
    }
  }
  var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
  var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
  var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
    keys: getSortedDatasetIndices(chart, true),
    values: null
  };
  var DatasetController = class {
    constructor(chart, datasetIndex) {
      this.chart = chart;
      this._ctx = chart.ctx;
      this.index = datasetIndex;
      this._cachedDataOpts = {};
      this._cachedMeta = this.getMeta();
      this._type = this._cachedMeta.type;
      this.options = void 0;
      this._parsing = false;
      this._data = void 0;
      this._objectData = void 0;
      this._sharedOptions = void 0;
      this._drawStart = void 0;
      this._drawCount = void 0;
      this.enableOptionSharing = false;
      this.supportsDecimation = false;
      this.$context = void 0;
      this._syncList = [];
      this.datasetElementType = new.target.datasetElementType;
      this.dataElementType = new.target.dataElementType;
      this.initialize();
    }
    initialize() {
      const meta = this._cachedMeta;
      this.configure();
      this.linkScales();
      meta._stacked = isStacked(meta.vScale, meta);
      this.addElements();
      if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
        console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
      }
    }
    updateIndex(datasetIndex) {
      if (this.index !== datasetIndex) {
        clearStacks(this._cachedMeta);
      }
      this.index = datasetIndex;
    }
    linkScales() {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
      const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
      const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
      const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
      const indexAxis = meta.indexAxis;
      const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
      const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
      meta.xScale = this.getScaleForId(xid);
      meta.yScale = this.getScaleForId(yid);
      meta.rScale = this.getScaleForId(rid);
      meta.iScale = this.getScaleForId(iid);
      meta.vScale = this.getScaleForId(vid);
    }
    getDataset() {
      return this.chart.data.datasets[this.index];
    }
    getMeta() {
      return this.chart.getDatasetMeta(this.index);
    }
    getScaleForId(scaleID) {
      return this.chart.scales[scaleID];
    }
    _getOtherScale(scale) {
      const meta = this._cachedMeta;
      return scale === meta.iScale ? meta.vScale : meta.iScale;
    }
    reset() {
      this._update("reset");
    }
    _destroy() {
      const meta = this._cachedMeta;
      if (this._data) {
        unlistenArrayEvents(this._data, this);
      }
      if (meta._stacked) {
        clearStacks(meta);
      }
    }
    _dataCheck() {
      const dataset = this.getDataset();
      const data = dataset.data || (dataset.data = []);
      const _data = this._data;
      if (isObject2(data)) {
        this._data = convertObjectDataToArray(data);
      } else if (_data !== data) {
        if (_data) {
          unlistenArrayEvents(_data, this);
          const meta = this._cachedMeta;
          clearStacks(meta);
          meta._parsed = [];
        }
        if (data && Object.isExtensible(data)) {
          listenArrayEvents(data, this);
        }
        this._syncList = [];
        this._data = data;
      }
    }
    addElements() {
      const meta = this._cachedMeta;
      this._dataCheck();
      if (this.datasetElementType) {
        meta.dataset = new this.datasetElementType();
      }
    }
    buildOrUpdateElements(resetNewElements) {
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      let stackChanged = false;
      this._dataCheck();
      const oldStacked = meta._stacked;
      meta._stacked = isStacked(meta.vScale, meta);
      if (meta.stack !== dataset.stack) {
        stackChanged = true;
        clearStacks(meta);
        meta.stack = dataset.stack;
      }
      this._resyncElements(resetNewElements);
      if (stackChanged || oldStacked !== meta._stacked) {
        updateStacks(this, meta._parsed);
      }
    }
    configure() {
      const config = this.chart.config;
      const scopeKeys = config.datasetScopeKeys(this._type);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
      this.options = config.createResolver(scopes, this.getContext());
      this._parsing = this.options.parsing;
      this._cachedDataOpts = {};
    }
    parse(start, count) {
      const { _cachedMeta: meta, _data: data } = this;
      const { iScale, _stacked } = meta;
      const iAxis = iScale.axis;
      let sorted = start === 0 && count === data.length ? true : meta._sorted;
      let prev = start > 0 && meta._parsed[start - 1];
      let i, cur, parsed;
      if (this._parsing === false) {
        meta._parsed = data;
        meta._sorted = true;
        parsed = data;
      } else {
        if (isArray(data[start])) {
          parsed = this.parseArrayData(meta, data, start, count);
        } else if (isObject2(data[start])) {
          parsed = this.parseObjectData(meta, data, start, count);
        } else {
          parsed = this.parsePrimitiveData(meta, data, start, count);
        }
        const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
        for (i = 0; i < count; ++i) {
          meta._parsed[i + start] = cur = parsed[i];
          if (sorted) {
            if (isNotInOrderComparedToPrev()) {
              sorted = false;
            }
            prev = cur;
          }
        }
        meta._sorted = sorted;
      }
      if (_stacked) {
        updateStacks(this, parsed);
      }
    }
    parsePrimitiveData(meta, data, start, count) {
      const { iScale, vScale } = meta;
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const labels = iScale.getLabels();
      const singleScale = iScale === vScale;
      const parsed = new Array(count);
      let i, ilen, index2;
      for (i = 0, ilen = count; i < ilen; ++i) {
        index2 = i + start;
        parsed[i] = {
          [iAxis]: singleScale || iScale.parse(labels[index2], index2),
          [vAxis]: vScale.parse(data[index2], index2)
        };
      }
      return parsed;
    }
    parseArrayData(meta, data, start, count) {
      const { xScale, yScale } = meta;
      const parsed = new Array(count);
      let i, ilen, index2, item;
      for (i = 0, ilen = count; i < ilen; ++i) {
        index2 = i + start;
        item = data[index2];
        parsed[i] = {
          x: xScale.parse(item[0], index2),
          y: yScale.parse(item[1], index2)
        };
      }
      return parsed;
    }
    parseObjectData(meta, data, start, count) {
      const { xScale, yScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const parsed = new Array(count);
      let i, ilen, index2, item;
      for (i = 0, ilen = count; i < ilen; ++i) {
        index2 = i + start;
        item = data[index2];
        parsed[i] = {
          x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
          y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
        };
      }
      return parsed;
    }
    getParsed(index2) {
      return this._cachedMeta._parsed[index2];
    }
    getDataElement(index2) {
      return this._cachedMeta.data[index2];
    }
    applyStack(scale, parsed, mode) {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const value = parsed[scale.axis];
      const stack = {
        keys: getSortedDatasetIndices(chart, true),
        values: parsed._stacks[scale.axis]._visualValues
      };
      return applyStack(stack, value, meta.index, {
        mode
      });
    }
    updateRangeFromParsed(range2, scale, parsed, stack) {
      const parsedValue = parsed[scale.axis];
      let value = parsedValue === null ? NaN : parsedValue;
      const values = stack && parsed._stacks[scale.axis];
      if (stack && values) {
        stack.values = values;
        value = applyStack(stack, parsedValue, this._cachedMeta.index);
      }
      range2.min = Math.min(range2.min, value);
      range2.max = Math.max(range2.max, value);
    }
    getMinMax(scale, canStack) {
      const meta = this._cachedMeta;
      const _parsed = meta._parsed;
      const sorted = meta._sorted && scale === meta.iScale;
      const ilen = _parsed.length;
      const otherScale = this._getOtherScale(scale);
      const stack = createStack(canStack, meta, this.chart);
      const range2 = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      };
      const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
      let i, parsed;
      function _skip() {
        parsed = _parsed[i];
        const otherValue = parsed[otherScale.axis];
        return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
      }
      for (i = 0; i < ilen; ++i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range2, scale, parsed, stack);
        if (sorted) {
          break;
        }
      }
      if (sorted) {
        for (i = ilen - 1; i >= 0; --i) {
          if (_skip()) {
            continue;
          }
          this.updateRangeFromParsed(range2, scale, parsed, stack);
          break;
        }
      }
      return range2;
    }
    getAllParsedValues(scale) {
      const parsed = this._cachedMeta._parsed;
      const values = [];
      let i, ilen, value;
      for (i = 0, ilen = parsed.length; i < ilen; ++i) {
        value = parsed[i][scale.axis];
        if (isNumberFinite(value)) {
          values.push(value);
        }
      }
      return values;
    }
    getMaxOverflow() {
      return false;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const vScale = meta.vScale;
      const parsed = this.getParsed(index2);
      return {
        label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
        value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
      };
    }
    _update(mode) {
      const meta = this._cachedMeta;
      this.update(mode || "default");
      meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
    }
    update(mode) {
    }
    draw() {
      const ctx = this._ctx;
      const chart = this.chart;
      const meta = this._cachedMeta;
      const elements2 = meta.data || [];
      const area = chart.chartArea;
      const active = [];
      const start = this._drawStart || 0;
      const count = this._drawCount || elements2.length - start;
      const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
      let i;
      if (meta.dataset) {
        meta.dataset.draw(ctx, area, start, count);
      }
      for (i = start; i < start + count; ++i) {
        const element = elements2[i];
        if (element.hidden) {
          continue;
        }
        if (element.active && drawActiveElementsOnTop) {
          active.push(element);
        } else {
          element.draw(ctx, area);
        }
      }
      for (i = 0; i < active.length; ++i) {
        active[i].draw(ctx, area);
      }
    }
    getStyle(index2, active) {
      const mode = active ? "active" : "default";
      return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
    }
    getContext(index2, active, mode) {
      const dataset = this.getDataset();
      let context;
      if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
        const element = this._cachedMeta.data[index2];
        context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
        context.parsed = this.getParsed(index2);
        context.raw = dataset.data[index2];
        context.index = context.dataIndex = index2;
      } else {
        context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
        context.dataset = dataset;
        context.index = context.datasetIndex = this.index;
      }
      context.active = !!active;
      context.mode = mode;
      return context;
    }
    resolveDatasetElementOptions(mode) {
      return this._resolveElementOptions(this.datasetElementType.id, mode);
    }
    resolveDataElementOptions(index2, mode) {
      return this._resolveElementOptions(this.dataElementType.id, mode, index2);
    }
    _resolveElementOptions(elementType, mode = "default", index2) {
      const active = mode === "active";
      const cache = this._cachedDataOpts;
      const cacheKey = elementType + "-" + mode;
      const cached = cache[cacheKey];
      const sharing = this.enableOptionSharing && defined(index2);
      if (cached) {
        return cloneIfNotShared(cached, sharing);
      }
      const config = this.chart.config;
      const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
      const prefixes = active ? [
        `${elementType}Hover`,
        "hover",
        elementType,
        ""
      ] : [
        elementType,
        ""
      ];
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      const names2 = Object.keys(defaults.elements[elementType]);
      const context = () => this.getContext(index2, active, mode);
      const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
      if (values.$shared) {
        values.$shared = sharing;
        cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
      }
      return values;
    }
    _resolveAnimations(index2, transition, active) {
      const chart = this.chart;
      const cache = this._cachedDataOpts;
      const cacheKey = `animation-${transition}`;
      const cached = cache[cacheKey];
      if (cached) {
        return cached;
      }
      let options;
      if (chart.options.animation !== false) {
        const config = this.chart.config;
        const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
        options = config.createResolver(scopes, this.getContext(index2, active, transition));
      }
      const animations = new Animations(chart, options && options.animations);
      if (options && options._cacheable) {
        cache[cacheKey] = Object.freeze(animations);
      }
      return animations;
    }
    getSharedOptions(options) {
      if (!options.$shared) {
        return;
      }
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
    }
    includeOptions(mode, sharedOptions) {
      return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
    }
    _getSharedOptions(start, mode) {
      const firstOpts = this.resolveDataElementOptions(start, mode);
      const previouslySharedOptions = this._sharedOptions;
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
      return {
        sharedOptions,
        includeOptions
      };
    }
    updateElement(element, index2, properties, mode) {
      if (isDirectUpdateMode(mode)) {
        Object.assign(element, properties);
      } else {
        this._resolveAnimations(index2, mode).update(element, properties);
      }
    }
    updateSharedOptions(sharedOptions, mode, newOptions) {
      if (sharedOptions && !isDirectUpdateMode(mode)) {
        this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
      }
    }
    _setStyle(element, index2, mode, active) {
      element.active = active;
      const options = this.getStyle(index2, active);
      this._resolveAnimations(index2, mode, active).update(element, {
        options: !active && this.getSharedOptions(options) || options
      });
    }
    removeHoverStyle(element, datasetIndex, index2) {
      this._setStyle(element, index2, "active", false);
    }
    setHoverStyle(element, datasetIndex, index2) {
      this._setStyle(element, index2, "active", true);
    }
    _removeDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", false);
      }
    }
    _setDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", true);
      }
    }
    _resyncElements(resetNewElements) {
      const data = this._data;
      const elements2 = this._cachedMeta.data;
      for (const [method, arg1, arg2] of this._syncList) {
        this[method](arg1, arg2);
      }
      this._syncList = [];
      const numMeta = elements2.length;
      const numData = data.length;
      const count = Math.min(numData, numMeta);
      if (count) {
        this.parse(0, count);
      }
      if (numData > numMeta) {
        this._insertElements(numMeta, numData - numMeta, resetNewElements);
      } else if (numData < numMeta) {
        this._removeElements(numData, numMeta - numData);
      }
    }
    _insertElements(start, count, resetNewElements = true) {
      const meta = this._cachedMeta;
      const data = meta.data;
      const end = start + count;
      let i;
      const move = (arr) => {
        arr.length += count;
        for (i = arr.length - 1; i >= end; i--) {
          arr[i] = arr[i - count];
        }
      };
      move(data);
      for (i = start; i < end; ++i) {
        data[i] = new this.dataElementType();
      }
      if (this._parsing) {
        move(meta._parsed);
      }
      this.parse(start, count);
      if (resetNewElements) {
        this.updateElements(data, start, count, "reset");
      }
    }
    updateElements(element, start, count, mode) {
    }
    _removeElements(start, count) {
      const meta = this._cachedMeta;
      if (this._parsing) {
        const removed = meta._parsed.splice(start, count);
        if (meta._stacked) {
          clearStacks(meta, removed);
        }
      }
      meta.data.splice(start, count);
    }
    _sync(args) {
      if (this._parsing) {
        this._syncList.push(args);
      } else {
        const [method, arg1, arg2] = args;
        this[method](arg1, arg2);
      }
      this.chart._dataChanges.push([
        this.index,
        ...args
      ]);
    }
    _onDataPush() {
      const count = arguments.length;
      this._sync([
        "_insertElements",
        this.getDataset().data.length - count,
        count
      ]);
    }
    _onDataPop() {
      this._sync([
        "_removeElements",
        this._cachedMeta.data.length - 1,
        1
      ]);
    }
    _onDataShift() {
      this._sync([
        "_removeElements",
        0,
        1
      ]);
    }
    _onDataSplice(start, count) {
      if (count) {
        this._sync([
          "_removeElements",
          start,
          count
        ]);
      }
      const newCount = arguments.length - 2;
      if (newCount) {
        this._sync([
          "_insertElements",
          start,
          newCount
        ]);
      }
    }
    _onDataUnshift() {
      this._sync([
        "_insertElements",
        0,
        arguments.length
      ]);
    }
  };
  __publicField(DatasetController, "defaults", {});
  __publicField(DatasetController, "datasetElementType", null);
  __publicField(DatasetController, "dataElementType", null);
  function getAllScaleValues(scale, type) {
    if (!scale._cache.$bar) {
      const visibleMetas = scale.getMatchingVisibleMetas(type);
      let values = [];
      for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
        values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
      }
      scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
    }
    return scale._cache.$bar;
  }
  function computeMinSampleSize(meta) {
    const scale = meta.iScale;
    const values = getAllScaleValues(scale, meta.type);
    let min = scale._length;
    let i, ilen, curr, prev;
    const updateMinAndPrev = () => {
      if (curr === 32767 || curr === -32768) {
        return;
      }
      if (defined(prev)) {
        min = Math.min(min, Math.abs(curr - prev) || min);
      }
      prev = curr;
    };
    for (i = 0, ilen = values.length; i < ilen; ++i) {
      curr = scale.getPixelForValue(values[i]);
      updateMinAndPrev();
    }
    prev = void 0;
    for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
      curr = scale.getPixelForTick(i);
      updateMinAndPrev();
    }
    return min;
  }
  function computeFitCategoryTraits(index2, ruler, options, stackCount) {
    const thickness = options.barThickness;
    let size, ratio;
    if (isNullOrUndef(thickness)) {
      size = ruler.min * options.categoryPercentage;
      ratio = options.barPercentage;
    } else {
      size = thickness * stackCount;
      ratio = 1;
    }
    return {
      chunk: size / stackCount,
      ratio,
      start: ruler.pixels[index2] - size / 2
    };
  }
  function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
    const pixels = ruler.pixels;
    const curr = pixels[index2];
    let prev = index2 > 0 ? pixels[index2 - 1] : null;
    let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
    const percent = options.categoryPercentage;
    if (prev === null) {
      prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
    }
    if (next === null) {
      next = curr + curr - prev;
    }
    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
    const size = Math.abs(next - prev) / 2 * percent;
    return {
      chunk: size / stackCount,
      ratio: options.barPercentage,
      start
    };
  }
  function parseFloatBar(entry, item, vScale, i) {
    const startValue = vScale.parse(entry[0], i);
    const endValue = vScale.parse(entry[1], i);
    const min = Math.min(startValue, endValue);
    const max = Math.max(startValue, endValue);
    let barStart = min;
    let barEnd = max;
    if (Math.abs(min) > Math.abs(max)) {
      barStart = max;
      barEnd = min;
    }
    item[vScale.axis] = barEnd;
    item._custom = {
      barStart,
      barEnd,
      start: startValue,
      end: endValue,
      min,
      max
    };
  }
  function parseValue(entry, item, vScale, i) {
    if (isArray(entry)) {
      parseFloatBar(entry, item, vScale, i);
    } else {
      item[vScale.axis] = vScale.parse(entry, i);
    }
    return item;
  }
  function parseArrayOrPrimitive(meta, data, start, count) {
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = [];
    let i, ilen, item, entry;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      entry = data[i];
      item = {};
      item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
      parsed.push(parseValue(entry, item, vScale, i));
    }
    return parsed;
  }
  function isFloatBar(custom) {
    return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
  }
  function barSign(size, vScale, actualBase) {
    if (size !== 0) {
      return sign(size);
    }
    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
  }
  function borderProps(properties) {
    let reverse, start, end, top2, bottom2;
    if (properties.horizontal) {
      reverse = properties.base > properties.x;
      start = "left";
      end = "right";
    } else {
      reverse = properties.base < properties.y;
      start = "bottom";
      end = "top";
    }
    if (reverse) {
      top2 = "end";
      bottom2 = "start";
    } else {
      top2 = "start";
      bottom2 = "end";
    }
    return {
      start,
      end,
      reverse,
      top: top2,
      bottom: bottom2
    };
  }
  function setBorderSkipped(properties, options, stack, index2) {
    let edge = options.borderSkipped;
    const res = {};
    if (!edge) {
      properties.borderSkipped = res;
      return;
    }
    if (edge === true) {
      properties.borderSkipped = {
        top: true,
        right: true,
        bottom: true,
        left: true
      };
      return;
    }
    const { start, end, reverse, top: top2, bottom: bottom2 } = borderProps(properties);
    if (edge === "middle" && stack) {
      properties.enableBorderRadius = true;
      if ((stack._top || 0) === index2) {
        edge = top2;
      } else if ((stack._bottom || 0) === index2) {
        edge = bottom2;
      } else {
        res[parseEdge(bottom2, start, end, reverse)] = true;
        edge = top2;
      }
    }
    res[parseEdge(edge, start, end, reverse)] = true;
    properties.borderSkipped = res;
  }
  function parseEdge(edge, a, b, reverse) {
    if (reverse) {
      edge = swap(edge, a, b);
      edge = startEnd(edge, b, a);
    } else {
      edge = startEnd(edge, a, b);
    }
    return edge;
  }
  function swap(orig, v1, v2) {
    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
  }
  function startEnd(v, start, end) {
    return v === "start" ? start : v === "end" ? end : v;
  }
  function setInflateAmount(properties, { inflateAmount }, ratio) {
    properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
  }
  var BarController = class extends DatasetController {
    parsePrimitiveData(meta, data, start, count) {
      return parseArrayOrPrimitive(meta, data, start, count);
    }
    parseArrayData(meta, data, start, count) {
      return parseArrayOrPrimitive(meta, data, start, count);
    }
    parseObjectData(meta, data, start, count) {
      const { iScale, vScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
      const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
      const parsed = [];
      let i, ilen, item, obj;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        obj = data[i];
        item = {};
        item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
        parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
      }
      return parsed;
    }
    updateRangeFromParsed(range2, scale, parsed, stack) {
      super.updateRangeFromParsed(range2, scale, parsed, stack);
      const custom = parsed._custom;
      if (custom && scale === this._cachedMeta.vScale) {
        range2.min = Math.min(range2.min, custom.min);
        range2.max = Math.max(range2.max, custom.max);
      }
    }
    getMaxOverflow() {
      return 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const { iScale, vScale } = meta;
      const parsed = this.getParsed(index2);
      const custom = parsed._custom;
      const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
      return {
        label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
        value
      };
    }
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
      const meta = this._cachedMeta;
      meta.stack = this.getDataset().stack;
    }
    update(mode) {
      const meta = this._cachedMeta;
      this.updateElements(meta.data, 0, meta.data.length, mode);
    }
    updateElements(bars, start, count, mode) {
      const reset = mode === "reset";
      const { index: index2, _cachedMeta: { vScale } } = this;
      const base = vScale.getBasePixel();
      const horizontal = vScale.isHorizontal();
      const ruler = this._getRuler();
      const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
      for (let i = start; i < start + count; i++) {
        const parsed = this.getParsed(i);
        const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
          base,
          head: base
        } : this._calculateBarValuePixels(i);
        const ipixels = this._calculateBarIndexPixels(i, ruler);
        const stack = (parsed._stacks || {})[vScale.axis];
        const properties = {
          horizontal,
          base: vpixels.base,
          enableBorderRadius: !stack || isFloatBar(parsed._custom) || index2 === stack._top || index2 === stack._bottom,
          x: horizontal ? vpixels.head : ipixels.center,
          y: horizontal ? ipixels.center : vpixels.head,
          height: horizontal ? ipixels.size : Math.abs(vpixels.size),
          width: horizontal ? Math.abs(vpixels.size) : ipixels.size
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
        }
        const options = properties.options || bars[i].options;
        setBorderSkipped(properties, options, stack, index2);
        setInflateAmount(properties, options, ruler.ratio);
        this.updateElement(bars[i], i, properties, mode);
      }
    }
    _getStacks(last, dataIndex) {
      const { iScale } = this._cachedMeta;
      const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
      const stacked = iScale.options.stacked;
      const stacks = [];
      const skipNull = (meta) => {
        const parsed = meta.controller.getParsed(dataIndex);
        const val = parsed && parsed[meta.vScale.axis];
        if (isNullOrUndef(val) || isNaN(val)) {
          return true;
        }
      };
      for (const meta of metasets) {
        if (dataIndex !== void 0 && skipNull(meta)) {
          continue;
        }
        if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
          stacks.push(meta.stack);
        }
        if (meta.index === last) {
          break;
        }
      }
      if (!stacks.length) {
        stacks.push(void 0);
      }
      return stacks;
    }
    _getStackCount(index2) {
      return this._getStacks(void 0, index2).length;
    }
    _getStackIndex(datasetIndex, name, dataIndex) {
      const stacks = this._getStacks(datasetIndex, dataIndex);
      const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
      return index2 === -1 ? stacks.length - 1 : index2;
    }
    _getRuler() {
      const opts = this.options;
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const pixels = [];
      let i, ilen;
      for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
        pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
      }
      const barThickness = opts.barThickness;
      const min = barThickness || computeMinSampleSize(meta);
      return {
        min,
        pixels,
        start: iScale._startPixel,
        end: iScale._endPixel,
        stackCount: this._getStackCount(),
        scale: iScale,
        grouped: opts.grouped,
        ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
      };
    }
    _calculateBarValuePixels(index2) {
      const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
      const actualBase = baseValue || 0;
      const parsed = this.getParsed(index2);
      const custom = parsed._custom;
      const floating = isFloatBar(custom);
      let value = parsed[vScale.axis];
      let start = 0;
      let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
      let head, size;
      if (length !== value) {
        start = length - value;
        length = value;
      }
      if (floating) {
        value = custom.barStart;
        length = custom.barEnd - custom.barStart;
        if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
          start = 0;
        }
        start += value;
      }
      const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
      let base = vScale.getPixelForValue(startValue);
      if (this.chart.getDataVisibility(index2)) {
        head = vScale.getPixelForValue(start + length);
      } else {
        head = base;
      }
      size = head - base;
      if (Math.abs(size) < minBarLength) {
        size = barSign(size, vScale, actualBase) * minBarLength;
        if (value === actualBase) {
          base -= size / 2;
        }
        const startPixel = vScale.getPixelForDecimal(0);
        const endPixel = vScale.getPixelForDecimal(1);
        const min = Math.min(startPixel, endPixel);
        const max = Math.max(startPixel, endPixel);
        base = Math.max(Math.min(base, max), min);
        head = base + size;
        if (_stacked && !floating) {
          parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
        }
      }
      if (base === vScale.getPixelForValue(actualBase)) {
        const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
        base += halfGrid;
        size -= halfGrid;
      }
      return {
        size,
        base,
        head,
        center: head + size / 2
      };
    }
    _calculateBarIndexPixels(index2, ruler) {
      const scale = ruler.scale;
      const options = this.options;
      const skipNull = options.skipNull;
      const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
      let center, size;
      if (ruler.grouped) {
        const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
        const range2 = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
        const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
        center = range2.start + range2.chunk * stackIndex + range2.chunk / 2;
        size = Math.min(maxBarThickness, range2.chunk * range2.ratio);
      } else {
        center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
        size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
      }
      return {
        base: center - size / 2,
        head: center + size / 2,
        center,
        size
      };
    }
    draw() {
      const meta = this._cachedMeta;
      const vScale = meta.vScale;
      const rects = meta.data;
      const ilen = rects.length;
      let i = 0;
      for (; i < ilen; ++i) {
        if (this.getParsed(i)[vScale.axis] !== null) {
          rects[i].draw(this._ctx);
        }
      }
    }
  };
  __publicField(BarController, "id", "bar");
  __publicField(BarController, "defaults", {
    datasetElementType: false,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: true,
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "base",
          "width",
          "height"
        ]
      }
    }
  });
  __publicField(BarController, "overrides", {
    scales: {
      _index_: {
        type: "category",
        offset: true,
        grid: {
          offset: true
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: true
      }
    }
  });
  var BubbleController = class extends DatasetController {
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
    }
    parsePrimitiveData(meta, data, start, count) {
      const parsed = super.parsePrimitiveData(meta, data, start, count);
      for (let i = 0; i < parsed.length; i++) {
        parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
      }
      return parsed;
    }
    parseArrayData(meta, data, start, count) {
      const parsed = super.parseArrayData(meta, data, start, count);
      for (let i = 0; i < parsed.length; i++) {
        const item = data[start + i];
        parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
      }
      return parsed;
    }
    parseObjectData(meta, data, start, count) {
      const parsed = super.parseObjectData(meta, data, start, count);
      for (let i = 0; i < parsed.length; i++) {
        const item = data[start + i];
        parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
      }
      return parsed;
    }
    getMaxOverflow() {
      const data = this._cachedMeta.data;
      let max = 0;
      for (let i = data.length - 1; i >= 0; --i) {
        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
      }
      return max > 0 && max;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const labels = this.chart.data.labels || [];
      const { xScale, yScale } = meta;
      const parsed = this.getParsed(index2);
      const x = xScale.getLabelForValue(parsed.x);
      const y = yScale.getLabelForValue(parsed.y);
      const r = parsed._custom;
      return {
        label: labels[index2] || "",
        value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
      };
    }
    update(mode) {
      const points = this._cachedMeta.data;
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      for (let i = start; i < start + count; i++) {
        const point = points[i];
        const parsed = !reset && this.getParsed(i);
        const properties = {};
        const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
        const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
        properties.skip = isNaN(iPixel) || isNaN(vPixel);
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
          if (reset) {
            properties.options.radius = 0;
          }
        }
        this.updateElement(point, i, properties, mode);
      }
    }
    resolveDataElementOptions(index2, mode) {
      const parsed = this.getParsed(index2);
      let values = super.resolveDataElementOptions(index2, mode);
      if (values.$shared) {
        values = Object.assign({}, values, {
          $shared: false
        });
      }
      const radius = values.radius;
      if (mode !== "active") {
        values.radius = 0;
      }
      values.radius += valueOrDefault(parsed && parsed._custom, radius);
      return values;
    }
  };
  __publicField(BubbleController, "id", "bubble");
  __publicField(BubbleController, "defaults", {
    datasetElementType: false,
    dataElementType: "point",
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "borderWidth",
          "radius"
        ]
      }
    }
  });
  __publicField(BubbleController, "overrides", {
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  });
  function getRatioAndOffset(rotation, circumference, cutout) {
    let ratioX = 1;
    let ratioY = 1;
    let offsetX = 0;
    let offsetY = 0;
    if (circumference < TAU) {
      const startAngle = rotation;
      const endAngle = startAngle + circumference;
      const startX = Math.cos(startAngle);
      const startY = Math.sin(startAngle);
      const endX = Math.cos(endAngle);
      const endY = Math.sin(endAngle);
      const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
      const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
      const maxX = calcMax(0, startX, endX);
      const maxY = calcMax(HALF_PI, startY, endY);
      const minX = calcMin(PI, startX, endX);
      const minY = calcMin(PI + HALF_PI, startY, endY);
      ratioX = (maxX - minX) / 2;
      ratioY = (maxY - minY) / 2;
      offsetX = -(maxX + minX) / 2;
      offsetY = -(maxY + minY) / 2;
    }
    return {
      ratioX,
      ratioY,
      offsetX,
      offsetY
    };
  }
  var DoughnutController = class extends DatasetController {
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.enableOptionSharing = true;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.offsetX = void 0;
      this.offsetY = void 0;
    }
    linkScales() {
    }
    parse(start, count) {
      const data = this.getDataset().data;
      const meta = this._cachedMeta;
      if (this._parsing === false) {
        meta._parsed = data;
      } else {
        let getter = (i2) => +data[i2];
        if (isObject2(data[start])) {
          const { key = "value" } = this._parsing;
          getter = (i2) => +resolveObjectKey(data[i2], key);
        }
        let i, ilen;
        for (i = start, ilen = start + count; i < ilen; ++i) {
          meta._parsed[i] = getter(i);
        }
      }
    }
    _getRotation() {
      return toRadians(this.options.rotation - 90);
    }
    _getCircumference() {
      return toRadians(this.options.circumference);
    }
    _getRotationExtents() {
      let min = TAU;
      let max = -TAU;
      for (let i = 0; i < this.chart.data.datasets.length; ++i) {
        if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
          const controller = this.chart.getDatasetMeta(i).controller;
          const rotation = controller._getRotation();
          const circumference = controller._getCircumference();
          min = Math.min(min, rotation);
          max = Math.max(max, rotation + circumference);
        }
      }
      return {
        rotation: min,
        circumference: max - min
      };
    }
    update(mode) {
      const chart = this.chart;
      const { chartArea } = chart;
      const meta = this._cachedMeta;
      const arcs = meta.data;
      const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
      const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
      const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
      const chartWeight = this._getRingWeight(this.index);
      const { circumference, rotation } = this._getRotationExtents();
      const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
      const maxWidth = (chartArea.width - spacing) / ratioX;
      const maxHeight = (chartArea.height - spacing) / ratioY;
      const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
      const outerRadius = toDimension(this.options.radius, maxRadius);
      const innerRadius = Math.max(outerRadius * cutout, 0);
      const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
      this.offsetX = offsetX * outerRadius;
      this.offsetY = offsetY * outerRadius;
      meta.total = this.calculateTotal();
      this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
      this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    _circumference(i, reset) {
      const opts = this.options;
      const meta = this._cachedMeta;
      const circumference = this._getCircumference();
      if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
        return 0;
      }
      return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
    }
    updateElements(arcs, start, count, mode) {
      const reset = mode === "reset";
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const centerX = (chartArea.left + chartArea.right) / 2;
      const centerY = (chartArea.top + chartArea.bottom) / 2;
      const animateScale = reset && animationOpts.animateScale;
      const innerRadius = animateScale ? 0 : this.innerRadius;
      const outerRadius = animateScale ? 0 : this.outerRadius;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
      let startAngle = this._getRotation();
      let i;
      for (i = 0; i < start; ++i) {
        startAngle += this._circumference(i, reset);
      }
      for (i = start; i < start + count; ++i) {
        const circumference = this._circumference(i, reset);
        const arc = arcs[i];
        const properties = {
          x: centerX + this.offsetX,
          y: centerY + this.offsetY,
          startAngle,
          endAngle: startAngle + circumference,
          circumference,
          outerRadius,
          innerRadius
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
        }
        startAngle += circumference;
        this.updateElement(arc, i, properties, mode);
      }
    }
    calculateTotal() {
      const meta = this._cachedMeta;
      const metaData = meta.data;
      let total = 0;
      let i;
      for (i = 0; i < metaData.length; i++) {
        const value = meta._parsed[i];
        if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
          total += Math.abs(value);
        }
      }
      return total;
    }
    calculateCircumference(value) {
      const total = this._cachedMeta.total;
      if (total > 0 && !isNaN(value)) {
        return TAU * (Math.abs(value) / total);
      }
      return 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber(meta._parsed[index2], chart.options.locale);
      return {
        label: labels[index2] || "",
        value
      };
    }
    getMaxBorderWidth(arcs) {
      let max = 0;
      const chart = this.chart;
      let i, ilen, meta, controller, options;
      if (!arcs) {
        for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            meta = chart.getDatasetMeta(i);
            arcs = meta.data;
            controller = meta.controller;
            break;
          }
        }
      }
      if (!arcs) {
        return 0;
      }
      for (i = 0, ilen = arcs.length; i < ilen; ++i) {
        options = controller.resolveDataElementOptions(i);
        if (options.borderAlign !== "inner") {
          max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
        }
      }
      return max;
    }
    getMaxOffset(arcs) {
      let max = 0;
      for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
        const options = this.resolveDataElementOptions(i);
        max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
      }
      return max;
    }
    _getRingWeightOffset(datasetIndex) {
      let ringWeightOffset = 0;
      for (let i = 0; i < datasetIndex; ++i) {
        if (this.chart.isDatasetVisible(i)) {
          ringWeightOffset += this._getRingWeight(i);
        }
      }
      return ringWeightOffset;
    }
    _getRingWeight(datasetIndex) {
      return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
    }
    _getVisibleDatasetWeightTotal() {
      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
    }
  };
  __publicField(DoughnutController, "id", "doughnut");
  __publicField(DoughnutController, "defaults", {
    datasetElementType: false,
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: false
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "circumference",
          "endAngle",
          "innerRadius",
          "outerRadius",
          "startAngle",
          "x",
          "y",
          "offset",
          "borderWidth",
          "spacing"
        ]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  });
  __publicField(DoughnutController, "descriptors", {
    _scriptable: (name) => name !== "spacing",
    _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
  });
  __publicField(DoughnutController, "overrides", {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const { labels: { pointStyle, color: color2 } } = chart.legend.options;
              return data.labels.map((label, i) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  fontColor: color2,
                  lineWidth: style.borderWidth,
                  pointStyle,
                  hidden: !chart.getDataVisibility(i),
                  index: i
                };
              });
            }
            return [];
          }
        },
        onClick(e, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      }
    }
  });
  var LineController = class extends DatasetController {
    initialize() {
      this.enableOptionSharing = true;
      this.supportsDecimation = true;
      super.initialize();
    }
    update(mode) {
      const meta = this._cachedMeta;
      const { dataset: line, data: points = [], _dataset } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start = 0;
        count = points.length;
      }
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
      this.updateElements(points, start, count, mode);
    }
    updateElements(points, start, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      const end = start + count;
      const pointsCount = points.length;
      let prevParsed = start > 0 && this.getParsed(start - 1);
      for (let i = 0; i < pointsCount; ++i) {
        const point = points[i];
        const properties = directUpdate ? point : {};
        if (i < start || i >= end) {
          properties.skip = true;
          continue;
        }
        const parsed = this.getParsed(i);
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i, properties, mode);
        }
        prevParsed = parsed;
      }
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      const data = meta.data || [];
      if (!data.length) {
        return border;
      }
      const firstPoint = data[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
    draw() {
      const meta = this._cachedMeta;
      meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
      super.draw();
    }
  };
  __publicField(LineController, "id", "line");
  __publicField(LineController, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: true,
    spanGaps: false
  });
  __publicField(LineController, "overrides", {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  });
  var PolarAreaController = class extends DatasetController {
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.innerRadius = void 0;
      this.outerRadius = void 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
      return {
        label: labels[index2] || "",
        value
      };
    }
    parseObjectData(meta, data, start, count) {
      return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
    }
    update(mode) {
      const arcs = this._cachedMeta.data;
      this._updateRadius();
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    getMinMax() {
      const meta = this._cachedMeta;
      const range2 = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      };
      meta.data.forEach((element, index2) => {
        const parsed = this.getParsed(index2).r;
        if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
          if (parsed < range2.min) {
            range2.min = parsed;
          }
          if (parsed > range2.max) {
            range2.max = parsed;
          }
        }
      });
      return range2;
    }
    _updateRadius() {
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
      const outerRadius = Math.max(minSize / 2, 0);
      const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
      const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
      this.outerRadius = outerRadius - radiusLength * this.index;
      this.innerRadius = this.outerRadius - radiusLength;
    }
    updateElements(arcs, start, count, mode) {
      const reset = mode === "reset";
      const chart = this.chart;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const scale = this._cachedMeta.rScale;
      const centerX = scale.xCenter;
      const centerY = scale.yCenter;
      const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
      let angle = datasetStartAngle;
      let i;
      const defaultAngle = 360 / this.countVisibleElements();
      for (i = 0; i < start; ++i) {
        angle += this._computeAngle(i, mode, defaultAngle);
      }
      for (i = start; i < start + count; i++) {
        const arc = arcs[i];
        let startAngle = angle;
        let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
        let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
        angle = endAngle;
        if (reset) {
          if (animationOpts.animateScale) {
            outerRadius = 0;
          }
          if (animationOpts.animateRotate) {
            startAngle = endAngle = datasetStartAngle;
          }
        }
        const properties = {
          x: centerX,
          y: centerY,
          innerRadius: 0,
          outerRadius,
          startAngle,
          endAngle,
          options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
        };
        this.updateElement(arc, i, properties, mode);
      }
    }
    countVisibleElements() {
      const meta = this._cachedMeta;
      let count = 0;
      meta.data.forEach((element, index2) => {
        if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
          count++;
        }
      });
      return count;
    }
    _computeAngle(index2, mode, defaultAngle) {
      return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
    }
  };
  __publicField(PolarAreaController, "id", "polarArea");
  __publicField(PolarAreaController, "defaults", {
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: true
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "startAngle",
          "endAngle",
          "innerRadius",
          "outerRadius"
        ]
      }
    },
    indexAxis: "r",
    startAngle: 0
  });
  __publicField(PolarAreaController, "overrides", {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const { labels: { pointStyle, color: color2 } } = chart.legend.options;
              return data.labels.map((label, i) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  fontColor: color2,
                  lineWidth: style.borderWidth,
                  pointStyle,
                  hidden: !chart.getDataVisibility(i),
                  index: i
                };
              });
            }
            return [];
          }
        },
        onClick(e, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      }
    },
    scales: {
      r: {
        type: "radialLinear",
        angleLines: {
          display: false
        },
        beginAtZero: true,
        grid: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        startAngle: 0
      }
    }
  });
  var PieController = class extends DoughnutController {
  };
  __publicField(PieController, "id", "pie");
  __publicField(PieController, "defaults", {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
  });
  var RadarController = class extends DatasetController {
    getLabelAndValue(index2) {
      const vScale = this._cachedMeta.vScale;
      const parsed = this.getParsed(index2);
      return {
        label: vScale.getLabels()[index2],
        value: "" + vScale.getLabelForValue(parsed[vScale.axis])
      };
    }
    parseObjectData(meta, data, start, count) {
      return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
    }
    update(mode) {
      const meta = this._cachedMeta;
      const line = meta.dataset;
      const points = meta.data || [];
      const labels = meta.iScale.getLabels();
      line.points = points;
      if (mode !== "resize") {
        const options = this.resolveDatasetElementOptions(mode);
        if (!this.options.showLine) {
          options.borderWidth = 0;
        }
        const properties = {
          _loop: true,
          _fullLoop: labels.length === points.length,
          options
        };
        this.updateElement(line, void 0, properties, mode);
      }
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start, count, mode) {
      const scale = this._cachedMeta.rScale;
      const reset = mode === "reset";
      for (let i = start; i < start + count; i++) {
        const point = points[i];
        const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
        const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
        const x = reset ? scale.xCenter : pointPosition.x;
        const y = reset ? scale.yCenter : pointPosition.y;
        const properties = {
          x,
          y,
          angle: pointPosition.angle,
          skip: isNaN(x) || isNaN(y),
          options
        };
        this.updateElement(point, i, properties, mode);
      }
    }
  };
  __publicField(RadarController, "id", "radar");
  __publicField(RadarController, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    indexAxis: "r",
    showLine: true,
    elements: {
      line: {
        fill: "start"
      }
    }
  });
  __publicField(RadarController, "overrides", {
    aspectRatio: 1,
    scales: {
      r: {
        type: "radialLinear"
      }
    }
  });
  var ScatterController = class extends DatasetController {
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const labels = this.chart.data.labels || [];
      const { xScale, yScale } = meta;
      const parsed = this.getParsed(index2);
      const x = xScale.getLabelForValue(parsed.x);
      const y = yScale.getLabelForValue(parsed.y);
      return {
        label: labels[index2] || "",
        value: "(" + x + ", " + y + ")"
      };
    }
    update(mode) {
      const meta = this._cachedMeta;
      const { data: points = [] } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start = 0;
        count = points.length;
      }
      if (this.options.showLine) {
        if (!this.datasetElementType) {
          this.addElements();
        }
        const { dataset: line, _dataset } = meta;
        line._chart = this.chart;
        line._datasetIndex = this.index;
        line._decimated = !!_dataset._decimated;
        line.points = points;
        const options = this.resolveDatasetElementOptions(mode);
        options.segment = this.options.segment;
        this.updateElement(line, void 0, {
          animated: !animationsDisabled,
          options
        }, mode);
      } else if (this.datasetElementType) {
        delete meta.dataset;
        this.datasetElementType = false;
      }
      this.updateElements(points, start, count, mode);
    }
    addElements() {
      const { showLine } = this.options;
      if (!this.datasetElementType && showLine) {
        this.datasetElementType = this.chart.registry.getElement("line");
      }
      super.addElements();
    }
    updateElements(points, start, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const firstOpts = this.resolveDataElementOptions(start, mode);
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      let prevParsed = start > 0 && this.getParsed(start - 1);
      for (let i = start; i < start + count; ++i) {
        const point = points[i];
        const parsed = this.getParsed(i);
        const properties = directUpdate ? point : {};
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i, properties, mode);
        }
        prevParsed = parsed;
      }
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const data = meta.data || [];
      if (!this.options.showLine) {
        let max = 0;
        for (let i = data.length - 1; i >= 0; --i) {
          max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
        }
        return max > 0 && max;
      }
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      if (!data.length) {
        return border;
      }
      const firstPoint = data[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
  };
  __publicField(ScatterController, "id", "scatter");
  __publicField(ScatterController, "defaults", {
    datasetElementType: false,
    dataElementType: "point",
    showLine: false,
    fill: false
  });
  __publicField(ScatterController, "overrides", {
    interaction: {
      mode: "point"
    },
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  });
  var controllers = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    BarController,
    BubbleController,
    DoughnutController,
    LineController,
    PieController,
    PolarAreaController,
    RadarController,
    ScatterController
  });
  function abstract() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
  }
  var DateAdapterBase = class {
    constructor(options) {
      __publicField(this, "options");
      this.options = options || {};
    }
    /**
    * Override default date adapter methods.
    * Accepts type parameter to define options type.
    * @example
    * Chart._adapters._date.override<{myAdapterOption: string}>({
    *   init() {
    *     console.log(this.options.myAdapterOption);
    *   }
    * })
    */
    static override(members) {
      Object.assign(DateAdapterBase.prototype, members);
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    init() {
    }
    formats() {
      return abstract();
    }
    parse() {
      return abstract();
    }
    format() {
      return abstract();
    }
    add() {
      return abstract();
    }
    diff() {
      return abstract();
    }
    startOf() {
      return abstract();
    }
    endOf() {
      return abstract();
    }
  };
  var adapters = {
    _date: DateAdapterBase
  };
  function binarySearch(metaset, axis, value, intersect) {
    const { controller, data, _sorted } = metaset;
    const iScale = controller._cachedMeta.iScale;
    if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
      const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
      if (!intersect) {
        return lookupMethod(data, axis, value);
      } else if (controller._sharedOptions) {
        const el = data[0];
        const range2 = typeof el.getRange === "function" && el.getRange(axis);
        if (range2) {
          const start = lookupMethod(data, axis, value - range2);
          const end = lookupMethod(data, axis, value + range2);
          return {
            lo: start.lo,
            hi: end.hi
          };
        }
      }
    }
    return {
      lo: 0,
      hi: data.length - 1
    };
  }
  function evaluateInteractionItems(chart, axis, position, handler, intersect) {
    const metasets = chart.getSortedVisibleDatasetMetas();
    const value = position[axis];
    for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
      const { index: index2, data } = metasets[i];
      const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
      for (let j = lo; j <= hi; ++j) {
        const element = data[j];
        if (!element.skip) {
          handler(element, index2, j);
        }
      }
    }
  }
  function getDistanceMetricForAxis(axis) {
    const useX = axis.indexOf("x") !== -1;
    const useY = axis.indexOf("y") !== -1;
    return function(pt1, pt2) {
      const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
      const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
      return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
  }
  function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
    const items = [];
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return items;
    }
    const evaluationFunc = function(element, datasetIndex, index2) {
      if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
        return;
      }
      if (element.inRange(position.x, position.y, useFinalPosition)) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
      }
    };
    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
    return items;
  }
  function getNearestRadialItems(chart, position, axis, useFinalPosition) {
    let items = [];
    function evaluationFunc(element, datasetIndex, index2) {
      const { startAngle, endAngle } = element.getProps([
        "startAngle",
        "endAngle"
      ], useFinalPosition);
      const { angle } = getAngleFromPoint(element, {
        x: position.x,
        y: position.y
      });
      if (_angleBetween(angle, startAngle, endAngle)) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    let items = [];
    const distanceMetric = getDistanceMetricForAxis(axis);
    let minDistance = Number.POSITIVE_INFINITY;
    function evaluationFunc(element, datasetIndex, index2) {
      const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
      if (intersect && !inRange2) {
        return;
      }
      const center = element.getCenterPoint(useFinalPosition);
      const pointInArea = !!includeInvisible || chart.isPointInArea(center);
      if (!pointInArea && !inRange2) {
        return;
      }
      const distance = distanceMetric(position, center);
      if (distance < minDistance) {
        items = [
          {
            element,
            datasetIndex,
            index: index2
          }
        ];
        minDistance = distance;
      } else if (distance === minDistance) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return [];
    }
    return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
  }
  function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
    const items = [];
    const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
    let intersectsItem = false;
    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
      if (element[rangeMethod](position[axis], useFinalPosition)) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
        intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
      }
    });
    if (intersect && !intersectsItem) {
      return [];
    }
    return items;
  }
  var Interaction = {
    evaluateInteractionItems,
    modes: {
      index(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "x";
        const includeInvisible = options.includeInvisible || false;
        const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        const elements2 = [];
        if (!items.length) {
          return [];
        }
        chart.getSortedVisibleDatasetMetas().forEach((meta) => {
          const index2 = items[0].index;
          const element = meta.data[index2];
          if (element && !element.skip) {
            elements2.push({
              element,
              datasetIndex: meta.index,
              index: index2
            });
          }
        });
        return elements2;
      },
      dataset(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        if (items.length > 0) {
          const datasetIndex = items[0].datasetIndex;
          const data = chart.getDatasetMeta(datasetIndex).data;
          items = [];
          for (let i = 0; i < data.length; ++i) {
            items.push({
              element: data[i],
              datasetIndex,
              index: i
            });
          }
        }
        return items;
      },
      point(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
      },
      nearest(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
      },
      x(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
      },
      y(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
      }
    }
  };
  var STATIC_POSITIONS = [
    "left",
    "top",
    "right",
    "bottom"
  ];
  function filterByPosition(array, position) {
    return array.filter((v) => v.pos === position);
  }
  function filterDynamicPositionByAxis(array, axis) {
    return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
  }
  function sortByWeight(array, reverse) {
    return array.sort((a, b) => {
      const v0 = reverse ? b : a;
      const v1 = reverse ? a : b;
      return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
  }
  function wrapBoxes(boxes) {
    const layoutBoxes = [];
    let i, ilen, box, pos, stack, stackWeight;
    for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
      box = boxes[i];
      ({ position: pos, options: { stack, stackWeight = 1 } } = box);
      layoutBoxes.push({
        index: i,
        box,
        pos,
        horizontal: box.isHorizontal(),
        weight: box.weight,
        stack: stack && pos + stack,
        stackWeight
      });
    }
    return layoutBoxes;
  }
  function buildStacks(layouts2) {
    const stacks = {};
    for (const wrap of layouts2) {
      const { stack, pos, stackWeight } = wrap;
      if (!stack || !STATIC_POSITIONS.includes(pos)) {
        continue;
      }
      const _stack = stacks[stack] || (stacks[stack] = {
        count: 0,
        placed: 0,
        weight: 0,
        size: 0
      });
      _stack.count++;
      _stack.weight += stackWeight;
    }
    return stacks;
  }
  function setLayoutDims(layouts2, params) {
    const stacks = buildStacks(layouts2);
    const { vBoxMaxWidth, hBoxMaxHeight } = params;
    let i, ilen, layout;
    for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
      layout = layouts2[i];
      const { fullSize } = layout.box;
      const stack = stacks[layout.stack];
      const factor = stack && layout.stackWeight / stack.weight;
      if (layout.horizontal) {
        layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
        layout.height = hBoxMaxHeight;
      } else {
        layout.width = vBoxMaxWidth;
        layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
      }
    }
    return stacks;
  }
  function buildLayoutBoxes(boxes) {
    const layoutBoxes = wrapBoxes(boxes);
    const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
    const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
    const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
    const top2 = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
    const bottom2 = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
    return {
      fullSize,
      leftAndTop: left.concat(top2),
      rightAndBottom: right.concat(centerVertical).concat(bottom2).concat(centerHorizontal),
      chartArea: filterByPosition(layoutBoxes, "chartArea"),
      vertical: left.concat(right).concat(centerVertical),
      horizontal: top2.concat(bottom2).concat(centerHorizontal)
    };
  }
  function getCombinedMax(maxPadding, chartArea, a, b) {
    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
  }
  function updateMaxPadding(maxPadding, boxPadding) {
    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
  }
  function updateDims(chartArea, params, layout, stacks) {
    const { pos, box } = layout;
    const maxPadding = chartArea.maxPadding;
    if (!isObject2(pos)) {
      if (layout.size) {
        chartArea[pos] -= layout.size;
      }
      const stack = stacks[layout.stack] || {
        size: 0,
        count: 1
      };
      stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
      layout.size = stack.size / stack.count;
      chartArea[pos] += layout.size;
    }
    if (box.getPadding) {
      updateMaxPadding(maxPadding, box.getPadding());
    }
    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
    const widthChanged = newWidth !== chartArea.w;
    const heightChanged = newHeight !== chartArea.h;
    chartArea.w = newWidth;
    chartArea.h = newHeight;
    return layout.horizontal ? {
      same: widthChanged,
      other: heightChanged
    } : {
      same: heightChanged,
      other: widthChanged
    };
  }
  function handleMaxPadding(chartArea) {
    const maxPadding = chartArea.maxPadding;
    function updatePos(pos) {
      const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
      chartArea[pos] += change;
      return change;
    }
    chartArea.y += updatePos("top");
    chartArea.x += updatePos("left");
    updatePos("right");
    updatePos("bottom");
  }
  function getMargins(horizontal, chartArea) {
    const maxPadding = chartArea.maxPadding;
    function marginForPositions(positions2) {
      const margin = {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
      positions2.forEach((pos) => {
        margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
      });
      return margin;
    }
    return horizontal ? marginForPositions([
      "left",
      "right"
    ]) : marginForPositions([
      "top",
      "bottom"
    ]);
  }
  function fitBoxes(boxes, chartArea, params, stacks) {
    const refitBoxes = [];
    let i, ilen, layout, box, refit, changed;
    for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
      layout = boxes[i];
      box = layout.box;
      box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
      const { same, other } = updateDims(chartArea, params, layout, stacks);
      refit |= same && refitBoxes.length;
      changed = changed || other;
      if (!box.fullSize) {
        refitBoxes.push(layout);
      }
    }
    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
  }
  function setBoxDims(box, left, top2, width, height) {
    box.top = top2;
    box.left = left;
    box.right = left + width;
    box.bottom = top2 + height;
    box.width = width;
    box.height = height;
  }
  function placeBoxes(boxes, chartArea, params, stacks) {
    const userPadding = params.padding;
    let { x, y } = chartArea;
    for (const layout of boxes) {
      const box = layout.box;
      const stack = stacks[layout.stack] || {
        count: 1,
        placed: 0,
        weight: 1
      };
      const weight = layout.stackWeight / stack.weight || 1;
      if (layout.horizontal) {
        const width = chartArea.w * weight;
        const height = stack.size || box.height;
        if (defined(stack.start)) {
          y = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
        } else {
          setBoxDims(box, chartArea.left + stack.placed, y, width, height);
        }
        stack.start = y;
        stack.placed += width;
        y = box.bottom;
      } else {
        const height = chartArea.h * weight;
        const width = stack.size || box.width;
        if (defined(stack.start)) {
          x = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
        } else {
          setBoxDims(box, x, chartArea.top + stack.placed, width, height);
        }
        stack.start = x;
        stack.placed += height;
        x = box.right;
      }
    }
    chartArea.x = x;
    chartArea.y = y;
  }
  var layouts = {
    addBox(chart, item) {
      if (!chart.boxes) {
        chart.boxes = [];
      }
      item.fullSize = item.fullSize || false;
      item.position = item.position || "top";
      item.weight = item.weight || 0;
      item._layers = item._layers || function() {
        return [
          {
            z: 0,
            draw(chartArea) {
              item.draw(chartArea);
            }
          }
        ];
      };
      chart.boxes.push(item);
    },
    removeBox(chart, layoutItem) {
      const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
      if (index2 !== -1) {
        chart.boxes.splice(index2, 1);
      }
    },
    configure(chart, item, options) {
      item.fullSize = options.fullSize;
      item.position = options.position;
      item.weight = options.weight;
    },
    update(chart, width, height, minPadding) {
      if (!chart) {
        return;
      }
      const padding = toPadding(chart.options.layout.padding);
      const availableWidth = Math.max(width - padding.width, 0);
      const availableHeight = Math.max(height - padding.height, 0);
      const boxes = buildLayoutBoxes(chart.boxes);
      const verticalBoxes = boxes.vertical;
      const horizontalBoxes = boxes.horizontal;
      each(chart.boxes, (box) => {
        if (typeof box.beforeLayout === "function") {
          box.beforeLayout();
        }
      });
      const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
      const params = Object.freeze({
        outerWidth: width,
        outerHeight: height,
        padding,
        availableWidth,
        availableHeight,
        vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
        hBoxMaxHeight: availableHeight / 2
      });
      const maxPadding = Object.assign({}, padding);
      updateMaxPadding(maxPadding, toPadding(minPadding));
      const chartArea = Object.assign({
        maxPadding,
        w: availableWidth,
        h: availableHeight,
        x: padding.left,
        y: padding.top
      }, padding);
      const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
      fitBoxes(boxes.fullSize, chartArea, params, stacks);
      fitBoxes(verticalBoxes, chartArea, params, stacks);
      if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
        fitBoxes(verticalBoxes, chartArea, params, stacks);
      }
      handleMaxPadding(chartArea);
      placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
      chartArea.x += chartArea.w;
      chartArea.y += chartArea.h;
      placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
      chart.chartArea = {
        left: chartArea.left,
        top: chartArea.top,
        right: chartArea.left + chartArea.w,
        bottom: chartArea.top + chartArea.h,
        height: chartArea.h,
        width: chartArea.w
      };
      each(boxes.chartArea, (layout) => {
        const box = layout.box;
        Object.assign(box, chart.chartArea);
        box.update(chartArea.w, chartArea.h, {
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        });
      });
    }
  };
  var BasePlatform = class {
    acquireContext(canvas, aspectRatio) {
    }
    releaseContext(context) {
      return false;
    }
    addEventListener(chart, type, listener) {
    }
    removeEventListener(chart, type, listener) {
    }
    getDevicePixelRatio() {
      return 1;
    }
    getMaximumSize(element, width, height, aspectRatio) {
      width = Math.max(0, width || element.width);
      height = height || element.height;
      return {
        width,
        height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
      };
    }
    isAttached(canvas) {
      return true;
    }
    updateConfig(config) {
    }
  };
  var BasicPlatform = class extends BasePlatform {
    acquireContext(item) {
      return item && item.getContext && item.getContext("2d") || null;
    }
    updateConfig(config) {
      config.options.animation = false;
    }
  };
  var EXPANDO_KEY = "$chartjs";
  var EVENT_TYPES = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout"
  };
  var isNullOrEmpty = (value) => value === null || value === "";
  function initCanvas(canvas, aspectRatio) {
    const style = canvas.style;
    const renderHeight = canvas.getAttribute("height");
    const renderWidth = canvas.getAttribute("width");
    canvas[EXPANDO_KEY] = {
      initial: {
        height: renderHeight,
        width: renderWidth,
        style: {
          display: style.display,
          height: style.height,
          width: style.width
        }
      }
    };
    style.display = style.display || "block";
    style.boxSizing = style.boxSizing || "border-box";
    if (isNullOrEmpty(renderWidth)) {
      const displayWidth = readUsedSize(canvas, "width");
      if (displayWidth !== void 0) {
        canvas.width = displayWidth;
      }
    }
    if (isNullOrEmpty(renderHeight)) {
      if (canvas.style.height === "") {
        canvas.height = canvas.width / (aspectRatio || 2);
      } else {
        const displayHeight = readUsedSize(canvas, "height");
        if (displayHeight !== void 0) {
          canvas.height = displayHeight;
        }
      }
    }
    return canvas;
  }
  var eventListenerOptions = supportsEventListenerOptions ? {
    passive: true
  } : false;
  function addListener(node, type, listener) {
    if (node) {
      node.addEventListener(type, listener, eventListenerOptions);
    }
  }
  function removeListener(chart, type, listener) {
    if (chart && chart.canvas) {
      chart.canvas.removeEventListener(type, listener, eventListenerOptions);
    }
  }
  function fromNativeEvent(event, chart) {
    const type = EVENT_TYPES[event.type] || event.type;
    const { x, y } = getRelativePosition(event, chart);
    return {
      type,
      chart,
      native: event,
      x: x !== void 0 ? x : null,
      y: y !== void 0 ? y : null
    };
  }
  function nodeListContains(nodeList, canvas) {
    for (const node of nodeList) {
      if (node === canvas || node.contains(canvas)) {
        return true;
      }
    }
  }
  function createAttachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.addedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, {
      childList: true,
      subtree: true
    });
    return observer;
  }
  function createDetachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.removedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, {
      childList: true,
      subtree: true
    });
    return observer;
  }
  var drpListeningCharts = /* @__PURE__ */ new Map();
  var oldDevicePixelRatio = 0;
  function onWindowResize() {
    const dpr = window.devicePixelRatio;
    if (dpr === oldDevicePixelRatio) {
      return;
    }
    oldDevicePixelRatio = dpr;
    drpListeningCharts.forEach((resize, chart) => {
      if (chart.currentDevicePixelRatio !== dpr) {
        resize();
      }
    });
  }
  function listenDevicePixelRatioChanges(chart, resize) {
    if (!drpListeningCharts.size) {
      window.addEventListener("resize", onWindowResize);
    }
    drpListeningCharts.set(chart, resize);
  }
  function unlistenDevicePixelRatioChanges(chart) {
    drpListeningCharts.delete(chart);
    if (!drpListeningCharts.size) {
      window.removeEventListener("resize", onWindowResize);
    }
  }
  function createResizeObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const container = canvas && _getParentNode(canvas);
    if (!container) {
      return;
    }
    const resize = throttled((width, height) => {
      const w = container.clientWidth;
      listener(width, height);
      if (w < container.clientWidth) {
        listener();
      }
    }, window);
    const observer = new ResizeObserver((entries) => {
      const entry = entries[0];
      const width = entry.contentRect.width;
      const height = entry.contentRect.height;
      if (width === 0 && height === 0) {
        return;
      }
      resize(width, height);
    });
    observer.observe(container);
    listenDevicePixelRatioChanges(chart, resize);
    return observer;
  }
  function releaseObserver(chart, type, observer) {
    if (observer) {
      observer.disconnect();
    }
    if (type === "resize") {
      unlistenDevicePixelRatioChanges(chart);
    }
  }
  function createProxyAndListen(chart, type, listener) {
    const canvas = chart.canvas;
    const proxy = throttled((event) => {
      if (chart.ctx !== null) {
        listener(fromNativeEvent(event, chart));
      }
    }, chart);
    addListener(canvas, type, proxy);
    return proxy;
  }
  var DomPlatform = class extends BasePlatform {
    acquireContext(canvas, aspectRatio) {
      const context = canvas && canvas.getContext && canvas.getContext("2d");
      if (context && context.canvas === canvas) {
        initCanvas(canvas, aspectRatio);
        return context;
      }
      return null;
    }
    releaseContext(context) {
      const canvas = context.canvas;
      if (!canvas[EXPANDO_KEY]) {
        return false;
      }
      const initial = canvas[EXPANDO_KEY].initial;
      [
        "height",
        "width"
      ].forEach((prop) => {
        const value = initial[prop];
        if (isNullOrUndef(value)) {
          canvas.removeAttribute(prop);
        } else {
          canvas.setAttribute(prop, value);
        }
      });
      const style = initial.style || {};
      Object.keys(style).forEach((key) => {
        canvas.style[key] = style[key];
      });
      canvas.width = canvas.width;
      delete canvas[EXPANDO_KEY];
      return true;
    }
    addEventListener(chart, type, listener) {
      this.removeEventListener(chart, type);
      const proxies = chart.$proxies || (chart.$proxies = {});
      const handlers = {
        attach: createAttachObserver,
        detach: createDetachObserver,
        resize: createResizeObserver
      };
      const handler = handlers[type] || createProxyAndListen;
      proxies[type] = handler(chart, type, listener);
    }
    removeEventListener(chart, type) {
      const proxies = chart.$proxies || (chart.$proxies = {});
      const proxy = proxies[type];
      if (!proxy) {
        return;
      }
      const handlers = {
        attach: releaseObserver,
        detach: releaseObserver,
        resize: releaseObserver
      };
      const handler = handlers[type] || removeListener;
      handler(chart, type, proxy);
      proxies[type] = void 0;
    }
    getDevicePixelRatio() {
      return window.devicePixelRatio;
    }
    getMaximumSize(canvas, width, height, aspectRatio) {
      return getMaximumSize(canvas, width, height, aspectRatio);
    }
    isAttached(canvas) {
      const container = _getParentNode(canvas);
      return !!(container && container.isConnected);
    }
  };
  function _detectPlatform(canvas) {
    if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
      return BasicPlatform;
    }
    return DomPlatform;
  }
  var Element = class {
    constructor() {
      __publicField(this, "x");
      __publicField(this, "y");
      __publicField(this, "active", false);
      __publicField(this, "options");
      __publicField(this, "$animations");
    }
    tooltipPosition(useFinalPosition) {
      const { x, y } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return {
        x,
        y
      };
    }
    hasValue() {
      return isNumber(this.x) && isNumber(this.y);
    }
    getProps(props, final) {
      const anims = this.$animations;
      if (!final || !anims) {
        return this;
      }
      const ret = {};
      props.forEach((prop) => {
        ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
      });
      return ret;
    }
  };
  __publicField(Element, "defaults", {});
  __publicField(Element, "defaultRoutes");
  function autoSkip(scale, ticks) {
    const tickOpts = scale.options.ticks;
    const determinedMaxTicks = determineMaxTicks(scale);
    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
    const numMajorIndices = majorIndices.length;
    const first = majorIndices[0];
    const last = majorIndices[numMajorIndices - 1];
    const newTicks = [];
    if (numMajorIndices > ticksLimit) {
      skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
      return newTicks;
    }
    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
    if (numMajorIndices > 0) {
      let i, ilen;
      const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
      skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
      for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
        skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
      }
      skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
      return newTicks;
    }
    skip(ticks, newTicks, spacing);
    return newTicks;
  }
  function determineMaxTicks(scale) {
    const offset = scale.options.offset;
    const tickLength = scale._tickSize();
    const maxScale = scale._length / tickLength + (offset ? 0 : 1);
    const maxChart = scale._maxLength / tickLength;
    return Math.floor(Math.min(maxScale, maxChart));
  }
  function calculateSpacing(majorIndices, ticks, ticksLimit) {
    const evenMajorSpacing = getEvenSpacing(majorIndices);
    const spacing = ticks.length / ticksLimit;
    if (!evenMajorSpacing) {
      return Math.max(spacing, 1);
    }
    const factors = _factorize(evenMajorSpacing);
    for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
      const factor = factors[i];
      if (factor > spacing) {
        return factor;
      }
    }
    return Math.max(spacing, 1);
  }
  function getMajorIndices(ticks) {
    const result = [];
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (ticks[i].major) {
        result.push(i);
      }
    }
    return result;
  }
  function skipMajors(ticks, newTicks, majorIndices, spacing) {
    let count = 0;
    let next = majorIndices[0];
    let i;
    spacing = Math.ceil(spacing);
    for (i = 0; i < ticks.length; i++) {
      if (i === next) {
        newTicks.push(ticks[i]);
        count++;
        next = majorIndices[count * spacing];
      }
    }
  }
  function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
    const start = valueOrDefault(majorStart, 0);
    const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
    let count = 0;
    let length, i, next;
    spacing = Math.ceil(spacing);
    if (majorEnd) {
      length = majorEnd - majorStart;
      spacing = length / Math.floor(length / spacing);
    }
    next = start;
    while (next < 0) {
      count++;
      next = Math.round(start + count * spacing);
    }
    for (i = Math.max(start, 0); i < end; i++) {
      if (i === next) {
        newTicks.push(ticks[i]);
        count++;
        next = Math.round(start + count * spacing);
      }
    }
  }
  function getEvenSpacing(arr) {
    const len = arr.length;
    let i, diff;
    if (len < 2) {
      return false;
    }
    for (diff = arr[0], i = 1; i < len; ++i) {
      if (arr[i] - arr[i - 1] !== diff) {
        return false;
      }
    }
    return diff;
  }
  var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
  var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
  var getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
  function sample(arr, numItems) {
    const result = [];
    const increment = arr.length / numItems;
    const len = arr.length;
    let i = 0;
    for (; i < len; i += increment) {
      result.push(arr[Math.floor(i)]);
    }
    return result;
  }
  function getPixelForGridLine(scale, index2, offsetGridLines) {
    const length = scale.ticks.length;
    const validIndex2 = Math.min(index2, length - 1);
    const start = scale._startPixel;
    const end = scale._endPixel;
    const epsilon = 1e-6;
    let lineValue = scale.getPixelForTick(validIndex2);
    let offset;
    if (offsetGridLines) {
      if (length === 1) {
        offset = Math.max(lineValue - start, end - lineValue);
      } else if (index2 === 0) {
        offset = (scale.getPixelForTick(1) - lineValue) / 2;
      } else {
        offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
      }
      lineValue += validIndex2 < index2 ? offset : -offset;
      if (lineValue < start - epsilon || lineValue > end + epsilon) {
        return;
      }
    }
    return lineValue;
  }
  function garbageCollect(caches, length) {
    each(caches, (cache) => {
      const gc = cache.gc;
      const gcLen = gc.length / 2;
      let i;
      if (gcLen > length) {
        for (i = 0; i < gcLen; ++i) {
          delete cache.data[gc[i]];
        }
        gc.splice(0, gcLen);
      }
    });
  }
  function getTickMarkLength(options) {
    return options.drawTicks ? options.tickLength : 0;
  }
  function getTitleHeight(options, fallback) {
    if (!options.display) {
      return 0;
    }
    const font = toFont(options.font, fallback);
    const padding = toPadding(options.padding);
    const lines = isArray(options.text) ? options.text.length : 1;
    return lines * font.lineHeight + padding.height;
  }
  function createScaleContext(parent, scale) {
    return createContext(parent, {
      scale,
      type: "scale"
    });
  }
  function createTickContext(parent, index2, tick) {
    return createContext(parent, {
      tick,
      index: index2,
      type: "tick"
    });
  }
  function titleAlign(align, position, reverse) {
    let ret = _toLeftRightCenter(align);
    if (reverse && position !== "right" || !reverse && position === "right") {
      ret = reverseAlign(ret);
    }
    return ret;
  }
  function titleArgs(scale, offset, position, align) {
    const { top: top2, left, bottom: bottom2, right, chart } = scale;
    const { chartArea, scales: scales2 } = chart;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    const height = bottom2 - top2;
    const width = right - left;
    if (scale.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      if (isObject2(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
      } else if (position === "center") {
        titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
      } else {
        titleY = offsetFromEdge(scale, position, offset);
      }
      maxWidth = right - left;
    } else {
      if (isObject2(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
      } else if (position === "center") {
        titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
      } else {
        titleX = offsetFromEdge(scale, position, offset);
      }
      titleY = _alignStartEnd(align, bottom2, top2);
      rotation = position === "left" ? -HALF_PI : HALF_PI;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  var Scale = class extends Element {
    constructor(cfg) {
      super();
      this.id = cfg.id;
      this.type = cfg.type;
      this.options = void 0;
      this.ctx = cfg.ctx;
      this.chart = cfg.chart;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this._margins = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      this.maxWidth = void 0;
      this.maxHeight = void 0;
      this.paddingTop = void 0;
      this.paddingBottom = void 0;
      this.paddingLeft = void 0;
      this.paddingRight = void 0;
      this.axis = void 0;
      this.labelRotation = void 0;
      this.min = void 0;
      this.max = void 0;
      this._range = void 0;
      this.ticks = [];
      this._gridLineItems = null;
      this._labelItems = null;
      this._labelSizes = null;
      this._length = 0;
      this._maxLength = 0;
      this._longestTextCache = {};
      this._startPixel = void 0;
      this._endPixel = void 0;
      this._reversePixels = false;
      this._userMax = void 0;
      this._userMin = void 0;
      this._suggestedMax = void 0;
      this._suggestedMin = void 0;
      this._ticksLength = 0;
      this._borderValue = 0;
      this._cache = {};
      this._dataLimitsCached = false;
      this.$context = void 0;
    }
    init(options) {
      this.options = options.setContext(this.getContext());
      this.axis = options.axis;
      this._userMin = this.parse(options.min);
      this._userMax = this.parse(options.max);
      this._suggestedMin = this.parse(options.suggestedMin);
      this._suggestedMax = this.parse(options.suggestedMax);
    }
    parse(raw, index2) {
      return raw;
    }
    getUserBounds() {
      let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
      _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
      _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
      _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
      _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
      return {
        min: finiteOrDefault(_userMin, _suggestedMin),
        max: finiteOrDefault(_userMax, _suggestedMax),
        minDefined: isNumberFinite(_userMin),
        maxDefined: isNumberFinite(_userMax)
      };
    }
    getMinMax(canStack) {
      let { min, max, minDefined, maxDefined } = this.getUserBounds();
      let range2;
      if (minDefined && maxDefined) {
        return {
          min,
          max
        };
      }
      const metas = this.getMatchingVisibleMetas();
      for (let i = 0, ilen = metas.length; i < ilen; ++i) {
        range2 = metas[i].controller.getMinMax(this, canStack);
        if (!minDefined) {
          min = Math.min(min, range2.min);
        }
        if (!maxDefined) {
          max = Math.max(max, range2.max);
        }
      }
      min = maxDefined && min > max ? max : min;
      max = minDefined && min > max ? min : max;
      return {
        min: finiteOrDefault(min, finiteOrDefault(max, min)),
        max: finiteOrDefault(max, finiteOrDefault(min, max))
      };
    }
    getPadding() {
      return {
        left: this.paddingLeft || 0,
        top: this.paddingTop || 0,
        right: this.paddingRight || 0,
        bottom: this.paddingBottom || 0
      };
    }
    getTicks() {
      return this.ticks;
    }
    getLabels() {
      const data = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
    }
    getLabelItems(chartArea = this.chart.chartArea) {
      const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
      return items;
    }
    beforeLayout() {
      this._cache = {};
      this._dataLimitsCached = false;
    }
    beforeUpdate() {
      callback(this.options.beforeUpdate, [
        this
      ]);
    }
    update(maxWidth, maxHeight, margins) {
      const { beginAtZero, grace, ticks: tickOpts } = this.options;
      const sampleSize = tickOpts.sampleSize;
      this.beforeUpdate();
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins = Object.assign({
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, margins);
      this.ticks = null;
      this._labelSizes = null;
      this._gridLineItems = null;
      this._labelItems = null;
      this.beforeSetDimensions();
      this.setDimensions();
      this.afterSetDimensions();
      this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
      if (!this._dataLimitsCached) {
        this.beforeDataLimits();
        this.determineDataLimits();
        this.afterDataLimits();
        this._range = _addGrace(this, grace, beginAtZero);
        this._dataLimitsCached = true;
      }
      this.beforeBuildTicks();
      this.ticks = this.buildTicks() || [];
      this.afterBuildTicks();
      const samplingEnabled = sampleSize < this.ticks.length;
      this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
      this.configure();
      this.beforeCalculateLabelRotation();
      this.calculateLabelRotation();
      this.afterCalculateLabelRotation();
      if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
        this.ticks = autoSkip(this, this.ticks);
        this._labelSizes = null;
        this.afterAutoSkip();
      }
      if (samplingEnabled) {
        this._convertTicksToLabels(this.ticks);
      }
      this.beforeFit();
      this.fit();
      this.afterFit();
      this.afterUpdate();
    }
    configure() {
      let reversePixels = this.options.reverse;
      let startPixel, endPixel;
      if (this.isHorizontal()) {
        startPixel = this.left;
        endPixel = this.right;
      } else {
        startPixel = this.top;
        endPixel = this.bottom;
        reversePixels = !reversePixels;
      }
      this._startPixel = startPixel;
      this._endPixel = endPixel;
      this._reversePixels = reversePixels;
      this._length = endPixel - startPixel;
      this._alignToPixels = this.options.alignToPixels;
    }
    afterUpdate() {
      callback(this.options.afterUpdate, [
        this
      ]);
    }
    beforeSetDimensions() {
      callback(this.options.beforeSetDimensions, [
        this
      ]);
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = 0;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = 0;
        this.bottom = this.height;
      }
      this.paddingLeft = 0;
      this.paddingTop = 0;
      this.paddingRight = 0;
      this.paddingBottom = 0;
    }
    afterSetDimensions() {
      callback(this.options.afterSetDimensions, [
        this
      ]);
    }
    _callHooks(name) {
      this.chart.notifyPlugins(name, this.getContext());
      callback(this.options[name], [
        this
      ]);
    }
    beforeDataLimits() {
      this._callHooks("beforeDataLimits");
    }
    determineDataLimits() {
    }
    afterDataLimits() {
      this._callHooks("afterDataLimits");
    }
    beforeBuildTicks() {
      this._callHooks("beforeBuildTicks");
    }
    buildTicks() {
      return [];
    }
    afterBuildTicks() {
      this._callHooks("afterBuildTicks");
    }
    beforeTickToLabelConversion() {
      callback(this.options.beforeTickToLabelConversion, [
        this
      ]);
    }
    generateTickLabels(ticks) {
      const tickOpts = this.options.ticks;
      let i, ilen, tick;
      for (i = 0, ilen = ticks.length; i < ilen; i++) {
        tick = ticks[i];
        tick.label = callback(tickOpts.callback, [
          tick.value,
          i,
          ticks
        ], this);
      }
    }
    afterTickToLabelConversion() {
      callback(this.options.afterTickToLabelConversion, [
        this
      ]);
    }
    beforeCalculateLabelRotation() {
      callback(this.options.beforeCalculateLabelRotation, [
        this
      ]);
    }
    calculateLabelRotation() {
      const options = this.options;
      const tickOpts = options.ticks;
      const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
      const minRotation = tickOpts.minRotation || 0;
      const maxRotation = tickOpts.maxRotation;
      let labelRotation = minRotation;
      let tickWidth, maxHeight, maxLabelDiagonal;
      if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
        this.labelRotation = minRotation;
        return;
      }
      const labelSizes = this._getLabelSizes();
      const maxLabelWidth = labelSizes.widest.width;
      const maxLabelHeight = labelSizes.highest.height;
      const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
      tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
      if (maxLabelWidth + 6 > tickWidth) {
        tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
        maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
        maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
        labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
        labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
      }
      this.labelRotation = labelRotation;
    }
    afterCalculateLabelRotation() {
      callback(this.options.afterCalculateLabelRotation, [
        this
      ]);
    }
    afterAutoSkip() {
    }
    beforeFit() {
      callback(this.options.beforeFit, [
        this
      ]);
    }
    fit() {
      const minSize = {
        width: 0,
        height: 0
      };
      const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
      const display = this._isVisible();
      const isHorizontal = this.isHorizontal();
      if (display) {
        const titleHeight = getTitleHeight(titleOpts, chart.options.font);
        if (isHorizontal) {
          minSize.width = this.maxWidth;
          minSize.height = getTickMarkLength(gridOpts) + titleHeight;
        } else {
          minSize.height = this.maxHeight;
          minSize.width = getTickMarkLength(gridOpts) + titleHeight;
        }
        if (tickOpts.display && this.ticks.length) {
          const { first, last, widest, highest } = this._getLabelSizes();
          const tickPadding = tickOpts.padding * 2;
          const angleRadians = toRadians(this.labelRotation);
          const cos = Math.cos(angleRadians);
          const sin = Math.sin(angleRadians);
          if (isHorizontal) {
            const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
            minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
          } else {
            const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
            minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
          }
          this._calculatePadding(first, last, sin, cos);
        }
      }
      this._handleMargins();
      if (isHorizontal) {
        this.width = this._length = chart.width - this._margins.left - this._margins.right;
        this.height = minSize.height;
      } else {
        this.width = minSize.width;
        this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
      }
    }
    _calculatePadding(first, last, sin, cos) {
      const { ticks: { align, padding }, position } = this.options;
      const isRotated = this.labelRotation !== 0;
      const labelsBelowTicks = position !== "top" && this.axis === "x";
      if (this.isHorizontal()) {
        const offsetLeft = this.getPixelForTick(0) - this.left;
        const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
        let paddingLeft = 0;
        let paddingRight = 0;
        if (isRotated) {
          if (labelsBelowTicks) {
            paddingLeft = cos * first.width;
            paddingRight = sin * last.height;
          } else {
            paddingLeft = sin * first.height;
            paddingRight = cos * last.width;
          }
        } else if (align === "start") {
          paddingRight = last.width;
        } else if (align === "end") {
          paddingLeft = first.width;
        } else if (align !== "inner") {
          paddingLeft = first.width / 2;
          paddingRight = last.width / 2;
        }
        this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
        this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
      } else {
        let paddingTop = last.height / 2;
        let paddingBottom = first.height / 2;
        if (align === "start") {
          paddingTop = 0;
          paddingBottom = first.height;
        } else if (align === "end") {
          paddingTop = last.height;
          paddingBottom = 0;
        }
        this.paddingTop = paddingTop + padding;
        this.paddingBottom = paddingBottom + padding;
      }
    }
    _handleMargins() {
      if (this._margins) {
        this._margins.left = Math.max(this.paddingLeft, this._margins.left);
        this._margins.top = Math.max(this.paddingTop, this._margins.top);
        this._margins.right = Math.max(this.paddingRight, this._margins.right);
        this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
      }
    }
    afterFit() {
      callback(this.options.afterFit, [
        this
      ]);
    }
    isHorizontal() {
      const { axis, position } = this.options;
      return position === "top" || position === "bottom" || axis === "x";
    }
    isFullSize() {
      return this.options.fullSize;
    }
    _convertTicksToLabels(ticks) {
      this.beforeTickToLabelConversion();
      this.generateTickLabels(ticks);
      let i, ilen;
      for (i = 0, ilen = ticks.length; i < ilen; i++) {
        if (isNullOrUndef(ticks[i].label)) {
          ticks.splice(i, 1);
          ilen--;
          i--;
        }
      }
      this.afterTickToLabelConversion();
    }
    _getLabelSizes() {
      let labelSizes = this._labelSizes;
      if (!labelSizes) {
        const sampleSize = this.options.ticks.sampleSize;
        let ticks = this.ticks;
        if (sampleSize < ticks.length) {
          ticks = sample(ticks, sampleSize);
        }
        this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
      }
      return labelSizes;
    }
    _computeLabelSizes(ticks, length, maxTicksLimit) {
      const { ctx, _longestTextCache: caches } = this;
      const widths = [];
      const heights = [];
      const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
      let widestLabelSize = 0;
      let highestLabelSize = 0;
      let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
      for (i = 0; i < length; i += increment) {
        label = ticks[i].label;
        tickFont = this._resolveTickFontOptions(i);
        ctx.font = fontString = tickFont.string;
        cache = caches[fontString] = caches[fontString] || {
          data: {},
          gc: []
        };
        lineHeight = tickFont.lineHeight;
        width = height = 0;
        if (!isNullOrUndef(label) && !isArray(label)) {
          width = _measureText(ctx, cache.data, cache.gc, width, label);
          height = lineHeight;
        } else if (isArray(label)) {
          for (j = 0, jlen = label.length; j < jlen; ++j) {
            nestedLabel = label[j];
            if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
              width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
              height += lineHeight;
            }
          }
        }
        widths.push(width);
        heights.push(height);
        widestLabelSize = Math.max(width, widestLabelSize);
        highestLabelSize = Math.max(height, highestLabelSize);
      }
      garbageCollect(caches, length);
      const widest = widths.indexOf(widestLabelSize);
      const highest = heights.indexOf(highestLabelSize);
      const valueAt = (idx) => ({
        width: widths[idx] || 0,
        height: heights[idx] || 0
      });
      return {
        first: valueAt(0),
        last: valueAt(length - 1),
        widest: valueAt(widest),
        highest: valueAt(highest),
        widths,
        heights
      };
    }
    getLabelForValue(value) {
      return value;
    }
    getPixelForValue(value, index2) {
      return NaN;
    }
    getValueForPixel(pixel) {
    }
    getPixelForTick(index2) {
      const ticks = this.ticks;
      if (index2 < 0 || index2 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index2].value);
    }
    getPixelForDecimal(decimal) {
      if (this._reversePixels) {
        decimal = 1 - decimal;
      }
      const pixel = this._startPixel + decimal * this._length;
      return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
    }
    getDecimalForPixel(pixel) {
      const decimal = (pixel - this._startPixel) / this._length;
      return this._reversePixels ? 1 - decimal : decimal;
    }
    getBasePixel() {
      return this.getPixelForValue(this.getBaseValue());
    }
    getBaseValue() {
      const { min, max } = this;
      return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
    }
    getContext(index2) {
      const ticks = this.ticks || [];
      if (index2 >= 0 && index2 < ticks.length) {
        const tick = ticks[index2];
        return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
      }
      return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
    }
    _tickSize() {
      const optionTicks = this.options.ticks;
      const rot = toRadians(this.labelRotation);
      const cos = Math.abs(Math.cos(rot));
      const sin = Math.abs(Math.sin(rot));
      const labelSizes = this._getLabelSizes();
      const padding = optionTicks.autoSkipPadding || 0;
      const w = labelSizes ? labelSizes.widest.width + padding : 0;
      const h = labelSizes ? labelSizes.highest.height + padding : 0;
      return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
    }
    _isVisible() {
      const display = this.options.display;
      if (display !== "auto") {
        return !!display;
      }
      return this.getMatchingVisibleMetas().length > 0;
    }
    _computeGridLineItems(chartArea) {
      const axis = this.axis;
      const chart = this.chart;
      const options = this.options;
      const { grid, position, border } = options;
      const offset = grid.offset;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const ticksLength = ticks.length + (offset ? 1 : 0);
      const tl = getTickMarkLength(grid);
      const items = [];
      const borderOpts = border.setContext(this.getContext());
      const axisWidth = borderOpts.display ? borderOpts.width : 0;
      const axisHalfWidth = axisWidth / 2;
      const alignBorderValue = function(pixel) {
        return _alignPixel(chart, pixel, axisWidth);
      };
      let borderValue, i, lineValue, alignedLineValue;
      let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
      if (position === "top") {
        borderValue = alignBorderValue(this.bottom);
        ty1 = this.bottom - tl;
        ty2 = borderValue - axisHalfWidth;
        y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
        y2 = chartArea.bottom;
      } else if (position === "bottom") {
        borderValue = alignBorderValue(this.top);
        y1 = chartArea.top;
        y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
        ty1 = borderValue + axisHalfWidth;
        ty2 = this.top + tl;
      } else if (position === "left") {
        borderValue = alignBorderValue(this.right);
        tx1 = this.right - tl;
        tx2 = borderValue - axisHalfWidth;
        x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
        x2 = chartArea.right;
      } else if (position === "right") {
        borderValue = alignBorderValue(this.left);
        x1 = chartArea.left;
        x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
        tx1 = borderValue + axisHalfWidth;
        tx2 = this.left + tl;
      } else if (axis === "x") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        y1 = chartArea.top;
        y2 = chartArea.bottom;
        ty1 = borderValue + axisHalfWidth;
        ty2 = ty1 + tl;
      } else if (axis === "y") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        tx1 = borderValue - axisHalfWidth;
        tx2 = tx1 - tl;
        x1 = chartArea.left;
        x2 = chartArea.right;
      }
      const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
      const step = Math.max(1, Math.ceil(ticksLength / limit));
      for (i = 0; i < ticksLength; i += step) {
        const context = this.getContext(i);
        const optsAtIndex = grid.setContext(context);
        const optsAtIndexBorder = border.setContext(context);
        const lineWidth = optsAtIndex.lineWidth;
        const lineColor = optsAtIndex.color;
        const borderDash = optsAtIndexBorder.dash || [];
        const borderDashOffset = optsAtIndexBorder.dashOffset;
        const tickWidth = optsAtIndex.tickWidth;
        const tickColor = optsAtIndex.tickColor;
        const tickBorderDash = optsAtIndex.tickBorderDash || [];
        const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
        lineValue = getPixelForGridLine(this, i, offset);
        if (lineValue === void 0) {
          continue;
        }
        alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
        if (isHorizontal) {
          tx1 = tx2 = x1 = x2 = alignedLineValue;
        } else {
          ty1 = ty2 = y1 = y2 = alignedLineValue;
        }
        items.push({
          tx1,
          ty1,
          tx2,
          ty2,
          x1,
          y1,
          x2,
          y2,
          width: lineWidth,
          color: lineColor,
          borderDash,
          borderDashOffset,
          tickWidth,
          tickColor,
          tickBorderDash,
          tickBorderDashOffset
        });
      }
      this._ticksLength = ticksLength;
      this._borderValue = borderValue;
      return items;
    }
    _computeLabelItems(chartArea) {
      const axis = this.axis;
      const options = this.options;
      const { position, ticks: optionTicks } = options;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const { align, crossAlign, padding, mirror } = optionTicks;
      const tl = getTickMarkLength(options.grid);
      const tickAndPadding = tl + padding;
      const hTickAndPadding = mirror ? -padding : tickAndPadding;
      const rotation = -toRadians(this.labelRotation);
      const items = [];
      let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
      let textBaseline = "middle";
      if (position === "top") {
        y = this.bottom - hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "bottom") {
        y = this.top + hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "left") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x = ret.x;
      } else if (position === "right") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x = ret.x;
      } else if (axis === "x") {
        if (position === "center") {
          y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
        }
        textAlign = this._getXAxisLabelAlignment();
      } else if (axis === "y") {
        if (position === "center") {
          x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          x = this.chart.scales[positionAxisID].getPixelForValue(value);
        }
        textAlign = this._getYAxisLabelAlignment(tl).textAlign;
      }
      if (axis === "y") {
        if (align === "start") {
          textBaseline = "top";
        } else if (align === "end") {
          textBaseline = "bottom";
        }
      }
      const labelSizes = this._getLabelSizes();
      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        tick = ticks[i];
        label = tick.label;
        const optsAtIndex = optionTicks.setContext(this.getContext(i));
        pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
        font = this._resolveTickFontOptions(i);
        lineHeight = font.lineHeight;
        lineCount = isArray(label) ? label.length : 1;
        const halfCount = lineCount / 2;
        const color2 = optsAtIndex.color;
        const strokeColor = optsAtIndex.textStrokeColor;
        const strokeWidth = optsAtIndex.textStrokeWidth;
        let tickTextAlign = textAlign;
        if (isHorizontal) {
          x = pixel;
          if (textAlign === "inner") {
            if (i === ilen - 1) {
              tickTextAlign = !this.options.reverse ? "right" : "left";
            } else if (i === 0) {
              tickTextAlign = !this.options.reverse ? "left" : "right";
            } else {
              tickTextAlign = "center";
            }
          }
          if (position === "top") {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = -lineCount * lineHeight + lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
            } else {
              textOffset = -labelSizes.highest.height + lineHeight / 2;
            }
          } else {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
            } else {
              textOffset = labelSizes.highest.height - lineCount * lineHeight;
            }
          }
          if (mirror) {
            textOffset *= -1;
          }
          if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
            x += lineHeight / 2 * Math.sin(rotation);
          }
        } else {
          y = pixel;
          textOffset = (1 - lineCount) * lineHeight / 2;
        }
        let backdrop;
        if (optsAtIndex.showLabelBackdrop) {
          const labelPadding = toPadding(optsAtIndex.backdropPadding);
          const height = labelSizes.heights[i];
          const width = labelSizes.widths[i];
          let top2 = textOffset - labelPadding.top;
          let left = 0 - labelPadding.left;
          switch (textBaseline) {
            case "middle":
              top2 -= height / 2;
              break;
            case "bottom":
              top2 -= height;
              break;
          }
          switch (textAlign) {
            case "center":
              left -= width / 2;
              break;
            case "right":
              left -= width;
              break;
            case "inner":
              if (i === ilen - 1) {
                left -= width;
              } else if (i > 0) {
                left -= width / 2;
              }
              break;
          }
          backdrop = {
            left,
            top: top2,
            width: width + labelPadding.width,
            height: height + labelPadding.height,
            color: optsAtIndex.backdropColor
          };
        }
        items.push({
          label,
          font,
          textOffset,
          options: {
            rotation,
            color: color2,
            strokeColor,
            strokeWidth,
            textAlign: tickTextAlign,
            textBaseline,
            translation: [
              x,
              y
            ],
            backdrop
          }
        });
      }
      return items;
    }
    _getXAxisLabelAlignment() {
      const { position, ticks } = this.options;
      const rotation = -toRadians(this.labelRotation);
      if (rotation) {
        return position === "top" ? "left" : "right";
      }
      let align = "center";
      if (ticks.align === "start") {
        align = "left";
      } else if (ticks.align === "end") {
        align = "right";
      } else if (ticks.align === "inner") {
        align = "inner";
      }
      return align;
    }
    _getYAxisLabelAlignment(tl) {
      const { position, ticks: { crossAlign, mirror, padding } } = this.options;
      const labelSizes = this._getLabelSizes();
      const tickAndPadding = tl + padding;
      const widest = labelSizes.widest.width;
      let textAlign;
      let x;
      if (position === "left") {
        if (mirror) {
          x = this.right + padding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x += widest / 2;
          } else {
            textAlign = "right";
            x += widest;
          }
        } else {
          x = this.right - tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x -= widest / 2;
          } else {
            textAlign = "left";
            x = this.left;
          }
        }
      } else if (position === "right") {
        if (mirror) {
          x = this.left + padding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x -= widest / 2;
          } else {
            textAlign = "left";
            x -= widest;
          }
        } else {
          x = this.left + tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x += widest / 2;
          } else {
            textAlign = "right";
            x = this.right;
          }
        }
      } else {
        textAlign = "right";
      }
      return {
        textAlign,
        x
      };
    }
    _computeLabelArea() {
      if (this.options.ticks.mirror) {
        return;
      }
      const chart = this.chart;
      const position = this.options.position;
      if (position === "left" || position === "right") {
        return {
          top: 0,
          left: this.left,
          bottom: chart.height,
          right: this.right
        };
      }
      if (position === "top" || position === "bottom") {
        return {
          top: this.top,
          left: 0,
          bottom: this.bottom,
          right: chart.width
        };
      }
    }
    drawBackground() {
      const { ctx, options: { backgroundColor }, left, top: top2, width, height } = this;
      if (backgroundColor) {
        ctx.save();
        ctx.fillStyle = backgroundColor;
        ctx.fillRect(left, top2, width, height);
        ctx.restore();
      }
    }
    getLineWidthForValue(value) {
      const grid = this.options.grid;
      if (!this._isVisible() || !grid.display) {
        return 0;
      }
      const ticks = this.ticks;
      const index2 = ticks.findIndex((t) => t.value === value);
      if (index2 >= 0) {
        const opts = grid.setContext(this.getContext(index2));
        return opts.lineWidth;
      }
      return 0;
    }
    drawGrid(chartArea) {
      const grid = this.options.grid;
      const ctx = this.ctx;
      const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
      let i, ilen;
      const drawLine = (p1, p2, style) => {
        if (!style.width || !style.color) {
          return;
        }
        ctx.save();
        ctx.lineWidth = style.width;
        ctx.strokeStyle = style.color;
        ctx.setLineDash(style.borderDash || []);
        ctx.lineDashOffset = style.borderDashOffset;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        ctx.restore();
      };
      if (grid.display) {
        for (i = 0, ilen = items.length; i < ilen; ++i) {
          const item = items[i];
          if (grid.drawOnChartArea) {
            drawLine({
              x: item.x1,
              y: item.y1
            }, {
              x: item.x2,
              y: item.y2
            }, item);
          }
          if (grid.drawTicks) {
            drawLine({
              x: item.tx1,
              y: item.ty1
            }, {
              x: item.tx2,
              y: item.ty2
            }, {
              color: item.tickColor,
              width: item.tickWidth,
              borderDash: item.tickBorderDash,
              borderDashOffset: item.tickBorderDashOffset
            });
          }
        }
      }
    }
    drawBorder() {
      const { chart, ctx, options: { border, grid } } = this;
      const borderOpts = border.setContext(this.getContext());
      const axisWidth = border.display ? borderOpts.width : 0;
      if (!axisWidth) {
        return;
      }
      const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
      const borderValue = this._borderValue;
      let x1, x2, y1, y2;
      if (this.isHorizontal()) {
        x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
        x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
        y1 = y2 = borderValue;
      } else {
        y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
        y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
        x1 = x2 = borderValue;
      }
      ctx.save();
      ctx.lineWidth = borderOpts.width;
      ctx.strokeStyle = borderOpts.color;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.restore();
    }
    drawLabels(chartArea) {
      const optionTicks = this.options.ticks;
      if (!optionTicks.display) {
        return;
      }
      const ctx = this.ctx;
      const area = this._computeLabelArea();
      if (area) {
        clipArea(ctx, area);
      }
      const items = this.getLabelItems(chartArea);
      for (const item of items) {
        const renderTextOptions = item.options;
        const tickFont = item.font;
        const label = item.label;
        const y = item.textOffset;
        renderText(ctx, label, 0, y, tickFont, renderTextOptions);
      }
      if (area) {
        unclipArea(ctx);
      }
    }
    drawTitle() {
      const { ctx, options: { position, title, reverse } } = this;
      if (!title.display) {
        return;
      }
      const font = toFont(title.font);
      const padding = toPadding(title.padding);
      const align = title.align;
      let offset = font.lineHeight / 2;
      if (position === "bottom" || position === "center" || isObject2(position)) {
        offset += padding.bottom;
        if (isArray(title.text)) {
          offset += font.lineHeight * (title.text.length - 1);
        }
      } else {
        offset += padding.top;
      }
      const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
      renderText(ctx, title.text, 0, 0, font, {
        color: title.color,
        maxWidth,
        rotation,
        textAlign: titleAlign(align, position, reverse),
        textBaseline: "middle",
        translation: [
          titleX,
          titleY
        ]
      });
    }
    draw(chartArea) {
      if (!this._isVisible()) {
        return;
      }
      this.drawBackground();
      this.drawGrid(chartArea);
      this.drawBorder();
      this.drawTitle();
      this.drawLabels(chartArea);
    }
    _layers() {
      const opts = this.options;
      const tz = opts.ticks && opts.ticks.z || 0;
      const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
      const bz = valueOrDefault(opts.border && opts.border.z, 0);
      if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
        return [
          {
            z: tz,
            draw: (chartArea) => {
              this.draw(chartArea);
            }
          }
        ];
      }
      return [
        {
          z: gz,
          draw: (chartArea) => {
            this.drawBackground();
            this.drawGrid(chartArea);
            this.drawTitle();
          }
        },
        {
          z: bz,
          draw: () => {
            this.drawBorder();
          }
        },
        {
          z: tz,
          draw: (chartArea) => {
            this.drawLabels(chartArea);
          }
        }
      ];
    }
    getMatchingVisibleMetas(type) {
      const metas = this.chart.getSortedVisibleDatasetMetas();
      const axisID = this.axis + "AxisID";
      const result = [];
      let i, ilen;
      for (i = 0, ilen = metas.length; i < ilen; ++i) {
        const meta = metas[i];
        if (meta[axisID] === this.id && (!type || meta.type === type)) {
          result.push(meta);
        }
      }
      return result;
    }
    _resolveTickFontOptions(index2) {
      const opts = this.options.ticks.setContext(this.getContext(index2));
      return toFont(opts.font);
    }
    _maxDigits() {
      const fontSize = this._resolveTickFontOptions(0).lineHeight;
      return (this.isHorizontal() ? this.width : this.height) / fontSize;
    }
  };
  var TypedRegistry = class {
    constructor(type, scope, override) {
      this.type = type;
      this.scope = scope;
      this.override = override;
      this.items = /* @__PURE__ */ Object.create(null);
    }
    isForType(type) {
      return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
    }
    register(item) {
      const proto = Object.getPrototypeOf(item);
      let parentScope;
      if (isIChartComponent(proto)) {
        parentScope = this.register(proto);
      }
      const items = this.items;
      const id = item.id;
      const scope = this.scope + "." + id;
      if (!id) {
        throw new Error("class does not have id: " + item);
      }
      if (id in items) {
        return scope;
      }
      items[id] = item;
      registerDefaults(item, scope, parentScope);
      if (this.override) {
        defaults.override(item.id, item.overrides);
      }
      return scope;
    }
    get(id) {
      return this.items[id];
    }
    unregister(item) {
      const items = this.items;
      const id = item.id;
      const scope = this.scope;
      if (id in items) {
        delete items[id];
      }
      if (scope && id in defaults[scope]) {
        delete defaults[scope][id];
        if (this.override) {
          delete overrides[id];
        }
      }
    }
  };
  function registerDefaults(item, scope, parentScope) {
    const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
      parentScope ? defaults.get(parentScope) : {},
      defaults.get(scope),
      item.defaults
    ]);
    defaults.set(scope, itemDefaults);
    if (item.defaultRoutes) {
      routeDefaults(scope, item.defaultRoutes);
    }
    if (item.descriptors) {
      defaults.describe(scope, item.descriptors);
    }
  }
  function routeDefaults(scope, routes) {
    Object.keys(routes).forEach((property) => {
      const propertyParts = property.split(".");
      const sourceName = propertyParts.pop();
      const sourceScope = [
        scope
      ].concat(propertyParts).join(".");
      const parts = routes[property].split(".");
      const targetName = parts.pop();
      const targetScope = parts.join(".");
      defaults.route(sourceScope, sourceName, targetScope, targetName);
    });
  }
  function isIChartComponent(proto) {
    return "id" in proto && "defaults" in proto;
  }
  var Registry = class {
    constructor() {
      this.controllers = new TypedRegistry(DatasetController, "datasets", true);
      this.elements = new TypedRegistry(Element, "elements");
      this.plugins = new TypedRegistry(Object, "plugins");
      this.scales = new TypedRegistry(Scale, "scales");
      this._typedRegistries = [
        this.controllers,
        this.scales,
        this.elements
      ];
    }
    add(...args) {
      this._each("register", args);
    }
    remove(...args) {
      this._each("unregister", args);
    }
    addControllers(...args) {
      this._each("register", args, this.controllers);
    }
    addElements(...args) {
      this._each("register", args, this.elements);
    }
    addPlugins(...args) {
      this._each("register", args, this.plugins);
    }
    addScales(...args) {
      this._each("register", args, this.scales);
    }
    getController(id) {
      return this._get(id, this.controllers, "controller");
    }
    getElement(id) {
      return this._get(id, this.elements, "element");
    }
    getPlugin(id) {
      return this._get(id, this.plugins, "plugin");
    }
    getScale(id) {
      return this._get(id, this.scales, "scale");
    }
    removeControllers(...args) {
      this._each("unregister", args, this.controllers);
    }
    removeElements(...args) {
      this._each("unregister", args, this.elements);
    }
    removePlugins(...args) {
      this._each("unregister", args, this.plugins);
    }
    removeScales(...args) {
      this._each("unregister", args, this.scales);
    }
    _each(method, args, typedRegistry) {
      [
        ...args
      ].forEach((arg) => {
        const reg = typedRegistry || this._getRegistryForType(arg);
        if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
          this._exec(method, reg, arg);
        } else {
          each(arg, (item) => {
            const itemReg = typedRegistry || this._getRegistryForType(item);
            this._exec(method, itemReg, item);
          });
        }
      });
    }
    _exec(method, registry2, component) {
      const camelMethod = _capitalize(method);
      callback(component["before" + camelMethod], [], component);
      registry2[method](component);
      callback(component["after" + camelMethod], [], component);
    }
    _getRegistryForType(type) {
      for (let i = 0; i < this._typedRegistries.length; i++) {
        const reg = this._typedRegistries[i];
        if (reg.isForType(type)) {
          return reg;
        }
      }
      return this.plugins;
    }
    _get(id, typedRegistry, type) {
      const item = typedRegistry.get(id);
      if (item === void 0) {
        throw new Error('"' + id + '" is not a registered ' + type + ".");
      }
      return item;
    }
  };
  var registry = /* @__PURE__ */ new Registry();
  var PluginService = class {
    constructor() {
      this._init = [];
    }
    notify(chart, hook, args, filter) {
      if (hook === "beforeInit") {
        this._init = this._createDescriptors(chart, true);
        this._notify(this._init, chart, "install");
      }
      const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
      const result = this._notify(descriptors2, chart, hook, args);
      if (hook === "afterDestroy") {
        this._notify(descriptors2, chart, "stop");
        this._notify(this._init, chart, "uninstall");
      }
      return result;
    }
    _notify(descriptors2, chart, hook, args) {
      args = args || {};
      for (const descriptor of descriptors2) {
        const plugin = descriptor.plugin;
        const method = plugin[hook];
        const params = [
          chart,
          args,
          descriptor.options
        ];
        if (callback(method, params, plugin) === false && args.cancelable) {
          return false;
        }
      }
      return true;
    }
    invalidate() {
      if (!isNullOrUndef(this._cache)) {
        this._oldCache = this._cache;
        this._cache = void 0;
      }
    }
    _descriptors(chart) {
      if (this._cache) {
        return this._cache;
      }
      const descriptors2 = this._cache = this._createDescriptors(chart);
      this._notifyStateChanges(chart);
      return descriptors2;
    }
    _createDescriptors(chart, all) {
      const config = chart && chart.config;
      const options = valueOrDefault(config.options && config.options.plugins, {});
      const plugins2 = allPlugins(config);
      return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
    }
    _notifyStateChanges(chart) {
      const previousDescriptors = this._oldCache || [];
      const descriptors2 = this._cache;
      const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
      this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
      this._notify(diff(descriptors2, previousDescriptors), chart, "start");
    }
  };
  function allPlugins(config) {
    const localIds = {};
    const plugins2 = [];
    const keys = Object.keys(registry.plugins.items);
    for (let i = 0; i < keys.length; i++) {
      plugins2.push(registry.getPlugin(keys[i]));
    }
    const local = config.plugins || [];
    for (let i = 0; i < local.length; i++) {
      const plugin = local[i];
      if (plugins2.indexOf(plugin) === -1) {
        plugins2.push(plugin);
        localIds[plugin.id] = true;
      }
    }
    return {
      plugins: plugins2,
      localIds
    };
  }
  function getOpts(options, all) {
    if (!all && options === false) {
      return null;
    }
    if (options === true) {
      return {};
    }
    return options;
  }
  function createDescriptors(chart, { plugins: plugins2, localIds }, options, all) {
    const result = [];
    const context = chart.getContext();
    for (const plugin of plugins2) {
      const id = plugin.id;
      const opts = getOpts(options[id], all);
      if (opts === null) {
        continue;
      }
      result.push({
        plugin,
        options: pluginOpts(chart.config, {
          plugin,
          local: localIds[id]
        }, opts, context)
      });
    }
    return result;
  }
  function pluginOpts(config, { plugin, local }, opts, context) {
    const keys = config.pluginScopeKeys(plugin);
    const scopes = config.getOptionScopes(opts, keys);
    if (local && plugin.defaults) {
      scopes.push(plugin.defaults);
    }
    return config.createResolver(scopes, context, [
      ""
    ], {
      scriptable: false,
      indexable: false,
      allKeys: true
    });
  }
  function getIndexAxis(type, options) {
    const datasetDefaults = defaults.datasets[type] || {};
    const datasetOptions = (options.datasets || {})[type] || {};
    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
  }
  function getAxisFromDefaultScaleID(id, indexAxis) {
    let axis = id;
    if (id === "_index_") {
      axis = indexAxis;
    } else if (id === "_value_") {
      axis = indexAxis === "x" ? "y" : "x";
    }
    return axis;
  }
  function getDefaultScaleIDFromAxis(axis, indexAxis) {
    return axis === indexAxis ? "_index_" : "_value_";
  }
  function idMatchesAxis(id) {
    if (id === "x" || id === "y" || id === "r") {
      return id;
    }
  }
  function axisFromPosition(position) {
    if (position === "top" || position === "bottom") {
      return "x";
    }
    if (position === "left" || position === "right") {
      return "y";
    }
  }
  function determineAxis(id, ...scaleOptions) {
    if (idMatchesAxis(id)) {
      return id;
    }
    for (const opts of scaleOptions) {
      const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
      if (axis) {
        return axis;
      }
    }
    throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
  }
  function getAxisFromDataset(id, axis, dataset) {
    if (dataset[axis + "AxisID"] === id) {
      return {
        axis
      };
    }
  }
  function retrieveAxisFromDatasets(id, config) {
    if (config.data && config.data.datasets) {
      const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);
      if (boundDs.length) {
        return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
      }
    }
    return {};
  }
  function mergeScaleConfig(config, options) {
    const chartDefaults = overrides[config.type] || {
      scales: {}
    };
    const configScales = options.scales || {};
    const chartIndexAxis = getIndexAxis(config.type, options);
    const scales2 = /* @__PURE__ */ Object.create(null);
    Object.keys(configScales).forEach((id) => {
      const scaleConf = configScales[id];
      if (!isObject2(scaleConf)) {
        return console.error(`Invalid scale configuration for scale: ${id}`);
      }
      if (scaleConf._proxy) {
        return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
      }
      const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
      const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
      const defaultScaleOptions = chartDefaults.scales || {};
      scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
        {
          axis
        },
        scaleConf,
        defaultScaleOptions[axis],
        defaultScaleOptions[defaultId]
      ]);
    });
    config.data.datasets.forEach((dataset) => {
      const type = dataset.type || config.type;
      const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
      const datasetDefaults = overrides[type] || {};
      const defaultScaleOptions = datasetDefaults.scales || {};
      Object.keys(defaultScaleOptions).forEach((defaultID) => {
        const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
        const id = dataset[axis + "AxisID"] || axis;
        scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
        mergeIf(scales2[id], [
          {
            axis
          },
          configScales[id],
          defaultScaleOptions[defaultID]
        ]);
      });
    });
    Object.keys(scales2).forEach((key) => {
      const scale = scales2[key];
      mergeIf(scale, [
        defaults.scales[scale.type],
        defaults.scale
      ]);
    });
    return scales2;
  }
  function initOptions(config) {
    const options = config.options || (config.options = {});
    options.plugins = valueOrDefault(options.plugins, {});
    options.scales = mergeScaleConfig(config, options);
  }
  function initData(data) {
    data = data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    return data;
  }
  function initConfig(config) {
    config = config || {};
    config.data = initData(config.data);
    initOptions(config);
    return config;
  }
  var keyCache = /* @__PURE__ */ new Map();
  var keysCached = /* @__PURE__ */ new Set();
  function cachedKeys(cacheKey, generate) {
    let keys = keyCache.get(cacheKey);
    if (!keys) {
      keys = generate();
      keyCache.set(cacheKey, keys);
      keysCached.add(keys);
    }
    return keys;
  }
  var addIfFound = (set2, obj, key) => {
    const opts = resolveObjectKey(obj, key);
    if (opts !== void 0) {
      set2.add(opts);
    }
  };
  var Config = class {
    constructor(config) {
      this._config = initConfig(config);
      this._scopeCache = /* @__PURE__ */ new Map();
      this._resolverCache = /* @__PURE__ */ new Map();
    }
    get platform() {
      return this._config.platform;
    }
    get type() {
      return this._config.type;
    }
    set type(type) {
      this._config.type = type;
    }
    get data() {
      return this._config.data;
    }
    set data(data) {
      this._config.data = initData(data);
    }
    get options() {
      return this._config.options;
    }
    set options(options) {
      this._config.options = options;
    }
    get plugins() {
      return this._config.plugins;
    }
    update() {
      const config = this._config;
      this.clearCache();
      initOptions(config);
    }
    clearCache() {
      this._scopeCache.clear();
      this._resolverCache.clear();
    }
    datasetScopeKeys(datasetType) {
      return cachedKeys(datasetType, () => [
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]);
    }
    datasetAnimationScopeKeys(datasetType, transition) {
      return cachedKeys(`${datasetType}.transition.${transition}`, () => [
        [
          `datasets.${datasetType}.transitions.${transition}`,
          `transitions.${transition}`
        ],
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]);
    }
    datasetElementScopeKeys(datasetType, elementType) {
      return cachedKeys(`${datasetType}-${elementType}`, () => [
        [
          `datasets.${datasetType}.elements.${elementType}`,
          `datasets.${datasetType}`,
          `elements.${elementType}`,
          ""
        ]
      ]);
    }
    pluginScopeKeys(plugin) {
      const id = plugin.id;
      const type = this.type;
      return cachedKeys(`${type}-plugin-${id}`, () => [
        [
          `plugins.${id}`,
          ...plugin.additionalOptionScopes || []
        ]
      ]);
    }
    _cachedScopes(mainScope, resetCache) {
      const _scopeCache = this._scopeCache;
      let cache = _scopeCache.get(mainScope);
      if (!cache || resetCache) {
        cache = /* @__PURE__ */ new Map();
        _scopeCache.set(mainScope, cache);
      }
      return cache;
    }
    getOptionScopes(mainScope, keyLists, resetCache) {
      const { options, type } = this;
      const cache = this._cachedScopes(mainScope, resetCache);
      const cached = cache.get(keyLists);
      if (cached) {
        return cached;
      }
      const scopes = /* @__PURE__ */ new Set();
      keyLists.forEach((keys) => {
        if (mainScope) {
          scopes.add(mainScope);
          keys.forEach((key) => addIfFound(scopes, mainScope, key));
        }
        keys.forEach((key) => addIfFound(scopes, options, key));
        keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
        keys.forEach((key) => addIfFound(scopes, defaults, key));
        keys.forEach((key) => addIfFound(scopes, descriptors, key));
      });
      const array = Array.from(scopes);
      if (array.length === 0) {
        array.push(/* @__PURE__ */ Object.create(null));
      }
      if (keysCached.has(keyLists)) {
        cache.set(keyLists, array);
      }
      return array;
    }
    chartOptionScopes() {
      const { options, type } = this;
      return [
        options,
        overrides[type] || {},
        defaults.datasets[type] || {},
        {
          type
        },
        defaults,
        descriptors
      ];
    }
    resolveNamedOptions(scopes, names2, context, prefixes = [
      ""
    ]) {
      const result = {
        $shared: true
      };
      const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
      let options = resolver;
      if (needContext(resolver, names2)) {
        result.$shared = false;
        context = isFunction(context) ? context() : context;
        const subResolver = this.createResolver(scopes, context, subPrefixes);
        options = _attachContext(resolver, context, subResolver);
      }
      for (const prop of names2) {
        result[prop] = options[prop];
      }
      return result;
    }
    createResolver(scopes, context, prefixes = [
      ""
    ], descriptorDefaults) {
      const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
      return isObject2(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
    }
  };
  function getResolver(resolverCache, scopes, prefixes) {
    let cache = resolverCache.get(scopes);
    if (!cache) {
      cache = /* @__PURE__ */ new Map();
      resolverCache.set(scopes, cache);
    }
    const cacheKey = prefixes.join();
    let cached = cache.get(cacheKey);
    if (!cached) {
      const resolver = _createResolver(scopes, prefixes);
      cached = {
        resolver,
        subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
      };
      cache.set(cacheKey, cached);
    }
    return cached;
  }
  var hasFunction = (value) => isObject2(value) && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));
  function needContext(proxy, names2) {
    const { isScriptable, isIndexable } = _descriptors(proxy);
    for (const prop of names2) {
      const scriptable = isScriptable(prop);
      const indexable = isIndexable(prop);
      const value = (indexable || scriptable) && proxy[prop];
      if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
        return true;
      }
    }
    return false;
  }
  var version = "4.4.2";
  var KNOWN_POSITIONS = [
    "top",
    "bottom",
    "left",
    "right",
    "chartArea"
  ];
  function positionIsHorizontal(position, axis) {
    return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
  }
  function compare2Level(l1, l2) {
    return function(a, b) {
      return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
    };
  }
  function onAnimationsComplete(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    chart.notifyPlugins("afterRender");
    callback(animationOptions && animationOptions.onComplete, [
      context
    ], chart);
  }
  function onAnimationProgress(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    callback(animationOptions && animationOptions.onProgress, [
      context
    ], chart);
  }
  function getCanvas(item) {
    if (_isDomSupported() && typeof item === "string") {
      item = document.getElementById(item);
    } else if (item && item.length) {
      item = item[0];
    }
    if (item && item.canvas) {
      item = item.canvas;
    }
    return item;
  }
  var instances = {};
  var getChart = (key) => {
    const canvas = getCanvas(key);
    return Object.values(instances).filter((c) => c.canvas === canvas).pop();
  };
  function moveNumericKeys(obj, start, move) {
    const keys = Object.keys(obj);
    for (const key of keys) {
      const intKey = +key;
      if (intKey >= start) {
        const value = obj[key];
        delete obj[key];
        if (move > 0 || intKey > start) {
          obj[intKey + move] = value;
        }
      }
    }
  }
  function determineLastEvent(e, lastEvent, inChartArea, isClick) {
    if (!inChartArea || e.type === "mouseout") {
      return null;
    }
    if (isClick) {
      return lastEvent;
    }
    return e;
  }
  function getSizeForArea(scale, chartArea, field) {
    return scale.options.clip ? scale[field] : chartArea[field];
  }
  function getDatasetArea(meta, chartArea) {
    const { xScale, yScale } = meta;
    if (xScale && yScale) {
      return {
        left: getSizeForArea(xScale, chartArea, "left"),
        right: getSizeForArea(xScale, chartArea, "right"),
        top: getSizeForArea(yScale, chartArea, "top"),
        bottom: getSizeForArea(yScale, chartArea, "bottom")
      };
    }
    return chartArea;
  }
  var Chart = class {
    static register(...items) {
      registry.add(...items);
      invalidatePlugins();
    }
    static unregister(...items) {
      registry.remove(...items);
      invalidatePlugins();
    }
    constructor(item, userConfig) {
      const config = this.config = new Config(userConfig);
      const initialCanvas = getCanvas(item);
      const existingChart = getChart(initialCanvas);
      if (existingChart) {
        throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
      }
      const options = config.createResolver(config.chartOptionScopes(), this.getContext());
      this.platform = new (config.platform || _detectPlatform(initialCanvas))();
      this.platform.updateConfig(config);
      const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
      const canvas = context && context.canvas;
      const height = canvas && canvas.height;
      const width = canvas && canvas.width;
      this.id = uid();
      this.ctx = context;
      this.canvas = canvas;
      this.width = width;
      this.height = height;
      this._options = options;
      this._aspectRatio = this.aspectRatio;
      this._layers = [];
      this._metasets = [];
      this._stacks = void 0;
      this.boxes = [];
      this.currentDevicePixelRatio = void 0;
      this.chartArea = void 0;
      this._active = [];
      this._lastEvent = void 0;
      this._listeners = {};
      this._responsiveListeners = void 0;
      this._sortedMetasets = [];
      this.scales = {};
      this._plugins = new PluginService();
      this.$proxies = {};
      this._hiddenIndices = {};
      this.attached = false;
      this._animationsDisabled = void 0;
      this.$context = void 0;
      this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
      this._dataChanges = [];
      instances[this.id] = this;
      if (!context || !canvas) {
        console.error("Failed to create chart: can't acquire context from the given item");
        return;
      }
      animator.listen(this, "complete", onAnimationsComplete);
      animator.listen(this, "progress", onAnimationProgress);
      this._initialize();
      if (this.attached) {
        this.update();
      }
    }
    get aspectRatio() {
      const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
      if (!isNullOrUndef(aspectRatio)) {
        return aspectRatio;
      }
      if (maintainAspectRatio && _aspectRatio) {
        return _aspectRatio;
      }
      return height ? width / height : null;
    }
    get data() {
      return this.config.data;
    }
    set data(data) {
      this.config.data = data;
    }
    get options() {
      return this._options;
    }
    set options(options) {
      this.config.options = options;
    }
    get registry() {
      return registry;
    }
    _initialize() {
      this.notifyPlugins("beforeInit");
      if (this.options.responsive) {
        this.resize();
      } else {
        retinaScale(this, this.options.devicePixelRatio);
      }
      this.bindEvents();
      this.notifyPlugins("afterInit");
      return this;
    }
    clear() {
      clearCanvas(this.canvas, this.ctx);
      return this;
    }
    stop() {
      animator.stop(this);
      return this;
    }
    resize(width, height) {
      if (!animator.running(this)) {
        this._resize(width, height);
      } else {
        this._resizeBeforeDraw = {
          width,
          height
        };
      }
    }
    _resize(width, height) {
      const options = this.options;
      const canvas = this.canvas;
      const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
      const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
      const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
      const mode = this.width ? "resize" : "attach";
      this.width = newSize.width;
      this.height = newSize.height;
      this._aspectRatio = this.aspectRatio;
      if (!retinaScale(this, newRatio, true)) {
        return;
      }
      this.notifyPlugins("resize", {
        size: newSize
      });
      callback(options.onResize, [
        this,
        newSize
      ], this);
      if (this.attached) {
        if (this._doResize(mode)) {
          this.render();
        }
      }
    }
    ensureScalesHaveIDs() {
      const options = this.options;
      const scalesOptions = options.scales || {};
      each(scalesOptions, (axisOptions, axisID) => {
        axisOptions.id = axisID;
      });
    }
    buildOrUpdateScales() {
      const options = this.options;
      const scaleOpts = options.scales;
      const scales2 = this.scales;
      const updated = Object.keys(scales2).reduce((obj, id) => {
        obj[id] = false;
        return obj;
      }, {});
      let items = [];
      if (scaleOpts) {
        items = items.concat(Object.keys(scaleOpts).map((id) => {
          const scaleOptions = scaleOpts[id];
          const axis = determineAxis(id, scaleOptions);
          const isRadial = axis === "r";
          const isHorizontal = axis === "x";
          return {
            options: scaleOptions,
            dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
            dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
          };
        }));
      }
      each(items, (item) => {
        const scaleOptions = item.options;
        const id = scaleOptions.id;
        const axis = determineAxis(id, scaleOptions);
        const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
        if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
          scaleOptions.position = item.dposition;
        }
        updated[id] = true;
        let scale = null;
        if (id in scales2 && scales2[id].type === scaleType) {
          scale = scales2[id];
        } else {
          const scaleClass = registry.getScale(scaleType);
          scale = new scaleClass({
            id,
            type: scaleType,
            ctx: this.ctx,
            chart: this
          });
          scales2[scale.id] = scale;
        }
        scale.init(scaleOptions, options);
      });
      each(updated, (hasUpdated, id) => {
        if (!hasUpdated) {
          delete scales2[id];
        }
      });
      each(scales2, (scale) => {
        layouts.configure(this, scale, scale.options);
        layouts.addBox(this, scale);
      });
    }
    _updateMetasets() {
      const metasets = this._metasets;
      const numData = this.data.datasets.length;
      const numMeta = metasets.length;
      metasets.sort((a, b) => a.index - b.index);
      if (numMeta > numData) {
        for (let i = numData; i < numMeta; ++i) {
          this._destroyDatasetMeta(i);
        }
        metasets.splice(numData, numMeta - numData);
      }
      this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
    }
    _removeUnreferencedMetasets() {
      const { _metasets: metasets, data: { datasets } } = this;
      if (metasets.length > datasets.length) {
        delete this._stacks;
      }
      metasets.forEach((meta, index2) => {
        if (datasets.filter((x) => x === meta._dataset).length === 0) {
          this._destroyDatasetMeta(index2);
        }
      });
    }
    buildOrUpdateControllers() {
      const newControllers = [];
      const datasets = this.data.datasets;
      let i, ilen;
      this._removeUnreferencedMetasets();
      for (i = 0, ilen = datasets.length; i < ilen; i++) {
        const dataset = datasets[i];
        let meta = this.getDatasetMeta(i);
        const type = dataset.type || this.config.type;
        if (meta.type && meta.type !== type) {
          this._destroyDatasetMeta(i);
          meta = this.getDatasetMeta(i);
        }
        meta.type = type;
        meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
        meta.order = dataset.order || 0;
        meta.index = i;
        meta.label = "" + dataset.label;
        meta.visible = this.isDatasetVisible(i);
        if (meta.controller) {
          meta.controller.updateIndex(i);
          meta.controller.linkScales();
        } else {
          const ControllerClass = registry.getController(type);
          const { datasetElementType, dataElementType } = defaults.datasets[type];
          Object.assign(ControllerClass, {
            dataElementType: registry.getElement(dataElementType),
            datasetElementType: datasetElementType && registry.getElement(datasetElementType)
          });
          meta.controller = new ControllerClass(this, i);
          newControllers.push(meta.controller);
        }
      }
      this._updateMetasets();
      return newControllers;
    }
    _resetElements() {
      each(this.data.datasets, (dataset, datasetIndex) => {
        this.getDatasetMeta(datasetIndex).controller.reset();
      }, this);
    }
    reset() {
      this._resetElements();
      this.notifyPlugins("reset");
    }
    update(mode) {
      const config = this.config;
      config.update();
      const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
      const animsDisabled = this._animationsDisabled = !options.animation;
      this._updateScales();
      this._checkEventBindings();
      this._updateHiddenIndices();
      this._plugins.invalidate();
      if (this.notifyPlugins("beforeUpdate", {
        mode,
        cancelable: true
      }) === false) {
        return;
      }
      const newControllers = this.buildOrUpdateControllers();
      this.notifyPlugins("beforeElementsUpdate");
      let minPadding = 0;
      for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
        const { controller } = this.getDatasetMeta(i);
        const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
        controller.buildOrUpdateElements(reset);
        minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
      }
      minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
      this._updateLayout(minPadding);
      if (!animsDisabled) {
        each(newControllers, (controller) => {
          controller.reset();
        });
      }
      this._updateDatasets(mode);
      this.notifyPlugins("afterUpdate", {
        mode
      });
      this._layers.sort(compare2Level("z", "_idx"));
      const { _active, _lastEvent } = this;
      if (_lastEvent) {
        this._eventHandler(_lastEvent, true);
      } else if (_active.length) {
        this._updateHoverStyles(_active, _active, true);
      }
      this.render();
    }
    _updateScales() {
      each(this.scales, (scale) => {
        layouts.removeBox(this, scale);
      });
      this.ensureScalesHaveIDs();
      this.buildOrUpdateScales();
    }
    _checkEventBindings() {
      const options = this.options;
      const existingEvents = new Set(Object.keys(this._listeners));
      const newEvents = new Set(options.events);
      if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
        this.unbindEvents();
        this.bindEvents();
      }
    }
    _updateHiddenIndices() {
      const { _hiddenIndices } = this;
      const changes = this._getUniformDataChanges() || [];
      for (const { method, start, count } of changes) {
        const move = method === "_removeElements" ? -count : count;
        moveNumericKeys(_hiddenIndices, start, move);
      }
    }
    _getUniformDataChanges() {
      const _dataChanges = this._dataChanges;
      if (!_dataChanges || !_dataChanges.length) {
        return;
      }
      this._dataChanges = [];
      const datasetCount = this.data.datasets.length;
      const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
      const changeSet = makeSet(0);
      for (let i = 1; i < datasetCount; i++) {
        if (!setsEqual(changeSet, makeSet(i))) {
          return;
        }
      }
      return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({
        method: a[1],
        start: +a[2],
        count: +a[3]
      }));
    }
    _updateLayout(minPadding) {
      if (this.notifyPlugins("beforeLayout", {
        cancelable: true
      }) === false) {
        return;
      }
      layouts.update(this, this.width, this.height, minPadding);
      const area = this.chartArea;
      const noArea = area.width <= 0 || area.height <= 0;
      this._layers = [];
      each(this.boxes, (box) => {
        if (noArea && box.position === "chartArea") {
          return;
        }
        if (box.configure) {
          box.configure();
        }
        this._layers.push(...box._layers());
      }, this);
      this._layers.forEach((item, index2) => {
        item._idx = index2;
      });
      this.notifyPlugins("afterLayout");
    }
    _updateDatasets(mode) {
      if (this.notifyPlugins("beforeDatasetsUpdate", {
        mode,
        cancelable: true
      }) === false) {
        return;
      }
      for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        this.getDatasetMeta(i).controller.configure();
      }
      for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        this._updateDataset(i, isFunction(mode) ? mode({
          datasetIndex: i
        }) : mode);
      }
      this.notifyPlugins("afterDatasetsUpdate", {
        mode
      });
    }
    _updateDataset(index2, mode) {
      const meta = this.getDatasetMeta(index2);
      const args = {
        meta,
        index: index2,
        mode,
        cancelable: true
      };
      if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
        return;
      }
      meta.controller._update(mode);
      args.cancelable = false;
      this.notifyPlugins("afterDatasetUpdate", args);
    }
    render() {
      if (this.notifyPlugins("beforeRender", {
        cancelable: true
      }) === false) {
        return;
      }
      if (animator.has(this)) {
        if (this.attached && !animator.running(this)) {
          animator.start(this);
        }
      } else {
        this.draw();
        onAnimationsComplete({
          chart: this
        });
      }
    }
    draw() {
      let i;
      if (this._resizeBeforeDraw) {
        const { width, height } = this._resizeBeforeDraw;
        this._resize(width, height);
        this._resizeBeforeDraw = null;
      }
      this.clear();
      if (this.width <= 0 || this.height <= 0) {
        return;
      }
      if (this.notifyPlugins("beforeDraw", {
        cancelable: true
      }) === false) {
        return;
      }
      const layers = this._layers;
      for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
        layers[i].draw(this.chartArea);
      }
      this._drawDatasets();
      for (; i < layers.length; ++i) {
        layers[i].draw(this.chartArea);
      }
      this.notifyPlugins("afterDraw");
    }
    _getSortedDatasetMetas(filterVisible) {
      const metasets = this._sortedMetasets;
      const result = [];
      let i, ilen;
      for (i = 0, ilen = metasets.length; i < ilen; ++i) {
        const meta = metasets[i];
        if (!filterVisible || meta.visible) {
          result.push(meta);
        }
      }
      return result;
    }
    getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(true);
    }
    _drawDatasets() {
      if (this.notifyPlugins("beforeDatasetsDraw", {
        cancelable: true
      }) === false) {
        return;
      }
      const metasets = this.getSortedVisibleDatasetMetas();
      for (let i = metasets.length - 1; i >= 0; --i) {
        this._drawDataset(metasets[i]);
      }
      this.notifyPlugins("afterDatasetsDraw");
    }
    _drawDataset(meta) {
      const ctx = this.ctx;
      const clip = meta._clip;
      const useClip = !clip.disabled;
      const area = getDatasetArea(meta, this.chartArea);
      const args = {
        meta,
        index: meta.index,
        cancelable: true
      };
      if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
        return;
      }
      if (useClip) {
        clipArea(ctx, {
          left: clip.left === false ? 0 : area.left - clip.left,
          right: clip.right === false ? this.width : area.right + clip.right,
          top: clip.top === false ? 0 : area.top - clip.top,
          bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
        });
      }
      meta.controller.draw();
      if (useClip) {
        unclipArea(ctx);
      }
      args.cancelable = false;
      this.notifyPlugins("afterDatasetDraw", args);
    }
    isPointInArea(point) {
      return _isPointInArea(point, this.chartArea, this._minPadding);
    }
    getElementsAtEventForMode(e, mode, options, useFinalPosition) {
      const method = Interaction.modes[mode];
      if (typeof method === "function") {
        return method(this, e, options, useFinalPosition);
      }
      return [];
    }
    getDatasetMeta(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      const metasets = this._metasets;
      let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
      if (!meta) {
        meta = {
          type: null,
          data: [],
          dataset: null,
          controller: null,
          hidden: null,
          xAxisID: null,
          yAxisID: null,
          order: dataset && dataset.order || 0,
          index: datasetIndex,
          _dataset: dataset,
          _parsed: [],
          _sorted: false
        };
        metasets.push(meta);
      }
      return meta;
    }
    getContext() {
      return this.$context || (this.$context = createContext(null, {
        chart: this,
        type: "chart"
      }));
    }
    getVisibleDatasetCount() {
      return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      if (!dataset) {
        return false;
      }
      const meta = this.getDatasetMeta(datasetIndex);
      return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
    }
    setDatasetVisibility(datasetIndex, visible) {
      const meta = this.getDatasetMeta(datasetIndex);
      meta.hidden = !visible;
    }
    toggleDataVisibility(index2) {
      this._hiddenIndices[index2] = !this._hiddenIndices[index2];
    }
    getDataVisibility(index2) {
      return !this._hiddenIndices[index2];
    }
    _updateVisibility(datasetIndex, dataIndex, visible) {
      const mode = visible ? "show" : "hide";
      const meta = this.getDatasetMeta(datasetIndex);
      const anims = meta.controller._resolveAnimations(void 0, mode);
      if (defined(dataIndex)) {
        meta.data[dataIndex].hidden = !visible;
        this.update();
      } else {
        this.setDatasetVisibility(datasetIndex, visible);
        anims.update(meta, {
          visible
        });
        this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
      }
    }
    hide(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, false);
    }
    show(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, true);
    }
    _destroyDatasetMeta(datasetIndex) {
      const meta = this._metasets[datasetIndex];
      if (meta && meta.controller) {
        meta.controller._destroy();
      }
      delete this._metasets[datasetIndex];
    }
    _stop() {
      let i, ilen;
      this.stop();
      animator.remove(this);
      for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        this._destroyDatasetMeta(i);
      }
    }
    destroy() {
      this.notifyPlugins("beforeDestroy");
      const { canvas, ctx } = this;
      this._stop();
      this.config.clearCache();
      if (canvas) {
        this.unbindEvents();
        clearCanvas(canvas, ctx);
        this.platform.releaseContext(ctx);
        this.canvas = null;
        this.ctx = null;
      }
      delete instances[this.id];
      this.notifyPlugins("afterDestroy");
    }
    toBase64Image(...args) {
      return this.canvas.toDataURL(...args);
    }
    bindEvents() {
      this.bindUserEvents();
      if (this.options.responsive) {
        this.bindResponsiveEvents();
      } else {
        this.attached = true;
      }
    }
    bindUserEvents() {
      const listeners = this._listeners;
      const platform = this.platform;
      const _add = (type, listener2) => {
        platform.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const listener = (e, x, y) => {
        e.offsetX = x;
        e.offsetY = y;
        this._eventHandler(e);
      };
      each(this.options.events, (type) => _add(type, listener));
    }
    bindResponsiveEvents() {
      if (!this._responsiveListeners) {
        this._responsiveListeners = {};
      }
      const listeners = this._responsiveListeners;
      const platform = this.platform;
      const _add = (type, listener2) => {
        platform.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const _remove = (type, listener2) => {
        if (listeners[type]) {
          platform.removeEventListener(this, type, listener2);
          delete listeners[type];
        }
      };
      const listener = (width, height) => {
        if (this.canvas) {
          this.resize(width, height);
        }
      };
      let detached;
      const attached = () => {
        _remove("attach", attached);
        this.attached = true;
        this.resize();
        _add("resize", listener);
        _add("detach", detached);
      };
      detached = () => {
        this.attached = false;
        _remove("resize", listener);
        this._stop();
        this._resize(0, 0);
        _add("attach", attached);
      };
      if (platform.isAttached(this.canvas)) {
        attached();
      } else {
        detached();
      }
    }
    unbindEvents() {
      each(this._listeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._listeners = {};
      each(this._responsiveListeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._responsiveListeners = void 0;
    }
    updateHoverStyle(items, mode, enabled) {
      const prefix = enabled ? "set" : "remove";
      let meta, item, i, ilen;
      if (mode === "dataset") {
        meta = this.getDatasetMeta(items[0].datasetIndex);
        meta.controller["_" + prefix + "DatasetHoverStyle"]();
      }
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        item = items[i];
        const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
        if (controller) {
          controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
        }
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements) {
      const lastActive = this._active || [];
      const active = activeElements.map(({ datasetIndex, index: index2 }) => {
        const meta = this.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("No dataset found at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index2],
          index: index2
        };
      });
      const changed = !_elementsEqual(active, lastActive);
      if (changed) {
        this._active = active;
        this._lastEvent = null;
        this._updateHoverStyles(active, lastActive);
      }
    }
    notifyPlugins(hook, args, filter) {
      return this._plugins.notify(this, hook, args, filter);
    }
    isPluginEnabled(pluginId) {
      return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
    }
    _updateHoverStyles(active, lastActive, replay) {
      const hoverOptions = this.options.hover;
      const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
      const deactivated = diff(lastActive, active);
      const activated = replay ? active : diff(active, lastActive);
      if (deactivated.length) {
        this.updateHoverStyle(deactivated, hoverOptions.mode, false);
      }
      if (activated.length && hoverOptions.mode) {
        this.updateHoverStyle(activated, hoverOptions.mode, true);
      }
    }
    _eventHandler(e, replay) {
      const args = {
        event: e,
        replay,
        cancelable: true,
        inChartArea: this.isPointInArea(e)
      };
      const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
      if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
        return;
      }
      const changed = this._handleEvent(e, replay, args.inChartArea);
      args.cancelable = false;
      this.notifyPlugins("afterEvent", args, eventFilter);
      if (changed || args.changed) {
        this.render();
      }
      return this;
    }
    _handleEvent(e, replay, inChartArea) {
      const { _active: lastActive = [], options } = this;
      const useFinalPosition = replay;
      const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
      const isClick = _isClickEvent(e);
      const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
      if (inChartArea) {
        this._lastEvent = null;
        callback(options.onHover, [
          e,
          active,
          this
        ], this);
        if (isClick) {
          callback(options.onClick, [
            e,
            active,
            this
          ], this);
        }
      }
      const changed = !_elementsEqual(active, lastActive);
      if (changed || replay) {
        this._active = active;
        this._updateHoverStyles(active, lastActive, replay);
      }
      this._lastEvent = lastEvent;
      return changed;
    }
    _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
      if (e.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive;
      }
      const hoverOptions = this.options.hover;
      return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
    }
  };
  __publicField(Chart, "defaults", defaults);
  __publicField(Chart, "instances", instances);
  __publicField(Chart, "overrides", overrides);
  __publicField(Chart, "registry", registry);
  __publicField(Chart, "version", version);
  __publicField(Chart, "getChart", getChart);
  function invalidatePlugins() {
    return each(Chart.instances, (chart) => chart._plugins.invalidate());
  }
  function clipArc(ctx, element, endAngle) {
    const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
    let angleMargin = pixelMargin / outerRadius;
    ctx.beginPath();
    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
    if (innerRadius > pixelMargin) {
      angleMargin = pixelMargin / innerRadius;
      ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
    } else {
      ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
    }
    ctx.closePath();
    ctx.clip();
  }
  function toRadiusCorners(value) {
    return _readValueToProps(value, [
      "outerStart",
      "outerEnd",
      "innerStart",
      "innerEnd"
    ]);
  }
  function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
    const o = toRadiusCorners(arc.options.borderRadius);
    const halfThickness = (outerRadius - innerRadius) / 2;
    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
    const computeOuterLimit = (val) => {
      const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
      return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
    };
    return {
      outerStart: computeOuterLimit(o.outerStart),
      outerEnd: computeOuterLimit(o.outerEnd),
      innerStart: _limitValue(o.innerStart, 0, innerLimit),
      innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
    };
  }
  function rThetaToXY(r, theta, x, y) {
    return {
      x: x + r * Math.cos(theta),
      y: y + r * Math.sin(theta)
    };
  }
  function pathArc(ctx, element, offset, spacing, end, circular) {
    const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
    let spacingOffset = 0;
    const alpha2 = end - start;
    if (spacing) {
      const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
      const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
      const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
      const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
      spacingOffset = (alpha2 - adjustedAngle) / 2;
    }
    const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
    const angleOffset = (alpha2 - beta) / 2;
    const startAngle = start + angleOffset + spacingOffset;
    const endAngle = end - angleOffset - spacingOffset;
    const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
    const outerStartAdjustedRadius = outerRadius - outerStart;
    const outerEndAdjustedRadius = outerRadius - outerEnd;
    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
    const innerStartAdjustedRadius = innerRadius + innerStart;
    const innerEndAdjustedRadius = innerRadius + innerEnd;
    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
    ctx.beginPath();
    if (circular) {
      const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
      ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
      ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
      if (outerEnd > 0) {
        const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
      }
      const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
      ctx.lineTo(p4.x, p4.y);
      if (innerEnd > 0) {
        const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
      }
      const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
      ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
      ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
      if (innerStart > 0) {
        const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
      }
      const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
      ctx.lineTo(p8.x, p8.y);
      if (outerStart > 0) {
        const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
      }
    } else {
      ctx.moveTo(x, y);
      const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
      const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
      ctx.lineTo(outerStartX, outerStartY);
      const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
      const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
      ctx.lineTo(outerEndX, outerEndY);
    }
    ctx.closePath();
  }
  function drawArc(ctx, element, offset, spacing, circular) {
    const { fullCircles, startAngle, circumference } = element;
    let endAngle = element.endAngle;
    if (fullCircles) {
      pathArc(ctx, element, offset, spacing, endAngle, circular);
      for (let i = 0; i < fullCircles; ++i) {
        ctx.fill();
      }
      if (!isNaN(circumference)) {
        endAngle = startAngle + (circumference % TAU || TAU);
      }
    }
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.fill();
    return endAngle;
  }
  function drawBorder(ctx, element, offset, spacing, circular) {
    const { fullCircles, startAngle, circumference, options } = element;
    const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } = options;
    const inner = options.borderAlign === "inner";
    if (!borderWidth) {
      return;
    }
    ctx.setLineDash(borderDash || []);
    ctx.lineDashOffset = borderDashOffset;
    if (inner) {
      ctx.lineWidth = borderWidth * 2;
      ctx.lineJoin = borderJoinStyle || "round";
    } else {
      ctx.lineWidth = borderWidth;
      ctx.lineJoin = borderJoinStyle || "bevel";
    }
    let endAngle = element.endAngle;
    if (fullCircles) {
      pathArc(ctx, element, offset, spacing, endAngle, circular);
      for (let i = 0; i < fullCircles; ++i) {
        ctx.stroke();
      }
      if (!isNaN(circumference)) {
        endAngle = startAngle + (circumference % TAU || TAU);
      }
    }
    if (inner) {
      clipArc(ctx, element, endAngle);
    }
    if (!fullCircles) {
      pathArc(ctx, element, offset, spacing, endAngle, circular);
      ctx.stroke();
    }
  }
  var ArcElement = class extends Element {
    constructor(cfg) {
      super();
      __publicField(this, "circumference");
      __publicField(this, "endAngle");
      __publicField(this, "fullCircles");
      __publicField(this, "innerRadius");
      __publicField(this, "outerRadius");
      __publicField(this, "pixelMargin");
      __publicField(this, "startAngle");
      this.options = void 0;
      this.circumference = void 0;
      this.startAngle = void 0;
      this.endAngle = void 0;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.pixelMargin = 0;
      this.fullCircles = 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(chartX, chartY, useFinalPosition) {
      const point = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      const { angle, distance } = getAngleFromPoint(point, {
        x: chartX,
        y: chartY
      });
      const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "circumference"
      ], useFinalPosition);
      const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
      const _circumference = valueOrDefault(circumference, endAngle - startAngle);
      const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
      const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
      return betweenAngles && withinRadius;
    }
    getCenterPoint(useFinalPosition) {
      const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ], useFinalPosition);
      const { offset, spacing } = this.options;
      const halfAngle = (startAngle + endAngle) / 2;
      const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
      return {
        x: x + Math.cos(halfAngle) * halfRadius,
        y: y + Math.sin(halfAngle) * halfRadius
      };
    }
    tooltipPosition(useFinalPosition) {
      return this.getCenterPoint(useFinalPosition);
    }
    draw(ctx) {
      const { options, circumference } = this;
      const offset = (options.offset || 0) / 4;
      const spacing = (options.spacing || 0) / 2;
      const circular = options.circular;
      this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
      this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
      if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
        return;
      }
      ctx.save();
      const halfAngle = (this.startAngle + this.endAngle) / 2;
      ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
      const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
      const radiusOffset = offset * fix;
      ctx.fillStyle = options.backgroundColor;
      ctx.strokeStyle = options.borderColor;
      drawArc(ctx, this, radiusOffset, spacing, circular);
      drawBorder(ctx, this, radiusOffset, spacing, circular);
      ctx.restore();
    }
  };
  __publicField(ArcElement, "id", "arc");
  __publicField(ArcElement, "defaults", {
    borderAlign: "center",
    borderColor: "#fff",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: true
  });
  __publicField(ArcElement, "defaultRoutes", {
    backgroundColor: "backgroundColor"
  });
  __publicField(ArcElement, "descriptors", {
    _scriptable: true,
    _indexable: (name) => name !== "borderDash"
  });
  function setStyle(ctx, options, style = options) {
    ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
    ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
    ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
    ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
    ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
    ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
  }
  function lineTo(ctx, previous, target) {
    ctx.lineTo(target.x, target.y);
  }
  function getLineMethod(options) {
    if (options.stepped) {
      return _steppedLineTo;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierCurveTo;
    }
    return lineTo;
  }
  function pathVars(points, segment, params = {}) {
    const count = points.length;
    const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
    const { start: segmentStart, end: segmentEnd } = segment;
    const start = Math.max(paramsStart, segmentStart);
    const end = Math.min(paramsEnd, segmentEnd);
    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
    return {
      count,
      start,
      loop: segment.loop,
      ilen: end < start && !outside ? count + end - start : end - start
    };
  }
  function pathSegment(ctx, line, segment, params) {
    const { points, options } = line;
    const { count, start, loop, ilen } = pathVars(points, segment, params);
    const lineMethod = getLineMethod(options);
    let { move = true, reverse } = params || {};
    let i, point, prev;
    for (i = 0; i <= ilen; ++i) {
      point = points[(start + (reverse ? ilen - i : i)) % count];
      if (point.skip) {
        continue;
      } else if (move) {
        ctx.moveTo(point.x, point.y);
        move = false;
      } else {
        lineMethod(ctx, prev, point, reverse, options.stepped);
      }
      prev = point;
    }
    if (loop) {
      point = points[(start + (reverse ? ilen : 0)) % count];
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    return !!loop;
  }
  function fastPathSegment(ctx, line, segment, params) {
    const points = line.points;
    const { count, start, ilen } = pathVars(points, segment, params);
    const { move = true, reverse } = params || {};
    let avgX = 0;
    let countX = 0;
    let i, point, prevX, minY, maxY, lastY;
    const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
    const drawX = () => {
      if (minY !== maxY) {
        ctx.lineTo(avgX, maxY);
        ctx.lineTo(avgX, minY);
        ctx.lineTo(avgX, lastY);
      }
    };
    if (move) {
      point = points[pointIndex(0)];
      ctx.moveTo(point.x, point.y);
    }
    for (i = 0; i <= ilen; ++i) {
      point = points[pointIndex(i)];
      if (point.skip) {
        continue;
      }
      const x = point.x;
      const y = point.y;
      const truncX = x | 0;
      if (truncX === prevX) {
        if (y < minY) {
          minY = y;
        } else if (y > maxY) {
          maxY = y;
        }
        avgX = (countX * avgX + x) / ++countX;
      } else {
        drawX();
        ctx.lineTo(x, y);
        prevX = truncX;
        countX = 0;
        minY = maxY = y;
      }
      lastY = y;
    }
    drawX();
  }
  function _getSegmentMethod(line) {
    const opts = line.options;
    const borderDash = opts.borderDash && opts.borderDash.length;
    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
    return useFastPath ? fastPathSegment : pathSegment;
  }
  function _getInterpolationMethod(options) {
    if (options.stepped) {
      return _steppedInterpolation;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierInterpolation;
    }
    return _pointInLine;
  }
  function strokePathWithCache(ctx, line, start, count) {
    let path = line._path;
    if (!path) {
      path = line._path = new Path2D();
      if (line.path(path, start, count)) {
        path.closePath();
      }
    }
    setStyle(ctx, line.options);
    ctx.stroke(path);
  }
  function strokePathDirect(ctx, line, start, count) {
    const { segments, options } = line;
    const segmentMethod = _getSegmentMethod(line);
    for (const segment of segments) {
      setStyle(ctx, options, segment.style);
      ctx.beginPath();
      if (segmentMethod(ctx, line, segment, {
        start,
        end: start + count - 1
      })) {
        ctx.closePath();
      }
      ctx.stroke();
    }
  }
  var usePath2D = typeof Path2D === "function";
  function draw(ctx, line, start, count) {
    if (usePath2D && !line.options.segment) {
      strokePathWithCache(ctx, line, start, count);
    } else {
      strokePathDirect(ctx, line, start, count);
    }
  }
  var LineElement = class extends Element {
    constructor(cfg) {
      super();
      this.animated = true;
      this.options = void 0;
      this._chart = void 0;
      this._loop = void 0;
      this._fullLoop = void 0;
      this._path = void 0;
      this._points = void 0;
      this._segments = void 0;
      this._decimated = false;
      this._pointsUpdated = false;
      this._datasetIndex = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    updateControlPoints(chartArea, indexAxis) {
      const options = this.options;
      if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
        const loop = options.spanGaps ? this._loop : this._fullLoop;
        _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
        this._pointsUpdated = true;
      }
    }
    set points(points) {
      this._points = points;
      delete this._segments;
      delete this._path;
      this._pointsUpdated = false;
    }
    get points() {
      return this._points;
    }
    get segments() {
      return this._segments || (this._segments = _computeSegments(this, this.options.segment));
    }
    first() {
      const segments = this.segments;
      const points = this.points;
      return segments.length && points[segments[0].start];
    }
    last() {
      const segments = this.segments;
      const points = this.points;
      const count = segments.length;
      return count && points[segments[count - 1].end];
    }
    interpolate(point, property) {
      const options = this.options;
      const value = point[property];
      const points = this.points;
      const segments = _boundSegments(this, {
        property,
        start: value,
        end: value
      });
      if (!segments.length) {
        return;
      }
      const result = [];
      const _interpolate = _getInterpolationMethod(options);
      let i, ilen;
      for (i = 0, ilen = segments.length; i < ilen; ++i) {
        const { start, end } = segments[i];
        const p1 = points[start];
        const p2 = points[end];
        if (p1 === p2) {
          result.push(p1);
          continue;
        }
        const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
        const interpolated = _interpolate(p1, p2, t, options.stepped);
        interpolated[property] = point[property];
        result.push(interpolated);
      }
      return result.length === 1 ? result[0] : result;
    }
    pathSegment(ctx, segment, params) {
      const segmentMethod = _getSegmentMethod(this);
      return segmentMethod(ctx, this, segment, params);
    }
    path(ctx, start, count) {
      const segments = this.segments;
      const segmentMethod = _getSegmentMethod(this);
      let loop = this._loop;
      start = start || 0;
      count = count || this.points.length - start;
      for (const segment of segments) {
        loop &= segmentMethod(ctx, this, segment, {
          start,
          end: start + count - 1
        });
      }
      return !!loop;
    }
    draw(ctx, chartArea, start, count) {
      const options = this.options || {};
      const points = this.points || [];
      if (points.length && options.borderWidth) {
        ctx.save();
        draw(ctx, this, start, count);
        ctx.restore();
      }
      if (this.animated) {
        this._pointsUpdated = false;
        this._path = void 0;
      }
    }
  };
  __publicField(LineElement, "id", "line");
  __publicField(LineElement, "defaults", {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: true,
    cubicInterpolationMode: "default",
    fill: false,
    spanGaps: false,
    stepped: false,
    tension: 0
  });
  __publicField(LineElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  __publicField(LineElement, "descriptors", {
    _scriptable: true,
    _indexable: (name) => name !== "borderDash" && name !== "fill"
  });
  function inRange$1(el, pos, axis, useFinalPosition) {
    const options = el.options;
    const { [axis]: value } = el.getProps([
      axis
    ], useFinalPosition);
    return Math.abs(pos - value) < options.radius + options.hitRadius;
  }
  var PointElement = class extends Element {
    constructor(cfg) {
      super();
      __publicField(this, "parsed");
      __publicField(this, "skip");
      __publicField(this, "stop");
      this.options = void 0;
      this.parsed = void 0;
      this.skip = void 0;
      this.stop = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      const options = this.options;
      const { x, y } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange$1(this, mouseX, "x", useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange$1(this, mouseY, "y", useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x, y } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return {
        x,
        y
      };
    }
    size(options) {
      options = options || this.options || {};
      let radius = options.radius || 0;
      radius = Math.max(radius, radius && options.hoverRadius || 0);
      const borderWidth = radius && options.borderWidth || 0;
      return (radius + borderWidth) * 2;
    }
    draw(ctx, area) {
      const options = this.options;
      if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
        return;
      }
      ctx.strokeStyle = options.borderColor;
      ctx.lineWidth = options.borderWidth;
      ctx.fillStyle = options.backgroundColor;
      drawPoint(ctx, options, this.x, this.y);
    }
    getRange() {
      const options = this.options || {};
      return options.radius + options.hitRadius;
    }
  };
  __publicField(PointElement, "id", "point");
  /**
  * @type {any}
  */
  __publicField(PointElement, "defaults", {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  });
  /**
  * @type {any}
  */
  __publicField(PointElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  function getBarBounds(bar, useFinalPosition) {
    const { x, y, base, width, height } = bar.getProps([
      "x",
      "y",
      "base",
      "width",
      "height"
    ], useFinalPosition);
    let left, right, top2, bottom2, half;
    if (bar.horizontal) {
      half = height / 2;
      left = Math.min(x, base);
      right = Math.max(x, base);
      top2 = y - half;
      bottom2 = y + half;
    } else {
      half = width / 2;
      left = x - half;
      right = x + half;
      top2 = Math.min(y, base);
      bottom2 = Math.max(y, base);
    }
    return {
      left,
      top: top2,
      right,
      bottom: bottom2
    };
  }
  function skipOrLimit(skip2, value, min, max) {
    return skip2 ? 0 : _limitValue(value, min, max);
  }
  function parseBorderWidth(bar, maxW, maxH) {
    const value = bar.options.borderWidth;
    const skip2 = bar.borderSkipped;
    const o = toTRBL(value);
    return {
      t: skipOrLimit(skip2.top, o.top, 0, maxH),
      r: skipOrLimit(skip2.right, o.right, 0, maxW),
      b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
      l: skipOrLimit(skip2.left, o.left, 0, maxW)
    };
  }
  function parseBorderRadius(bar, maxW, maxH) {
    const { enableBorderRadius } = bar.getProps([
      "enableBorderRadius"
    ]);
    const value = bar.options.borderRadius;
    const o = toTRBLCorners(value);
    const maxR = Math.min(maxW, maxH);
    const skip2 = bar.borderSkipped;
    const enableBorder = enableBorderRadius || isObject2(value);
    return {
      topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
      topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
      bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
      bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
    };
  }
  function boundingRects(bar) {
    const bounds = getBarBounds(bar);
    const width = bounds.right - bounds.left;
    const height = bounds.bottom - bounds.top;
    const border = parseBorderWidth(bar, width / 2, height / 2);
    const radius = parseBorderRadius(bar, width / 2, height / 2);
    return {
      outer: {
        x: bounds.left,
        y: bounds.top,
        w: width,
        h: height,
        radius
      },
      inner: {
        x: bounds.left + border.l,
        y: bounds.top + border.t,
        w: width - border.l - border.r,
        h: height - border.t - border.b,
        radius: {
          topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
          topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
          bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
          bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
        }
      }
    };
  }
  function inRange(bar, x, y, useFinalPosition) {
    const skipX = x === null;
    const skipY = y === null;
    const skipBoth = skipX && skipY;
    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
    return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
  }
  function hasRadius(radius) {
    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
  }
  function addNormalRectPath(ctx, rect) {
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
  }
  function inflateRect(rect, amount, refRect = {}) {
    const x = rect.x !== refRect.x ? -amount : 0;
    const y = rect.y !== refRect.y ? -amount : 0;
    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
    return {
      x: rect.x + x,
      y: rect.y + y,
      w: rect.w + w,
      h: rect.h + h,
      radius: rect.radius
    };
  }
  var BarElement = class extends Element {
    constructor(cfg) {
      super();
      this.options = void 0;
      this.horizontal = void 0;
      this.base = void 0;
      this.width = void 0;
      this.height = void 0;
      this.inflateAmount = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    draw(ctx) {
      const { inflateAmount, options: { borderColor, backgroundColor } } = this;
      const { inner, outer } = boundingRects(this);
      const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
      ctx.save();
      if (outer.w !== inner.w || outer.h !== inner.h) {
        ctx.beginPath();
        addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
        ctx.clip();
        addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
        ctx.fillStyle = borderColor;
        ctx.fill("evenodd");
      }
      ctx.beginPath();
      addRectPath(ctx, inflateRect(inner, inflateAmount));
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      return inRange(this, mouseX, mouseY, useFinalPosition);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange(this, mouseX, null, useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange(this, null, mouseY, useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x, y, base, horizontal } = this.getProps([
        "x",
        "y",
        "base",
        "horizontal"
      ], useFinalPosition);
      return {
        x: horizontal ? (x + base) / 2 : x,
        y: horizontal ? y : (y + base) / 2
      };
    }
    getRange(axis) {
      return axis === "x" ? this.width / 2 : this.height / 2;
    }
  };
  __publicField(BarElement, "id", "bar");
  __publicField(BarElement, "defaults", {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  });
  __publicField(BarElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  var elements = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ArcElement,
    BarElement,
    LineElement,
    PointElement
  });
  var BORDER_COLORS = [
    "rgb(54, 162, 235)",
    "rgb(255, 99, 132)",
    "rgb(255, 159, 64)",
    "rgb(255, 205, 86)",
    "rgb(75, 192, 192)",
    "rgb(153, 102, 255)",
    "rgb(201, 203, 207)"
    // grey
  ];
  var BACKGROUND_COLORS = /* @__PURE__ */ BORDER_COLORS.map((color2) => color2.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
  function getBorderColor(i) {
    return BORDER_COLORS[i % BORDER_COLORS.length];
  }
  function getBackgroundColor(i) {
    return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
  }
  function colorizeDefaultDataset(dataset, i) {
    dataset.borderColor = getBorderColor(i);
    dataset.backgroundColor = getBackgroundColor(i);
    return ++i;
  }
  function colorizeDoughnutDataset(dataset, i) {
    dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));
    return i;
  }
  function colorizePolarAreaDataset(dataset, i) {
    dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));
    return i;
  }
  function getColorizer(chart) {
    let i = 0;
    return (dataset, datasetIndex) => {
      const controller = chart.getDatasetMeta(datasetIndex).controller;
      if (controller instanceof DoughnutController) {
        i = colorizeDoughnutDataset(dataset, i);
      } else if (controller instanceof PolarAreaController) {
        i = colorizePolarAreaDataset(dataset, i);
      } else if (controller) {
        i = colorizeDefaultDataset(dataset, i);
      }
    };
  }
  function containsColorsDefinitions(descriptors2) {
    let k;
    for (k in descriptors2) {
      if (descriptors2[k].borderColor || descriptors2[k].backgroundColor) {
        return true;
      }
    }
    return false;
  }
  function containsColorsDefinition(descriptor) {
    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
  }
  var plugin_colors = {
    id: "colors",
    defaults: {
      enabled: true,
      forceOverride: false
    },
    beforeLayout(chart, _args, options) {
      if (!options.enabled) {
        return;
      }
      const { data: { datasets }, options: chartOptions } = chart.config;
      const { elements: elements2 } = chartOptions;
      if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2))) {
        return;
      }
      const colorizer = getColorizer(chart);
      datasets.forEach(colorizer);
    }
  };
  function lttbDecimation(data, start, count, availableWidth, options) {
    const samples = options.samples || availableWidth;
    if (samples >= count) {
      return data.slice(start, start + count);
    }
    const decimated = [];
    const bucketWidth = (count - 2) / (samples - 2);
    let sampledIndex = 0;
    const endIndex = start + count - 1;
    let a = start;
    let i, maxAreaPoint, maxArea, area, nextA;
    decimated[sampledIndex++] = data[a];
    for (i = 0; i < samples - 2; i++) {
      let avgX = 0;
      let avgY = 0;
      let j;
      const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
      const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
      const avgRangeLength = avgRangeEnd - avgRangeStart;
      for (j = avgRangeStart; j < avgRangeEnd; j++) {
        avgX += data[j].x;
        avgY += data[j].y;
      }
      avgX /= avgRangeLength;
      avgY /= avgRangeLength;
      const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
      const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
      const { x: pointAx, y: pointAy } = data[a];
      maxArea = area = -1;
      for (j = rangeOffs; j < rangeTo; j++) {
        area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
        if (area > maxArea) {
          maxArea = area;
          maxAreaPoint = data[j];
          nextA = j;
        }
      }
      decimated[sampledIndex++] = maxAreaPoint;
      a = nextA;
    }
    decimated[sampledIndex++] = data[endIndex];
    return decimated;
  }
  function minMaxDecimation(data, start, count, availableWidth) {
    let avgX = 0;
    let countX = 0;
    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
    const decimated = [];
    const endIndex = start + count - 1;
    const xMin = data[start].x;
    const xMax = data[endIndex].x;
    const dx = xMax - xMin;
    for (i = start; i < start + count; ++i) {
      point = data[i];
      x = (point.x - xMin) / dx * availableWidth;
      y = point.y;
      const truncX = x | 0;
      if (truncX === prevX) {
        if (y < minY) {
          minY = y;
          minIndex = i;
        } else if (y > maxY) {
          maxY = y;
          maxIndex = i;
        }
        avgX = (countX * avgX + point.x) / ++countX;
      } else {
        const lastIndex = i - 1;
        if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
          const intermediateIndex1 = Math.min(minIndex, maxIndex);
          const intermediateIndex2 = Math.max(minIndex, maxIndex);
          if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
            decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex1]), {
              x: avgX
            }));
          }
          if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
            decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex2]), {
              x: avgX
            }));
          }
        }
        if (i > 0 && lastIndex !== startIndex) {
          decimated.push(data[lastIndex]);
        }
        decimated.push(point);
        prevX = truncX;
        countX = 0;
        minY = maxY = y;
        minIndex = maxIndex = startIndex = i;
      }
    }
    return decimated;
  }
  function cleanDecimatedDataset(dataset) {
    if (dataset._decimated) {
      const data = dataset._data;
      delete dataset._decimated;
      delete dataset._data;
      Object.defineProperty(dataset, "data", {
        configurable: true,
        enumerable: true,
        writable: true,
        value: data
      });
    }
  }
  function cleanDecimatedData(chart) {
    chart.data.datasets.forEach((dataset) => {
      cleanDecimatedDataset(dataset);
    });
  }
  function getStartAndCountOfVisiblePointsSimplified(meta, points) {
    const pointCount = points.length;
    let start = 0;
    let count;
    const { iScale } = meta;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
    return {
      start,
      count
    };
  }
  var plugin_decimation = {
    id: "decimation",
    defaults: {
      algorithm: "min-max",
      enabled: false
    },
    beforeElementsUpdate: (chart, args, options) => {
      if (!options.enabled) {
        cleanDecimatedData(chart);
        return;
      }
      const availableWidth = chart.width;
      chart.data.datasets.forEach((dataset, datasetIndex) => {
        const { _data, indexAxis } = dataset;
        const meta = chart.getDatasetMeta(datasetIndex);
        const data = _data || dataset.data;
        if (resolve([
          indexAxis,
          chart.options.indexAxis
        ]) === "y") {
          return;
        }
        if (!meta.controller.supportsDecimation) {
          return;
        }
        const xAxis = chart.scales[meta.xAxisID];
        if (xAxis.type !== "linear" && xAxis.type !== "time") {
          return;
        }
        if (chart.options.parsing) {
          return;
        }
        let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
        const threshold = options.threshold || 4 * availableWidth;
        if (count <= threshold) {
          cleanDecimatedDataset(dataset);
          return;
        }
        if (isNullOrUndef(_data)) {
          dataset._data = data;
          delete dataset.data;
          Object.defineProperty(dataset, "data", {
            configurable: true,
            enumerable: true,
            get: function() {
              return this._decimated;
            },
            set: function(d) {
              this._data = d;
            }
          });
        }
        let decimated;
        switch (options.algorithm) {
          case "lttb":
            decimated = lttbDecimation(data, start, count, availableWidth, options);
            break;
          case "min-max":
            decimated = minMaxDecimation(data, start, count, availableWidth);
            break;
          default:
            throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
        }
        dataset._decimated = decimated;
      });
    },
    destroy(chart) {
      cleanDecimatedData(chart);
    }
  };
  function _segments(line, target, property) {
    const segments = line.segments;
    const points = line.points;
    const tpoints = target.points;
    const parts = [];
    for (const segment of segments) {
      let { start, end } = segment;
      end = _findSegmentEnd(start, end, points);
      const bounds = _getBounds(property, points[start], points[end], segment.loop);
      if (!target.segments) {
        parts.push({
          source: segment,
          target: bounds,
          start: points[start],
          end: points[end]
        });
        continue;
      }
      const targetSegments = _boundSegments(target, bounds);
      for (const tgt of targetSegments) {
        const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
        const fillSources = _boundSegment(segment, points, subBounds);
        for (const fillSource of fillSources) {
          parts.push({
            source: fillSource,
            target: tgt,
            start: {
              [property]: _getEdge(bounds, subBounds, "start", Math.max)
            },
            end: {
              [property]: _getEdge(bounds, subBounds, "end", Math.min)
            }
          });
        }
      }
    }
    return parts;
  }
  function _getBounds(property, first, last, loop) {
    if (loop) {
      return;
    }
    let start = first[property];
    let end = last[property];
    if (property === "angle") {
      start = _normalizeAngle(start);
      end = _normalizeAngle(end);
    }
    return {
      property,
      start,
      end
    };
  }
  function _pointsFromSegments(boundary, line) {
    const { x = null, y = null } = boundary || {};
    const linePoints = line.points;
    const points = [];
    line.segments.forEach(({ start, end }) => {
      end = _findSegmentEnd(start, end, linePoints);
      const first = linePoints[start];
      const last = linePoints[end];
      if (y !== null) {
        points.push({
          x: first.x,
          y
        });
        points.push({
          x: last.x,
          y
        });
      } else if (x !== null) {
        points.push({
          x,
          y: first.y
        });
        points.push({
          x,
          y: last.y
        });
      }
    });
    return points;
  }
  function _findSegmentEnd(start, end, points) {
    for (; end > start; end--) {
      const point = points[end];
      if (!isNaN(point.x) && !isNaN(point.y)) {
        break;
      }
    }
    return end;
  }
  function _getEdge(a, b, prop, fn) {
    if (a && b) {
      return fn(a[prop], b[prop]);
    }
    return a ? a[prop] : b ? b[prop] : 0;
  }
  function _createBoundaryLine(boundary, line) {
    let points = [];
    let _loop = false;
    if (isArray(boundary)) {
      _loop = true;
      points = boundary;
    } else {
      points = _pointsFromSegments(boundary, line);
    }
    return points.length ? new LineElement({
      points,
      options: {
        tension: 0
      },
      _loop,
      _fullLoop: _loop
    }) : null;
  }
  function _shouldApplyFill(source) {
    return source && source.fill !== false;
  }
  function _resolveTarget(sources, index2, propagate) {
    const source = sources[index2];
    let fill2 = source.fill;
    const visited = [
      index2
    ];
    let target;
    if (!propagate) {
      return fill2;
    }
    while (fill2 !== false && visited.indexOf(fill2) === -1) {
      if (!isNumberFinite(fill2)) {
        return fill2;
      }
      target = sources[fill2];
      if (!target) {
        return false;
      }
      if (target.visible) {
        return fill2;
      }
      visited.push(fill2);
      fill2 = target.fill;
    }
    return false;
  }
  function _decodeFill(line, index2, count) {
    const fill2 = parseFillOption(line);
    if (isObject2(fill2)) {
      return isNaN(fill2.value) ? false : fill2;
    }
    let target = parseFloat(fill2);
    if (isNumberFinite(target) && Math.floor(target) === target) {
      return decodeTargetIndex(fill2[0], index2, target, count);
    }
    return [
      "origin",
      "start",
      "end",
      "stack",
      "shape"
    ].indexOf(fill2) >= 0 && fill2;
  }
  function decodeTargetIndex(firstCh, index2, target, count) {
    if (firstCh === "-" || firstCh === "+") {
      target = index2 + target;
    }
    if (target === index2 || target < 0 || target >= count) {
      return false;
    }
    return target;
  }
  function _getTargetPixel(fill2, scale) {
    let pixel = null;
    if (fill2 === "start") {
      pixel = scale.bottom;
    } else if (fill2 === "end") {
      pixel = scale.top;
    } else if (isObject2(fill2)) {
      pixel = scale.getPixelForValue(fill2.value);
    } else if (scale.getBasePixel) {
      pixel = scale.getBasePixel();
    }
    return pixel;
  }
  function _getTargetValue(fill2, scale, startValue) {
    let value;
    if (fill2 === "start") {
      value = startValue;
    } else if (fill2 === "end") {
      value = scale.options.reverse ? scale.min : scale.max;
    } else if (isObject2(fill2)) {
      value = fill2.value;
    } else {
      value = scale.getBaseValue();
    }
    return value;
  }
  function parseFillOption(line) {
    const options = line.options;
    const fillOption = options.fill;
    let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
    if (fill2 === void 0) {
      fill2 = !!options.backgroundColor;
    }
    if (fill2 === false || fill2 === null) {
      return false;
    }
    if (fill2 === true) {
      return "origin";
    }
    return fill2;
  }
  function _buildStackLine(source) {
    const { scale, index: index2, line } = source;
    const points = [];
    const segments = line.segments;
    const sourcePoints = line.points;
    const linesBelow = getLinesBelow(scale, index2);
    linesBelow.push(_createBoundaryLine({
      x: null,
      y: scale.bottom
    }, line));
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      for (let j = segment.start; j <= segment.end; j++) {
        addPointsBelow(points, sourcePoints[j], linesBelow);
      }
    }
    return new LineElement({
      points,
      options: {}
    });
  }
  function getLinesBelow(scale, index2) {
    const below = [];
    const metas = scale.getMatchingVisibleMetas("line");
    for (let i = 0; i < metas.length; i++) {
      const meta = metas[i];
      if (meta.index === index2) {
        break;
      }
      if (!meta.hidden) {
        below.unshift(meta.dataset);
      }
    }
    return below;
  }
  function addPointsBelow(points, sourcePoint, linesBelow) {
    const postponed = [];
    for (let j = 0; j < linesBelow.length; j++) {
      const line = linesBelow[j];
      const { first, last, point } = findPoint(line, sourcePoint, "x");
      if (!point || first && last) {
        continue;
      }
      if (first) {
        postponed.unshift(point);
      } else {
        points.push(point);
        if (!last) {
          break;
        }
      }
    }
    points.push(...postponed);
  }
  function findPoint(line, sourcePoint, property) {
    const point = line.interpolate(sourcePoint, property);
    if (!point) {
      return {};
    }
    const pointValue = point[property];
    const segments = line.segments;
    const linePoints = line.points;
    let first = false;
    let last = false;
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      const firstValue = linePoints[segment.start][property];
      const lastValue = linePoints[segment.end][property];
      if (_isBetween(pointValue, firstValue, lastValue)) {
        first = pointValue === firstValue;
        last = pointValue === lastValue;
        break;
      }
    }
    return {
      first,
      last,
      point
    };
  }
  var simpleArc = class {
    constructor(opts) {
      this.x = opts.x;
      this.y = opts.y;
      this.radius = opts.radius;
    }
    pathSegment(ctx, bounds, opts) {
      const { x, y, radius } = this;
      bounds = bounds || {
        start: 0,
        end: TAU
      };
      ctx.arc(x, y, radius, bounds.end, bounds.start, true);
      return !opts.bounds;
    }
    interpolate(point) {
      const { x, y, radius } = this;
      const angle = point.angle;
      return {
        x: x + Math.cos(angle) * radius,
        y: y + Math.sin(angle) * radius,
        angle
      };
    }
  };
  function _getTarget(source) {
    const { chart, fill: fill2, line } = source;
    if (isNumberFinite(fill2)) {
      return getLineByIndex(chart, fill2);
    }
    if (fill2 === "stack") {
      return _buildStackLine(source);
    }
    if (fill2 === "shape") {
      return true;
    }
    const boundary = computeBoundary(source);
    if (boundary instanceof simpleArc) {
      return boundary;
    }
    return _createBoundaryLine(boundary, line);
  }
  function getLineByIndex(chart, index2) {
    const meta = chart.getDatasetMeta(index2);
    const visible = meta && chart.isDatasetVisible(index2);
    return visible ? meta.dataset : null;
  }
  function computeBoundary(source) {
    const scale = source.scale || {};
    if (scale.getPointPositionForValue) {
      return computeCircularBoundary(source);
    }
    return computeLinearBoundary(source);
  }
  function computeLinearBoundary(source) {
    const { scale = {}, fill: fill2 } = source;
    const pixel = _getTargetPixel(fill2, scale);
    if (isNumberFinite(pixel)) {
      const horizontal = scale.isHorizontal();
      return {
        x: horizontal ? pixel : null,
        y: horizontal ? null : pixel
      };
    }
    return null;
  }
  function computeCircularBoundary(source) {
    const { scale, fill: fill2 } = source;
    const options = scale.options;
    const length = scale.getLabels().length;
    const start = options.reverse ? scale.max : scale.min;
    const value = _getTargetValue(fill2, scale, start);
    const target = [];
    if (options.grid.circular) {
      const center = scale.getPointPositionForValue(0, start);
      return new simpleArc({
        x: center.x,
        y: center.y,
        radius: scale.getDistanceFromCenterForValue(value)
      });
    }
    for (let i = 0; i < length; ++i) {
      target.push(scale.getPointPositionForValue(i, value));
    }
    return target;
  }
  function _drawfill(ctx, source, area) {
    const target = _getTarget(source);
    const { line, scale, axis } = source;
    const lineOpts = line.options;
    const fillOption = lineOpts.fill;
    const color2 = lineOpts.backgroundColor;
    const { above = color2, below = color2 } = fillOption || {};
    if (target && line.points.length) {
      clipArea(ctx, area);
      doFill(ctx, {
        line,
        target,
        above,
        below,
        area,
        scale,
        axis
      });
      unclipArea(ctx);
    }
  }
  function doFill(ctx, cfg) {
    const { line, target, above, below, area, scale } = cfg;
    const property = line._loop ? "angle" : cfg.axis;
    ctx.save();
    if (property === "x" && below !== above) {
      clipVertical(ctx, target, area.top);
      fill(ctx, {
        line,
        target,
        color: above,
        scale,
        property
      });
      ctx.restore();
      ctx.save();
      clipVertical(ctx, target, area.bottom);
    }
    fill(ctx, {
      line,
      target,
      color: below,
      scale,
      property
    });
    ctx.restore();
  }
  function clipVertical(ctx, target, clipY) {
    const { segments, points } = target;
    let first = true;
    let lineLoop = false;
    ctx.beginPath();
    for (const segment of segments) {
      const { start, end } = segment;
      const firstPoint = points[start];
      const lastPoint = points[_findSegmentEnd(start, end, points)];
      if (first) {
        ctx.moveTo(firstPoint.x, firstPoint.y);
        first = false;
      } else {
        ctx.lineTo(firstPoint.x, clipY);
        ctx.lineTo(firstPoint.x, firstPoint.y);
      }
      lineLoop = !!target.pathSegment(ctx, segment, {
        move: lineLoop
      });
      if (lineLoop) {
        ctx.closePath();
      } else {
        ctx.lineTo(lastPoint.x, clipY);
      }
    }
    ctx.lineTo(target.first().x, clipY);
    ctx.closePath();
    ctx.clip();
  }
  function fill(ctx, cfg) {
    const { line, target, property, color: color2, scale } = cfg;
    const segments = _segments(line, target, property);
    for (const { source: src, target: tgt, start, end } of segments) {
      const { style: { backgroundColor = color2 } = {} } = src;
      const notShape = target !== true;
      ctx.save();
      ctx.fillStyle = backgroundColor;
      clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
      ctx.beginPath();
      const lineLoop = !!line.pathSegment(ctx, src);
      let loop;
      if (notShape) {
        if (lineLoop) {
          ctx.closePath();
        } else {
          interpolatedLineTo(ctx, target, end, property);
        }
        const targetLoop = !!target.pathSegment(ctx, tgt, {
          move: lineLoop,
          reverse: true
        });
        loop = lineLoop && targetLoop;
        if (!loop) {
          interpolatedLineTo(ctx, target, start, property);
        }
      }
      ctx.closePath();
      ctx.fill(loop ? "evenodd" : "nonzero");
      ctx.restore();
    }
  }
  function clipBounds(ctx, scale, bounds) {
    const { top: top2, bottom: bottom2 } = scale.chart.chartArea;
    const { property, start, end } = bounds || {};
    if (property === "x") {
      ctx.beginPath();
      ctx.rect(start, top2, end - start, bottom2 - top2);
      ctx.clip();
    }
  }
  function interpolatedLineTo(ctx, target, point, property) {
    const interpolatedPoint = target.interpolate(point, property);
    if (interpolatedPoint) {
      ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
    }
  }
  var index = {
    id: "filler",
    afterDatasetsUpdate(chart, _args, options) {
      const count = (chart.data.datasets || []).length;
      const sources = [];
      let meta, i, line, source;
      for (i = 0; i < count; ++i) {
        meta = chart.getDatasetMeta(i);
        line = meta.dataset;
        source = null;
        if (line && line.options && line instanceof LineElement) {
          source = {
            visible: chart.isDatasetVisible(i),
            index: i,
            fill: _decodeFill(line, i, count),
            chart,
            axis: meta.controller.options.indexAxis,
            scale: meta.vScale,
            line
          };
        }
        meta.$filler = source;
        sources.push(source);
      }
      for (i = 0; i < count; ++i) {
        source = sources[i];
        if (!source || source.fill === false) {
          continue;
        }
        source.fill = _resolveTarget(sources, i, options.propagate);
      }
    },
    beforeDraw(chart, _args, options) {
      const draw2 = options.drawTime === "beforeDraw";
      const metasets = chart.getSortedVisibleDatasetMetas();
      const area = chart.chartArea;
      for (let i = metasets.length - 1; i >= 0; --i) {
        const source = metasets[i].$filler;
        if (!source) {
          continue;
        }
        source.line.updateControlPoints(area, source.axis);
        if (draw2 && source.fill) {
          _drawfill(chart.ctx, source, area);
        }
      }
    },
    beforeDatasetsDraw(chart, _args, options) {
      if (options.drawTime !== "beforeDatasetsDraw") {
        return;
      }
      const metasets = chart.getSortedVisibleDatasetMetas();
      for (let i = metasets.length - 1; i >= 0; --i) {
        const source = metasets[i].$filler;
        if (_shouldApplyFill(source)) {
          _drawfill(chart.ctx, source, chart.chartArea);
        }
      }
    },
    beforeDatasetDraw(chart, args, options) {
      const source = args.meta.$filler;
      if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
        return;
      }
      _drawfill(chart.ctx, source, chart.chartArea);
    },
    defaults: {
      propagate: true,
      drawTime: "beforeDatasetDraw"
    }
  };
  var getBoxSize = (labelOpts, fontSize) => {
    let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
    if (labelOpts.usePointStyle) {
      boxHeight = Math.min(boxHeight, fontSize);
      boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
    }
    return {
      boxWidth,
      boxHeight,
      itemHeight: Math.max(fontSize, boxHeight)
    };
  };
  var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
  var Legend = class extends Element {
    constructor(config) {
      super();
      this._added = false;
      this.legendHitBoxes = [];
      this._hoveredItem = null;
      this.doughnutMode = false;
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this.legendItems = void 0;
      this.columnSizes = void 0;
      this.lineWidths = void 0;
      this.maxHeight = void 0;
      this.maxWidth = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.height = void 0;
      this.width = void 0;
      this._margins = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight, margins) {
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins;
      this.setDimensions();
      this.buildLabels();
      this.fit();
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = this._margins.left;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = this._margins.top;
        this.bottom = this.height;
      }
    }
    buildLabels() {
      const labelOpts = this.options.labels || {};
      let legendItems = callback(labelOpts.generateLabels, [
        this.chart
      ], this) || [];
      if (labelOpts.filter) {
        legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
      }
      if (labelOpts.sort) {
        legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
      }
      if (this.options.reverse) {
        legendItems.reverse();
      }
      this.legendItems = legendItems;
    }
    fit() {
      const { options, ctx } = this;
      if (!options.display) {
        this.width = this.height = 0;
        return;
      }
      const labelOpts = options.labels;
      const labelFont = toFont(labelOpts.font);
      const fontSize = labelFont.size;
      const titleHeight = this._computeTitleHeight();
      const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
      let width, height;
      ctx.font = labelFont.string;
      if (this.isHorizontal()) {
        width = this.maxWidth;
        height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
      } else {
        height = this.maxHeight;
        width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
      }
      this.width = Math.min(width, options.maxWidth || this.maxWidth);
      this.height = Math.min(height, options.maxHeight || this.maxHeight);
    }
    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
      const { ctx, maxWidth, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const lineWidths = this.lineWidths = [
        0
      ];
      const lineHeight = itemHeight + padding;
      let totalHeight = titleHeight;
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      let row = -1;
      let top2 = -lineHeight;
      this.legendItems.forEach((legendItem, i) => {
        const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
        if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
          totalHeight += lineHeight;
          lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
          top2 += lineHeight;
          row++;
        }
        hitboxes[i] = {
          left: 0,
          top: top2,
          row,
          width: itemWidth,
          height: itemHeight
        };
        lineWidths[lineWidths.length - 1] += itemWidth + padding;
      });
      return totalHeight;
    }
    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
      const { ctx, maxHeight, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const columnSizes = this.columnSizes = [];
      const heightLimit = maxHeight - titleHeight;
      let totalWidth = padding;
      let currentColWidth = 0;
      let currentColHeight = 0;
      let left = 0;
      let col = 0;
      this.legendItems.forEach((legendItem, i) => {
        const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
        if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
          totalWidth += currentColWidth + padding;
          columnSizes.push({
            width: currentColWidth,
            height: currentColHeight
          });
          left += currentColWidth + padding;
          col++;
          currentColWidth = currentColHeight = 0;
        }
        hitboxes[i] = {
          left,
          top: currentColHeight,
          col,
          width: itemWidth,
          height: itemHeight
        };
        currentColWidth = Math.max(currentColWidth, itemWidth);
        currentColHeight += itemHeight + padding;
      });
      totalWidth += currentColWidth;
      columnSizes.push({
        width: currentColWidth,
        height: currentColHeight
      });
      return totalWidth;
    }
    adjustHitBoxes() {
      if (!this.options.display) {
        return;
      }
      const titleHeight = this._computeTitleHeight();
      const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
      const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
      if (this.isHorizontal()) {
        let row = 0;
        let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        for (const hitbox of hitboxes) {
          if (row !== hitbox.row) {
            row = hitbox.row;
            left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
          }
          hitbox.top += this.top + titleHeight + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
          left += hitbox.width + padding;
        }
      } else {
        let col = 0;
        let top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        for (const hitbox of hitboxes) {
          if (hitbox.col !== col) {
            col = hitbox.col;
            top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
          }
          hitbox.top = top2;
          hitbox.left += this.left + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
          top2 += hitbox.height + padding;
        }
      }
    }
    isHorizontal() {
      return this.options.position === "top" || this.options.position === "bottom";
    }
    draw() {
      if (this.options.display) {
        const ctx = this.ctx;
        clipArea(ctx, this);
        this._draw();
        unclipArea(ctx);
      }
    }
    _draw() {
      const { options: opts, columnSizes, lineWidths, ctx } = this;
      const { align, labels: labelOpts } = opts;
      const defaultColor = defaults.color;
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const labelFont = toFont(labelOpts.font);
      const { padding } = labelOpts;
      const fontSize = labelFont.size;
      const halfFontSize = fontSize / 2;
      let cursor;
      this.drawTitle();
      ctx.textAlign = rtlHelper.textAlign("left");
      ctx.textBaseline = "middle";
      ctx.lineWidth = 0.5;
      ctx.font = labelFont.string;
      const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
      const drawLegendBox = function(x, y, legendItem) {
        if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
          return;
        }
        ctx.save();
        const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
        ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
        ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
        ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
        ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
        ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
        if (labelOpts.usePointStyle) {
          const drawOptions = {
            radius: boxHeight * Math.SQRT2 / 2,
            pointStyle: legendItem.pointStyle,
            rotation: legendItem.rotation,
            borderWidth: lineWidth
          };
          const centerX = rtlHelper.xPlus(x, boxWidth / 2);
          const centerY = y + halfFontSize;
          drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
        } else {
          const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
          const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
          const borderRadius = toTRBLCorners(legendItem.borderRadius);
          ctx.beginPath();
          if (Object.values(borderRadius).some((v) => v !== 0)) {
            addRoundedRectPath(ctx, {
              x: xBoxLeft,
              y: yBoxTop,
              w: boxWidth,
              h: boxHeight,
              radius: borderRadius
            });
          } else {
            ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
          }
          ctx.fill();
          if (lineWidth !== 0) {
            ctx.stroke();
          }
        }
        ctx.restore();
      };
      const fillText = function(x, y, legendItem) {
        renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
          strikethrough: legendItem.hidden,
          textAlign: rtlHelper.textAlign(legendItem.textAlign)
        });
      };
      const isHorizontal = this.isHorizontal();
      const titleHeight = this._computeTitleHeight();
      if (isHorizontal) {
        cursor = {
          x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
          y: this.top + padding + titleHeight,
          line: 0
        };
      } else {
        cursor = {
          x: this.left + padding,
          y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
          line: 0
        };
      }
      overrideTextDirection(this.ctx, opts.textDirection);
      const lineHeight = itemHeight + padding;
      this.legendItems.forEach((legendItem, i) => {
        ctx.strokeStyle = legendItem.fontColor;
        ctx.fillStyle = legendItem.fontColor;
        const textWidth = ctx.measureText(legendItem.text).width;
        const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
        const width = boxWidth + halfFontSize + textWidth;
        let x = cursor.x;
        let y = cursor.y;
        rtlHelper.setWidth(this.width);
        if (isHorizontal) {
          if (i > 0 && x + width + padding > this.right) {
            y = cursor.y += lineHeight;
            cursor.line++;
            x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
          }
        } else if (i > 0 && y + lineHeight > this.bottom) {
          x = cursor.x = x + columnSizes[cursor.line].width + padding;
          cursor.line++;
          y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
        }
        const realX = rtlHelper.x(x);
        drawLegendBox(realX, y, legendItem);
        x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
        fillText(rtlHelper.x(x), y, legendItem);
        if (isHorizontal) {
          cursor.x += width + padding;
        } else if (typeof legendItem.text !== "string") {
          const fontLineHeight = labelFont.lineHeight;
          cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
        } else {
          cursor.y += lineHeight;
        }
      });
      restoreTextDirection(this.ctx, opts.textDirection);
    }
    drawTitle() {
      const opts = this.options;
      const titleOpts = opts.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      if (!titleOpts.display) {
        return;
      }
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const ctx = this.ctx;
      const position = titleOpts.position;
      const halfFontSize = titleFont.size / 2;
      const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
      let y;
      let left = this.left;
      let maxWidth = this.width;
      if (this.isHorizontal()) {
        maxWidth = Math.max(...this.lineWidths);
        y = this.top + topPaddingPlusHalfFontSize;
        left = _alignStartEnd(opts.align, left, this.right - maxWidth);
      } else {
        const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
        y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
      }
      const x = _alignStartEnd(position, left, left + maxWidth);
      ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
      ctx.textBaseline = "middle";
      ctx.strokeStyle = titleOpts.color;
      ctx.fillStyle = titleOpts.color;
      ctx.font = titleFont.string;
      renderText(ctx, titleOpts.text, x, y, titleFont);
    }
    _computeTitleHeight() {
      const titleOpts = this.options.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
    }
    _getLegendItemAt(x, y) {
      let i, hitBox, lh;
      if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
        lh = this.legendHitBoxes;
        for (i = 0; i < lh.length; ++i) {
          hitBox = lh[i];
          if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
            return this.legendItems[i];
          }
        }
      }
      return null;
    }
    handleEvent(e) {
      const opts = this.options;
      if (!isListened(e.type, opts)) {
        return;
      }
      const hoveredItem = this._getLegendItemAt(e.x, e.y);
      if (e.type === "mousemove" || e.type === "mouseout") {
        const previous = this._hoveredItem;
        const sameItem = itemsEqual(previous, hoveredItem);
        if (previous && !sameItem) {
          callback(opts.onLeave, [
            e,
            previous,
            this
          ], this);
        }
        this._hoveredItem = hoveredItem;
        if (hoveredItem && !sameItem) {
          callback(opts.onHover, [
            e,
            hoveredItem,
            this
          ], this);
        }
      } else if (hoveredItem) {
        callback(opts.onClick, [
          e,
          hoveredItem,
          this
        ], this);
      }
    }
  };
  function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
    return {
      itemWidth,
      itemHeight
    };
  }
  function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
    let legendItemText = legendItem.text;
    if (legendItemText && typeof legendItemText !== "string") {
      legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
    }
    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
  }
  function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
    let itemHeight = _itemHeight;
    if (typeof legendItem.text !== "string") {
      itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
    }
    return itemHeight;
  }
  function calculateLegendItemHeight(legendItem, fontLineHeight) {
    const labelHeight = legendItem.text ? legendItem.text.length : 0;
    return fontLineHeight * labelHeight;
  }
  function isListened(type, opts) {
    if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
      return true;
    }
    if (opts.onClick && (type === "click" || type === "mouseup")) {
      return true;
    }
    return false;
  }
  var plugin_legend = {
    id: "legend",
    _element: Legend,
    start(chart, _args, options) {
      const legend = chart.legend = new Legend({
        ctx: chart.ctx,
        options,
        chart
      });
      layouts.configure(chart, legend, options);
      layouts.addBox(chart, legend);
    },
    stop(chart) {
      layouts.removeBox(chart, chart.legend);
      delete chart.legend;
    },
    beforeUpdate(chart, _args, options) {
      const legend = chart.legend;
      layouts.configure(chart, legend, options);
      legend.options = options;
    },
    afterUpdate(chart) {
      const legend = chart.legend;
      legend.buildLabels();
      legend.adjustHitBoxes();
    },
    afterEvent(chart, args) {
      if (!args.replay) {
        chart.legend.handleEvent(args.event);
      }
    },
    defaults: {
      display: true,
      position: "top",
      align: "center",
      fullSize: true,
      reverse: false,
      weight: 1e3,
      onClick(e, legendItem, legend) {
        const index2 = legendItem.datasetIndex;
        const ci = legend.chart;
        if (ci.isDatasetVisible(index2)) {
          ci.hide(index2);
          legendItem.hidden = true;
        } else {
          ci.show(index2);
          legendItem.hidden = false;
        }
      },
      onHover: null,
      onLeave: null,
      labels: {
        color: (ctx) => ctx.chart.options.color,
        boxWidth: 40,
        padding: 10,
        generateLabels(chart) {
          const datasets = chart.data.datasets;
          const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
          return chart._getSortedDatasetMetas().map((meta) => {
            const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
            const borderWidth = toPadding(style.borderWidth);
            return {
              text: datasets[meta.index].label,
              fillStyle: style.backgroundColor,
              fontColor: color2,
              hidden: !meta.visible,
              lineCap: style.borderCapStyle,
              lineDash: style.borderDash,
              lineDashOffset: style.borderDashOffset,
              lineJoin: style.borderJoinStyle,
              lineWidth: (borderWidth.width + borderWidth.height) / 4,
              strokeStyle: style.borderColor,
              pointStyle: pointStyle || style.pointStyle,
              rotation: style.rotation,
              textAlign: textAlign || style.textAlign,
              borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
              datasetIndex: meta.index
            };
          }, this);
        }
      },
      title: {
        color: (ctx) => ctx.chart.options.color,
        display: false,
        position: "center",
        text: ""
      }
    },
    descriptors: {
      _scriptable: (name) => !name.startsWith("on"),
      labels: {
        _scriptable: (name) => ![
          "generateLabels",
          "filter",
          "sort"
        ].includes(name)
      }
    }
  };
  var Title = class extends Element {
    constructor(config) {
      super();
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this._padding = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight) {
      const opts = this.options;
      this.left = 0;
      this.top = 0;
      if (!opts.display) {
        this.width = this.height = this.right = this.bottom = 0;
        return;
      }
      this.width = this.right = maxWidth;
      this.height = this.bottom = maxHeight;
      const lineCount = isArray(opts.text) ? opts.text.length : 1;
      this._padding = toPadding(opts.padding);
      const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
      if (this.isHorizontal()) {
        this.height = textSize;
      } else {
        this.width = textSize;
      }
    }
    isHorizontal() {
      const pos = this.options.position;
      return pos === "top" || pos === "bottom";
    }
    _drawArgs(offset) {
      const { top: top2, left, bottom: bottom2, right, options } = this;
      const align = options.align;
      let rotation = 0;
      let maxWidth, titleX, titleY;
      if (this.isHorizontal()) {
        titleX = _alignStartEnd(align, left, right);
        titleY = top2 + offset;
        maxWidth = right - left;
      } else {
        if (options.position === "left") {
          titleX = left + offset;
          titleY = _alignStartEnd(align, bottom2, top2);
          rotation = PI * -0.5;
        } else {
          titleX = right - offset;
          titleY = _alignStartEnd(align, top2, bottom2);
          rotation = PI * 0.5;
        }
        maxWidth = bottom2 - top2;
      }
      return {
        titleX,
        titleY,
        maxWidth,
        rotation
      };
    }
    draw() {
      const ctx = this.ctx;
      const opts = this.options;
      if (!opts.display) {
        return;
      }
      const fontOpts = toFont(opts.font);
      const lineHeight = fontOpts.lineHeight;
      const offset = lineHeight / 2 + this._padding.top;
      const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
      renderText(ctx, opts.text, 0, 0, fontOpts, {
        color: opts.color,
        maxWidth,
        rotation,
        textAlign: _toLeftRightCenter(opts.align),
        textBaseline: "middle",
        translation: [
          titleX,
          titleY
        ]
      });
    }
  };
  function createTitle(chart, titleOpts) {
    const title = new Title({
      ctx: chart.ctx,
      options: titleOpts,
      chart
    });
    layouts.configure(chart, title, titleOpts);
    layouts.addBox(chart, title);
    chart.titleBlock = title;
  }
  var plugin_title = {
    id: "title",
    _element: Title,
    start(chart, _args, options) {
      createTitle(chart, options);
    },
    stop(chart) {
      const titleBlock = chart.titleBlock;
      layouts.removeBox(chart, titleBlock);
      delete chart.titleBlock;
    },
    beforeUpdate(chart, _args, options) {
      const title = chart.titleBlock;
      layouts.configure(chart, title, options);
      title.options = options;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "bold"
      },
      fullSize: true,
      padding: 10,
      position: "top",
      text: "",
      weight: 2e3
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var map2 = /* @__PURE__ */ new WeakMap();
  var plugin_subtitle = {
    id: "subtitle",
    start(chart, _args, options) {
      const title = new Title({
        ctx: chart.ctx,
        options,
        chart
      });
      layouts.configure(chart, title, options);
      layouts.addBox(chart, title);
      map2.set(chart, title);
    },
    stop(chart) {
      layouts.removeBox(chart, map2.get(chart));
      map2.delete(chart);
    },
    beforeUpdate(chart, _args, options) {
      const title = map2.get(chart);
      layouts.configure(chart, title, options);
      title.options = options;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "normal"
      },
      fullSize: true,
      padding: 0,
      position: "top",
      text: "",
      weight: 1500
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var positioners = {
    average(items) {
      if (!items.length) {
        return false;
      }
      let i, len;
      let xSet = /* @__PURE__ */ new Set();
      let y = 0;
      let count = 0;
      for (i = 0, len = items.length; i < len; ++i) {
        const el = items[i].element;
        if (el && el.hasValue()) {
          const pos = el.tooltipPosition();
          xSet.add(pos.x);
          y += pos.y;
          ++count;
        }
      }
      const xAverage = [
        ...xSet
      ].reduce((a, b) => a + b) / xSet.size;
      return {
        x: xAverage,
        y: y / count
      };
    },
    nearest(items, eventPosition) {
      if (!items.length) {
        return false;
      }
      let x = eventPosition.x;
      let y = eventPosition.y;
      let minDistance = Number.POSITIVE_INFINITY;
      let i, len, nearestElement;
      for (i = 0, len = items.length; i < len; ++i) {
        const el = items[i].element;
        if (el && el.hasValue()) {
          const center = el.getCenterPoint();
          const d = distanceBetweenPoints(eventPosition, center);
          if (d < minDistance) {
            minDistance = d;
            nearestElement = el;
          }
        }
      }
      if (nearestElement) {
        const tp = nearestElement.tooltipPosition();
        x = tp.x;
        y = tp.y;
      }
      return {
        x,
        y
      };
    }
  };
  function pushOrConcat(base, toPush) {
    if (toPush) {
      if (isArray(toPush)) {
        Array.prototype.push.apply(base, toPush);
      } else {
        base.push(toPush);
      }
    }
    return base;
  }
  function splitNewlines(str) {
    if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
      return str.split("\n");
    }
    return str;
  }
  function createTooltipItem(chart, item) {
    const { element, datasetIndex, index: index2 } = item;
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    const { label, value } = controller.getLabelAndValue(index2);
    return {
      chart,
      label,
      parsed: controller.getParsed(index2),
      raw: chart.data.datasets[datasetIndex].data[index2],
      formattedValue: value,
      dataset: controller.getDataset(),
      dataIndex: index2,
      datasetIndex,
      element
    };
  }
  function getTooltipSize(tooltip, options) {
    const ctx = tooltip.chart.ctx;
    const { body, footer, title } = tooltip;
    const { boxWidth, boxHeight } = options;
    const bodyFont = toFont(options.bodyFont);
    const titleFont = toFont(options.titleFont);
    const footerFont = toFont(options.footerFont);
    const titleLineCount = title.length;
    const footerLineCount = footer.length;
    const bodyLineItemCount = body.length;
    const padding = toPadding(options.padding);
    let height = padding.height;
    let width = 0;
    let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
    if (titleLineCount) {
      height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
    }
    if (combinedBodyLength) {
      const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
      height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
    }
    if (footerLineCount) {
      height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
    }
    let widthPadding = 0;
    const maxLineWidth = function(line) {
      width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };
    ctx.save();
    ctx.font = titleFont.string;
    each(tooltip.title, maxLineWidth);
    ctx.font = bodyFont.string;
    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
    each(body, (bodyItem) => {
      each(bodyItem.before, maxLineWidth);
      each(bodyItem.lines, maxLineWidth);
      each(bodyItem.after, maxLineWidth);
    });
    widthPadding = 0;
    ctx.font = footerFont.string;
    each(tooltip.footer, maxLineWidth);
    ctx.restore();
    width += padding.width;
    return {
      width,
      height
    };
  }
  function determineYAlign(chart, size) {
    const { y, height } = size;
    if (y < height / 2) {
      return "top";
    } else if (y > chart.height - height / 2) {
      return "bottom";
    }
    return "center";
  }
  function doesNotFitWithAlign(xAlign, chart, options, size) {
    const { x, width } = size;
    const caret = options.caretSize + options.caretPadding;
    if (xAlign === "left" && x + width + caret > chart.width) {
      return true;
    }
    if (xAlign === "right" && x - width - caret < 0) {
      return true;
    }
  }
  function determineXAlign(chart, options, size, yAlign) {
    const { x, width } = size;
    const { width: chartWidth, chartArea: { left, right } } = chart;
    let xAlign = "center";
    if (yAlign === "center") {
      xAlign = x <= (left + right) / 2 ? "left" : "right";
    } else if (x <= width / 2) {
      xAlign = "left";
    } else if (x >= chartWidth - width / 2) {
      xAlign = "right";
    }
    if (doesNotFitWithAlign(xAlign, chart, options, size)) {
      xAlign = "center";
    }
    return xAlign;
  }
  function determineAlignment(chart, options, size) {
    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
    return {
      xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
      yAlign
    };
  }
  function alignX(size, xAlign) {
    let { x, width } = size;
    if (xAlign === "right") {
      x -= width;
    } else if (xAlign === "center") {
      x -= width / 2;
    }
    return x;
  }
  function alignY(size, yAlign, paddingAndSize) {
    let { y, height } = size;
    if (yAlign === "top") {
      y += paddingAndSize;
    } else if (yAlign === "bottom") {
      y -= height + paddingAndSize;
    } else {
      y -= height / 2;
    }
    return y;
  }
  function getBackgroundPoint(options, size, alignment, chart) {
    const { caretSize, caretPadding, cornerRadius } = options;
    const { xAlign, yAlign } = alignment;
    const paddingAndSize = caretSize + caretPadding;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    let x = alignX(size, xAlign);
    const y = alignY(size, yAlign, paddingAndSize);
    if (yAlign === "center") {
      if (xAlign === "left") {
        x += paddingAndSize;
      } else if (xAlign === "right") {
        x -= paddingAndSize;
      }
    } else if (xAlign === "left") {
      x -= Math.max(topLeft, bottomLeft) + caretSize;
    } else if (xAlign === "right") {
      x += Math.max(topRight, bottomRight) + caretSize;
    }
    return {
      x: _limitValue(x, 0, chart.width - size.width),
      y: _limitValue(y, 0, chart.height - size.height)
    };
  }
  function getAlignedX(tooltip, align, options) {
    const padding = toPadding(options.padding);
    return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
  }
  function getBeforeAfterBodyLines(callback2) {
    return pushOrConcat([], splitNewlines(callback2));
  }
  function createTooltipContext(parent, tooltip, tooltipItems) {
    return createContext(parent, {
      tooltip,
      tooltipItems,
      type: "tooltip"
    });
  }
  function overrideCallbacks(callbacks, context) {
    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
    return override ? callbacks.override(override) : callbacks;
  }
  var defaultCallbacks = {
    beforeTitle: noop2,
    title(tooltipItems) {
      if (tooltipItems.length > 0) {
        const item = tooltipItems[0];
        const labels = item.chart.data.labels;
        const labelCount = labels ? labels.length : 0;
        if (this && this.options && this.options.mode === "dataset") {
          return item.dataset.label || "";
        } else if (item.label) {
          return item.label;
        } else if (labelCount > 0 && item.dataIndex < labelCount) {
          return labels[item.dataIndex];
        }
      }
      return "";
    },
    afterTitle: noop2,
    beforeBody: noop2,
    beforeLabel: noop2,
    label(tooltipItem) {
      if (this && this.options && this.options.mode === "dataset") {
        return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
      }
      let label = tooltipItem.dataset.label || "";
      if (label) {
        label += ": ";
      }
      const value = tooltipItem.formattedValue;
      if (!isNullOrUndef(value)) {
        label += value;
      }
      return label;
    },
    labelColor(tooltipItem) {
      const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
      const options = meta.controller.getStyle(tooltipItem.dataIndex);
      return {
        borderColor: options.borderColor,
        backgroundColor: options.backgroundColor,
        borderWidth: options.borderWidth,
        borderDash: options.borderDash,
        borderDashOffset: options.borderDashOffset,
        borderRadius: 0
      };
    },
    labelTextColor() {
      return this.options.bodyColor;
    },
    labelPointStyle(tooltipItem) {
      const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
      const options = meta.controller.getStyle(tooltipItem.dataIndex);
      return {
        pointStyle: options.pointStyle,
        rotation: options.rotation
      };
    },
    afterLabel: noop2,
    afterBody: noop2,
    beforeFooter: noop2,
    footer: noop2,
    afterFooter: noop2
  };
  function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
    const result = callbacks[name].call(ctx, arg);
    if (typeof result === "undefined") {
      return defaultCallbacks[name].call(ctx, arg);
    }
    return result;
  }
  var Tooltip = class extends Element {
    constructor(config) {
      super();
      this.opacity = 0;
      this._active = [];
      this._eventPosition = void 0;
      this._size = void 0;
      this._cachedAnimations = void 0;
      this._tooltipItems = [];
      this.$animations = void 0;
      this.$context = void 0;
      this.chart = config.chart;
      this.options = config.options;
      this.dataPoints = void 0;
      this.title = void 0;
      this.beforeBody = void 0;
      this.body = void 0;
      this.afterBody = void 0;
      this.footer = void 0;
      this.xAlign = void 0;
      this.yAlign = void 0;
      this.x = void 0;
      this.y = void 0;
      this.height = void 0;
      this.width = void 0;
      this.caretX = void 0;
      this.caretY = void 0;
      this.labelColors = void 0;
      this.labelPointStyles = void 0;
      this.labelTextColors = void 0;
    }
    initialize(options) {
      this.options = options;
      this._cachedAnimations = void 0;
      this.$context = void 0;
    }
    _resolveAnimations() {
      const cached = this._cachedAnimations;
      if (cached) {
        return cached;
      }
      const chart = this.chart;
      const options = this.options.setContext(this.getContext());
      const opts = options.enabled && chart.options.animation && options.animations;
      const animations = new Animations(this.chart, opts);
      if (opts._cacheable) {
        this._cachedAnimations = Object.freeze(animations);
      }
      return animations;
    }
    getContext() {
      return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
    }
    getTitle(context, options) {
      const { callbacks } = options;
      const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
      const title = invokeCallbackWithFallback(callbacks, "title", this, context);
      const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeTitle));
      lines = pushOrConcat(lines, splitNewlines(title));
      lines = pushOrConcat(lines, splitNewlines(afterTitle));
      return lines;
    }
    getBeforeBody(tooltipItems, options) {
      return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
    }
    getBody(tooltipItems, options) {
      const { callbacks } = options;
      const bodyItems = [];
      each(tooltipItems, (context) => {
        const bodyItem = {
          before: [],
          lines: [],
          after: []
        };
        const scoped = overrideCallbacks(callbacks, context);
        pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
        pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
        pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
        bodyItems.push(bodyItem);
      });
      return bodyItems;
    }
    getAfterBody(tooltipItems, options) {
      return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
    }
    getFooter(tooltipItems, options) {
      const { callbacks } = options;
      const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
      const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
      const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeFooter));
      lines = pushOrConcat(lines, splitNewlines(footer));
      lines = pushOrConcat(lines, splitNewlines(afterFooter));
      return lines;
    }
    _createItems(options) {
      const active = this._active;
      const data = this.chart.data;
      const labelColors = [];
      const labelPointStyles = [];
      const labelTextColors = [];
      let tooltipItems = [];
      let i, len;
      for (i = 0, len = active.length; i < len; ++i) {
        tooltipItems.push(createTooltipItem(this.chart, active[i]));
      }
      if (options.filter) {
        tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
      }
      if (options.itemSort) {
        tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
      }
      each(tooltipItems, (context) => {
        const scoped = overrideCallbacks(options.callbacks, context);
        labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
        labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
        labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
      });
      this.labelColors = labelColors;
      this.labelPointStyles = labelPointStyles;
      this.labelTextColors = labelTextColors;
      this.dataPoints = tooltipItems;
      return tooltipItems;
    }
    update(changed, replay) {
      const options = this.options.setContext(this.getContext());
      const active = this._active;
      let properties;
      let tooltipItems = [];
      if (!active.length) {
        if (this.opacity !== 0) {
          properties = {
            opacity: 0
          };
        }
      } else {
        const position = positioners[options.position].call(this, active, this._eventPosition);
        tooltipItems = this._createItems(options);
        this.title = this.getTitle(tooltipItems, options);
        this.beforeBody = this.getBeforeBody(tooltipItems, options);
        this.body = this.getBody(tooltipItems, options);
        this.afterBody = this.getAfterBody(tooltipItems, options);
        this.footer = this.getFooter(tooltipItems, options);
        const size = this._size = getTooltipSize(this, options);
        const positionAndSize = Object.assign({}, position, size);
        const alignment = determineAlignment(this.chart, options, positionAndSize);
        const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        properties = {
          opacity: 1,
          x: backgroundPoint.x,
          y: backgroundPoint.y,
          width: size.width,
          height: size.height,
          caretX: position.x,
          caretY: position.y
        };
      }
      this._tooltipItems = tooltipItems;
      this.$context = void 0;
      if (properties) {
        this._resolveAnimations().update(this, properties);
      }
      if (changed && options.external) {
        options.external.call(this, {
          chart: this.chart,
          tooltip: this,
          replay
        });
      }
    }
    drawCaret(tooltipPoint, ctx, size, options) {
      const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
      ctx.lineTo(caretPosition.x1, caretPosition.y1);
      ctx.lineTo(caretPosition.x2, caretPosition.y2);
      ctx.lineTo(caretPosition.x3, caretPosition.y3);
    }
    getCaretPosition(tooltipPoint, size, options) {
      const { xAlign, yAlign } = this;
      const { caretSize, cornerRadius } = options;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
      const { x: ptX, y: ptY } = tooltipPoint;
      const { width, height } = size;
      let x1, x2, x3, y1, y2, y3;
      if (yAlign === "center") {
        y2 = ptY + height / 2;
        if (xAlign === "left") {
          x1 = ptX;
          x2 = x1 - caretSize;
          y1 = y2 + caretSize;
          y3 = y2 - caretSize;
        } else {
          x1 = ptX + width;
          x2 = x1 + caretSize;
          y1 = y2 - caretSize;
          y3 = y2 + caretSize;
        }
        x3 = x1;
      } else {
        if (xAlign === "left") {
          x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
        } else if (xAlign === "right") {
          x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
        } else {
          x2 = this.caretX;
        }
        if (yAlign === "top") {
          y1 = ptY;
          y2 = y1 - caretSize;
          x1 = x2 - caretSize;
          x3 = x2 + caretSize;
        } else {
          y1 = ptY + height;
          y2 = y1 + caretSize;
          x1 = x2 + caretSize;
          x3 = x2 - caretSize;
        }
        y3 = y1;
      }
      return {
        x1,
        x2,
        x3,
        y1,
        y2,
        y3
      };
    }
    drawTitle(pt, ctx, options) {
      const title = this.title;
      const length = title.length;
      let titleFont, titleSpacing, i;
      if (length) {
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        pt.x = getAlignedX(this, options.titleAlign, options);
        ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
        ctx.textBaseline = "middle";
        titleFont = toFont(options.titleFont);
        titleSpacing = options.titleSpacing;
        ctx.fillStyle = options.titleColor;
        ctx.font = titleFont.string;
        for (i = 0; i < length; ++i) {
          ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
          pt.y += titleFont.lineHeight + titleSpacing;
          if (i + 1 === length) {
            pt.y += options.titleMarginBottom - titleSpacing;
          }
        }
      }
    }
    _drawColorBox(ctx, pt, i, rtlHelper, options) {
      const labelColor = this.labelColors[i];
      const labelPointStyle = this.labelPointStyles[i];
      const { boxHeight, boxWidth } = options;
      const bodyFont = toFont(options.bodyFont);
      const colorX = getAlignedX(this, "left", options);
      const rtlColorX = rtlHelper.x(colorX);
      const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
      const colorY = pt.y + yOffSet;
      if (options.usePointStyle) {
        const drawOptions = {
          radius: Math.min(boxWidth, boxHeight) / 2,
          pointStyle: labelPointStyle.pointStyle,
          rotation: labelPointStyle.rotation,
          borderWidth: 1
        };
        const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
        const centerY = colorY + boxHeight / 2;
        ctx.strokeStyle = options.multiKeyBackground;
        ctx.fillStyle = options.multiKeyBackground;
        drawPoint(ctx, drawOptions, centerX, centerY);
        ctx.strokeStyle = labelColor.borderColor;
        ctx.fillStyle = labelColor.backgroundColor;
        drawPoint(ctx, drawOptions, centerX, centerY);
      } else {
        ctx.lineWidth = isObject2(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
        ctx.strokeStyle = labelColor.borderColor;
        ctx.setLineDash(labelColor.borderDash || []);
        ctx.lineDashOffset = labelColor.borderDashOffset || 0;
        const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
        const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
        const borderRadius = toTRBLCorners(labelColor.borderRadius);
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          ctx.beginPath();
          ctx.fillStyle = options.multiKeyBackground;
          addRoundedRectPath(ctx, {
            x: outerX,
            y: colorY,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = labelColor.backgroundColor;
          ctx.beginPath();
          addRoundedRectPath(ctx, {
            x: innerX,
            y: colorY + 1,
            w: boxWidth - 2,
            h: boxHeight - 2,
            radius: borderRadius
          });
          ctx.fill();
        } else {
          ctx.fillStyle = options.multiKeyBackground;
          ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
          ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
          ctx.fillStyle = labelColor.backgroundColor;
          ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
        }
      }
      ctx.fillStyle = this.labelTextColors[i];
    }
    drawBody(pt, ctx, options) {
      const { body } = this;
      const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
      const bodyFont = toFont(options.bodyFont);
      let bodyLineHeight = bodyFont.lineHeight;
      let xLinePadding = 0;
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      const fillLineOfText = function(line) {
        ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
        pt.y += bodyLineHeight + bodySpacing;
      };
      const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
      let bodyItem, textColor, lines, i, j, ilen, jlen;
      ctx.textAlign = bodyAlign;
      ctx.textBaseline = "middle";
      ctx.font = bodyFont.string;
      pt.x = getAlignedX(this, bodyAlignForCalculation, options);
      ctx.fillStyle = options.bodyColor;
      each(this.beforeBody, fillLineOfText);
      xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
      for (i = 0, ilen = body.length; i < ilen; ++i) {
        bodyItem = body[i];
        textColor = this.labelTextColors[i];
        ctx.fillStyle = textColor;
        each(bodyItem.before, fillLineOfText);
        lines = bodyItem.lines;
        if (displayColors && lines.length) {
          this._drawColorBox(ctx, pt, i, rtlHelper, options);
          bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
        }
        for (j = 0, jlen = lines.length; j < jlen; ++j) {
          fillLineOfText(lines[j]);
          bodyLineHeight = bodyFont.lineHeight;
        }
        each(bodyItem.after, fillLineOfText);
      }
      xLinePadding = 0;
      bodyLineHeight = bodyFont.lineHeight;
      each(this.afterBody, fillLineOfText);
      pt.y -= bodySpacing;
    }
    drawFooter(pt, ctx, options) {
      const footer = this.footer;
      const length = footer.length;
      let footerFont, i;
      if (length) {
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        pt.x = getAlignedX(this, options.footerAlign, options);
        pt.y += options.footerMarginTop;
        ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
        ctx.textBaseline = "middle";
        footerFont = toFont(options.footerFont);
        ctx.fillStyle = options.footerColor;
        ctx.font = footerFont.string;
        for (i = 0; i < length; ++i) {
          ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
          pt.y += footerFont.lineHeight + options.footerSpacing;
        }
      }
    }
    drawBackground(pt, ctx, tooltipSize, options) {
      const { xAlign, yAlign } = this;
      const { x, y } = pt;
      const { width, height } = tooltipSize;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
      ctx.fillStyle = options.backgroundColor;
      ctx.strokeStyle = options.borderColor;
      ctx.lineWidth = options.borderWidth;
      ctx.beginPath();
      ctx.moveTo(x + topLeft, y);
      if (yAlign === "top") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + width - topRight, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
      if (yAlign === "center" && xAlign === "right") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + width, y + height - bottomRight);
      ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
      if (yAlign === "bottom") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + bottomLeft, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
      if (yAlign === "center" && xAlign === "left") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x, y + topLeft);
      ctx.quadraticCurveTo(x, y, x + topLeft, y);
      ctx.closePath();
      ctx.fill();
      if (options.borderWidth > 0) {
        ctx.stroke();
      }
    }
    _updateAnimationTarget(options) {
      const chart = this.chart;
      const anims = this.$animations;
      const animX = anims && anims.x;
      const animY = anims && anims.y;
      if (animX || animY) {
        const position = positioners[options.position].call(this, this._active, this._eventPosition);
        if (!position) {
          return;
        }
        const size = this._size = getTooltipSize(this, options);
        const positionAndSize = Object.assign({}, position, this._size);
        const alignment = determineAlignment(chart, options, positionAndSize);
        const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
        if (animX._to !== point.x || animY._to !== point.y) {
          this.xAlign = alignment.xAlign;
          this.yAlign = alignment.yAlign;
          this.width = size.width;
          this.height = size.height;
          this.caretX = position.x;
          this.caretY = position.y;
          this._resolveAnimations().update(this, point);
        }
      }
    }
    _willRender() {
      return !!this.opacity;
    }
    draw(ctx) {
      const options = this.options.setContext(this.getContext());
      let opacity = this.opacity;
      if (!opacity) {
        return;
      }
      this._updateAnimationTarget(options);
      const tooltipSize = {
        width: this.width,
        height: this.height
      };
      const pt = {
        x: this.x,
        y: this.y
      };
      opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
      const padding = toPadding(options.padding);
      const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
      if (options.enabled && hasTooltipContent) {
        ctx.save();
        ctx.globalAlpha = opacity;
        this.drawBackground(pt, ctx, tooltipSize, options);
        overrideTextDirection(ctx, options.textDirection);
        pt.y += padding.top;
        this.drawTitle(pt, ctx, options);
        this.drawBody(pt, ctx, options);
        this.drawFooter(pt, ctx, options);
        restoreTextDirection(ctx, options.textDirection);
        ctx.restore();
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements, eventPosition) {
      const lastActive = this._active;
      const active = activeElements.map(({ datasetIndex, index: index2 }) => {
        const meta = this.chart.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("Cannot find a dataset at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index2],
          index: index2
        };
      });
      const changed = !_elementsEqual(lastActive, active);
      const positionChanged = this._positionChanged(active, eventPosition);
      if (changed || positionChanged) {
        this._active = active;
        this._eventPosition = eventPosition;
        this._ignoreReplayEvents = true;
        this.update(true);
      }
    }
    handleEvent(e, replay, inChartArea = true) {
      if (replay && this._ignoreReplayEvents) {
        return false;
      }
      this._ignoreReplayEvents = false;
      const options = this.options;
      const lastActive = this._active || [];
      const active = this._getActiveElements(e, lastActive, replay, inChartArea);
      const positionChanged = this._positionChanged(active, e);
      const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
      if (changed) {
        this._active = active;
        if (options.enabled || options.external) {
          this._eventPosition = {
            x: e.x,
            y: e.y
          };
          this.update(true, replay);
        }
      }
      return changed;
    }
    _getActiveElements(e, lastActive, replay, inChartArea) {
      const options = this.options;
      if (e.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive.filter((i) => this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== void 0);
      }
      const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
      if (options.reverse) {
        active.reverse();
      }
      return active;
    }
    _positionChanged(active, e) {
      const { caretX, caretY, options } = this;
      const position = positioners[options.position].call(this, active, e);
      return position !== false && (caretX !== position.x || caretY !== position.y);
    }
  };
  __publicField(Tooltip, "positioners", positioners);
  var plugin_tooltip = {
    id: "tooltip",
    _element: Tooltip,
    positioners,
    afterInit(chart, _args, options) {
      if (options) {
        chart.tooltip = new Tooltip({
          chart,
          options
        });
      }
    },
    beforeUpdate(chart, _args, options) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options);
      }
    },
    reset(chart, _args, options) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options);
      }
    },
    afterDraw(chart) {
      const tooltip = chart.tooltip;
      if (tooltip && tooltip._willRender()) {
        const args = {
          tooltip
        };
        if (chart.notifyPlugins("beforeTooltipDraw", __spreadProps(__spreadValues({}, args), {
          cancelable: true
        })) === false) {
          return;
        }
        tooltip.draw(chart.ctx);
        chart.notifyPlugins("afterTooltipDraw", args);
      }
    },
    afterEvent(chart, args) {
      if (chart.tooltip) {
        const useFinalPosition = args.replay;
        if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
          args.changed = true;
        }
      }
    },
    defaults: {
      enabled: true,
      external: null,
      position: "average",
      backgroundColor: "rgba(0,0,0,0.8)",
      titleColor: "#fff",
      titleFont: {
        weight: "bold"
      },
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleAlign: "left",
      bodyColor: "#fff",
      bodySpacing: 2,
      bodyFont: {},
      bodyAlign: "left",
      footerColor: "#fff",
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFont: {
        weight: "bold"
      },
      footerAlign: "left",
      padding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      boxHeight: (ctx, opts) => opts.bodyFont.size,
      boxWidth: (ctx, opts) => opts.bodyFont.size,
      multiKeyBackground: "#fff",
      displayColors: true,
      boxPadding: 0,
      borderColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      animation: {
        duration: 400,
        easing: "easeOutQuart"
      },
      animations: {
        numbers: {
          type: "number",
          properties: [
            "x",
            "y",
            "width",
            "height",
            "caretX",
            "caretY"
          ]
        },
        opacity: {
          easing: "linear",
          duration: 200
        }
      },
      callbacks: defaultCallbacks
    },
    defaultRoutes: {
      bodyFont: "font",
      footerFont: "font",
      titleFont: "font"
    },
    descriptors: {
      _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
      _indexable: false,
      callbacks: {
        _scriptable: false,
        _indexable: false
      },
      animation: {
        _fallback: false
      },
      animations: {
        _fallback: "animation"
      }
    },
    additionalOptionScopes: [
      "interaction"
    ]
  };
  var plugins = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    Colors: plugin_colors,
    Decimation: plugin_decimation,
    Filler: index,
    Legend: plugin_legend,
    SubTitle: plugin_subtitle,
    Title: plugin_title,
    Tooltip: plugin_tooltip
  });
  var addIfString = (labels, raw, index2, addedLabels) => {
    if (typeof raw === "string") {
      index2 = labels.push(raw) - 1;
      addedLabels.unshift({
        index: index2,
        label: raw
      });
    } else if (isNaN(raw)) {
      index2 = null;
    }
    return index2;
  };
  function findOrAddLabel(labels, raw, index2, addedLabels) {
    const first = labels.indexOf(raw);
    if (first === -1) {
      return addIfString(labels, raw, index2, addedLabels);
    }
    const last = labels.lastIndexOf(raw);
    return first !== last ? index2 : first;
  }
  var validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
  function _getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
      return labels[value];
    }
    return value;
  }
  var CategoryScale = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this._startValue = void 0;
      this._valueRange = 0;
      this._addedLabels = [];
    }
    init(scaleOptions) {
      const added = this._addedLabels;
      if (added.length) {
        const labels = this.getLabels();
        for (const { index: index2, label } of added) {
          if (labels[index2] === label) {
            labels.splice(index2, 1);
          }
        }
        this._addedLabels = [];
      }
      super.init(scaleOptions);
    }
    parse(raw, index2) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      const labels = this.getLabels();
      index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
      return validIndex(index2, labels.length - 1);
    }
    determineDataLimits() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min, max } = this.getMinMax(true);
      if (this.options.bounds === "ticks") {
        if (!minDefined) {
          min = 0;
        }
        if (!maxDefined) {
          max = this.getLabels().length - 1;
        }
      }
      this.min = min;
      this.max = max;
    }
    buildTicks() {
      const min = this.min;
      const max = this.max;
      const offset = this.options.offset;
      const ticks = [];
      let labels = this.getLabels();
      labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
      this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
      this._startValue = this.min - (offset ? 0.5 : 0);
      for (let value = min; value <= max; value++) {
        ticks.push({
          value
        });
      }
      return ticks;
    }
    getLabelForValue(value) {
      return _getLabelForValue.call(this, value);
    }
    configure() {
      super.configure();
      if (!this.isHorizontal()) {
        this._reversePixels = !this._reversePixels;
      }
    }
    getPixelForValue(value) {
      if (typeof value !== "number") {
        value = this.parse(value);
      }
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getPixelForTick(index2) {
      const ticks = this.ticks;
      if (index2 < 0 || index2 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index2].value);
    }
    getValueForPixel(pixel) {
      return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
    }
    getBasePixel() {
      return this.bottom;
    }
  };
  __publicField(CategoryScale, "id", "category");
  __publicField(CategoryScale, "defaults", {
    ticks: {
      callback: _getLabelForValue
    }
  });
  function generateTicks$1(generationOptions, dataRange) {
    const ticks = [];
    const MIN_SPACING = 1e-14;
    const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
    const unit = step || 1;
    const maxSpaces = maxTicks - 1;
    const { min: rmin, max: rmax } = dataRange;
    const minDefined = !isNullOrUndef(min);
    const maxDefined = !isNullOrUndef(max);
    const countDefined = !isNullOrUndef(count);
    const minSpacing = (rmax - rmin) / (maxDigits + 1);
    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
    let factor, niceMin, niceMax, numSpaces;
    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
      return [
        {
          value: rmin
        },
        {
          value: rmax
        }
      ];
    }
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxSpaces) {
      spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
    }
    if (!isNullOrUndef(precision)) {
      factor = Math.pow(10, precision);
      spacing = Math.ceil(spacing * factor) / factor;
    }
    if (bounds === "ticks") {
      niceMin = Math.floor(rmin / spacing) * spacing;
      niceMax = Math.ceil(rmax / spacing) * spacing;
    } else {
      niceMin = rmin;
      niceMax = rmax;
    }
    if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
      numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
      spacing = (max - min) / numSpaces;
      niceMin = min;
      niceMax = max;
    } else if (countDefined) {
      niceMin = minDefined ? min : niceMin;
      niceMax = maxDefined ? max : niceMax;
      numSpaces = count - 1;
      spacing = (niceMax - niceMin) / numSpaces;
    } else {
      numSpaces = (niceMax - niceMin) / spacing;
      if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
        numSpaces = Math.round(numSpaces);
      } else {
        numSpaces = Math.ceil(numSpaces);
      }
    }
    const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    let j = 0;
    if (minDefined) {
      if (includeBounds && niceMin !== min) {
        ticks.push({
          value: min
        });
        if (niceMin < min) {
          j++;
        }
        if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
          j++;
        }
      } else if (niceMin < min) {
        j++;
      }
    }
    for (; j < numSpaces; ++j) {
      const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
      if (maxDefined && tickValue > max) {
        break;
      }
      ticks.push({
        value: tickValue
      });
    }
    if (maxDefined && includeBounds && niceMax !== max) {
      if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
        ticks[ticks.length - 1].value = max;
      } else {
        ticks.push({
          value: max
        });
      }
    } else if (!maxDefined || niceMax === max) {
      ticks.push({
        value: niceMax
      });
    }
    return ticks;
  }
  function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
    const rad = toRadians(minRotation);
    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
    const length = 0.75 * minSpacing * ("" + value).length;
    return Math.min(minSpacing / ratio, length);
  }
  var LinearScaleBase = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._endValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index2) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
        return null;
      }
      return +raw;
    }
    handleTickRangeOptions() {
      const { beginAtZero } = this.options;
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min, max } = this;
      const setMin = (v) => min = minDefined ? min : v;
      const setMax = (v) => max = maxDefined ? max : v;
      if (beginAtZero) {
        const minSign = sign(min);
        const maxSign = sign(max);
        if (minSign < 0 && maxSign < 0) {
          setMax(0);
        } else if (minSign > 0 && maxSign > 0) {
          setMin(0);
        }
      }
      if (min === max) {
        let offset = max === 0 ? 1 : Math.abs(max * 0.05);
        setMax(max + offset);
        if (!beginAtZero) {
          setMin(min - offset);
        }
      }
      this.min = min;
      this.max = max;
    }
    getTickLimit() {
      const tickOpts = this.options.ticks;
      let { maxTicksLimit, stepSize } = tickOpts;
      let maxTicks;
      if (stepSize) {
        maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
        if (maxTicks > 1e3) {
          console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
          maxTicks = 1e3;
        }
      } else {
        maxTicks = this.computeTickLimit();
        maxTicksLimit = maxTicksLimit || 11;
      }
      if (maxTicksLimit) {
        maxTicks = Math.min(maxTicksLimit, maxTicks);
      }
      return maxTicks;
    }
    computeTickLimit() {
      return Number.POSITIVE_INFINITY;
    }
    buildTicks() {
      const opts = this.options;
      const tickOpts = opts.ticks;
      let maxTicks = this.getTickLimit();
      maxTicks = Math.max(2, maxTicks);
      const numericGeneratorOptions = {
        maxTicks,
        bounds: opts.bounds,
        min: opts.min,
        max: opts.max,
        precision: tickOpts.precision,
        step: tickOpts.stepSize,
        count: tickOpts.count,
        maxDigits: this._maxDigits(),
        horizontal: this.isHorizontal(),
        minRotation: tickOpts.minRotation || 0,
        includeBounds: tickOpts.includeBounds !== false
      };
      const dataRange = this._range || this;
      const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    configure() {
      const ticks = this.ticks;
      let start = this.min;
      let end = this.max;
      super.configure();
      if (this.options.offset && ticks.length) {
        const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
        start -= offset;
        end += offset;
      }
      this._startValue = start;
      this._endValue = end;
      this._valueRange = end - start;
    }
    getLabelForValue(value) {
      return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
  };
  var LinearScale = class extends LinearScaleBase {
    determineDataLimits() {
      const { min, max } = this.getMinMax(true);
      this.min = isNumberFinite(min) ? min : 0;
      this.max = isNumberFinite(max) ? max : 1;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      const horizontal = this.isHorizontal();
      const length = horizontal ? this.width : this.height;
      const minRotation = toRadians(this.options.ticks.minRotation);
      const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
      const tickFont = this._resolveTickFontOptions(0);
      return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
    }
    getPixelForValue(value) {
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
    }
  };
  __publicField(LinearScale, "id", "linear");
  __publicField(LinearScale, "defaults", {
    ticks: {
      callback: Ticks.formatters.numeric
    }
  });
  var log10Floor = (v) => Math.floor(log10(v));
  var changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
  function isMajor(tickVal) {
    const remain = tickVal / Math.pow(10, log10Floor(tickVal));
    return remain === 1;
  }
  function steps(min, max, rangeExp) {
    const rangeStep = Math.pow(10, rangeExp);
    const start = Math.floor(min / rangeStep);
    const end = Math.ceil(max / rangeStep);
    return end - start;
  }
  function startExp(min, max) {
    const range2 = max - min;
    let rangeExp = log10Floor(range2);
    while (steps(min, max, rangeExp) > 10) {
      rangeExp++;
    }
    while (steps(min, max, rangeExp) < 10) {
      rangeExp--;
    }
    return Math.min(rangeExp, log10Floor(min));
  }
  function generateTicks(generationOptions, { min, max }) {
    min = finiteOrDefault(generationOptions.min, min);
    const ticks = [];
    const minExp = log10Floor(min);
    let exp = startExp(min, max);
    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    const stepSize = Math.pow(10, exp);
    const base = minExp > exp ? Math.pow(10, minExp) : 0;
    const start = Math.round((min - base) * precision) / precision;
    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
    let significand = Math.floor((start - offset) / Math.pow(10, exp));
    let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
    while (value < max) {
      ticks.push({
        value,
        major: isMajor(value),
        significand
      });
      if (significand >= 10) {
        significand = significand < 15 ? 15 : 20;
      } else {
        significand++;
      }
      if (significand >= 20) {
        exp++;
        significand = 2;
        precision = exp >= 0 ? 1 : precision;
      }
      value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
    }
    const lastTick = finiteOrDefault(generationOptions.max, value);
    ticks.push({
      value: lastTick,
      major: isMajor(lastTick),
      significand
    });
    return ticks;
  }
  var LogarithmicScale = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index2) {
      const value = LinearScaleBase.prototype.parse.apply(this, [
        raw,
        index2
      ]);
      if (value === 0) {
        this._zero = true;
        return void 0;
      }
      return isNumberFinite(value) && value > 0 ? value : null;
    }
    determineDataLimits() {
      const { min, max } = this.getMinMax(true);
      this.min = isNumberFinite(min) ? Math.max(0, min) : null;
      this.max = isNumberFinite(max) ? Math.max(0, max) : null;
      if (this.options.beginAtZero) {
        this._zero = true;
      }
      if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
        this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
      }
      this.handleTickRangeOptions();
    }
    handleTickRangeOptions() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let min = this.min;
      let max = this.max;
      const setMin = (v) => min = minDefined ? min : v;
      const setMax = (v) => max = maxDefined ? max : v;
      if (min === max) {
        if (min <= 0) {
          setMin(1);
          setMax(10);
        } else {
          setMin(changeExponent(min, -1));
          setMax(changeExponent(max, 1));
        }
      }
      if (min <= 0) {
        setMin(changeExponent(max, -1));
      }
      if (max <= 0) {
        setMax(changeExponent(min, 1));
      }
      this.min = min;
      this.max = max;
    }
    buildTicks() {
      const opts = this.options;
      const generationOptions = {
        min: this._userMin,
        max: this._userMax
      };
      const ticks = generateTicks(generationOptions, this);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    getLabelForValue(value) {
      return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
    configure() {
      const start = this.min;
      super.configure();
      this._startValue = log10(start);
      this._valueRange = log10(this.max) - log10(start);
    }
    getPixelForValue(value) {
      if (value === void 0 || value === 0) {
        value = this.min;
      }
      if (value === null || isNaN(value)) {
        return NaN;
      }
      return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      const decimal = this.getDecimalForPixel(pixel);
      return Math.pow(10, this._startValue + decimal * this._valueRange);
    }
  };
  __publicField(LogarithmicScale, "id", "logarithmic");
  __publicField(LogarithmicScale, "defaults", {
    ticks: {
      callback: Ticks.formatters.logarithmic,
      major: {
        enabled: true
      }
    }
  });
  function getTickBackdropHeight(opts) {
    const tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
      const padding = toPadding(tickOpts.backdropPadding);
      return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
    }
    return 0;
  }
  function measureLabelSize(ctx, font, label) {
    label = isArray(label) ? label : [
      label
    ];
    return {
      w: _longestText(ctx, font.string, label),
      h: label.length * font.lineHeight
    };
  }
  function determineLimits(angle, pos, size, min, max) {
    if (angle === min || angle === max) {
      return {
        start: pos - size / 2,
        end: pos + size / 2
      };
    } else if (angle < min || angle > max) {
      return {
        start: pos - size,
        end: pos
      };
    }
    return {
      start: pos,
      end: pos + size
    };
  }
  function fitWithPointLabels(scale) {
    const orig = {
      l: scale.left + scale._padding.left,
      r: scale.right - scale._padding.right,
      t: scale.top + scale._padding.top,
      b: scale.bottom - scale._padding.bottom
    };
    const limits = Object.assign({}, orig);
    const labelSizes = [];
    const padding = [];
    const valueCount = scale._pointLabels.length;
    const pointLabelOpts = scale.options.pointLabels;
    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
    for (let i = 0; i < valueCount; i++) {
      const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
      padding[i] = opts.padding;
      const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
      const plFont = toFont(opts.font);
      const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
      labelSizes[i] = textSize;
      const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
      const angle = Math.round(toDegrees(angleRadians));
      const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
      const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
      updateLimits(limits, orig, angleRadians, hLimits, vLimits);
    }
    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
  }
  function updateLimits(limits, orig, angle, hLimits, vLimits) {
    const sin = Math.abs(Math.sin(angle));
    const cos = Math.abs(Math.cos(angle));
    let x = 0;
    let y = 0;
    if (hLimits.start < orig.l) {
      x = (orig.l - hLimits.start) / sin;
      limits.l = Math.min(limits.l, orig.l - x);
    } else if (hLimits.end > orig.r) {
      x = (hLimits.end - orig.r) / sin;
      limits.r = Math.max(limits.r, orig.r + x);
    }
    if (vLimits.start < orig.t) {
      y = (orig.t - vLimits.start) / cos;
      limits.t = Math.min(limits.t, orig.t - y);
    } else if (vLimits.end > orig.b) {
      y = (vLimits.end - orig.b) / cos;
      limits.b = Math.max(limits.b, orig.b + y);
    }
  }
  function createPointLabelItem(scale, index2, itemOpts) {
    const outerDistance = scale.drawingArea;
    const { extra, additionalAngle, padding, size } = itemOpts;
    const pointLabelPosition = scale.getPointPosition(index2, outerDistance + extra + padding, additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    return {
      visible: true,
      x: pointLabelPosition.x,
      y,
      textAlign,
      left,
      top: y,
      right: left + size.w,
      bottom: y + size.h
    };
  }
  function isNotOverlapped(item, area) {
    if (!area) {
      return true;
    }
    const { left, top: top2, right, bottom: bottom2 } = item;
    const apexesInArea = _isPointInArea({
      x: left,
      y: top2
    }, area) || _isPointInArea({
      x: left,
      y: bottom2
    }, area) || _isPointInArea({
      x: right,
      y: top2
    }, area) || _isPointInArea({
      x: right,
      y: bottom2
    }, area);
    return !apexesInArea;
  }
  function buildPointLabelItems(scale, labelSizes, padding) {
    const items = [];
    const valueCount = scale._pointLabels.length;
    const opts = scale.options;
    const { centerPointLabels, display } = opts.pointLabels;
    const itemOpts = {
      extra: getTickBackdropHeight(opts) / 2,
      additionalAngle: centerPointLabels ? PI / valueCount : 0
    };
    let area;
    for (let i = 0; i < valueCount; i++) {
      itemOpts.padding = padding[i];
      itemOpts.size = labelSizes[i];
      const item = createPointLabelItem(scale, i, itemOpts);
      items.push(item);
      if (display === "auto") {
        item.visible = isNotOverlapped(item, area);
        if (item.visible) {
          area = item;
        }
      }
    }
    return items;
  }
  function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) {
      return "center";
    } else if (angle < 180) {
      return "left";
    }
    return "right";
  }
  function leftForTextAlign(x, w, align) {
    if (align === "right") {
      x -= w;
    } else if (align === "center") {
      x -= w / 2;
    }
    return x;
  }
  function yForAngle(y, h, angle) {
    if (angle === 90 || angle === 270) {
      y -= h / 2;
    } else if (angle > 270 || angle < 90) {
      y -= h;
    }
    return y;
  }
  function drawPointLabelBox(ctx, opts, item) {
    const { left, top: top2, right, bottom: bottom2 } = item;
    const { backdropColor } = opts;
    if (!isNullOrUndef(backdropColor)) {
      const borderRadius = toTRBLCorners(opts.borderRadius);
      const padding = toPadding(opts.backdropPadding);
      ctx.fillStyle = backdropColor;
      const backdropLeft = left - padding.left;
      const backdropTop = top2 - padding.top;
      const backdropWidth = right - left + padding.width;
      const backdropHeight = bottom2 - top2 + padding.height;
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: backdropLeft,
          y: backdropTop,
          w: backdropWidth,
          h: backdropHeight,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
      }
    }
  }
  function drawPointLabels(scale, labelCount) {
    const { ctx, options: { pointLabels } } = scale;
    for (let i = labelCount - 1; i >= 0; i--) {
      const item = scale._pointLabelItems[i];
      if (!item.visible) {
        continue;
      }
      const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
      drawPointLabelBox(ctx, optsAtIndex, item);
      const plFont = toFont(optsAtIndex.font);
      const { x, y, textAlign } = item;
      renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
        color: optsAtIndex.color,
        textAlign,
        textBaseline: "middle"
      });
    }
  }
  function pathRadiusLine(scale, radius, circular, labelCount) {
    const { ctx } = scale;
    if (circular) {
      ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
    } else {
      let pointPosition = scale.getPointPosition(0, radius);
      ctx.moveTo(pointPosition.x, pointPosition.y);
      for (let i = 1; i < labelCount; i++) {
        pointPosition = scale.getPointPosition(i, radius);
        ctx.lineTo(pointPosition.x, pointPosition.y);
      }
    }
  }
  function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
    const ctx = scale.ctx;
    const circular = gridLineOpts.circular;
    const { color: color2, lineWidth } = gridLineOpts;
    if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
      return;
    }
    ctx.save();
    ctx.strokeStyle = color2;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(borderOpts.dash);
    ctx.lineDashOffset = borderOpts.dashOffset;
    ctx.beginPath();
    pathRadiusLine(scale, radius, circular, labelCount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
  function createPointLabelContext(parent, index2, label) {
    return createContext(parent, {
      label,
      index: index2,
      type: "pointLabel"
    });
  }
  var RadialLinearScale = class extends LinearScaleBase {
    constructor(cfg) {
      super(cfg);
      this.xCenter = void 0;
      this.yCenter = void 0;
      this.drawingArea = void 0;
      this._pointLabels = [];
      this._pointLabelItems = [];
    }
    setDimensions() {
      const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
      const w = this.width = this.maxWidth - padding.width;
      const h = this.height = this.maxHeight - padding.height;
      this.xCenter = Math.floor(this.left + w / 2 + padding.left);
      this.yCenter = Math.floor(this.top + h / 2 + padding.top);
      this.drawingArea = Math.floor(Math.min(w, h) / 2);
    }
    determineDataLimits() {
      const { min, max } = this.getMinMax(false);
      this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
      this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
    }
    generateTickLabels(ticks) {
      LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
      this._pointLabels = this.getLabels().map((value, index2) => {
        const label = callback(this.options.pointLabels.callback, [
          value,
          index2
        ], this);
        return label || label === 0 ? label : "";
      }).filter((v, i) => this.chart.getDataVisibility(i));
    }
    fit() {
      const opts = this.options;
      if (opts.display && opts.pointLabels.display) {
        fitWithPointLabels(this);
      } else {
        this.setCenterPoint(0, 0, 0, 0);
      }
    }
    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
      this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
      this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
      this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
    }
    getIndexAngle(index2) {
      const angleMultiplier = TAU / (this._pointLabels.length || 1);
      const startAngle = this.options.startAngle || 0;
      return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
    }
    getDistanceFromCenterForValue(value) {
      if (isNullOrUndef(value)) {
        return NaN;
      }
      const scalingFactor = this.drawingArea / (this.max - this.min);
      if (this.options.reverse) {
        return (this.max - value) * scalingFactor;
      }
      return (value - this.min) * scalingFactor;
    }
    getValueForDistanceFromCenter(distance) {
      if (isNullOrUndef(distance)) {
        return NaN;
      }
      const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
      return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
    }
    getPointLabelContext(index2) {
      const pointLabels = this._pointLabels || [];
      if (index2 >= 0 && index2 < pointLabels.length) {
        const pointLabel = pointLabels[index2];
        return createPointLabelContext(this.getContext(), index2, pointLabel);
      }
    }
    getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
      const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
      return {
        x: Math.cos(angle) * distanceFromCenter + this.xCenter,
        y: Math.sin(angle) * distanceFromCenter + this.yCenter,
        angle
      };
    }
    getPointPositionForValue(index2, value) {
      return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
    }
    getBasePosition(index2) {
      return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
    }
    getPointLabelPosition(index2) {
      const { left, top: top2, right, bottom: bottom2 } = this._pointLabelItems[index2];
      return {
        left,
        top: top2,
        right,
        bottom: bottom2
      };
    }
    drawBackground() {
      const { backgroundColor, grid: { circular } } = this.options;
      if (backgroundColor) {
        const ctx = this.ctx;
        ctx.save();
        ctx.beginPath();
        pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
        ctx.closePath();
        ctx.fillStyle = backgroundColor;
        ctx.fill();
        ctx.restore();
      }
    }
    drawGrid() {
      const ctx = this.ctx;
      const opts = this.options;
      const { angleLines, grid, border } = opts;
      const labelCount = this._pointLabels.length;
      let i, offset, position;
      if (opts.pointLabels.display) {
        drawPointLabels(this, labelCount);
      }
      if (grid.display) {
        this.ticks.forEach((tick, index2) => {
          if (index2 !== 0 || index2 === 0 && this.min < 0) {
            offset = this.getDistanceFromCenterForValue(tick.value);
            const context = this.getContext(index2);
            const optsAtIndex = grid.setContext(context);
            const optsAtIndexBorder = border.setContext(context);
            drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
          }
        });
      }
      if (angleLines.display) {
        ctx.save();
        for (i = labelCount - 1; i >= 0; i--) {
          const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
          const { color: color2, lineWidth } = optsAtIndex;
          if (!lineWidth || !color2) {
            continue;
          }
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = color2;
          ctx.setLineDash(optsAtIndex.borderDash);
          ctx.lineDashOffset = optsAtIndex.borderDashOffset;
          offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
          position = this.getPointPosition(i, offset);
          ctx.beginPath();
          ctx.moveTo(this.xCenter, this.yCenter);
          ctx.lineTo(position.x, position.y);
          ctx.stroke();
        }
        ctx.restore();
      }
    }
    drawBorder() {
    }
    drawLabels() {
      const ctx = this.ctx;
      const opts = this.options;
      const tickOpts = opts.ticks;
      if (!tickOpts.display) {
        return;
      }
      const startAngle = this.getIndexAngle(0);
      let offset, width;
      ctx.save();
      ctx.translate(this.xCenter, this.yCenter);
      ctx.rotate(startAngle);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      this.ticks.forEach((tick, index2) => {
        if (index2 === 0 && this.min >= 0 && !opts.reverse) {
          return;
        }
        const optsAtIndex = tickOpts.setContext(this.getContext(index2));
        const tickFont = toFont(optsAtIndex.font);
        offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
        if (optsAtIndex.showLabelBackdrop) {
          ctx.font = tickFont.string;
          width = ctx.measureText(tick.label).width;
          ctx.fillStyle = optsAtIndex.backdropColor;
          const padding = toPadding(optsAtIndex.backdropPadding);
          ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
        }
        renderText(ctx, tick.label, 0, -offset, tickFont, {
          color: optsAtIndex.color,
          strokeColor: optsAtIndex.textStrokeColor,
          strokeWidth: optsAtIndex.textStrokeWidth
        });
      });
      ctx.restore();
    }
    drawTitle() {
    }
  };
  __publicField(RadialLinearScale, "id", "radialLinear");
  __publicField(RadialLinearScale, "defaults", {
    display: true,
    animate: true,
    position: "chartArea",
    angleLines: {
      display: true,
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0
    },
    grid: {
      circular: false
    },
    startAngle: 0,
    ticks: {
      showLabelBackdrop: true,
      callback: Ticks.formatters.numeric
    },
    pointLabels: {
      backdropColor: void 0,
      backdropPadding: 2,
      display: true,
      font: {
        size: 10
      },
      callback(label) {
        return label;
      },
      padding: 5,
      centerPointLabels: false
    }
  });
  __publicField(RadialLinearScale, "defaultRoutes", {
    "angleLines.color": "borderColor",
    "pointLabels.color": "color",
    "ticks.color": "color"
  });
  __publicField(RadialLinearScale, "descriptors", {
    angleLines: {
      _fallback: "grid"
    }
  });
  var INTERVALS = {
    millisecond: {
      common: true,
      size: 1,
      steps: 1e3
    },
    second: {
      common: true,
      size: 1e3,
      steps: 60
    },
    minute: {
      common: true,
      size: 6e4,
      steps: 60
    },
    hour: {
      common: true,
      size: 36e5,
      steps: 24
    },
    day: {
      common: true,
      size: 864e5,
      steps: 30
    },
    week: {
      common: false,
      size: 6048e5,
      steps: 4
    },
    month: {
      common: true,
      size: 2628e6,
      steps: 12
    },
    quarter: {
      common: false,
      size: 7884e6,
      steps: 4
    },
    year: {
      common: true,
      size: 3154e7
    }
  };
  var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
  function sorter(a, b) {
    return a - b;
  }
  function parse(scale, input) {
    if (isNullOrUndef(input)) {
      return null;
    }
    const adapter = scale._adapter;
    const { parser, round: round2, isoWeekday } = scale._parseOpts;
    let value = input;
    if (typeof parser === "function") {
      value = parser(value);
    }
    if (!isNumberFinite(value)) {
      value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
    }
    if (value === null) {
      return null;
    }
    if (round2) {
      value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
    }
    return +value;
  }
  function determineUnitForAutoTicks(minUnit, min, max, capacity) {
    const ilen = UNITS.length;
    for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
      const interval = INTERVALS[UNITS[i]];
      const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
      if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
        return UNITS[i];
      }
    }
    return UNITS[ilen - 1];
  }
  function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
    for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
      const unit = UNITS[i];
      if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
        return unit;
      }
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
  }
  function determineMajorUnit(unit) {
    for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
      if (INTERVALS[UNITS[i]].common) {
        return UNITS[i];
      }
    }
  }
  function addTick(ticks, time, timestamps) {
    if (!timestamps) {
      ticks[time] = true;
    } else if (timestamps.length) {
      const { lo, hi } = _lookup(timestamps, time);
      const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
      ticks[timestamp] = true;
    }
  }
  function setMajorTicks(scale, ticks, map3, majorUnit) {
    const adapter = scale._adapter;
    const first = +adapter.startOf(ticks[0].value, majorUnit);
    const last = ticks[ticks.length - 1].value;
    let major, index2;
    for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
      index2 = map3[major];
      if (index2 >= 0) {
        ticks[index2].major = true;
      }
    }
    return ticks;
  }
  function ticksFromTimestamps(scale, values, majorUnit) {
    const ticks = [];
    const map3 = {};
    const ilen = values.length;
    let i, value;
    for (i = 0; i < ilen; ++i) {
      value = values[i];
      map3[value] = i;
      ticks.push({
        value,
        major: false
      });
    }
    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
  }
  var TimeScale = class extends Scale {
    constructor(props) {
      super(props);
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
      this._unit = "day";
      this._majorUnit = void 0;
      this._offsets = {};
      this._normalized = false;
      this._parseOpts = void 0;
    }
    init(scaleOpts, opts = {}) {
      const time = scaleOpts.time || (scaleOpts.time = {});
      const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
      adapter.init(opts);
      mergeIf(time.displayFormats, adapter.formats());
      this._parseOpts = {
        parser: time.parser,
        round: time.round,
        isoWeekday: time.isoWeekday
      };
      super.init(scaleOpts);
      this._normalized = opts.normalized;
    }
    parse(raw, index2) {
      if (raw === void 0) {
        return null;
      }
      return parse(this, raw);
    }
    beforeLayout() {
      super.beforeLayout();
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
    }
    determineDataLimits() {
      const options = this.options;
      const adapter = this._adapter;
      const unit = options.time.unit || "day";
      let { min, max, minDefined, maxDefined } = this.getUserBounds();
      function _applyBounds(bounds) {
        if (!minDefined && !isNaN(bounds.min)) {
          min = Math.min(min, bounds.min);
        }
        if (!maxDefined && !isNaN(bounds.max)) {
          max = Math.max(max, bounds.max);
        }
      }
      if (!minDefined || !maxDefined) {
        _applyBounds(this._getLabelBounds());
        if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
          _applyBounds(this.getMinMax(false));
        }
      }
      min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
      max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
      this.min = Math.min(min, max - 1);
      this.max = Math.max(min + 1, max);
    }
    _getLabelBounds() {
      const arr = this.getLabelTimestamps();
      let min = Number.POSITIVE_INFINITY;
      let max = Number.NEGATIVE_INFINITY;
      if (arr.length) {
        min = arr[0];
        max = arr[arr.length - 1];
      }
      return {
        min,
        max
      };
    }
    buildTicks() {
      const options = this.options;
      const timeOpts = options.time;
      const tickOpts = options.ticks;
      const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
      if (options.bounds === "ticks" && timestamps.length) {
        this.min = this._userMin || timestamps[0];
        this.max = this._userMax || timestamps[timestamps.length - 1];
      }
      const min = this.min;
      const max = this.max;
      const ticks = _filterBetween(timestamps, min, max);
      this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
      this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
      this.initOffsets(timestamps);
      if (options.reverse) {
        ticks.reverse();
      }
      return ticksFromTimestamps(this, ticks, this._majorUnit);
    }
    afterAutoSkip() {
      if (this.options.offsetAfterAutoskip) {
        this.initOffsets(this.ticks.map((tick) => +tick.value));
      }
    }
    initOffsets(timestamps = []) {
      let start = 0;
      let end = 0;
      let first, last;
      if (this.options.offset && timestamps.length) {
        first = this.getDecimalForValue(timestamps[0]);
        if (timestamps.length === 1) {
          start = 1 - first;
        } else {
          start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
        }
        last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
        if (timestamps.length === 1) {
          end = last;
        } else {
          end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
        }
      }
      const limit = timestamps.length < 3 ? 0.5 : 0.25;
      start = _limitValue(start, 0, limit);
      end = _limitValue(end, 0, limit);
      this._offsets = {
        start,
        end,
        factor: 1 / (start + 1 + end)
      };
    }
    _generate() {
      const adapter = this._adapter;
      const min = this.min;
      const max = this.max;
      const options = this.options;
      const timeOpts = options.time;
      const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
      const stepSize = valueOrDefault(options.ticks.stepSize, 1);
      const weekday = minor === "week" ? timeOpts.isoWeekday : false;
      const hasWeekday = isNumber(weekday) || weekday === true;
      const ticks = {};
      let first = min;
      let time, count;
      if (hasWeekday) {
        first = +adapter.startOf(first, "isoWeek", weekday);
      }
      first = +adapter.startOf(first, hasWeekday ? "day" : minor);
      if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
        throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
      }
      const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
      for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
        addTick(ticks, time, timestamps);
      }
      if (time === max || options.bounds === "ticks" || count === 1) {
        addTick(ticks, time, timestamps);
      }
      return Object.keys(ticks).sort(sorter).map((x) => +x);
    }
    getLabelForValue(value) {
      const adapter = this._adapter;
      const timeOpts = this.options.time;
      if (timeOpts.tooltipFormat) {
        return adapter.format(value, timeOpts.tooltipFormat);
      }
      return adapter.format(value, timeOpts.displayFormats.datetime);
    }
    format(value, format) {
      const options = this.options;
      const formats = options.time.displayFormats;
      const unit = this._unit;
      const fmt = format || formats[unit];
      return this._adapter.format(value, fmt);
    }
    _tickFormatFunction(time, index2, ticks, format) {
      const options = this.options;
      const formatter = options.ticks.callback;
      if (formatter) {
        return callback(formatter, [
          time,
          index2,
          ticks
        ], this);
      }
      const formats = options.time.displayFormats;
      const unit = this._unit;
      const majorUnit = this._majorUnit;
      const minorFormat = unit && formats[unit];
      const majorFormat = majorUnit && formats[majorUnit];
      const tick = ticks[index2];
      const major = majorUnit && majorFormat && tick && tick.major;
      return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    }
    generateTickLabels(ticks) {
      let i, ilen, tick;
      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        tick = ticks[i];
        tick.label = this._tickFormatFunction(tick.value, i, ticks);
      }
    }
    getDecimalForValue(value) {
      return value === null ? NaN : (value - this.min) / (this.max - this.min);
    }
    getPixelForValue(value) {
      const offsets = this._offsets;
      const pos = this.getDecimalForValue(value);
      return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return this.min + pos * (this.max - this.min);
    }
    _getLabelSize(label) {
      const ticksOpts = this.options.ticks;
      const tickLabelWidth = this.ctx.measureText(label).width;
      const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
      const cosRotation = Math.cos(angle);
      const sinRotation = Math.sin(angle);
      const tickFontSize = this._resolveTickFontOptions(0).size;
      return {
        w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
        h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
      };
    }
    _getLabelCapacity(exampleTime) {
      const timeOpts = this.options.time;
      const displayFormats = timeOpts.displayFormats;
      const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
      const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
        exampleTime
      ], this._majorUnit), format);
      const size = this._getLabelSize(exampleLabel);
      const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
      return capacity > 0 ? capacity : 1;
    }
    getDataTimestamps() {
      let timestamps = this._cache.data || [];
      let i, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const metas = this.getMatchingVisibleMetas();
      if (this._normalized && metas.length) {
        return this._cache.data = metas[0].controller.getAllParsedValues(this);
      }
      for (i = 0, ilen = metas.length; i < ilen; ++i) {
        timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
      }
      return this._cache.data = this.normalize(timestamps);
    }
    getLabelTimestamps() {
      const timestamps = this._cache.labels || [];
      let i, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const labels = this.getLabels();
      for (i = 0, ilen = labels.length; i < ilen; ++i) {
        timestamps.push(parse(this, labels[i]));
      }
      return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
    }
    normalize(values) {
      return _arrayUnique(values.sort(sorter));
    }
  };
  __publicField(TimeScale, "id", "time");
  __publicField(TimeScale, "defaults", {
    bounds: "data",
    adapters: {},
    time: {
      parser: false,
      unit: false,
      round: false,
      isoWeekday: false,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      callback: false,
      major: {
        enabled: false
      }
    }
  });
  function interpolate2(table, val, reverse) {
    let lo = 0;
    let hi = table.length - 1;
    let prevSource, nextSource, prevTarget, nextTarget;
    if (reverse) {
      if (val >= table[lo].pos && val <= table[hi].pos) {
        ({ lo, hi } = _lookupByKey(table, "pos", val));
      }
      ({ pos: prevSource, time: prevTarget } = table[lo]);
      ({ pos: nextSource, time: nextTarget } = table[hi]);
    } else {
      if (val >= table[lo].time && val <= table[hi].time) {
        ({ lo, hi } = _lookupByKey(table, "time", val));
      }
      ({ time: prevSource, pos: prevTarget } = table[lo]);
      ({ time: nextSource, pos: nextTarget } = table[hi]);
    }
    const span = nextSource - prevSource;
    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
  }
  var TimeSeriesScale = class extends TimeScale {
    constructor(props) {
      super(props);
      this._table = [];
      this._minPos = void 0;
      this._tableRange = void 0;
    }
    initOffsets() {
      const timestamps = this._getTimestampsForTable();
      const table = this._table = this.buildLookupTable(timestamps);
      this._minPos = interpolate2(table, this.min);
      this._tableRange = interpolate2(table, this.max) - this._minPos;
      super.initOffsets(timestamps);
    }
    buildLookupTable(timestamps) {
      const { min, max } = this;
      const items = [];
      const table = [];
      let i, ilen, prev, curr, next;
      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
        curr = timestamps[i];
        if (curr >= min && curr <= max) {
          items.push(curr);
        }
      }
      if (items.length < 2) {
        return [
          {
            time: min,
            pos: 0
          },
          {
            time: max,
            pos: 1
          }
        ];
      }
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        next = items[i + 1];
        prev = items[i - 1];
        curr = items[i];
        if (Math.round((next + prev) / 2) !== curr) {
          table.push({
            time: curr,
            pos: i / (ilen - 1)
          });
        }
      }
      return table;
    }
    _generate() {
      const min = this.min;
      const max = this.max;
      let timestamps = super.getDataTimestamps();
      if (!timestamps.includes(min) || !timestamps.length) {
        timestamps.splice(0, 0, min);
      }
      if (!timestamps.includes(max) || timestamps.length === 1) {
        timestamps.push(max);
      }
      return timestamps.sort((a, b) => a - b);
    }
    _getTimestampsForTable() {
      let timestamps = this._cache.all || [];
      if (timestamps.length) {
        return timestamps;
      }
      const data = this.getDataTimestamps();
      const label = this.getLabelTimestamps();
      if (data.length && label.length) {
        timestamps = this.normalize(data.concat(label));
      } else {
        timestamps = data.length ? data : label;
      }
      timestamps = this._cache.all = timestamps;
      return timestamps;
    }
    getDecimalForValue(value) {
      return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
    }
  };
  __publicField(TimeSeriesScale, "id", "timeseries");
  __publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
  var scales = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    CategoryScale,
    LinearScale,
    LogarithmicScale,
    RadialLinearScale,
    TimeScale,
    TimeSeriesScale
  });
  var registerables = [
    controllers,
    elements,
    plugins,
    scales
  ];

  // node_modules/chart.js/auto/auto.js
  Chart.register(...registerables);

  // js/app.js
  var hooks = {};
  hooks.ChartJS = {
    person() {
      return this.el.dataset.person;
    },
    mounted() {
      trends.embed.renderExploreWidgetTo(document.getElementById("my-chart"), "TIMESERIES", {
        "comparisonItem": [{ "keyword": this.person(), "geo": "ES", "time": "2004-01-01 2024-02-04" }],
        "category": 0,
        "property": ""
      }, {
        "exploreQuery": `date=all&geo=ES&q=${this.person()}&hl=es`,
        "guestPath": "https://trends.google.com:443/trends/embed/"
      });
    }
  };
  hooks.Gallery = {
    nextImage(galleryId) {
      const galleryElement = document.querySelector(`#${galleryId}`);
      const images = JSON.parse(galleryElement.dataset.images);
      const imgElement = document.querySelector(`#${galleryId}-image`);
      const currentSrc = imgElement.src;
      const currentIndex = images.indexOf(currentSrc);
      const nextIndex = (currentIndex + 1) % images.length;
      imgElement.src = images[nextIndex];
    },
    prevImage(galleryId) {
      const galleryElement = document.querySelector(`#${galleryId}`);
      const images = JSON.parse(galleryElement.dataset.images);
      const imgElement = document.querySelector(`#${galleryId}-image`);
      const currentSrc = imgElement.src;
      const currentIndex = images.indexOf(currentSrc);
      const prevIndex = (currentIndex - 1 + images.length) % images.length;
      imgElement.src = images[prevIndex];
    },
    mounted() {
      document.getElementById("button-prev").onclick = () => this.prevImage(this.el.id);
      document.getElementById("button-next").onclick = () => this.nextImage(this.el.id);
    }
  };
  var csrfToken = document.querySelector("meta[name='csrf-token']").getAttribute("content");
  var liveSocket = new LiveSocket("/live", Socket, {
    longPollFallbackMs: 2500,
    hooks,
    params: { _csrf_token: csrfToken }
  });
  import_topbar.default.config({ barColors: { 0: "#29d" }, shadowColor: "rgba(0, 0, 0, .3)" });
  window.addEventListener("phx:page-loading-start", (_info) => import_topbar.default.show(300));
  window.addEventListener("phx:page-loading-stop", (_info) => import_topbar.default.hide());
  liveSocket.connect();
  window.liveSocket = liveSocket;
})();
/**
 * @license MIT
 * topbar 2.0.0, 2023-02-04
 * https://buunguyen.github.io/topbar
 * Copyright (c) 2021 Buu Nguyen
 */
/*! Bundled license information:

@kurkle/color/dist/color.esm.js:
  (*!
   * @kurkle/color v0.3.2
   * https://github.com/kurkle/color#readme
   * (c) 2023 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.segment.js:
  (*!
   * Chart.js v4.4.2
   * https://www.chartjs.org
   * (c) 2024 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chart.js:
  (*!
   * Chart.js v4.4.2
   * https://www.chartjs.org
   * (c) 2024 Chart.js Contributors
   * Released under the MIT License
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vYXNzZXRzL3ZlbmRvci90b3BiYXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2h0bWwvcHJpdi9zdGF0aWMvcGhvZW5peF9odG1sLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC91dGlscy5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvY29uc3RhbnRzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9wdXNoLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC90aW1lci5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvY2hhbm5lbC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvYWpheC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvbG9uZ3BvbGwuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3ByZXNlbmNlLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9zZXJpYWxpemVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9zb2NrZXQuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvY29uc3RhbnRzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2VudHJ5X3VwbG9hZGVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3V0aWxzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2Jyb3dzZXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvYXJpYS5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9qcy5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9kb20uanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvdXBsb2FkX2VudHJ5LmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2xpdmVfdXBsb2FkZXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvaG9va3MuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZG9tX3Bvc3RfbW9ycGhfcmVzdG9yZXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvbm9kZV9tb2R1bGVzL21vcnBoZG9tL2Rpc3QvbW9ycGhkb20tZXNtLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2RvbV9wYXRjaC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9yZW5kZXJlZC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy92aWV3X2hvb2suanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvdmlldy5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9saXZlX3NvY2tldC5qcyIsICIuLi8uLi8uLi9hc3NldHMvanMvYXBwLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvQGt1cmtsZS9jb2xvci9kaXN0L2NvbG9yLmVzbS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY29yZS50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMubWF0aC50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY29sbGVjdGlvbi50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5lYXNpbmcudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNvbG9yLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRpb25zLmRlZmF1bHRzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5sYXlvdXRzLmRlZmF1bHRzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5pbnRsLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS50aWNrcy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuc2NhbGUuZGVmYXVsdHMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmRlZmF1bHRzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jYW52YXMudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLm9wdGlvbnMudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNvbmZpZy50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY3VydmUudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmRvbS50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuaW50ZXJwb2xhdGlvbi50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMucnRsLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5zZWdtZW50LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRvci5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYW5pbWF0aW9uLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRpb25zLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmJhci5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmJ1YmJsZS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmRvdWdobnV0LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIubGluZS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnBvbGFyQXJlYS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnBpZS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnJhZGFyLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuc2NhdHRlci5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYWRhcHRlcnMudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmludGVyYWN0aW9uLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5sYXlvdXRzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsYXRmb3JtL3BsYXRmb3JtLmJhc2UuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGxhdGZvcm0vcGxhdGZvcm0uYmFzaWMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGxhdGZvcm0vcGxhdGZvcm0uZG9tLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsYXRmb3JtL2luZGV4LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5lbGVtZW50LnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5zY2FsZS5hdXRvc2tpcC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuc2NhbGUuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnR5cGVkUmVnaXN0cnkuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnJlZ2lzdHJ5LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5wbHVnaW5zLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5jb25maWcuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmNvbnRyb2xsZXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvZWxlbWVudHMvZWxlbWVudC5hcmMudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvZWxlbWVudHMvZWxlbWVudC5saW5lLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvZWxlbWVudHMvZWxlbWVudC5iYXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uY29sb3JzLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmRlY2ltYXRpb24uanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci5zZWdtZW50LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIuaGVscGVyLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIub3B0aW9ucy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLnRhcmdldC5zdGFjay5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvc2ltcGxlQXJjLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIudGFyZ2V0LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIuZHJhd2luZy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvaW5kZXguanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4ubGVnZW5kLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLnRpdGxlLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLnN1YnRpdGxlLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLnRvb2x0aXAuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLmNhdGVnb3J5LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5saW5lYXJiYXNlLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5saW5lYXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLmxvZ2FyaXRobWljLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5yYWRpYWxMaW5lYXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLnRpbWUuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLnRpbWVzZXJpZXMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaW5kZXgudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9hdXRvL2F1dG8uanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogQGxpY2Vuc2UgTUlUXG4gKiB0b3BiYXIgMi4wLjAsIDIwMjMtMDItMDRcbiAqIGh0dHBzOi8vYnV1bmd1eWVuLmdpdGh1Yi5pby90b3BiYXJcbiAqIENvcHlyaWdodCAoYykgMjAyMSBCdXUgTmd1eWVuXG4gKi9cbihmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvMTU3OTY3MVxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBsYXN0VGltZSA9IDA7XG4gICAgdmFyIHZlbmRvcnMgPSBbXCJtc1wiLCBcIm1velwiLCBcIndlYmtpdFwiLCBcIm9cIl07XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4KSB7XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID1cbiAgICAgICAgd2luZG93W3ZlbmRvcnNbeF0gKyBcIlJlcXVlc3RBbmltYXRpb25GcmFtZVwiXTtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9XG4gICAgICAgIHdpbmRvd1t2ZW5kb3JzW3hdICsgXCJDYW5jZWxBbmltYXRpb25GcmFtZVwiXSB8fFxuICAgICAgICB3aW5kb3dbdmVuZG9yc1t4XSArIFwiQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO1xuICAgIH1cbiAgICBpZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpXG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcbiAgICAgICAgdmFyIGlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7XG4gICAgICAgIH0sIHRpbWVUb0NhbGwpO1xuICAgICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfTtcbiAgICBpZiAoIXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSlcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgICAgfTtcbiAgfSkoKTtcblxuICB2YXIgY2FudmFzLFxuICAgIGN1cnJlbnRQcm9ncmVzcyxcbiAgICBzaG93aW5nLFxuICAgIHByb2dyZXNzVGltZXJJZCA9IG51bGwsXG4gICAgZmFkZVRpbWVySWQgPSBudWxsLFxuICAgIGRlbGF5VGltZXJJZCA9IG51bGwsXG4gICAgYWRkRXZlbnQgPSBmdW5jdGlvbiAoZWxlbSwgdHlwZSwgaGFuZGxlcikge1xuICAgICAgaWYgKGVsZW0uYWRkRXZlbnRMaXN0ZW5lcikgZWxlbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgIGVsc2UgaWYgKGVsZW0uYXR0YWNoRXZlbnQpIGVsZW0uYXR0YWNoRXZlbnQoXCJvblwiICsgdHlwZSwgaGFuZGxlcik7XG4gICAgICBlbHNlIGVsZW1bXCJvblwiICsgdHlwZV0gPSBoYW5kbGVyO1xuICAgIH0sXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGF1dG9SdW46IHRydWUsXG4gICAgICBiYXJUaGlja25lc3M6IDMsXG4gICAgICBiYXJDb2xvcnM6IHtcbiAgICAgICAgMDogXCJyZ2JhKDI2LCAgMTg4LCAxNTYsIC45KVwiLFxuICAgICAgICBcIi4yNVwiOiBcInJnYmEoNTIsICAxNTIsIDIxOSwgLjkpXCIsXG4gICAgICAgIFwiLjUwXCI6IFwicmdiYSgyNDEsIDE5NiwgMTUsICAuOSlcIixcbiAgICAgICAgXCIuNzVcIjogXCJyZ2JhKDIzMCwgMTI2LCAzNCwgIC45KVwiLFxuICAgICAgICBcIjEuMFwiOiBcInJnYmEoMjExLCA4NCwgIDAsICAgLjkpXCIsXG4gICAgICB9LFxuICAgICAgc2hhZG93Qmx1cjogMTAsXG4gICAgICBzaGFkb3dDb2xvcjogXCJyZ2JhKDAsICAgMCwgICAwLCAgIC42KVwiLFxuICAgICAgY2xhc3NOYW1lOiBudWxsLFxuICAgIH0sXG4gICAgcmVwYWludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzICogNTsgLy8gbmVlZCBzcGFjZSBmb3Igc2hhZG93XG5cbiAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LnNoYWRvd0JsdXIgPSBvcHRpb25zLnNoYWRvd0JsdXI7XG4gICAgICBjdHguc2hhZG93Q29sb3IgPSBvcHRpb25zLnNoYWRvd0NvbG9yO1xuXG4gICAgICB2YXIgbGluZUdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIGNhbnZhcy53aWR0aCwgMCk7XG4gICAgICBmb3IgKHZhciBzdG9wIGluIG9wdGlvbnMuYmFyQ29sb3JzKVxuICAgICAgICBsaW5lR3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3AsIG9wdGlvbnMuYmFyQ29sb3JzW3N0b3BdKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJhclRoaWNrbmVzcztcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oMCwgb3B0aW9ucy5iYXJUaGlja25lc3MgLyAyKTtcbiAgICAgIGN0eC5saW5lVG8oXG4gICAgICAgIE1hdGguY2VpbChjdXJyZW50UHJvZ3Jlc3MgKiBjYW52YXMud2lkdGgpLFxuICAgICAgICBvcHRpb25zLmJhclRoaWNrbmVzcyAvIDJcbiAgICAgICk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsaW5lR3JhZGllbnQ7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSxcbiAgICBjcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgdmFyIHN0eWxlID0gY2FudmFzLnN0eWxlO1xuICAgICAgc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgICBzdHlsZS50b3AgPSBzdHlsZS5sZWZ0ID0gc3R5bGUucmlnaHQgPSBzdHlsZS5tYXJnaW4gPSBzdHlsZS5wYWRkaW5nID0gMDtcbiAgICAgIHN0eWxlLnpJbmRleCA9IDEwMDAwMTtcbiAgICAgIHN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIGlmIChvcHRpb25zLmNsYXNzTmFtZSkgY2FudmFzLmNsYXNzTGlzdC5hZGQob3B0aW9ucy5jbGFzc05hbWUpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgYWRkRXZlbnQod2luZG93LCBcInJlc2l6ZVwiLCByZXBhaW50KTtcbiAgICB9LFxuICAgIHRvcGJhciA9IHtcbiAgICAgIGNvbmZpZzogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdHMpXG4gICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkgb3B0aW9uc1trZXldID0gb3B0c1trZXldO1xuICAgICAgfSxcbiAgICAgIHNob3c6IGZ1bmN0aW9uIChkZWxheSkge1xuICAgICAgICBpZiAoc2hvd2luZykgcmV0dXJuO1xuICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICBpZiAoZGVsYXlUaW1lcklkKSByZXR1cm47XG4gICAgICAgICAgZGVsYXlUaW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB0b3BiYXIuc2hvdygpLCBkZWxheSk7XG4gICAgICAgIH0gZWxzZSAge1xuICAgICAgICAgIHNob3dpbmcgPSB0cnVlO1xuICAgICAgICAgIGlmIChmYWRlVGltZXJJZCAhPT0gbnVsbCkgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGZhZGVUaW1lcklkKTtcbiAgICAgICAgICBpZiAoIWNhbnZhcykgY3JlYXRlQ2FudmFzKCk7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgIHRvcGJhci5wcm9ncmVzcygwKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hdXRvUnVuKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgICAgcHJvZ3Jlc3NUaW1lcklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICAgICAgICAgICAgdG9wYmFyLnByb2dyZXNzKFxuICAgICAgICAgICAgICAgIFwiK1wiICsgMC4wNSAqIE1hdGgucG93KDEgLSBNYXRoLnNxcnQoY3VycmVudFByb2dyZXNzKSwgMilcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvZ3Jlc3M6IGZ1bmN0aW9uICh0bykge1xuICAgICAgICBpZiAodHlwZW9mIHRvID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gY3VycmVudFByb2dyZXNzO1xuICAgICAgICBpZiAodHlwZW9mIHRvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdG8gPVxuICAgICAgICAgICAgKHRvLmluZGV4T2YoXCIrXCIpID49IDAgfHwgdG8uaW5kZXhPZihcIi1cIikgPj0gMFxuICAgICAgICAgICAgICA/IGN1cnJlbnRQcm9ncmVzc1xuICAgICAgICAgICAgICA6IDApICsgcGFyc2VGbG9hdCh0byk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFByb2dyZXNzID0gdG8gPiAxID8gMSA6IHRvO1xuICAgICAgICByZXBhaW50KCk7XG4gICAgICAgIHJldHVybiBjdXJyZW50UHJvZ3Jlc3M7XG4gICAgICB9LFxuICAgICAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoZGVsYXlUaW1lcklkKTtcbiAgICAgICAgZGVsYXlUaW1lcklkID0gbnVsbDtcbiAgICAgICAgaWYgKCFzaG93aW5nKSByZXR1cm47XG4gICAgICAgIHNob3dpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHByb2dyZXNzVGltZXJJZCAhPSBudWxsKSB7XG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHByb2dyZXNzVGltZXJJZCk7XG4gICAgICAgICAgcHJvZ3Jlc3NUaW1lcklkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAoZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICBpZiAodG9wYmFyLnByb2dyZXNzKFwiKy4xXCIpID49IDEpIHtcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5vcGFjaXR5IC09IDAuMDU7XG4gICAgICAgICAgICBpZiAoY2FudmFzLnN0eWxlLm9wYWNpdHkgPD0gMC4wNSkge1xuICAgICAgICAgICAgICBjYW52YXMuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICBmYWRlVGltZXJJZCA9IG51bGw7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZmFkZVRpbWVySWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgICAgICB9KSgpO1xuICAgICAgfSxcbiAgICB9O1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gdG9wYmFyO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0b3BiYXI7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50b3BiYXIgPSB0b3BiYXI7XG4gIH1cbn0uY2FsbCh0aGlzLCB3aW5kb3csIGRvY3VtZW50KSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIFBvbHlmaWxsRXZlbnQgPSBldmVudENvbnN0cnVjdG9yKCk7XG5cbiAgZnVuY3Rpb24gZXZlbnRDb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gd2luZG93LkN1c3RvbUV2ZW50O1xuICAgIC8vIElFPD05IFN1cHBvcnRcbiAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XG4gICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge2J1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiB1bmRlZmluZWR9O1xuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICAgIHJldHVybiBldnQ7XG4gICAgfVxuICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRIaWRkZW5JbnB1dChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJoaWRkZW5cIjtcbiAgICBpbnB1dC5uYW1lID0gbmFtZTtcbiAgICBpbnB1dC52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGVsZW1lbnQsIHRhcmdldE1vZGlmaWVyS2V5KSB7XG4gICAgdmFyIHRvID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRvXCIpLFxuICAgICAgICBtZXRob2QgPSBidWlsZEhpZGRlbklucHV0KFwiX21ldGhvZFwiLCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbWV0aG9kXCIpKSxcbiAgICAgICAgY3NyZiA9IGJ1aWxkSGlkZGVuSW5wdXQoXCJfY3NyZl90b2tlblwiLCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtY3NyZlwiKSksXG4gICAgICAgIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKSxcbiAgICAgICAgc3VibWl0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLFxuICAgICAgICB0YXJnZXQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInRhcmdldFwiKTtcblxuICAgIGZvcm0ubWV0aG9kID0gKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tZXRob2RcIikgPT09IFwiZ2V0XCIpID8gXCJnZXRcIiA6IFwicG9zdFwiO1xuICAgIGZvcm0uYWN0aW9uID0gdG87XG4gICAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cbiAgICBpZiAodGFyZ2V0KSBmb3JtLnRhcmdldCA9IHRhcmdldDtcbiAgICBlbHNlIGlmICh0YXJnZXRNb2RpZmllcktleSkgZm9ybS50YXJnZXQgPSBcIl9ibGFua1wiO1xuXG4gICAgZm9ybS5hcHBlbmRDaGlsZChjc3JmKTtcbiAgICBmb3JtLmFwcGVuZENoaWxkKG1ldGhvZCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuICAgIC8vIEluc2VydCBhIGJ1dHRvbiBhbmQgY2xpY2sgaXQgaW5zdGVhZCBvZiB1c2luZyBgZm9ybS5zdWJtaXRgXG4gICAgLy8gYmVjYXVzZSB0aGUgYHN1Ym1pdGAgZnVuY3Rpb24gZG9lcyBub3QgZW1pdCBhIGBzdWJtaXRgIGV2ZW50LlxuICAgIHN1Ym1pdC50eXBlID0gXCJzdWJtaXRcIjtcbiAgICBmb3JtLmFwcGVuZENoaWxkKHN1Ym1pdCk7XG4gICAgc3VibWl0LmNsaWNrKCk7XG4gIH1cblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGUudGFyZ2V0O1xuICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKSB7XG4gICAgICB2YXIgcGhvZW5peExpbmtFdmVudCA9IG5ldyBQb2x5ZmlsbEV2ZW50KCdwaG9lbml4LmxpbmsuY2xpY2snLCB7XG4gICAgICAgIFwiYnViYmxlc1wiOiB0cnVlLCBcImNhbmNlbGFibGVcIjogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghZWxlbWVudC5kaXNwYXRjaEV2ZW50KHBob2VuaXhMaW5rRXZlbnQpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdG9cIikpIHtcbiAgICAgICAgaGFuZGxlQ2xpY2soZWxlbWVudCwgZS5tZXRhS2V5IHx8IGUuc2hpZnRLZXkpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9LCBmYWxzZSk7XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Bob2VuaXgubGluay5jbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbmZpcm1cIik7XG4gICAgaWYobWVzc2FnZSAmJiAhd2luZG93LmNvbmZpcm0obWVzc2FnZSkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIGZhbHNlKTtcbn0pKCk7XG4iLCAiLy8gd3JhcHMgdmFsdWUgaW4gY2xvc3VyZSBvciByZXR1cm5zIGNsb3N1cmVcbmV4cG9ydCBsZXQgY2xvc3VyZSA9ICh2YWx1ZSkgPT4ge1xuICBpZih0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIil7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgbGV0IGNsb3N1cmUgPSBmdW5jdGlvbiAoKXsgcmV0dXJuIHZhbHVlIH1cbiAgICByZXR1cm4gY2xvc3VyZVxuICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IGdsb2JhbFNlbGYgPSB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiBudWxsXG5leHBvcnQgY29uc3QgcGh4V2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IG51bGxcbmV4cG9ydCBjb25zdCBnbG9iYWwgPSBnbG9iYWxTZWxmIHx8IHBoeFdpbmRvdyB8fCBnbG9iYWxcbmV4cG9ydCBjb25zdCBERUZBVUxUX1ZTTiA9IFwiMi4wLjBcIlxuZXhwb3J0IGNvbnN0IFNPQ0tFVF9TVEFURVMgPSB7Y29ubmVjdGluZzogMCwgb3BlbjogMSwgY2xvc2luZzogMiwgY2xvc2VkOiAzfVxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVElNRU9VVCA9IDEwMDAwXG5leHBvcnQgY29uc3QgV1NfQ0xPU0VfTk9STUFMID0gMTAwMFxuZXhwb3J0IGNvbnN0IENIQU5ORUxfU1RBVEVTID0ge1xuICBjbG9zZWQ6IFwiY2xvc2VkXCIsXG4gIGVycm9yZWQ6IFwiZXJyb3JlZFwiLFxuICBqb2luZWQ6IFwiam9pbmVkXCIsXG4gIGpvaW5pbmc6IFwiam9pbmluZ1wiLFxuICBsZWF2aW5nOiBcImxlYXZpbmdcIixcbn1cbmV4cG9ydCBjb25zdCBDSEFOTkVMX0VWRU5UUyA9IHtcbiAgY2xvc2U6IFwicGh4X2Nsb3NlXCIsXG4gIGVycm9yOiBcInBoeF9lcnJvclwiLFxuICBqb2luOiBcInBoeF9qb2luXCIsXG4gIHJlcGx5OiBcInBoeF9yZXBseVwiLFxuICBsZWF2ZTogXCJwaHhfbGVhdmVcIlxufVxuXG5leHBvcnQgY29uc3QgVFJBTlNQT1JUUyA9IHtcbiAgbG9uZ3BvbGw6IFwibG9uZ3BvbGxcIixcbiAgd2Vic29ja2V0OiBcIndlYnNvY2tldFwiXG59XG5leHBvcnQgY29uc3QgWEhSX1NUQVRFUyA9IHtcbiAgY29tcGxldGU6IDRcbn1cbiIsICIvKipcbiAqIEluaXRpYWxpemVzIHRoZSBQdXNoXG4gKiBAcGFyYW0ge0NoYW5uZWx9IGNoYW5uZWwgLSBUaGUgQ2hhbm5lbFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50LCBmb3IgZXhhbXBsZSBgXCJwaHhfam9pblwiYFxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgLSBUaGUgcGF5bG9hZCwgZm9yIGV4YW1wbGUgYHt1c2VyX2lkOiAxMjN9YFxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgLSBUaGUgcHVzaCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQdXNoIHtcbiAgY29uc3RydWN0b3IoY2hhbm5lbCwgZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQpe1xuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWxcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnRcbiAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkIHx8IGZ1bmN0aW9uICgpeyByZXR1cm4ge30gfVxuICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gbnVsbFxuICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXRcbiAgICB0aGlzLnRpbWVvdXRUaW1lciA9IG51bGxcbiAgICB0aGlzLnJlY0hvb2tzID0gW11cbiAgICB0aGlzLnNlbnQgPSBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gICAqL1xuICByZXNlbmQodGltZW91dCl7XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dFxuICAgIHRoaXMucmVzZXQoKVxuICAgIHRoaXMuc2VuZCgpXG4gIH1cblxuICAvKipcbiAgICpcbiAgICovXG4gIHNlbmQoKXtcbiAgICBpZih0aGlzLmhhc1JlY2VpdmVkKFwidGltZW91dFwiKSl7IHJldHVybiB9XG4gICAgdGhpcy5zdGFydFRpbWVvdXQoKVxuICAgIHRoaXMuc2VudCA9IHRydWVcbiAgICB0aGlzLmNoYW5uZWwuc29ja2V0LnB1c2goe1xuICAgICAgdG9waWM6IHRoaXMuY2hhbm5lbC50b3BpYyxcbiAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgcGF5bG9hZDogdGhpcy5wYXlsb2FkKCksXG4gICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgam9pbl9yZWY6IHRoaXMuY2hhbm5lbC5qb2luUmVmKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gc3RhdHVzXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAgICovXG4gIHJlY2VpdmUoc3RhdHVzLCBjYWxsYmFjayl7XG4gICAgaWYodGhpcy5oYXNSZWNlaXZlZChzdGF0dXMpKXtcbiAgICAgIGNhbGxiYWNrKHRoaXMucmVjZWl2ZWRSZXNwLnJlc3BvbnNlKVxuICAgIH1cblxuICAgIHRoaXMucmVjSG9va3MucHVzaCh7c3RhdHVzLCBjYWxsYmFja30pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVzZXQoKXtcbiAgICB0aGlzLmNhbmNlbFJlZkV2ZW50KClcbiAgICB0aGlzLnJlZiA9IG51bGxcbiAgICB0aGlzLnJlZkV2ZW50ID0gbnVsbFxuICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gbnVsbFxuICAgIHRoaXMuc2VudCA9IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG1hdGNoUmVjZWl2ZSh7c3RhdHVzLCByZXNwb25zZSwgX3JlZn0pe1xuICAgIHRoaXMucmVjSG9va3MuZmlsdGVyKGggPT4gaC5zdGF0dXMgPT09IHN0YXR1cylcbiAgICAgIC5mb3JFYWNoKGggPT4gaC5jYWxsYmFjayhyZXNwb25zZSkpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbmNlbFJlZkV2ZW50KCl7XG4gICAgaWYoIXRoaXMucmVmRXZlbnQpeyByZXR1cm4gfVxuICAgIHRoaXMuY2hhbm5lbC5vZmYodGhpcy5yZWZFdmVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FuY2VsVGltZW91dCgpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRUaW1lcilcbiAgICB0aGlzLnRpbWVvdXRUaW1lciA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRUaW1lb3V0KCl7XG4gICAgaWYodGhpcy50aW1lb3V0VGltZXIpeyB0aGlzLmNhbmNlbFRpbWVvdXQoKSB9XG4gICAgdGhpcy5yZWYgPSB0aGlzLmNoYW5uZWwuc29ja2V0Lm1ha2VSZWYoKVxuICAgIHRoaXMucmVmRXZlbnQgPSB0aGlzLmNoYW5uZWwucmVwbHlFdmVudE5hbWUodGhpcy5yZWYpXG5cbiAgICB0aGlzLmNoYW5uZWwub24odGhpcy5yZWZFdmVudCwgcGF5bG9hZCA9PiB7XG4gICAgICB0aGlzLmNhbmNlbFJlZkV2ZW50KClcbiAgICAgIHRoaXMuY2FuY2VsVGltZW91dCgpXG4gICAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IHBheWxvYWRcbiAgICAgIHRoaXMubWF0Y2hSZWNlaXZlKHBheWxvYWQpXG4gICAgfSlcblxuICAgIHRoaXMudGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIoXCJ0aW1lb3V0XCIsIHt9KVxuICAgIH0sIHRoaXMudGltZW91dClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFzUmVjZWl2ZWQoc3RhdHVzKXtcbiAgICByZXR1cm4gdGhpcy5yZWNlaXZlZFJlc3AgJiYgdGhpcy5yZWNlaXZlZFJlc3Auc3RhdHVzID09PSBzdGF0dXNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdHJpZ2dlcihzdGF0dXMsIHJlc3BvbnNlKXtcbiAgICB0aGlzLmNoYW5uZWwudHJpZ2dlcih0aGlzLnJlZkV2ZW50LCB7c3RhdHVzLCByZXNwb25zZX0pXG4gIH1cbn1cbiIsICIvKipcbiAqXG4gKiBDcmVhdGVzIGEgdGltZXIgdGhhdCBhY2NlcHRzIGEgYHRpbWVyQ2FsY2AgZnVuY3Rpb24gdG8gcGVyZm9ybVxuICogY2FsY3VsYXRlZCB0aW1lb3V0IHJldHJpZXMsIHN1Y2ggYXMgZXhwb25lbnRpYWwgYmFja29mZi5cbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IHJlY29ubmVjdFRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHRoaXMuY29ubmVjdCgpLCBmdW5jdGlvbih0cmllcyl7XG4gKiAgIHJldHVybiBbMTAwMCwgNTAwMCwgMTAwMDBdW3RyaWVzIC0gMV0gfHwgMTAwMDBcbiAqIH0pXG4gKiByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciAxMDAwXG4gKiByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciA1MDAwXG4gKiByZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gKiByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciAxMDAwXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRpbWVyQ2FsY1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lciB7XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCB0aW1lckNhbGMpe1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMudGltZXJDYWxjID0gdGltZXJDYWxjXG4gICAgdGhpcy50aW1lciA9IG51bGxcbiAgICB0aGlzLnRyaWVzID0gMFxuICB9XG5cbiAgcmVzZXQoKXtcbiAgICB0aGlzLnRyaWVzID0gMFxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgYW55IHByZXZpb3VzIHNjaGVkdWxlVGltZW91dCBhbmQgc2NoZWR1bGVzIGNhbGxiYWNrXG4gICAqL1xuICBzY2hlZHVsZVRpbWVvdXQoKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcilcblxuICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudHJpZXMgPSB0aGlzLnRyaWVzICsgMVxuICAgICAgdGhpcy5jYWxsYmFjaygpXG4gICAgfSwgdGhpcy50aW1lckNhbGModGhpcy50cmllcyArIDEpKVxuICB9XG59XG4iLCAiaW1wb3J0IHtjbG9zdXJlfSBmcm9tIFwiLi91dGlsc1wiXG5pbXBvcnQge1xuICBDSEFOTkVMX0VWRU5UUyxcbiAgQ0hBTk5FTF9TVEFURVMsXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBQdXNoIGZyb20gXCIuL3B1c2hcIlxuaW1wb3J0IFRpbWVyIGZyb20gXCIuL3RpbWVyXCJcblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcGljXG4gKiBAcGFyYW0geyhPYmplY3R8ZnVuY3Rpb24pfSBwYXJhbXNcbiAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhbm5lbCB7XG4gIGNvbnN0cnVjdG9yKHRvcGljLCBwYXJhbXMsIHNvY2tldCl7XG4gICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZFxuICAgIHRoaXMudG9waWMgPSB0b3BpY1xuICAgIHRoaXMucGFyYW1zID0gY2xvc3VyZShwYXJhbXMgfHwge30pXG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRcbiAgICB0aGlzLmJpbmRpbmdzID0gW11cbiAgICB0aGlzLmJpbmRpbmdSZWYgPSAwXG4gICAgdGhpcy50aW1lb3V0ID0gdGhpcy5zb2NrZXQudGltZW91dFxuICAgIHRoaXMuam9pbmVkT25jZSA9IGZhbHNlXG4gICAgdGhpcy5qb2luUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmpvaW4sIHRoaXMucGFyYW1zLCB0aGlzLnRpbWVvdXQpXG4gICAgdGhpcy5wdXNoQnVmZmVyID0gW11cbiAgICB0aGlzLnN0YXRlQ2hhbmdlUmVmcyA9IFtdXG5cbiAgICB0aGlzLnJlam9pblRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHtcbiAgICAgIGlmKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLnJlam9pbigpIH1cbiAgICB9LCB0aGlzLnNvY2tldC5yZWpvaW5BZnRlck1zKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25FcnJvcigoKSA9PiB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCkpKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25PcGVuKCgpID0+IHtcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgaWYodGhpcy5pc0Vycm9yZWQoKSl7IHRoaXMucmVqb2luKCkgfVxuICAgIH0pXG4gICAgKVxuICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcIm9rXCIsICgpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5qb2luZWRcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgdGhpcy5wdXNoQnVmZmVyLmZvckVhY2gocHVzaEV2ZW50ID0+IHB1c2hFdmVudC5zZW5kKCkpXG4gICAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXVxuICAgIH0pXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKFwiZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIGlmKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpIH1cbiAgICB9KVxuICAgIHRoaXMub25DbG9zZSgoKSA9PiB7XG4gICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBjbG9zZSAke3RoaXMudG9waWN9ICR7dGhpcy5qb2luUmVmKCl9YClcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWRcbiAgICAgIHRoaXMuc29ja2V0LnJlbW92ZSh0aGlzKVxuICAgIH0pXG4gICAgdGhpcy5vbkVycm9yKHJlYXNvbiA9PiB7XG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgZXJyb3IgJHt0aGlzLnRvcGljfWAsIHJlYXNvbilcbiAgICAgIGlmKHRoaXMuaXNKb2luaW5nKCkpeyB0aGlzLmpvaW5QdXNoLnJlc2V0KCkgfVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIGlmKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpIH1cbiAgICB9KVxuICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4ge1xuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYHRpbWVvdXQgJHt0aGlzLnRvcGljfSAoJHt0aGlzLmpvaW5SZWYoKX0pYCwgdGhpcy5qb2luUHVzaC50aW1lb3V0KVxuICAgICAgbGV0IGxlYXZlUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmxlYXZlLCBjbG9zdXJlKHt9KSwgdGhpcy50aW1lb3V0KVxuICAgICAgbGVhdmVQdXNoLnNlbmQoKVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIHRoaXMuam9pblB1c2gucmVzZXQoKVxuICAgICAgaWYodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSl7IHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgfVxuICAgIH0pXG4gICAgdGhpcy5vbihDSEFOTkVMX0VWRU5UUy5yZXBseSwgKHBheWxvYWQsIHJlZikgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKHRoaXMucmVwbHlFdmVudE5hbWUocmVmKSwgcGF5bG9hZClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEpvaW4gdGhlIGNoYW5uZWxcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSB0aW1lb3V0XG4gICAqIEByZXR1cm5zIHtQdXNofVxuICAgKi9cbiAgam9pbih0aW1lb3V0ID0gdGhpcy50aW1lb3V0KXtcbiAgICBpZih0aGlzLmpvaW5lZE9uY2Upe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJpZWQgdG8gam9pbiBtdWx0aXBsZSB0aW1lcy4gJ2pvaW4nIGNhbiBvbmx5IGJlIGNhbGxlZCBhIHNpbmdsZSB0aW1lIHBlciBjaGFubmVsIGluc3RhbmNlXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXRcbiAgICAgIHRoaXMuam9pbmVkT25jZSA9IHRydWVcbiAgICAgIHRoaXMucmVqb2luKClcbiAgICAgIHJldHVybiB0aGlzLmpvaW5QdXNoXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhvb2sgaW50byBjaGFubmVsIGNsb3NlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbkNsb3NlKGNhbGxiYWNrKXtcbiAgICB0aGlzLm9uKENIQU5ORUxfRVZFTlRTLmNsb3NlLCBjYWxsYmFjaylcbiAgfVxuXG4gIC8qKlxuICAgKiBIb29rIGludG8gY2hhbm5lbCBlcnJvcnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uRXJyb3IoY2FsbGJhY2spe1xuICAgIHJldHVybiB0aGlzLm9uKENIQU5ORUxfRVZFTlRTLmVycm9yLCByZWFzb24gPT4gY2FsbGJhY2socmVhc29uKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmVzIG9uIGNoYW5uZWwgZXZlbnRzXG4gICAqXG4gICAqIFN1YnNjcmlwdGlvbiByZXR1cm5zIGEgcmVmIGNvdW50ZXIsIHdoaWNoIGNhbiBiZSB1c2VkIGxhdGVyIHRvXG4gICAqIHVuc3Vic2NyaWJlIHRoZSBleGFjdCBldmVudCBsaXN0ZW5lclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByZWYxID0gY2hhbm5lbC5vbihcImV2ZW50XCIsIGRvX3N0dWZmKVxuICAgKiBjb25zdCByZWYyID0gY2hhbm5lbC5vbihcImV2ZW50XCIsIGRvX290aGVyX3N0dWZmKVxuICAgKiBjaGFubmVsLm9mZihcImV2ZW50XCIsIHJlZjEpXG4gICAqIC8vIFNpbmNlIHVuc3Vic2NyaXB0aW9uLCBkb19zdHVmZiB3b24ndCBmaXJlLFxuICAgKiAvLyB3aGlsZSBkb19vdGhlcl9zdHVmZiB3aWxsIGtlZXAgZmlyaW5nIG9uIHRoZSBcImV2ZW50XCJcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtpbnRlZ2VyfSByZWZcbiAgICovXG4gIG9uKGV2ZW50LCBjYWxsYmFjayl7XG4gICAgbGV0IHJlZiA9IHRoaXMuYmluZGluZ1JlZisrXG4gICAgdGhpcy5iaW5kaW5ncy5wdXNoKHtldmVudCwgcmVmLCBjYWxsYmFja30pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlcyBvZmYgb2YgY2hhbm5lbCBldmVudHNcbiAgICpcbiAgICogVXNlIHRoZSByZWYgcmV0dXJuZWQgZnJvbSBhIGNoYW5uZWwub24oKSB0byB1bnN1YnNjcmliZSBvbmVcbiAgICogaGFuZGxlciwgb3IgcGFzcyBub3RoaW5nIGZvciB0aGUgcmVmIHRvIHVuc3Vic2NyaWJlIGFsbFxuICAgKiBoYW5kbGVycyBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBVbnN1YnNjcmliZSB0aGUgZG9fc3R1ZmYgaGFuZGxlclxuICAgKiBjb25zdCByZWYxID0gY2hhbm5lbC5vbihcImV2ZW50XCIsIGRvX3N0dWZmKVxuICAgKiBjaGFubmVsLm9mZihcImV2ZW50XCIsIHJlZjEpXG4gICAqXG4gICAqIC8vIFVuc3Vic2NyaWJlIGFsbCBoYW5kbGVycyBmcm9tIGV2ZW50XG4gICAqIGNoYW5uZWwub2ZmKFwiZXZlbnRcIilcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gcmVmXG4gICAqL1xuICBvZmYoZXZlbnQsIHJlZil7XG4gICAgdGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuZmlsdGVyKChiaW5kKSA9PiB7XG4gICAgICByZXR1cm4gIShiaW5kLmV2ZW50ID09PSBldmVudCAmJiAodHlwZW9mIHJlZiA9PT0gXCJ1bmRlZmluZWRcIiB8fCByZWYgPT09IGJpbmQucmVmKSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYW5QdXNoKCl7IHJldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuaXNKb2luZWQoKSB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgbWVzc2FnZSBgZXZlbnRgIHRvIHBob2VuaXggd2l0aCB0aGUgcGF5bG9hZCBgcGF5bG9hZGAuXG4gICAqIFBob2VuaXggcmVjZWl2ZXMgdGhpcyBpbiB0aGUgYGhhbmRsZV9pbihldmVudCwgcGF5bG9hZCwgc29ja2V0KWBcbiAgICogZnVuY3Rpb24uIGlmIHBob2VuaXggcmVwbGllcyBvciBpdCB0aW1lcyBvdXQgKGRlZmF1bHQgMTAwMDBtcyksXG4gICAqIHRoZW4gb3B0aW9uYWxseSB0aGUgcmVwbHkgY2FuIGJlIHJlY2VpdmVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjaGFubmVsLnB1c2goXCJldmVudFwiKVxuICAgKiAgIC5yZWNlaXZlKFwib2tcIiwgcGF5bG9hZCA9PiBjb25zb2xlLmxvZyhcInBob2VuaXggcmVwbGllZDpcIiwgcGF5bG9hZCkpXG4gICAqICAgLnJlY2VpdmUoXCJlcnJvclwiLCBlcnIgPT4gY29uc29sZS5sb2coXCJwaG9lbml4IGVycm9yZWRcIiwgZXJyKSlcbiAgICogICAucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4gY29uc29sZS5sb2coXCJ0aW1lZCBvdXQgcHVzaGluZ1wiKSlcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dF1cbiAgICogQHJldHVybnMge1B1c2h9XG4gICAqL1xuICBwdXNoKGV2ZW50LCBwYXlsb2FkLCB0aW1lb3V0ID0gdGhpcy50aW1lb3V0KXtcbiAgICBwYXlsb2FkID0gcGF5bG9hZCB8fCB7fVxuICAgIGlmKCF0aGlzLmpvaW5lZE9uY2Upe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0cmllZCB0byBwdXNoICcke2V2ZW50fScgdG8gJyR7dGhpcy50b3BpY30nIGJlZm9yZSBqb2luaW5nLiBVc2UgY2hhbm5lbC5qb2luKCkgYmVmb3JlIHB1c2hpbmcgZXZlbnRzYClcbiAgICB9XG4gICAgbGV0IHB1c2hFdmVudCA9IG5ldyBQdXNoKHRoaXMsIGV2ZW50LCBmdW5jdGlvbiAoKXsgcmV0dXJuIHBheWxvYWQgfSwgdGltZW91dClcbiAgICBpZih0aGlzLmNhblB1c2goKSl7XG4gICAgICBwdXNoRXZlbnQuc2VuZCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2hFdmVudC5zdGFydFRpbWVvdXQoKVxuICAgICAgdGhpcy5wdXNoQnVmZmVyLnB1c2gocHVzaEV2ZW50KVxuICAgIH1cblxuICAgIHJldHVybiBwdXNoRXZlbnRcbiAgfVxuXG4gIC8qKiBMZWF2ZXMgdGhlIGNoYW5uZWxcbiAgICpcbiAgICogVW5zdWJzY3JpYmVzIGZyb20gc2VydmVyIGV2ZW50cywgYW5kXG4gICAqIGluc3RydWN0cyBjaGFubmVsIHRvIHRlcm1pbmF0ZSBvbiBzZXJ2ZXJcbiAgICpcbiAgICogVHJpZ2dlcnMgb25DbG9zZSgpIGhvb2tzXG4gICAqXG4gICAqIFRvIHJlY2VpdmUgbGVhdmUgYWNrbm93bGVkZ2VtZW50cywgdXNlIHRoZSBgcmVjZWl2ZWBcbiAgICogaG9vayB0byBiaW5kIHRvIHRoZSBzZXJ2ZXIgYWNrLCBpZTpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY2hhbm5lbC5sZWF2ZSgpLnJlY2VpdmUoXCJva1wiLCAoKSA9PiBhbGVydChcImxlZnQhXCIpIClcbiAgICpcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSB0aW1lb3V0XG4gICAqIEByZXR1cm5zIHtQdXNofVxuICAgKi9cbiAgbGVhdmUodGltZW91dCA9IHRoaXMudGltZW91dCl7XG4gICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgdGhpcy5qb2luUHVzaC5jYW5jZWxUaW1lb3V0KClcblxuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nXG4gICAgbGV0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgbGVhdmUgJHt0aGlzLnRvcGljfWApXG4gICAgICB0aGlzLnRyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIFwibGVhdmVcIilcbiAgICB9XG4gICAgbGV0IGxlYXZlUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmxlYXZlLCBjbG9zdXJlKHt9KSwgdGltZW91dClcbiAgICBsZWF2ZVB1c2gucmVjZWl2ZShcIm9rXCIsICgpID0+IG9uQ2xvc2UoKSlcbiAgICAgIC5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiBvbkNsb3NlKCkpXG4gICAgbGVhdmVQdXNoLnNlbmQoKVxuICAgIGlmKCF0aGlzLmNhblB1c2goKSl7IGxlYXZlUHVzaC50cmlnZ2VyKFwib2tcIiwge30pIH1cblxuICAgIHJldHVybiBsZWF2ZVB1c2hcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkYWJsZSBtZXNzYWdlIGhvb2tcbiAgICpcbiAgICogUmVjZWl2ZXMgYWxsIGV2ZW50cyBmb3Igc3BlY2lhbGl6ZWQgbWVzc2FnZSBoYW5kbGluZ1xuICAgKiBiZWZvcmUgZGlzcGF0Y2hpbmcgdG8gdGhlIGNoYW5uZWwgY2FsbGJhY2tzLlxuICAgKlxuICAgKiBNdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSByZWZcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIG9uTWVzc2FnZShfZXZlbnQsIHBheWxvYWQsIF9yZWYpeyByZXR1cm4gcGF5bG9hZCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc01lbWJlcih0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5SZWYpe1xuICAgIGlmKHRoaXMudG9waWMgIT09IHRvcGljKXsgcmV0dXJuIGZhbHNlIH1cblxuICAgIGlmKGpvaW5SZWYgJiYgam9pblJlZiAhPT0gdGhpcy5qb2luUmVmKCkpe1xuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgXCJkcm9wcGluZyBvdXRkYXRlZCBtZXNzYWdlXCIsIHt0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5SZWZ9KVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBqb2luUmVmKCl7IHJldHVybiB0aGlzLmpvaW5QdXNoLnJlZiB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWpvaW4odGltZW91dCA9IHRoaXMudGltZW91dCl7XG4gICAgaWYodGhpcy5pc0xlYXZpbmcoKSl7IHJldHVybiB9XG4gICAgdGhpcy5zb2NrZXQubGVhdmVPcGVuVG9waWModGhpcy50b3BpYylcbiAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmluZ1xuICAgIHRoaXMuam9pblB1c2gucmVzZW5kKHRpbWVvdXQpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRyaWdnZXIoZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pblJlZil7XG4gICAgbGV0IGhhbmRsZWRQYXlsb2FkID0gdGhpcy5vbk1lc3NhZ2UoZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pblJlZilcbiAgICBpZihwYXlsb2FkICYmICFoYW5kbGVkUGF5bG9hZCl7IHRocm93IG5ldyBFcnJvcihcImNoYW5uZWwgb25NZXNzYWdlIGNhbGxiYWNrcyBtdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZFwiKSB9XG5cbiAgICBsZXQgZXZlbnRCaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuZmlsdGVyKGJpbmQgPT4gYmluZC5ldmVudCA9PT0gZXZlbnQpXG5cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZXZlbnRCaW5kaW5ncy5sZW5ndGg7IGkrKyl7XG4gICAgICBsZXQgYmluZCA9IGV2ZW50QmluZGluZ3NbaV1cbiAgICAgIGJpbmQuY2FsbGJhY2soaGFuZGxlZFBheWxvYWQsIHJlZiwgam9pblJlZiB8fCB0aGlzLmpvaW5SZWYoKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlcGx5RXZlbnROYW1lKHJlZil7IHJldHVybiBgY2hhbl9yZXBseV8ke3JlZn1gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzQ2xvc2VkKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNFcnJvcmVkKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzSm9pbmVkKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luZWQgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNKb2luaW5nKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luaW5nIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzTGVhdmluZygpeyByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMubGVhdmluZyB9XG59XG4iLCAiaW1wb3J0IHtcbiAgZ2xvYmFsLFxuICBYSFJfU1RBVEVTXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFqYXgge1xuXG4gIHN0YXRpYyByZXF1ZXN0KG1ldGhvZCwgZW5kUG9pbnQsIGFjY2VwdCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayl7XG4gICAgaWYoZ2xvYmFsLlhEb21haW5SZXF1ZXN0KXtcbiAgICAgIGxldCByZXEgPSBuZXcgZ2xvYmFsLlhEb21haW5SZXF1ZXN0KCkgLy8gSUU4LCBJRTlcbiAgICAgIHJldHVybiB0aGlzLnhkb21haW5SZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHJlcSA9IG5ldyBnbG9iYWwuWE1MSHR0cFJlcXVlc3QoKSAvLyBJRTcrLCBGaXJlZm94LCBDaHJvbWUsIE9wZXJhLCBTYWZhcmlcbiAgICAgIHJldHVybiB0aGlzLnhoclJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBhY2NlcHQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHhkb21haW5SZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayl7XG4gICAgcmVxLnRpbWVvdXQgPSB0aW1lb3V0XG4gICAgcmVxLm9wZW4obWV0aG9kLCBlbmRQb2ludClcbiAgICByZXEub25sb2FkID0gKCkgPT4ge1xuICAgICAgbGV0IHJlc3BvbnNlID0gdGhpcy5wYXJzZUpTT04ocmVxLnJlc3BvbnNlVGV4dClcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3BvbnNlKVxuICAgIH1cbiAgICBpZihvbnRpbWVvdXQpeyByZXEub250aW1lb3V0ID0gb250aW1lb3V0IH1cblxuICAgIC8vIFdvcmsgYXJvdW5kIGJ1ZyBpbiBJRTkgdGhhdCByZXF1aXJlcyBhbiBhdHRhY2hlZCBvbnByb2dyZXNzIGhhbmRsZXJcbiAgICByZXEub25wcm9ncmVzcyA9ICgpID0+IHsgfVxuXG4gICAgcmVxLnNlbmQoYm9keSlcbiAgICByZXR1cm4gcmVxXG4gIH1cblxuICBzdGF0aWMgeGhyUmVxdWVzdChyZXEsIG1ldGhvZCwgZW5kUG9pbnQsIGFjY2VwdCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayl7XG4gICAgcmVxLm9wZW4obWV0aG9kLCBlbmRQb2ludCwgdHJ1ZSlcbiAgICByZXEudGltZW91dCA9IHRpbWVvdXRcbiAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBhY2NlcHQpXG4gICAgcmVxLm9uZXJyb3IgPSAoKSA9PiBjYWxsYmFjayAmJiBjYWxsYmFjayhudWxsKVxuICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZihyZXEucmVhZHlTdGF0ZSA9PT0gWEhSX1NUQVRFUy5jb21wbGV0ZSAmJiBjYWxsYmFjayl7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHRoaXMucGFyc2VKU09OKHJlcS5yZXNwb25zZVRleHQpXG4gICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKVxuICAgICAgfVxuICAgIH1cbiAgICBpZihvbnRpbWVvdXQpeyByZXEub250aW1lb3V0ID0gb250aW1lb3V0IH1cblxuICAgIHJlcS5zZW5kKGJvZHkpXG4gICAgcmV0dXJuIHJlcVxuICB9XG5cbiAgc3RhdGljIHBhcnNlSlNPTihyZXNwKXtcbiAgICBpZighcmVzcCB8fCByZXNwID09PSBcIlwiKXsgcmV0dXJuIG51bGwgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3ApXG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICBjb25zb2xlICYmIGNvbnNvbGUubG9nKFwiZmFpbGVkIHRvIHBhcnNlIEpTT04gcmVzcG9uc2VcIiwgcmVzcClcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHNlcmlhbGl6ZShvYmosIHBhcmVudEtleSl7XG4gICAgbGV0IHF1ZXJ5U3RyID0gW11cbiAgICBmb3IodmFyIGtleSBpbiBvYmope1xuICAgICAgaWYoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpeyBjb250aW51ZSB9XG4gICAgICBsZXQgcGFyYW1LZXkgPSBwYXJlbnRLZXkgPyBgJHtwYXJlbnRLZXl9WyR7a2V5fV1gIDoga2V5XG4gICAgICBsZXQgcGFyYW1WYWwgPSBvYmpba2V5XVxuICAgICAgaWYodHlwZW9mIHBhcmFtVmFsID09PSBcIm9iamVjdFwiKXtcbiAgICAgICAgcXVlcnlTdHIucHVzaCh0aGlzLnNlcmlhbGl6ZShwYXJhbVZhbCwgcGFyYW1LZXkpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnlTdHIucHVzaChlbmNvZGVVUklDb21wb25lbnQocGFyYW1LZXkpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1WYWwpKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcXVlcnlTdHIuam9pbihcIiZcIilcbiAgfVxuXG4gIHN0YXRpYyBhcHBlbmRQYXJhbXModXJsLCBwYXJhbXMpe1xuICAgIGlmKE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID09PSAwKXsgcmV0dXJuIHVybCB9XG5cbiAgICBsZXQgcHJlZml4ID0gdXJsLm1hdGNoKC9cXD8vKSA/IFwiJlwiIDogXCI/XCJcbiAgICByZXR1cm4gYCR7dXJsfSR7cHJlZml4fSR7dGhpcy5zZXJpYWxpemUocGFyYW1zKX1gXG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBTT0NLRVRfU1RBVEVTLFxuICBUUkFOU1BPUlRTXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBBamF4IGZyb20gXCIuL2FqYXhcIlxuXG5sZXQgYXJyYXlCdWZmZXJUb0Jhc2U2NCA9IChidWZmZXIpID0+IHtcbiAgbGV0IGJpbmFyeSA9IFwiXCJcbiAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKVxuICBsZXQgbGVuID0gYnl0ZXMuYnl0ZUxlbmd0aFxuICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspeyBiaW5hcnkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSkgfVxuICByZXR1cm4gYnRvYShiaW5hcnkpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvbmdQb2xsIHtcblxuICBjb25zdHJ1Y3RvcihlbmRQb2ludCl7XG4gICAgdGhpcy5lbmRQb2ludCA9IG51bGxcbiAgICB0aGlzLnRva2VuID0gbnVsbFxuICAgIHRoaXMuc2tpcEhlYXJ0YmVhdCA9IHRydWVcbiAgICB0aGlzLnJlcXMgPSBuZXcgU2V0KClcbiAgICB0aGlzLmF3YWl0aW5nQmF0Y2hBY2sgPSBmYWxzZVxuICAgIHRoaXMuY3VycmVudEJhdGNoID0gbnVsbFxuICAgIHRoaXMuY3VycmVudEJhdGNoVGltZXIgPSBudWxsXG4gICAgdGhpcy5iYXRjaEJ1ZmZlciA9IFtdXG4gICAgdGhpcy5vbm9wZW4gPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgdGhpcy5vbmVycm9yID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgIHRoaXMub25tZXNzYWdlID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgIHRoaXMub25jbG9zZSA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICB0aGlzLnBvbGxFbmRwb2ludCA9IHRoaXMubm9ybWFsaXplRW5kcG9pbnQoZW5kUG9pbnQpXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nXG4gICAgLy8gd2UgbXVzdCB3YWl0IGZvciB0aGUgY2FsbGVyIHRvIGZpbmlzaCBzZXR0aW5nIHVwIG91ciBjYWxsYmFja3MgYW5kIHRpbWVvdXQgcHJvcGVydGllc1xuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5wb2xsKCksIDApXG4gIH1cblxuICBub3JtYWxpemVFbmRwb2ludChlbmRQb2ludCl7XG4gICAgcmV0dXJuIChlbmRQb2ludFxuICAgICAgLnJlcGxhY2UoXCJ3czovL1wiLCBcImh0dHA6Ly9cIilcbiAgICAgIC5yZXBsYWNlKFwid3NzOi8vXCIsIFwiaHR0cHM6Ly9cIilcbiAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoLiopXFwvXCIgKyBUUkFOU1BPUlRTLndlYnNvY2tldCksIFwiJDEvXCIgKyBUUkFOU1BPUlRTLmxvbmdwb2xsKSlcbiAgfVxuXG4gIGVuZHBvaW50VVJMKCl7XG4gICAgcmV0dXJuIEFqYXguYXBwZW5kUGFyYW1zKHRoaXMucG9sbEVuZHBvaW50LCB7dG9rZW46IHRoaXMudG9rZW59KVxuICB9XG5cbiAgY2xvc2VBbmRSZXRyeShjb2RlLCByZWFzb24sIHdhc0NsZWFuKXtcbiAgICB0aGlzLmNsb3NlKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nXG4gIH1cblxuICBvbnRpbWVvdXQoKXtcbiAgICB0aGlzLm9uZXJyb3IoXCJ0aW1lb3V0XCIpXG4gICAgdGhpcy5jbG9zZUFuZFJldHJ5KDEwMDUsIFwidGltZW91dFwiLCBmYWxzZSlcbiAgfVxuXG4gIGlzQWN0aXZlKCl7IHJldHVybiB0aGlzLnJlYWR5U3RhdGUgPT09IFNPQ0tFVF9TVEFURVMub3BlbiB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZyB9XG5cbiAgcG9sbCgpe1xuICAgIHRoaXMuYWpheChcIkdFVFwiLCBcImFwcGxpY2F0aW9uL2pzb25cIiwgbnVsbCwgKCkgPT4gdGhpcy5vbnRpbWVvdXQoKSwgcmVzcCA9PiB7XG4gICAgICBpZihyZXNwKXtcbiAgICAgICAgdmFyIHtzdGF0dXMsIHRva2VuLCBtZXNzYWdlc30gPSByZXNwXG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdHVzID0gMFxuICAgICAgfVxuXG4gICAgICBzd2l0Y2goc3RhdHVzKXtcbiAgICAgICAgY2FzZSAyMDA6XG4gICAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChtc2cgPT4ge1xuICAgICAgICAgICAgLy8gVGFza3MgYXJlIHdoYXQgdGhpbmdzIGxpa2UgZXZlbnQgaGFuZGxlcnMsIHNldFRpbWVvdXQgY2FsbGJhY2tzLFxuICAgICAgICAgICAgLy8gcHJvbWlzZSByZXNvbHZlcyBhbmQgbW9yZSBhcmUgcnVuIHdpdGhpbi5cbiAgICAgICAgICAgIC8vIEluIG1vZGVybiBicm93c2VycywgdGhlcmUgYXJlIHR3byBkaWZmZXJlbnQga2luZHMgb2YgdGFza3MsXG4gICAgICAgICAgICAvLyBtaWNyb3Rhc2tzIGFuZCBtYWNyb3Rhc2tzLlxuICAgICAgICAgICAgLy8gTWljcm90YXNrcyBhcmUgbWFpbmx5IHVzZWQgZm9yIFByb21pc2VzLCB3aGlsZSBtYWNyb3Rhc2tzIGFyZVxuICAgICAgICAgICAgLy8gdXNlZCBmb3IgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgICAgICAgLy8gTWljcm90YXNrcyBhbHdheXMgaGF2ZSBwcmlvcml0eSBvdmVyIG1hY3JvdGFza3MuIElmIHRoZSBKUyBlbmdpbmVcbiAgICAgICAgICAgIC8vIGlzIGxvb2tpbmcgZm9yIGEgdGFzayB0byBydW4sIGl0IHdpbGwgYWx3YXlzIHRyeSB0byBlbXB0eSB0aGVcbiAgICAgICAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBiZWZvcmUgYXR0ZW1wdGluZyB0byBydW4gYW55dGhpbmcgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIG1hY3JvdGFzayBxdWV1ZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBGb3IgdGhlIFdlYlNvY2tldCB0cmFuc3BvcnQsIG1lc3NhZ2VzIGFsd2F5cyBhcnJpdmUgaW4gdGhlaXIgb3duXG4gICAgICAgICAgICAvLyBldmVudC4gVGhpcyBtZWFucyB0aGF0IGlmIGFueSBwcm9taXNlcyBhcmUgcmVzb2x2ZWQgZnJvbSB3aXRoaW4sXG4gICAgICAgICAgICAvLyB0aGVpciBjYWxsYmFja3Mgd2lsbCBhbHdheXMgZmluaXNoIGV4ZWN1dGlvbiBieSB0aGUgdGltZSB0aGVcbiAgICAgICAgICAgIC8vIG5leHQgbWVzc2FnZSBldmVudCBoYW5kbGVyIGlzIHJ1bi5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJbiBvcmRlciB0byBlbXVsYXRlIHRoaXMgYmVoYXZpb3VyLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBlYWNoXG4gICAgICAgICAgICAvLyBvbm1lc3NhZ2UgaGFuZGxlciBpcyBydW4gd2l0aGluIGl0cyBvd24gbWFjcm90YXNrLlxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLm9ubWVzc2FnZSh7ZGF0YTogbXNnfSksIDApXG4gICAgICAgICAgfSlcbiAgICAgICAgICB0aGlzLnBvbGwoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjA0OlxuICAgICAgICAgIHRoaXMucG9sbCgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0MTA6XG4gICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5vcGVuXG4gICAgICAgICAgdGhpcy5vbm9wZW4oe30pXG4gICAgICAgICAgdGhpcy5wb2xsKClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQwMzpcbiAgICAgICAgICB0aGlzLm9uZXJyb3IoNDAzKVxuICAgICAgICAgIHRoaXMuY2xvc2UoMTAwOCwgXCJmb3JiaWRkZW5cIiwgZmFsc2UpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDUwMDpcbiAgICAgICAgICB0aGlzLm9uZXJyb3IoNTAwKVxuICAgICAgICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgxMDExLCBcImludGVybmFsIHNlcnZlciBlcnJvclwiLCA1MDApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgcG9sbCBzdGF0dXMgJHtzdGF0dXN9YClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gd2UgY29sbGVjdCBhbGwgcHVzaGVzIHdpdGhpbiB0aGUgY3VycmVudCBldmVudCBsb29wIGJ5XG4gIC8vIHNldFRpbWVvdXQgMCwgd2hpY2ggb3B0aW1pemVzIGJhY2stdG8tYmFjayBwcm9jZWR1cmFsXG4gIC8vIHB1c2hlcyBhZ2FpbnN0IGFuIGVtcHR5IGJ1ZmZlclxuXG4gIHNlbmQoYm9keSl7XG4gICAgaWYodHlwZW9mKGJvZHkpICE9PSBcInN0cmluZ1wiKXsgYm9keSA9IGFycmF5QnVmZmVyVG9CYXNlNjQoYm9keSkgfVxuICAgIGlmKHRoaXMuY3VycmVudEJhdGNoKXtcbiAgICAgIHRoaXMuY3VycmVudEJhdGNoLnB1c2goYm9keSlcbiAgICB9IGVsc2UgaWYodGhpcy5hd2FpdGluZ0JhdGNoQWNrKXtcbiAgICAgIHRoaXMuYmF0Y2hCdWZmZXIucHVzaChib2R5KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1cnJlbnRCYXRjaCA9IFtib2R5XVxuICAgICAgdGhpcy5jdXJyZW50QmF0Y2hUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmJhdGNoU2VuZCh0aGlzLmN1cnJlbnRCYXRjaClcbiAgICAgICAgdGhpcy5jdXJyZW50QmF0Y2ggPSBudWxsXG4gICAgICB9LCAwKVxuICAgIH1cbiAgfVxuXG4gIGJhdGNoU2VuZChtZXNzYWdlcyl7XG4gICAgdGhpcy5hd2FpdGluZ0JhdGNoQWNrID0gdHJ1ZVxuICAgIHRoaXMuYWpheChcIlBPU1RcIiwgXCJhcHBsaWNhdGlvbi94LW5kanNvblwiLCBtZXNzYWdlcy5qb2luKFwiXFxuXCIpLCAoKSA9PiB0aGlzLm9uZXJyb3IoXCJ0aW1lb3V0XCIpLCByZXNwID0+IHtcbiAgICAgIHRoaXMuYXdhaXRpbmdCYXRjaEFjayA9IGZhbHNlXG4gICAgICBpZighcmVzcCB8fCByZXNwLnN0YXR1cyAhPT0gMjAwKXtcbiAgICAgICAgdGhpcy5vbmVycm9yKHJlc3AgJiYgcmVzcC5zdGF0dXMpXG4gICAgICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgxMDExLCBcImludGVybmFsIHNlcnZlciBlcnJvclwiLCBmYWxzZSlcbiAgICAgIH0gZWxzZSBpZih0aGlzLmJhdGNoQnVmZmVyLmxlbmd0aCA+IDApe1xuICAgICAgICB0aGlzLmJhdGNoU2VuZCh0aGlzLmJhdGNoQnVmZmVyKVxuICAgICAgICB0aGlzLmJhdGNoQnVmZmVyID0gW11cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgY2xvc2UoY29kZSwgcmVhc29uLCB3YXNDbGVhbil7XG4gICAgZm9yKGxldCByZXEgb2YgdGhpcy5yZXFzKXsgcmVxLmFib3J0KCkgfVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMuY2xvc2VkXG4gICAgbGV0IG9wdHMgPSBPYmplY3QuYXNzaWduKHtjb2RlOiAxMDAwLCByZWFzb246IHVuZGVmaW5lZCwgd2FzQ2xlYW46IHRydWV9LCB7Y29kZSwgcmVhc29uLCB3YXNDbGVhbn0pXG4gICAgdGhpcy5iYXRjaEJ1ZmZlciA9IFtdXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuY3VycmVudEJhdGNoVGltZXIpXG4gICAgdGhpcy5jdXJyZW50QmF0Y2hUaW1lciA9IG51bGxcbiAgICBpZih0eXBlb2YoQ2xvc2VFdmVudCkgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgdGhpcy5vbmNsb3NlKG5ldyBDbG9zZUV2ZW50KFwiY2xvc2VcIiwgb3B0cykpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub25jbG9zZShvcHRzKVxuICAgIH1cbiAgfVxuXG4gIGFqYXgobWV0aG9kLCBjb250ZW50VHlwZSwgYm9keSwgb25DYWxsZXJUaW1lb3V0LCBjYWxsYmFjayl7XG4gICAgbGV0IHJlcVxuICAgIGxldCBvbnRpbWVvdXQgPSAoKSA9PiB7XG4gICAgICB0aGlzLnJlcXMuZGVsZXRlKHJlcSlcbiAgICAgIG9uQ2FsbGVyVGltZW91dCgpXG4gICAgfVxuICAgIHJlcSA9IEFqYXgucmVxdWVzdChtZXRob2QsIHRoaXMuZW5kcG9pbnRVUkwoKSwgY29udGVudFR5cGUsIGJvZHksIHRoaXMudGltZW91dCwgb250aW1lb3V0LCByZXNwID0+IHtcbiAgICAgIHRoaXMucmVxcy5kZWxldGUocmVxKVxuICAgICAgaWYodGhpcy5pc0FjdGl2ZSgpKXsgY2FsbGJhY2socmVzcCkgfVxuICAgIH0pXG4gICAgdGhpcy5yZXFzLmFkZChyZXEpXG4gIH1cbn1cbiIsICIvKipcbiAqIEluaXRpYWxpemVzIHRoZSBQcmVzZW5jZVxuICogQHBhcmFtIHtDaGFubmVsfSBjaGFubmVsIC0gVGhlIENoYW5uZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIG9wdGlvbnMsXG4gKiAgICAgICAgZm9yIGV4YW1wbGUgYHtldmVudHM6IHtzdGF0ZTogXCJzdGF0ZVwiLCBkaWZmOiBcImRpZmZcIn19YFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmVzZW5jZSB7XG5cbiAgY29uc3RydWN0b3IoY2hhbm5lbCwgb3B0cyA9IHt9KXtcbiAgICBsZXQgZXZlbnRzID0gb3B0cy5ldmVudHMgfHwge3N0YXRlOiBcInByZXNlbmNlX3N0YXRlXCIsIGRpZmY6IFwicHJlc2VuY2VfZGlmZlwifVxuICAgIHRoaXMuc3RhdGUgPSB7fVxuICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW11cbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsXG4gICAgdGhpcy5qb2luUmVmID0gbnVsbFxuICAgIHRoaXMuY2FsbGVyID0ge1xuICAgICAgb25Kb2luOiBmdW5jdGlvbiAoKXsgfSxcbiAgICAgIG9uTGVhdmU6IGZ1bmN0aW9uICgpeyB9LFxuICAgICAgb25TeW5jOiBmdW5jdGlvbiAoKXsgfVxuICAgIH1cblxuICAgIHRoaXMuY2hhbm5lbC5vbihldmVudHMuc3RhdGUsIG5ld1N0YXRlID0+IHtcbiAgICAgIGxldCB7b25Kb2luLCBvbkxlYXZlLCBvblN5bmN9ID0gdGhpcy5jYWxsZXJcblxuICAgICAgdGhpcy5qb2luUmVmID0gdGhpcy5jaGFubmVsLmpvaW5SZWYoKVxuICAgICAgdGhpcy5zdGF0ZSA9IFByZXNlbmNlLnN5bmNTdGF0ZSh0aGlzLnN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKVxuXG4gICAgICB0aGlzLnBlbmRpbmdEaWZmcy5mb3JFYWNoKGRpZmYgPT4ge1xuICAgICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKVxuICAgICAgfSlcbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW11cbiAgICAgIG9uU3luYygpXG4gICAgfSlcblxuICAgIHRoaXMuY2hhbm5lbC5vbihldmVudHMuZGlmZiwgZGlmZiA9PiB7XG4gICAgICBsZXQge29uSm9pbiwgb25MZWF2ZSwgb25TeW5jfSA9IHRoaXMuY2FsbGVyXG5cbiAgICAgIGlmKHRoaXMuaW5QZW5kaW5nU3luY1N0YXRlKCkpe1xuICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcy5wdXNoKGRpZmYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKVxuICAgICAgICBvblN5bmMoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBvbkpvaW4oY2FsbGJhY2speyB0aGlzLmNhbGxlci5vbkpvaW4gPSBjYWxsYmFjayB9XG5cbiAgb25MZWF2ZShjYWxsYmFjayl7IHRoaXMuY2FsbGVyLm9uTGVhdmUgPSBjYWxsYmFjayB9XG5cbiAgb25TeW5jKGNhbGxiYWNrKXsgdGhpcy5jYWxsZXIub25TeW5jID0gY2FsbGJhY2sgfVxuXG4gIGxpc3QoYnkpeyByZXR1cm4gUHJlc2VuY2UubGlzdCh0aGlzLnN0YXRlLCBieSkgfVxuXG4gIGluUGVuZGluZ1N5bmNTdGF0ZSgpe1xuICAgIHJldHVybiAhdGhpcy5qb2luUmVmIHx8ICh0aGlzLmpvaW5SZWYgIT09IHRoaXMuY2hhbm5lbC5qb2luUmVmKCkpXG4gIH1cblxuICAvLyBsb3dlci1sZXZlbCBwdWJsaWMgc3RhdGljIEFQSVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHN5bmMgdGhlIGxpc3Qgb2YgcHJlc2VuY2VzIG9uIHRoZSBzZXJ2ZXJcbiAgICogd2l0aCB0aGUgY2xpZW50J3Mgc3RhdGUuIEFuIG9wdGlvbmFsIGBvbkpvaW5gIGFuZCBgb25MZWF2ZWAgY2FsbGJhY2sgY2FuXG4gICAqIGJlIHByb3ZpZGVkIHRvIHJlYWN0IHRvIGNoYW5nZXMgaW4gdGhlIGNsaWVudCdzIGxvY2FsIHByZXNlbmNlcyBhY3Jvc3NcbiAgICogZGlzY29ubmVjdHMgYW5kIHJlY29ubmVjdHMgd2l0aCB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJlc2VuY2V9XG4gICAqL1xuICBzdGF0aWMgc3luY1N0YXRlKGN1cnJlbnRTdGF0ZSwgbmV3U3RhdGUsIG9uSm9pbiwgb25MZWF2ZSl7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5jbG9uZShjdXJyZW50U3RhdGUpXG4gICAgbGV0IGpvaW5zID0ge31cbiAgICBsZXQgbGVhdmVzID0ge31cblxuICAgIHRoaXMubWFwKHN0YXRlLCAoa2V5LCBwcmVzZW5jZSkgPT4ge1xuICAgICAgaWYoIW5ld1N0YXRlW2tleV0pe1xuICAgICAgICBsZWF2ZXNba2V5XSA9IHByZXNlbmNlXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLm1hcChuZXdTdGF0ZSwgKGtleSwgbmV3UHJlc2VuY2UpID0+IHtcbiAgICAgIGxldCBjdXJyZW50UHJlc2VuY2UgPSBzdGF0ZVtrZXldXG4gICAgICBpZihjdXJyZW50UHJlc2VuY2Upe1xuICAgICAgICBsZXQgbmV3UmVmcyA9IG5ld1ByZXNlbmNlLm1ldGFzLm1hcChtID0+IG0ucGh4X3JlZilcbiAgICAgICAgbGV0IGN1clJlZnMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMubWFwKG0gPT4gbS5waHhfcmVmKVxuICAgICAgICBsZXQgam9pbmVkTWV0YXMgPSBuZXdQcmVzZW5jZS5tZXRhcy5maWx0ZXIobSA9PiBjdXJSZWZzLmluZGV4T2YobS5waHhfcmVmKSA8IDApXG4gICAgICAgIGxldCBsZWZ0TWV0YXMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMuZmlsdGVyKG0gPT4gbmV3UmVmcy5pbmRleE9mKG0ucGh4X3JlZikgPCAwKVxuICAgICAgICBpZihqb2luZWRNZXRhcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2VcbiAgICAgICAgICBqb2luc1trZXldLm1ldGFzID0gam9pbmVkTWV0YXNcbiAgICAgICAgfVxuICAgICAgICBpZihsZWZ0TWV0YXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgbGVhdmVzW2tleV0gPSB0aGlzLmNsb25lKGN1cnJlbnRQcmVzZW5jZSlcbiAgICAgICAgICBsZWF2ZXNba2V5XS5tZXRhcyA9IGxlZnRNZXRhc1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2VcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB0aGlzLnN5bmNEaWZmKHN0YXRlLCB7am9pbnM6IGpvaW5zLCBsZWF2ZXM6IGxlYXZlc30sIG9uSm9pbiwgb25MZWF2ZSlcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBVc2VkIHRvIHN5bmMgYSBkaWZmIG9mIHByZXNlbmNlIGpvaW4gYW5kIGxlYXZlXG4gICAqIGV2ZW50cyBmcm9tIHRoZSBzZXJ2ZXIsIGFzIHRoZXkgaGFwcGVuLiBMaWtlIGBzeW5jU3RhdGVgLCBgc3luY0RpZmZgXG4gICAqIGFjY2VwdHMgb3B0aW9uYWwgYG9uSm9pbmAgYW5kIGBvbkxlYXZlYCBjYWxsYmFja3MgdG8gcmVhY3QgdG8gYSB1c2VyXG4gICAqIGpvaW5pbmcgb3IgbGVhdmluZyBmcm9tIGEgZGV2aWNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJlc2VuY2V9XG4gICAqL1xuICBzdGF0aWMgc3luY0RpZmYoc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSl7XG4gICAgbGV0IHtqb2lucywgbGVhdmVzfSA9IHRoaXMuY2xvbmUoZGlmZilcbiAgICBpZighb25Kb2luKXsgb25Kb2luID0gZnVuY3Rpb24gKCl7IH0gfVxuICAgIGlmKCFvbkxlYXZlKXsgb25MZWF2ZSA9IGZ1bmN0aW9uICgpeyB9IH1cblxuICAgIHRoaXMubWFwKGpvaW5zLCAoa2V5LCBuZXdQcmVzZW5jZSkgPT4ge1xuICAgICAgbGV0IGN1cnJlbnRQcmVzZW5jZSA9IHN0YXRlW2tleV1cbiAgICAgIHN0YXRlW2tleV0gPSB0aGlzLmNsb25lKG5ld1ByZXNlbmNlKVxuICAgICAgaWYoY3VycmVudFByZXNlbmNlKXtcbiAgICAgICAgbGV0IGpvaW5lZFJlZnMgPSBzdGF0ZVtrZXldLm1ldGFzLm1hcChtID0+IG0ucGh4X3JlZilcbiAgICAgICAgbGV0IGN1ck1ldGFzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLmZpbHRlcihtID0+IGpvaW5lZFJlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMClcbiAgICAgICAgc3RhdGVba2V5XS5tZXRhcy51bnNoaWZ0KC4uLmN1ck1ldGFzKVxuICAgICAgfVxuICAgICAgb25Kb2luKGtleSwgY3VycmVudFByZXNlbmNlLCBuZXdQcmVzZW5jZSlcbiAgICB9KVxuICAgIHRoaXMubWFwKGxlYXZlcywgKGtleSwgbGVmdFByZXNlbmNlKSA9PiB7XG4gICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XVxuICAgICAgaWYoIWN1cnJlbnRQcmVzZW5jZSl7IHJldHVybiB9XG4gICAgICBsZXQgcmVmc1RvUmVtb3ZlID0gbGVmdFByZXNlbmNlLm1ldGFzLm1hcChtID0+IG0ucGh4X3JlZilcbiAgICAgIGN1cnJlbnRQcmVzZW5jZS5tZXRhcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5maWx0ZXIocCA9PiB7XG4gICAgICAgIHJldHVybiByZWZzVG9SZW1vdmUuaW5kZXhPZihwLnBoeF9yZWYpIDwgMFxuICAgICAgfSlcbiAgICAgIG9uTGVhdmUoa2V5LCBjdXJyZW50UHJlc2VuY2UsIGxlZnRQcmVzZW5jZSlcbiAgICAgIGlmKGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5sZW5ndGggPT09IDApe1xuICAgICAgICBkZWxldGUgc3RhdGVba2V5XVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHN0YXRlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJlc2VuY2VzLCB3aXRoIHNlbGVjdGVkIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJlc2VuY2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNob29zZXJcbiAgICpcbiAgICogQHJldHVybnMge1ByZXNlbmNlfVxuICAgKi9cbiAgc3RhdGljIGxpc3QocHJlc2VuY2VzLCBjaG9vc2VyKXtcbiAgICBpZighY2hvb3Nlcil7IGNob29zZXIgPSBmdW5jdGlvbiAoa2V5LCBwcmVzKXsgcmV0dXJuIHByZXMgfSB9XG5cbiAgICByZXR1cm4gdGhpcy5tYXAocHJlc2VuY2VzLCAoa2V5LCBwcmVzZW5jZSkgPT4ge1xuICAgICAgcmV0dXJuIGNob29zZXIoa2V5LCBwcmVzZW5jZSlcbiAgICB9KVxuICB9XG5cbiAgLy8gcHJpdmF0ZVxuXG4gIHN0YXRpYyBtYXAob2JqLCBmdW5jKXtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5tYXAoa2V5ID0+IGZ1bmMoa2V5LCBvYmpba2V5XSkpXG4gIH1cblxuICBzdGF0aWMgY2xvbmUob2JqKXsgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSkgfVxufVxuIiwgIi8qIFRoZSBkZWZhdWx0IHNlcmlhbGl6ZXIgZm9yIGVuY29kaW5nIGFuZCBkZWNvZGluZyBtZXNzYWdlcyAqL1xuaW1wb3J0IHtcbiAgQ0hBTk5FTF9FVkVOVFNcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuZXhwb3J0IGRlZmF1bHQge1xuICBIRUFERVJfTEVOR1RIOiAxLFxuICBNRVRBX0xFTkdUSDogNCxcbiAgS0lORFM6IHtwdXNoOiAwLCByZXBseTogMSwgYnJvYWRjYXN0OiAyfSxcblxuICBlbmNvZGUobXNnLCBjYWxsYmFjayl7XG4gICAgaWYobXNnLnBheWxvYWQuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKXtcbiAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLmJpbmFyeUVuY29kZShtc2cpKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGF5bG9hZCA9IFttc2cuam9pbl9yZWYsIG1zZy5yZWYsIG1zZy50b3BpYywgbXNnLmV2ZW50LCBtc2cucGF5bG9hZF1cbiAgICAgIHJldHVybiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSlcbiAgICB9XG4gIH0sXG5cbiAgZGVjb2RlKHJhd1BheWxvYWQsIGNhbGxiYWNrKXtcbiAgICBpZihyYXdQYXlsb2FkLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcil7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5iaW5hcnlEZWNvZGUocmF3UGF5bG9hZCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBbam9pbl9yZWYsIHJlZiwgdG9waWMsIGV2ZW50LCBwYXlsb2FkXSA9IEpTT04ucGFyc2UocmF3UGF5bG9hZClcbiAgICAgIHJldHVybiBjYWxsYmFjayh7am9pbl9yZWYsIHJlZiwgdG9waWMsIGV2ZW50LCBwYXlsb2FkfSlcbiAgICB9XG4gIH0sXG5cbiAgLy8gcHJpdmF0ZVxuXG4gIGJpbmFyeUVuY29kZShtZXNzYWdlKXtcbiAgICBsZXQge2pvaW5fcmVmLCByZWYsIGV2ZW50LCB0b3BpYywgcGF5bG9hZH0gPSBtZXNzYWdlXG4gICAgbGV0IG1ldGFMZW5ndGggPSB0aGlzLk1FVEFfTEVOR1RIICsgam9pbl9yZWYubGVuZ3RoICsgcmVmLmxlbmd0aCArIHRvcGljLmxlbmd0aCArIGV2ZW50Lmxlbmd0aFxuICAgIGxldCBoZWFkZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5IRUFERVJfTEVOR1RIICsgbWV0YUxlbmd0aClcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhoZWFkZXIpXG4gICAgbGV0IG9mZnNldCA9IDBcblxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHRoaXMuS0lORFMucHVzaCkgLy8ga2luZFxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGpvaW5fcmVmLmxlbmd0aClcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCByZWYubGVuZ3RoKVxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHRvcGljLmxlbmd0aClcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBldmVudC5sZW5ndGgpXG4gICAgQXJyYXkuZnJvbShqb2luX3JlZiwgY2hhciA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKVxuICAgIEFycmF5LmZyb20ocmVmLCBjaGFyID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpXG4gICAgQXJyYXkuZnJvbSh0b3BpYywgY2hhciA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKVxuICAgIEFycmF5LmZyb20oZXZlbnQsIGNoYXIgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSlcblxuICAgIHZhciBjb21iaW5lZCA9IG5ldyBVaW50OEFycmF5KGhlYWRlci5ieXRlTGVuZ3RoICsgcGF5bG9hZC5ieXRlTGVuZ3RoKVxuICAgIGNvbWJpbmVkLnNldChuZXcgVWludDhBcnJheShoZWFkZXIpLCAwKVxuICAgIGNvbWJpbmVkLnNldChuZXcgVWludDhBcnJheShwYXlsb2FkKSwgaGVhZGVyLmJ5dGVMZW5ndGgpXG5cbiAgICByZXR1cm4gY29tYmluZWQuYnVmZmVyXG4gIH0sXG5cbiAgYmluYXJ5RGVjb2RlKGJ1ZmZlcil7XG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKVxuICAgIGxldCBraW5kID0gdmlldy5nZXRVaW50OCgwKVxuICAgIGxldCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIHRoaXMuS0lORFMucHVzaDogcmV0dXJuIHRoaXMuZGVjb2RlUHVzaChidWZmZXIsIHZpZXcsIGRlY29kZXIpXG4gICAgICBjYXNlIHRoaXMuS0lORFMucmVwbHk6IHJldHVybiB0aGlzLmRlY29kZVJlcGx5KGJ1ZmZlciwgdmlldywgZGVjb2RlcilcbiAgICAgIGNhc2UgdGhpcy5LSU5EUy5icm9hZGNhc3Q6IHJldHVybiB0aGlzLmRlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpXG4gICAgfVxuICB9LFxuXG4gIGRlY29kZVB1c2goYnVmZmVyLCB2aWV3LCBkZWNvZGVyKXtcbiAgICBsZXQgam9pblJlZlNpemUgPSB2aWV3LmdldFVpbnQ4KDEpXG4gICAgbGV0IHRvcGljU2l6ZSA9IHZpZXcuZ2V0VWludDgoMilcbiAgICBsZXQgZXZlbnRTaXplID0gdmlldy5nZXRVaW50OCgzKVxuICAgIGxldCBvZmZzZXQgPSB0aGlzLkhFQURFUl9MRU5HVEggKyB0aGlzLk1FVEFfTEVOR1RIIC0gMSAvLyBwdXNoZXMgaGF2ZSBubyByZWZcbiAgICBsZXQgam9pblJlZiA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGpvaW5SZWZTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBqb2luUmVmU2l6ZVxuICAgIGxldCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplXG4gICAgbGV0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemVcbiAgICBsZXQgZGF0YSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgIHJldHVybiB7am9pbl9yZWY6IGpvaW5SZWYsIHJlZjogbnVsbCwgdG9waWM6IHRvcGljLCBldmVudDogZXZlbnQsIHBheWxvYWQ6IGRhdGF9XG4gIH0sXG5cbiAgZGVjb2RlUmVwbHkoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKXtcbiAgICBsZXQgam9pblJlZlNpemUgPSB2aWV3LmdldFVpbnQ4KDEpXG4gICAgbGV0IHJlZlNpemUgPSB2aWV3LmdldFVpbnQ4KDIpXG4gICAgbGV0IHRvcGljU2l6ZSA9IHZpZXcuZ2V0VWludDgoMylcbiAgICBsZXQgZXZlbnRTaXplID0gdmlldy5nZXRVaW50OCg0KVxuICAgIGxldCBvZmZzZXQgPSB0aGlzLkhFQURFUl9MRU5HVEggKyB0aGlzLk1FVEFfTEVOR1RIXG4gICAgbGV0IGpvaW5SZWYgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBqb2luUmVmU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgam9pblJlZlNpemVcbiAgICBsZXQgcmVmID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgcmVmU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgcmVmU2l6ZVxuICAgIGxldCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplXG4gICAgbGV0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemVcbiAgICBsZXQgZGF0YSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgIGxldCBwYXlsb2FkID0ge3N0YXR1czogZXZlbnQsIHJlc3BvbnNlOiBkYXRhfVxuICAgIHJldHVybiB7am9pbl9yZWY6IGpvaW5SZWYsIHJlZjogcmVmLCB0b3BpYzogdG9waWMsIGV2ZW50OiBDSEFOTkVMX0VWRU5UUy5yZXBseSwgcGF5bG9hZDogcGF5bG9hZH1cbiAgfSxcblxuICBkZWNvZGVCcm9hZGNhc3QoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKXtcbiAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgxKVxuICAgIGxldCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDIpXG4gICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIDJcbiAgICBsZXQgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZVxuICAgIGxldCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplXG4gICAgbGV0IGRhdGEgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aClcblxuICAgIHJldHVybiB7am9pbl9yZWY6IG51bGwsIHJlZjogbnVsbCwgdG9waWM6IHRvcGljLCBldmVudDogZXZlbnQsIHBheWxvYWQ6IGRhdGF9XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBnbG9iYWwsXG4gIHBoeFdpbmRvdyxcbiAgQ0hBTk5FTF9FVkVOVFMsXG4gIERFRkFVTFRfVElNRU9VVCxcbiAgREVGQVVMVF9WU04sXG4gIFNPQ0tFVF9TVEFURVMsXG4gIFRSQU5TUE9SVFMsXG4gIFdTX0NMT1NFX05PUk1BTFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBjbG9zdXJlXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IEFqYXggZnJvbSBcIi4vYWpheFwiXG5pbXBvcnQgQ2hhbm5lbCBmcm9tIFwiLi9jaGFubmVsXCJcbmltcG9ydCBMb25nUG9sbCBmcm9tIFwiLi9sb25ncG9sbFwiXG5pbXBvcnQgU2VyaWFsaXplciBmcm9tIFwiLi9zZXJpYWxpemVyXCJcbmltcG9ydCBUaW1lciBmcm9tIFwiLi90aW1lclwiXG5cbi8qKiBJbml0aWFsaXplcyB0aGUgU29ja2V0ICpcbiAqXG4gKiBGb3IgSUU4IHN1cHBvcnQgdXNlIGFuIEVTNS1zaGltIChodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuZFBvaW50IC0gVGhlIHN0cmluZyBXZWJTb2NrZXQgZW5kcG9pbnQsIGllLCBgXCJ3czovL2V4YW1wbGUuY29tL3NvY2tldFwiYCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXCJ3c3M6Ly9leGFtcGxlLmNvbVwiYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcIi9zb2NrZXRcImAgKGluaGVyaXRlZCBob3N0ICYgcHJvdG9jb2wpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMudHJhbnNwb3J0XSAtIFRoZSBXZWJzb2NrZXQgVHJhbnNwb3J0LCBmb3IgZXhhbXBsZSBXZWJTb2NrZXQgb3IgUGhvZW5peC5Mb25nUG9sbC5cbiAqXG4gKiBEZWZhdWx0cyB0byBXZWJTb2NrZXQgd2l0aCBhdXRvbWF0aWMgTG9uZ1BvbGwgZmFsbGJhY2sgaWYgV2ViU29ja2V0IGlzIG5vdCBkZWZpbmVkLlxuICogVG8gZmFsbGJhY2sgdG8gTG9uZ1BvbGwgd2hlbiBXZWJTb2NrZXQgYXR0ZW1wdHMgZmFpbCwgdXNlIGBsb25nUG9sbEZhbGxiYWNrTXM6IDI1MDBgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmxvbmdQb2xsRmFsbGJhY2tNc10gLSBUaGUgbWlsbGlzZWNvbmQgdGltZSB0byBhdHRlbXB0IHRoZSBwcmltYXJ5IHRyYW5zcG9ydFxuICogYmVmb3JlIGZhbGxpbmcgYmFjayB0byB0aGUgTG9uZ1BvbGwgdHJhbnNwb3J0LiBEaXNhYmxlZCBieSBkZWZhdWx0LlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmRlYnVnXSAtIFdoZW4gdHJ1ZSwgZW5hYmxlcyBkZWJ1ZyBsb2dnaW5nLiBEZWZhdWx0IGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmVuY29kZV0gLSBUaGUgZnVuY3Rpb24gdG8gZW5jb2RlIG91dGdvaW5nIG1lc3NhZ2VzLlxuICpcbiAqIERlZmF1bHRzIHRvIEpTT04gZW5jb2Rlci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5kZWNvZGVdIC0gVGhlIGZ1bmN0aW9uIHRvIGRlY29kZSBpbmNvbWluZyBtZXNzYWdlcy5cbiAqXG4gKiBEZWZhdWx0cyB0byBKU09OOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIChwYXlsb2FkLCBjYWxsYmFjaykgPT4gY2FsbGJhY2soSlNPTi5wYXJzZShwYXlsb2FkKSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50aW1lb3V0XSAtIFRoZSBkZWZhdWx0IHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIHRyaWdnZXIgcHVzaCB0aW1lb3V0cy5cbiAqXG4gKiBEZWZhdWx0cyBgREVGQVVMVF9USU1FT1VUYFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmhlYXJ0YmVhdEludGVydmFsTXNdIC0gVGhlIG1pbGxpc2VjIGludGVydmFsIHRvIHNlbmQgYSBoZWFydGJlYXQgbWVzc2FnZVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnJlY29ubmVjdEFmdGVyTXNdIC0gVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbWlsbGlzZWNcbiAqIHNvY2tldCByZWNvbm5lY3QgaW50ZXJ2YWwuXG4gKlxuICogRGVmYXVsdHMgdG8gc3RlcHBlZCBiYWNrb2ZmIG9mOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMCwgNTAsIDEwMCwgMTUwLCAyMDAsIDI1MCwgNTAwLCAxMDAwLCAyMDAwXVt0cmllcyAtIDFdIHx8IDUwMDBcbiAqIH1cbiAqIGBgYGBcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMucmVqb2luQWZ0ZXJNc10gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtaWxsaXNlY1xuICogcmVqb2luIGludGVydmFsIGZvciBpbmRpdmlkdWFsIGNoYW5uZWxzLlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMDAwLCAyMDAwLCA1MDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gKiB9XG4gKiBgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMubG9nZ2VyXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3Igc3BlY2lhbGl6ZWQgbG9nZ2luZywgaWU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogZnVuY3Rpb24oa2luZCwgbXNnLCBkYXRhKSB7XG4gKiAgIGNvbnNvbGUubG9nKGAke2tpbmR9OiAke21zZ31gLCBkYXRhKVxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmxvbmdwb2xsZXJUaW1lb3V0XSAtIFRoZSBtYXhpbXVtIHRpbWVvdXQgb2YgYSBsb25nIHBvbGwgQUpBWCByZXF1ZXN0LlxuICpcbiAqIERlZmF1bHRzIHRvIDIwcyAoZG91YmxlIHRoZSBzZXJ2ZXIgbG9uZyBwb2xsIHRpbWVyKS5cbiAqXG4gKiBAcGFyYW0geyhPYmplY3R8ZnVuY3Rpb24pfSBbb3B0cy5wYXJhbXNdIC0gVGhlIG9wdGlvbmFsIHBhcmFtcyB0byBwYXNzIHdoZW4gY29ubmVjdGluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJpbmFyeVR5cGVdIC0gVGhlIGJpbmFyeSB0eXBlIHRvIHVzZSBmb3IgYmluYXJ5IFdlYlNvY2tldCBmcmFtZXMuXG4gKlxuICogRGVmYXVsdHMgdG8gXCJhcnJheWJ1ZmZlclwiXG4gKlxuICogQHBhcmFtIHt2c259IFtvcHRzLnZzbl0gLSBUaGUgc2VyaWFsaXplcidzIHByb3RvY29sIHZlcnNpb24gdG8gc2VuZCBvbiBjb25uZWN0LlxuICpcbiAqIERlZmF1bHRzIHRvIERFRkFVTFRfVlNOLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5zZXNzaW9uU3RvcmFnZV0gLSBBbiBvcHRpb25hbCBTdG9yYWdlIGNvbXBhdGlibGUgb2JqZWN0XG4gKiBQaG9lbml4IHVzZXMgc2Vzc2lvblN0b3JhZ2UgZm9yIGxvbmdwb2xsIGZhbGxiYWNrIGhpc3RvcnkuIE92ZXJyaWRpbmcgdGhlIHN0b3JlIGlzXG4gKiB1c2VmdWwgd2hlbiBQaG9lbml4IHdvbid0IGhhdmUgYWNjZXNzIHRvIGBzZXNzaW9uU3RvcmFnZWAuIEZvciBleGFtcGxlLCBUaGlzIGNvdWxkXG4gKiBoYXBwZW4gaWYgYSBzaXRlIGxvYWRzIGEgY3Jvc3MtZG9tYWluIGNoYW5uZWwgaW4gYW4gaWZyYW1lLiBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICAgICBjbGFzcyBJbk1lbW9yeVN0b3JhZ2Uge1xuICogICAgICAgY29uc3RydWN0b3IoKSB7IHRoaXMuc3RvcmFnZSA9IHt9IH1cbiAqICAgICAgIGdldEl0ZW0oa2V5TmFtZSkgeyByZXR1cm4gdGhpcy5zdG9yYWdlW2tleU5hbWVdIHx8IG51bGwgfVxuICogICAgICAgcmVtb3ZlSXRlbShrZXlOYW1lKSB7IGRlbGV0ZSB0aGlzLnN0b3JhZ2Vba2V5TmFtZV0gfVxuICogICAgICAgc2V0SXRlbShrZXlOYW1lLCBrZXlWYWx1ZSkgeyB0aGlzLnN0b3JhZ2Vba2V5TmFtZV0gPSBrZXlWYWx1ZSB9XG4gKiAgICAgfVxuICpcbiovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTb2NrZXQge1xuICBjb25zdHJ1Y3RvcihlbmRQb2ludCwgb3B0cyA9IHt9KXtcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzID0ge29wZW46IFtdLCBjbG9zZTogW10sIGVycm9yOiBbXSwgbWVzc2FnZTogW119XG4gICAgdGhpcy5jaGFubmVscyA9IFtdXG4gICAgdGhpcy5zZW5kQnVmZmVyID0gW11cbiAgICB0aGlzLnJlZiA9IDBcbiAgICB0aGlzLnRpbWVvdXQgPSBvcHRzLnRpbWVvdXQgfHwgREVGQVVMVF9USU1FT1VUXG4gICAgdGhpcy50cmFuc3BvcnQgPSBvcHRzLnRyYW5zcG9ydCB8fCBnbG9iYWwuV2ViU29ja2V0IHx8IExvbmdQb2xsXG4gICAgdGhpcy5wcmltYXJ5UGFzc2VkSGVhbHRoQ2hlY2sgPSBmYWxzZVxuICAgIHRoaXMubG9uZ1BvbGxGYWxsYmFja01zID0gb3B0cy5sb25nUG9sbEZhbGxiYWNrTXNcbiAgICB0aGlzLmZhbGxiYWNrVGltZXIgPSBudWxsXG4gICAgdGhpcy5zZXNzaW9uU3RvcmUgPSBvcHRzLnNlc3Npb25TdG9yYWdlIHx8IGdsb2JhbC5zZXNzaW9uU3RvcmFnZVxuICAgIHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9ucyA9IDBcbiAgICB0aGlzLmRlZmF1bHRFbmNvZGVyID0gU2VyaWFsaXplci5lbmNvZGUuYmluZChTZXJpYWxpemVyKVxuICAgIHRoaXMuZGVmYXVsdERlY29kZXIgPSBTZXJpYWxpemVyLmRlY29kZS5iaW5kKFNlcmlhbGl6ZXIpXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gZmFsc2VcbiAgICB0aGlzLmJpbmFyeVR5cGUgPSBvcHRzLmJpbmFyeVR5cGUgfHwgXCJhcnJheWJ1ZmZlclwiXG4gICAgdGhpcy5jb25uZWN0Q2xvY2sgPSAxXG4gICAgaWYodGhpcy50cmFuc3BvcnQgIT09IExvbmdQb2xsKXtcbiAgICAgIHRoaXMuZW5jb2RlID0gb3B0cy5lbmNvZGUgfHwgdGhpcy5kZWZhdWx0RW5jb2RlclxuICAgICAgdGhpcy5kZWNvZGUgPSBvcHRzLmRlY29kZSB8fCB0aGlzLmRlZmF1bHREZWNvZGVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5jb2RlID0gdGhpcy5kZWZhdWx0RW5jb2RlclxuICAgICAgdGhpcy5kZWNvZGUgPSB0aGlzLmRlZmF1bHREZWNvZGVyXG4gICAgfVxuICAgIGxldCBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gbnVsbFxuICAgIGlmKHBoeFdpbmRvdyAmJiBwaHhXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcil7XG4gICAgICBwaHhXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIF9lID0+IHtcbiAgICAgICAgaWYodGhpcy5jb25uKXtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgIGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPSB0aGlzLmNvbm5lY3RDbG9ja1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgcGh4V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLCBfZSA9PiB7XG4gICAgICAgIGlmKGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPT09IHRoaXMuY29ubmVjdENsb2NrKXtcbiAgICAgICAgICBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gbnVsbFxuICAgICAgICAgIHRoaXMuY29ubmVjdCgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyA9IG9wdHMuaGVhcnRiZWF0SW50ZXJ2YWxNcyB8fCAzMDAwMFxuICAgIHRoaXMucmVqb2luQWZ0ZXJNcyA9ICh0cmllcykgPT4ge1xuICAgICAgaWYob3B0cy5yZWpvaW5BZnRlck1zKXtcbiAgICAgICAgcmV0dXJuIG9wdHMucmVqb2luQWZ0ZXJNcyh0cmllcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbMTAwMCwgMjAwMCwgNTAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMFxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlY29ubmVjdEFmdGVyTXMgPSAodHJpZXMpID0+IHtcbiAgICAgIGlmKG9wdHMucmVjb25uZWN0QWZ0ZXJNcyl7XG4gICAgICAgIHJldHVybiBvcHRzLnJlY29ubmVjdEFmdGVyTXModHJpZXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzEwLCA1MCwgMTAwLCAxNTAsIDIwMCwgMjUwLCA1MDAsIDEwMDAsIDIwMDBdW3RyaWVzIC0gMV0gfHwgNTAwMFxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxvZ2dlciA9IG9wdHMubG9nZ2VyIHx8IG51bGxcbiAgICBpZighdGhpcy5sb2dnZXIgJiYgb3B0cy5kZWJ1Zyl7XG4gICAgICB0aGlzLmxvZ2dlciA9IChraW5kLCBtc2csIGRhdGEpID0+IHsgY29uc29sZS5sb2coYCR7a2luZH06ICR7bXNnfWAsIGRhdGEpIH1cbiAgICB9XG4gICAgdGhpcy5sb25ncG9sbGVyVGltZW91dCA9IG9wdHMubG9uZ3BvbGxlclRpbWVvdXQgfHwgMjAwMDBcbiAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUob3B0cy5wYXJhbXMgfHwge30pXG4gICAgdGhpcy5lbmRQb2ludCA9IGAke2VuZFBvaW50fS8ke1RSQU5TUE9SVFMud2Vic29ja2V0fWBcbiAgICB0aGlzLnZzbiA9IG9wdHMudnNuIHx8IERFRkFVTFRfVlNOXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lb3V0VGltZXIgPSBudWxsXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IG51bGxcbiAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcigoKSA9PiB7XG4gICAgICB0aGlzLnRlYXJkb3duKCgpID0+IHRoaXMuY29ubmVjdCgpKVxuICAgIH0sIHRoaXMucmVjb25uZWN0QWZ0ZXJNcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBMb25nUG9sbCB0cmFuc3BvcnQgcmVmZXJlbmNlXG4gICAqL1xuICBnZXRMb25nUG9sbFRyYW5zcG9ydCgpeyByZXR1cm4gTG9uZ1BvbGwgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyBhbmQgcmVwbGFjZXMgdGhlIGFjdGl2ZSB0cmFuc3BvcnRcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV3VHJhbnNwb3J0IC0gVGhlIG5ldyB0cmFuc3BvcnQgY2xhc3MgdG8gaW5zdGFudGlhdGVcbiAgICpcbiAgICovXG4gIHJlcGxhY2VUcmFuc3BvcnQobmV3VHJhbnNwb3J0KXtcbiAgICB0aGlzLmNvbm5lY3RDbG9jaysrXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gdHJ1ZVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmZhbGxiYWNrVGltZXIpXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gICAgaWYodGhpcy5jb25uKXtcbiAgICAgIHRoaXMuY29ubi5jbG9zZSgpXG4gICAgICB0aGlzLmNvbm4gPSBudWxsXG4gICAgfVxuICAgIHRoaXMudHJhbnNwb3J0ID0gbmV3VHJhbnNwb3J0XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc29ja2V0IHByb3RvY29sXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBwcm90b2NvbCgpeyByZXR1cm4gbG9jYXRpb24ucHJvdG9jb2wubWF0Y2goL15odHRwcy8pID8gXCJ3c3NcIiA6IFwid3NcIiB9XG5cbiAgLyoqXG4gICAqIFRoZSBmdWxseSBxdWFsaWZpZWQgc29ja2V0IHVybFxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZW5kUG9pbnRVUkwoKXtcbiAgICBsZXQgdXJpID0gQWpheC5hcHBlbmRQYXJhbXMoXG4gICAgICBBamF4LmFwcGVuZFBhcmFtcyh0aGlzLmVuZFBvaW50LCB0aGlzLnBhcmFtcygpKSwge3ZzbjogdGhpcy52c259KVxuICAgIGlmKHVyaS5jaGFyQXQoMCkgIT09IFwiL1wiKXsgcmV0dXJuIHVyaSB9XG4gICAgaWYodXJpLmNoYXJBdCgxKSA9PT0gXCIvXCIpeyByZXR1cm4gYCR7dGhpcy5wcm90b2NvbCgpfToke3VyaX1gIH1cblxuICAgIHJldHVybiBgJHt0aGlzLnByb3RvY29sKCl9Oi8vJHtsb2NhdGlvbi5ob3N0fSR7dXJpfWBcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0XG4gICAqXG4gICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2xvc2VFdmVudCNTdGF0dXNfY29kZXMgZm9yIHZhbGlkIHN0YXR1cyBjb2Rlcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgc29ja2V0IGlzIGRpc2Nvbm5lY3RlZC5cbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBjb2RlIC0gQSBzdGF0dXMgY29kZSBmb3IgZGlzY29ubmVjdGlvbiAoT3B0aW9uYWwpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gQSB0ZXh0dWFsIGRlc2NyaXB0aW9uIG9mIHRoZSByZWFzb24gdG8gZGlzY29ubmVjdC4gKE9wdGlvbmFsKVxuICAgKi9cbiAgZGlzY29ubmVjdChjYWxsYmFjaywgY29kZSwgcmVhc29uKXtcbiAgICB0aGlzLmNvbm5lY3RDbG9jaysrXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gdHJ1ZVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmZhbGxiYWNrVGltZXIpXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gICAgdGhpcy50ZWFyZG93bihjYWxsYmFjaywgY29kZSwgcmVhc29uKVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1zIHRvIHNlbmQgd2hlbiBjb25uZWN0aW5nLCBmb3IgZXhhbXBsZSBge3VzZXJfaWQ6IHVzZXJUb2tlbn1gXG4gICAqXG4gICAqIFBhc3NpbmcgcGFyYW1zIHRvIGNvbm5lY3QgaXMgZGVwcmVjYXRlZDsgcGFzcyB0aGVtIGluIHRoZSBTb2NrZXQgY29uc3RydWN0b3IgaW5zdGVhZDpcbiAgICogYG5ldyBTb2NrZXQoXCIvc29ja2V0XCIsIHtwYXJhbXM6IHt1c2VyX2lkOiB1c2VyVG9rZW59fSlgLlxuICAgKi9cbiAgY29ubmVjdChwYXJhbXMpe1xuICAgIGlmKHBhcmFtcyl7XG4gICAgICBjb25zb2xlICYmIGNvbnNvbGUubG9nKFwicGFzc2luZyBwYXJhbXMgdG8gY29ubmVjdCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHBhc3MgOnBhcmFtcyB0byB0aGUgU29ja2V0IGNvbnN0cnVjdG9yXCIpXG4gICAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUocGFyYW1zKVxuICAgIH1cbiAgICBpZih0aGlzLmNvbm4peyByZXR1cm4gfVxuICAgIGlmKHRoaXMubG9uZ1BvbGxGYWxsYmFja01zICYmIHRoaXMudHJhbnNwb3J0ICE9PSBMb25nUG9sbCl7XG4gICAgICB0aGlzLmNvbm5lY3RXaXRoRmFsbGJhY2soTG9uZ1BvbGwsIHRoaXMubG9uZ1BvbGxGYWxsYmFja01zKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zcG9ydENvbm5lY3QoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIHRoZSBtZXNzYWdlLiBPdmVycmlkZSBgdGhpcy5sb2dnZXJgIGZvciBzcGVjaWFsaXplZCBsb2dnaW5nLiBub29wcyBieSBkZWZhdWx0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBraW5kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtc2dcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICovXG4gIGxvZyhraW5kLCBtc2csIGRhdGEpeyB0aGlzLmxvZ2dlciAmJiB0aGlzLmxvZ2dlcihraW5kLCBtc2csIGRhdGEpIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGEgbG9nZ2VyIGhhcyBiZWVuIHNldCBvbiB0aGlzIHNvY2tldC5cbiAgICovXG4gIGhhc0xvZ2dlcigpeyByZXR1cm4gdGhpcy5sb2dnZXIgIT09IG51bGwgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIGZvciBjb25uZWN0aW9uIG9wZW4gZXZlbnRzXG4gICAqXG4gICAqIEBleGFtcGxlIHNvY2tldC5vbk9wZW4oZnVuY3Rpb24oKXsgY29uc29sZS5pbmZvKFwidGhlIHNvY2tldCB3YXMgb3BlbmVkXCIpIH0pXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbk9wZW4oY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mub3Blbi5wdXNoKFtyZWYsIGNhbGxiYWNrXSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBjbG9zZSBldmVudHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uQ2xvc2UoY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3MgZm9yIGNvbm5lY3Rpb24gZXJyb3IgZXZlbnRzXG4gICAqXG4gICAqIEBleGFtcGxlIHNvY2tldC5vbkVycm9yKGZ1bmN0aW9uKGVycm9yKXsgYWxlcnQoXCJBbiBlcnJvciBvY2N1cnJlZFwiKSB9KVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25FcnJvcihjYWxsYmFjayl7XG4gICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5lcnJvci5wdXNoKFtyZWYsIGNhbGxiYWNrXSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBtZXNzYWdlIGV2ZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25NZXNzYWdlKGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2UucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFBpbmdzIHRoZSBzZXJ2ZXIgYW5kIGludm9rZXMgdGhlIGNhbGxiYWNrIHdpdGggdGhlIFJUVCBpbiBtaWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwaW5nIHdhcyBwdXNoZWQgb3IgZmFsc2UgaWYgdW5hYmxlIHRvIGJlIHB1c2hlZC5cbiAgICovXG4gIHBpbmcoY2FsbGJhY2spe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gZmFsc2UgfVxuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIGxldCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgdGhpcy5wdXNoKHt0b3BpYzogXCJwaG9lbml4XCIsIGV2ZW50OiBcImhlYXJ0YmVhdFwiLCBwYXlsb2FkOiB7fSwgcmVmOiByZWZ9KVxuICAgIGxldCBvbk1zZ1JlZiA9IHRoaXMub25NZXNzYWdlKG1zZyA9PiB7XG4gICAgICBpZihtc2cucmVmID09PSByZWYpe1xuICAgICAgICB0aGlzLm9mZihbb25Nc2dSZWZdKVxuICAgICAgICBjYWxsYmFjayhEYXRlLm5vdygpIC0gc3RhcnRUaW1lKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0cmFuc3BvcnRDb25uZWN0KCl7XG4gICAgdGhpcy5jb25uZWN0Q2xvY2srK1xuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlXG4gICAgdGhpcy5jb25uID0gbmV3IHRoaXMudHJhbnNwb3J0KHRoaXMuZW5kUG9pbnRVUkwoKSlcbiAgICB0aGlzLmNvbm4uYmluYXJ5VHlwZSA9IHRoaXMuYmluYXJ5VHlwZVxuICAgIHRoaXMuY29ubi50aW1lb3V0ID0gdGhpcy5sb25ncG9sbGVyVGltZW91dFxuICAgIHRoaXMuY29ubi5vbm9wZW4gPSAoKSA9PiB0aGlzLm9uQ29ubk9wZW4oKVxuICAgIHRoaXMuY29ubi5vbmVycm9yID0gZXJyb3IgPT4gdGhpcy5vbkNvbm5FcnJvcihlcnJvcilcbiAgICB0aGlzLmNvbm4ub25tZXNzYWdlID0gZXZlbnQgPT4gdGhpcy5vbkNvbm5NZXNzYWdlKGV2ZW50KVxuICAgIHRoaXMuY29ubi5vbmNsb3NlID0gZXZlbnQgPT4gdGhpcy5vbkNvbm5DbG9zZShldmVudClcbiAgfVxuXG4gIGdldFNlc3Npb24oa2V5KXsgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JlICYmIHRoaXMuc2Vzc2lvblN0b3JlLmdldEl0ZW0oa2V5KSB9XG5cbiAgc3RvcmVTZXNzaW9uKGtleSwgdmFsKXsgdGhpcy5zZXNzaW9uU3RvcmUgJiYgdGhpcy5zZXNzaW9uU3RvcmUuc2V0SXRlbShrZXksIHZhbCkgfVxuXG4gIGNvbm5lY3RXaXRoRmFsbGJhY2soZmFsbGJhY2tUcmFuc3BvcnQsIGZhbGxiYWNrVGhyZXNob2xkID0gMjUwMCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZmFsbGJhY2tUaW1lcilcbiAgICBsZXQgZXN0YWJsaXNoZWQgPSBmYWxzZVxuICAgIGxldCBwcmltYXJ5VHJhbnNwb3J0ID0gdHJ1ZVxuICAgIGxldCBvcGVuUmVmLCBlcnJvclJlZlxuICAgIGxldCBmYWxsYmFjayA9IChyZWFzb24pID0+IHtcbiAgICAgIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGBmYWxsaW5nIGJhY2sgdG8gJHtmYWxsYmFja1RyYW5zcG9ydC5uYW1lfS4uLmAsIHJlYXNvbilcbiAgICAgIHRoaXMub2ZmKFtvcGVuUmVmLCBlcnJvclJlZl0pXG4gICAgICBwcmltYXJ5VHJhbnNwb3J0ID0gZmFsc2VcbiAgICAgIHRoaXMucmVwbGFjZVRyYW5zcG9ydChmYWxsYmFja1RyYW5zcG9ydClcbiAgICAgIHRoaXMudHJhbnNwb3J0Q29ubmVjdCgpXG4gICAgfVxuICAgIGlmKHRoaXMuZ2V0U2Vzc2lvbihgcGh4OmZhbGxiYWNrOiR7ZmFsbGJhY2tUcmFuc3BvcnQubmFtZX1gKSl7IHJldHVybiBmYWxsYmFjayhcIm1lbW9yaXplZFwiKSB9XG5cbiAgICB0aGlzLmZhbGxiYWNrVGltZXIgPSBzZXRUaW1lb3V0KGZhbGxiYWNrLCBmYWxsYmFja1RocmVzaG9sZClcblxuICAgIGVycm9yUmVmID0gdGhpcy5vbkVycm9yKHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBcImVycm9yXCIsIHJlYXNvbilcbiAgICAgIGlmKHByaW1hcnlUcmFuc3BvcnQgJiYgIWVzdGFibGlzaGVkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmZhbGxiYWNrVGltZXIpXG4gICAgICAgIGZhbGxiYWNrKHJlYXNvbilcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMub25PcGVuKCgpID0+IHtcbiAgICAgIGVzdGFibGlzaGVkID0gdHJ1ZVxuICAgICAgaWYoIXByaW1hcnlUcmFuc3BvcnQpe1xuICAgICAgICAvLyBvbmx5IG1lbW9yaXplIExQIGlmIHdlIG5ldmVyIGNvbm5lY3RlZCB0byBwcmltYXJ5XG4gICAgICAgIGlmKCF0aGlzLnByaW1hcnlQYXNzZWRIZWFsdGhDaGVjayl7IHRoaXMuc3RvcmVTZXNzaW9uKGBwaHg6ZmFsbGJhY2s6JHtmYWxsYmFja1RyYW5zcG9ydC5uYW1lfWAsIFwidHJ1ZVwiKSB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBgZXN0YWJsaXNoZWQgJHtmYWxsYmFja1RyYW5zcG9ydC5uYW1lfSBmYWxsYmFja2ApXG4gICAgICB9XG4gICAgICAvLyBpZiB3ZSd2ZSBlc3RhYmxpc2hlZCBwcmltYXJ5LCBnaXZlIHRoZSBmYWxsYmFjayBhIG5ldyBwZXJpb2QgdG8gYXR0ZW1wdCBwaW5nXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5mYWxsYmFja1RpbWVyKVxuICAgICAgdGhpcy5mYWxsYmFja1RpbWVyID0gc2V0VGltZW91dChmYWxsYmFjaywgZmFsbGJhY2tUaHJlc2hvbGQpXG4gICAgICB0aGlzLnBpbmcocnR0ID0+IHtcbiAgICAgICAgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgXCJjb25uZWN0ZWQgdG8gcHJpbWFyeSBhZnRlclwiLCBydHQpXG4gICAgICAgIHRoaXMucHJpbWFyeVBhc3NlZEhlYWx0aENoZWNrID0gdHJ1ZVxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5mYWxsYmFja1RpbWVyKVxuICAgICAgfSlcbiAgICB9KVxuICAgIHRoaXMudHJhbnNwb3J0Q29ubmVjdCgpXG4gIH1cblxuICBjbGVhckhlYXJ0YmVhdHMoKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5oZWFydGJlYXRUaW1lcilcbiAgICBjbGVhclRpbWVvdXQodGhpcy5oZWFydGJlYXRUaW1lb3V0VGltZXIpXG4gIH1cblxuICBvbkNvbm5PcGVuKCl7XG4gICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgYCR7dGhpcy50cmFuc3BvcnQubmFtZX0gY29ubmVjdGVkIHRvICR7dGhpcy5lbmRQb2ludFVSTCgpfWApXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gZmFsc2VcbiAgICB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnMrK1xuICAgIHRoaXMuZmx1c2hTZW5kQnVmZmVyKClcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAgICB0aGlzLnJlc2V0SGVhcnRiZWF0KClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm9wZW4uZm9yRWFjaCgoWywgY2FsbGJhY2tdKSA9PiBjYWxsYmFjaygpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIGhlYXJ0YmVhdFRpbWVvdXQoKXtcbiAgICBpZih0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYpe1xuICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbFxuICAgICAgaWYodGhpcy5oYXNMb2dnZXIoKSl7IHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIFwiaGVhcnRiZWF0IHRpbWVvdXQuIEF0dGVtcHRpbmcgdG8gcmUtZXN0YWJsaXNoIGNvbm5lY3Rpb25cIikgfVxuICAgICAgdGhpcy50cmlnZ2VyQ2hhbkVycm9yKClcbiAgICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlXG4gICAgICB0aGlzLnRlYXJkb3duKCgpID0+IHRoaXMucmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCksIFdTX0NMT1NFX05PUk1BTCwgXCJoZWFydGJlYXQgdGltZW91dFwiKVxuICAgIH1cbiAgfVxuXG4gIHJlc2V0SGVhcnRiZWF0KCl7XG4gICAgaWYodGhpcy5jb25uICYmIHRoaXMuY29ubi5za2lwSGVhcnRiZWF0KXsgcmV0dXJuIH1cbiAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgdGhpcy5jbGVhckhlYXJ0YmVhdHMoKVxuICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VuZEhlYXJ0YmVhdCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpXG4gIH1cblxuICB0ZWFyZG93bihjYWxsYmFjaywgY29kZSwgcmVhc29uKXtcbiAgICBpZighdGhpcy5jb25uKXtcbiAgICAgIHJldHVybiBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gICAgfVxuXG4gICAgdGhpcy53YWl0Rm9yQnVmZmVyRG9uZSgoKSA9PiB7XG4gICAgICBpZih0aGlzLmNvbm4pe1xuICAgICAgICBpZihjb2RlKXsgdGhpcy5jb25uLmNsb3NlKGNvZGUsIHJlYXNvbiB8fCBcIlwiKSB9IGVsc2UgeyB0aGlzLmNvbm4uY2xvc2UoKSB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMud2FpdEZvclNvY2tldENsb3NlZCgoKSA9PiB7XG4gICAgICAgIGlmKHRoaXMuY29ubil7XG4gICAgICAgICAgdGhpcy5jb25uLm9ub3BlbiA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICAgICAgICB0aGlzLmNvbm4ub25lcnJvciA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICAgICAgICB0aGlzLmNvbm4ub25tZXNzYWdlID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgICAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgICAgICAgIHRoaXMuY29ubiA9IG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHdhaXRGb3JCdWZmZXJEb25lKGNhbGxiYWNrLCB0cmllcyA9IDEpe1xuICAgIGlmKHRyaWVzID09PSA1IHx8ICF0aGlzLmNvbm4gfHwgIXRoaXMuY29ubi5idWZmZXJlZEFtb3VudCl7XG4gICAgICBjYWxsYmFjaygpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMud2FpdEZvckJ1ZmZlckRvbmUoY2FsbGJhY2ssIHRyaWVzICsgMSlcbiAgICB9LCAxNTAgKiB0cmllcylcbiAgfVxuXG4gIHdhaXRGb3JTb2NrZXRDbG9zZWQoY2FsbGJhY2ssIHRyaWVzID0gMSl7XG4gICAgaWYodHJpZXMgPT09IDUgfHwgIXRoaXMuY29ubiB8fCB0aGlzLmNvbm4ucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5jbG9zZWQpe1xuICAgICAgY2FsbGJhY2soKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLndhaXRGb3JTb2NrZXRDbG9zZWQoY2FsbGJhY2ssIHRyaWVzICsgMSlcbiAgICB9LCAxNTAgKiB0cmllcylcbiAgfVxuXG4gIG9uQ29ubkNsb3NlKGV2ZW50KXtcbiAgICBsZXQgY2xvc2VDb2RlID0gZXZlbnQgJiYgZXZlbnQuY29kZVxuICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIFwiY2xvc2VcIiwgZXZlbnQpXG4gICAgdGhpcy50cmlnZ2VyQ2hhbkVycm9yKClcbiAgICB0aGlzLmNsZWFySGVhcnRiZWF0cygpXG4gICAgaWYoIXRoaXMuY2xvc2VXYXNDbGVhbiAmJiBjbG9zZUNvZGUgIT09IDEwMDApe1xuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKVxuICAgIH1cbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmNsb3NlLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4gY2FsbGJhY2soZXZlbnQpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbkNvbm5FcnJvcihlcnJvcil7XG4gICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgZXJyb3IpXG4gICAgbGV0IHRyYW5zcG9ydEJlZm9yZSA9IHRoaXMudHJhbnNwb3J0XG4gICAgbGV0IGVzdGFibGlzaGVkQmVmb3JlID0gdGhpcy5lc3RhYmxpc2hlZENvbm5lY3Rpb25zXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5lcnJvci5mb3JFYWNoKChbLCBjYWxsYmFja10pID0+IHtcbiAgICAgIGNhbGxiYWNrKGVycm9yLCB0cmFuc3BvcnRCZWZvcmUsIGVzdGFibGlzaGVkQmVmb3JlKVxuICAgIH0pXG4gICAgaWYodHJhbnNwb3J0QmVmb3JlID09PSB0aGlzLnRyYW5zcG9ydCB8fCBlc3RhYmxpc2hlZEJlZm9yZSA+IDApe1xuICAgICAgdGhpcy50cmlnZ2VyQ2hhbkVycm9yKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRyaWdnZXJDaGFuRXJyb3IoKXtcbiAgICB0aGlzLmNoYW5uZWxzLmZvckVhY2goY2hhbm5lbCA9PiB7XG4gICAgICBpZighKGNoYW5uZWwuaXNFcnJvcmVkKCkgfHwgY2hhbm5lbC5pc0xlYXZpbmcoKSB8fCBjaGFubmVsLmlzQ2xvc2VkKCkpKXtcbiAgICAgICAgY2hhbm5lbC50cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmVycm9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGNvbm5lY3Rpb25TdGF0ZSgpe1xuICAgIHN3aXRjaCh0aGlzLmNvbm4gJiYgdGhpcy5jb25uLnJlYWR5U3RhdGUpe1xuICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLmNvbm5lY3Rpbmc6IHJldHVybiBcImNvbm5lY3RpbmdcIlxuICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLm9wZW46IHJldHVybiBcIm9wZW5cIlxuICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLmNsb3Npbmc6IHJldHVybiBcImNsb3NpbmdcIlxuICAgICAgZGVmYXVsdDogcmV0dXJuIFwiY2xvc2VkXCJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc0Nvbm5lY3RlZCgpeyByZXR1cm4gdGhpcy5jb25uZWN0aW9uU3RhdGUoKSA9PT0gXCJvcGVuXCIgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0NoYW5uZWx9XG4gICAqL1xuICByZW1vdmUoY2hhbm5lbCl7XG4gICAgdGhpcy5vZmYoY2hhbm5lbC5zdGF0ZUNoYW5nZVJlZnMpXG4gICAgdGhpcy5jaGFubmVscyA9IHRoaXMuY2hhbm5lbHMuZmlsdGVyKGMgPT4gYyAhPT0gY2hhbm5lbClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGBvbk9wZW5gLCBgb25DbG9zZWAsIGBvbkVycm9yLGAgYW5kIGBvbk1lc3NhZ2VgIHJlZ2lzdHJhdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7cmVmc30gLSBsaXN0IG9mIHJlZnMgcmV0dXJuZWQgYnkgY2FsbHMgdG9cbiAgICogICAgICAgICAgICAgICAgIGBvbk9wZW5gLCBgb25DbG9zZWAsIGBvbkVycm9yLGAgYW5kIGBvbk1lc3NhZ2VgXG4gICAqL1xuICBvZmYocmVmcyl7XG4gICAgZm9yKGxldCBrZXkgaW4gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcyl7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzW2tleV0gPSB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzW2tleV0uZmlsdGVyKChbcmVmXSkgPT4ge1xuICAgICAgICByZXR1cm4gcmVmcy5pbmRleE9mKHJlZikgPT09IC0xXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgYSBuZXcgY2hhbm5lbCBmb3IgdGhlIGdpdmVuIHRvcGljXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhblBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIHRoZSBjaGFubmVsXG4gICAqIEByZXR1cm5zIHtDaGFubmVsfVxuICAgKi9cbiAgY2hhbm5lbCh0b3BpYywgY2hhblBhcmFtcyA9IHt9KXtcbiAgICBsZXQgY2hhbiA9IG5ldyBDaGFubmVsKHRvcGljLCBjaGFuUGFyYW1zLCB0aGlzKVxuICAgIHRoaXMuY2hhbm5lbHMucHVzaChjaGFuKVxuICAgIHJldHVybiBjaGFuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICovXG4gIHB1c2goZGF0YSl7XG4gICAgaWYodGhpcy5oYXNMb2dnZXIoKSl7XG4gICAgICBsZXQge3RvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luX3JlZn0gPSBkYXRhXG4gICAgICB0aGlzLmxvZyhcInB1c2hcIiwgYCR7dG9waWN9ICR7ZXZlbnR9ICgke2pvaW5fcmVmfSwgJHtyZWZ9KWAsIHBheWxvYWQpXG4gICAgfVxuXG4gICAgaWYodGhpcy5pc0Nvbm5lY3RlZCgpKXtcbiAgICAgIHRoaXMuZW5jb2RlKGRhdGEsIHJlc3VsdCA9PiB0aGlzLmNvbm4uc2VuZChyZXN1bHQpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRCdWZmZXIucHVzaCgoKSA9PiB0aGlzLmVuY29kZShkYXRhLCByZXN1bHQgPT4gdGhpcy5jb25uLnNlbmQocmVzdWx0KSkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbmV4dCBtZXNzYWdlIHJlZiwgYWNjb3VudGluZyBmb3Igb3ZlcmZsb3dzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBtYWtlUmVmKCl7XG4gICAgbGV0IG5ld1JlZiA9IHRoaXMucmVmICsgMVxuICAgIGlmKG5ld1JlZiA9PT0gdGhpcy5yZWYpeyB0aGlzLnJlZiA9IDAgfSBlbHNlIHsgdGhpcy5yZWYgPSBuZXdSZWYgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVmLnRvU3RyaW5nKClcbiAgfVxuXG4gIHNlbmRIZWFydGJlYXQoKXtcbiAgICBpZih0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgJiYgIXRoaXMuaXNDb25uZWN0ZWQoKSl7IHJldHVybiB9XG4gICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICB0aGlzLnB1c2goe3RvcGljOiBcInBob2VuaXhcIiwgZXZlbnQ6IFwiaGVhcnRiZWF0XCIsIHBheWxvYWQ6IHt9LCByZWY6IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZn0pXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaGVhcnRiZWF0VGltZW91dCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpXG4gIH1cblxuICBmbHVzaFNlbmRCdWZmZXIoKXtcbiAgICBpZih0aGlzLmlzQ29ubmVjdGVkKCkgJiYgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aCA+IDApe1xuICAgICAgdGhpcy5zZW5kQnVmZmVyLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soKSlcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdXG4gICAgfVxuICB9XG5cbiAgb25Db25uTWVzc2FnZShyYXdNZXNzYWdlKXtcbiAgICB0aGlzLmRlY29kZShyYXdNZXNzYWdlLmRhdGEsIG1zZyA9PiB7XG4gICAgICBsZXQge3RvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luX3JlZn0gPSBtc2dcbiAgICAgIGlmKHJlZiAmJiByZWYgPT09IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZil7XG4gICAgICAgIHRoaXMuY2xlYXJIZWFydGJlYXRzKClcbiAgICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbFxuICAgICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbmRIZWFydGJlYXQoKSwgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zKVxuICAgICAgfVxuXG4gICAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInJlY2VpdmVcIiwgYCR7cGF5bG9hZC5zdGF0dXMgfHwgXCJcIn0gJHt0b3BpY30gJHtldmVudH0gJHtyZWYgJiYgXCIoXCIgKyByZWYgKyBcIilcIiB8fCBcIlwifWAsIHBheWxvYWQpXG5cbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbaV1cbiAgICAgICAgaWYoIWNoYW5uZWwuaXNNZW1iZXIodG9waWMsIGV2ZW50LCBwYXlsb2FkLCBqb2luX3JlZikpeyBjb250aW51ZSB9XG4gICAgICAgIGNoYW5uZWwudHJpZ2dlcihldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luX3JlZilcbiAgICAgIH1cblxuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGxldCBbLCBjYWxsYmFja10gPSB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2VbaV1cbiAgICAgICAgY2FsbGJhY2sobXNnKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBsZWF2ZU9wZW5Ub3BpYyh0b3BpYyl7XG4gICAgbGV0IGR1cENoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLmZpbmQoYyA9PiBjLnRvcGljID09PSB0b3BpYyAmJiAoYy5pc0pvaW5lZCgpIHx8IGMuaXNKb2luaW5nKCkpKVxuICAgIGlmKGR1cENoYW5uZWwpe1xuICAgICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgYGxlYXZpbmcgZHVwbGljYXRlIHRvcGljIFwiJHt0b3BpY31cImApXG4gICAgICBkdXBDaGFubmVsLmxlYXZlKClcbiAgICB9XG4gIH1cbn1cbiIsICJleHBvcnQgY29uc3QgQ09OU0VDVVRJVkVfUkVMT0FEUyA9IFwiY29uc2VjdXRpdmUtcmVsb2Fkc1wiXG5leHBvcnQgY29uc3QgTUFYX1JFTE9BRFMgPSAxMFxuZXhwb3J0IGNvbnN0IFJFTE9BRF9KSVRURVJfTUlOID0gNTAwMFxuZXhwb3J0IGNvbnN0IFJFTE9BRF9KSVRURVJfTUFYID0gMTAwMDBcbmV4cG9ydCBjb25zdCBGQUlMU0FGRV9KSVRURVIgPSAzMDAwMFxuZXhwb3J0IGNvbnN0IFBIWF9FVkVOVF9DTEFTU0VTID0gW1xuICBcInBoeC1jbGljay1sb2FkaW5nXCIsIFwicGh4LWNoYW5nZS1sb2FkaW5nXCIsIFwicGh4LXN1Ym1pdC1sb2FkaW5nXCIsXG4gIFwicGh4LWtleWRvd24tbG9hZGluZ1wiLCBcInBoeC1rZXl1cC1sb2FkaW5nXCIsIFwicGh4LWJsdXItbG9hZGluZ1wiLCBcInBoeC1mb2N1cy1sb2FkaW5nXCIsXG4gIFwicGh4LWhvb2stbG9hZGluZ1wiXG5dXG5leHBvcnQgY29uc3QgUEhYX0NPTVBPTkVOVCA9IFwiZGF0YS1waHgtY29tcG9uZW50XCJcbmV4cG9ydCBjb25zdCBQSFhfTElWRV9MSU5LID0gXCJkYXRhLXBoeC1saW5rXCJcbmV4cG9ydCBjb25zdCBQSFhfVFJBQ0tfU1RBVElDID0gXCJ0cmFjay1zdGF0aWNcIlxuZXhwb3J0IGNvbnN0IFBIWF9MSU5LX1NUQVRFID0gXCJkYXRhLXBoeC1saW5rLXN0YXRlXCJcbmV4cG9ydCBjb25zdCBQSFhfUkVGID0gXCJkYXRhLXBoeC1yZWZcIlxuZXhwb3J0IGNvbnN0IFBIWF9SRUZfU1JDID0gXCJkYXRhLXBoeC1yZWYtc3JjXCJcbmV4cG9ydCBjb25zdCBQSFhfVFJBQ0tfVVBMT0FEUyA9IFwidHJhY2stdXBsb2Fkc1wiXG5leHBvcnQgY29uc3QgUEhYX1VQTE9BRF9SRUYgPSBcImRhdGEtcGh4LXVwbG9hZC1yZWZcIlxuZXhwb3J0IGNvbnN0IFBIWF9QUkVGTElHSFRFRF9SRUZTID0gXCJkYXRhLXBoeC1wcmVmbGlnaHRlZC1yZWZzXCJcbmV4cG9ydCBjb25zdCBQSFhfRE9ORV9SRUZTID0gXCJkYXRhLXBoeC1kb25lLXJlZnNcIlxuZXhwb3J0IGNvbnN0IFBIWF9EUk9QX1RBUkdFVCA9IFwiZHJvcC10YXJnZXRcIlxuZXhwb3J0IGNvbnN0IFBIWF9BQ1RJVkVfRU5UUllfUkVGUyA9IFwiZGF0YS1waHgtYWN0aXZlLXJlZnNcIlxuZXhwb3J0IGNvbnN0IFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCA9IFwicGh4OmxpdmUtZmlsZTp1cGRhdGVkXCJcbmV4cG9ydCBjb25zdCBQSFhfU0tJUCA9IFwiZGF0YS1waHgtc2tpcFwiXG5leHBvcnQgY29uc3QgUEhYX01BR0lDX0lEID0gXCJkYXRhLXBoeC1pZFwiXG5leHBvcnQgY29uc3QgUEhYX1BSVU5FID0gXCJkYXRhLXBoeC1wcnVuZVwiXG5leHBvcnQgY29uc3QgUEhYX1BBR0VfTE9BRElORyA9IFwicGFnZS1sb2FkaW5nXCJcbmV4cG9ydCBjb25zdCBQSFhfQ09OTkVDVEVEX0NMQVNTID0gXCJwaHgtY29ubmVjdGVkXCJcbmV4cG9ydCBjb25zdCBQSFhfTE9BRElOR19DTEFTUyA9IFwicGh4LWxvYWRpbmdcIlxuZXhwb3J0IGNvbnN0IFBIWF9OT19GRUVEQkFDS19DTEFTUyA9IFwicGh4LW5vLWZlZWRiYWNrXCJcbmV4cG9ydCBjb25zdCBQSFhfRVJST1JfQ0xBU1MgPSBcInBoeC1lcnJvclwiXG5leHBvcnQgY29uc3QgUEhYX0NMSUVOVF9FUlJPUl9DTEFTUyA9IFwicGh4LWNsaWVudC1lcnJvclwiXG5leHBvcnQgY29uc3QgUEhYX1NFUlZFUl9FUlJPUl9DTEFTUyA9IFwicGh4LXNlcnZlci1lcnJvclwiXG5leHBvcnQgY29uc3QgUEhYX1BBUkVOVF9JRCA9IFwiZGF0YS1waHgtcGFyZW50LWlkXCJcbmV4cG9ydCBjb25zdCBQSFhfTUFJTiA9IFwiZGF0YS1waHgtbWFpblwiXG5leHBvcnQgY29uc3QgUEhYX1JPT1RfSUQgPSBcImRhdGEtcGh4LXJvb3QtaWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9WSUVXUE9SVF9UT1AgPSBcInZpZXdwb3J0LXRvcFwiXG5leHBvcnQgY29uc3QgUEhYX1ZJRVdQT1JUX0JPVFRPTSA9IFwidmlld3BvcnQtYm90dG9tXCJcbmV4cG9ydCBjb25zdCBQSFhfVFJJR0dFUl9BQ1RJT04gPSBcInRyaWdnZXItYWN0aW9uXCJcbmV4cG9ydCBjb25zdCBQSFhfRkVFREJBQ0tfRk9SID0gXCJmZWVkYmFjay1mb3JcIlxuZXhwb3J0IGNvbnN0IFBIWF9GRUVEQkFDS19HUk9VUCA9IFwiZmVlZGJhY2stZ3JvdXBcIlxuZXhwb3J0IGNvbnN0IFBIWF9IQVNfRk9DVVNFRCA9IFwicGh4LWhhcy1mb2N1c2VkXCJcbmV4cG9ydCBjb25zdCBGT0NVU0FCTEVfSU5QVVRTID0gW1widGV4dFwiLCBcInRleHRhcmVhXCIsIFwibnVtYmVyXCIsIFwiZW1haWxcIiwgXCJwYXNzd29yZFwiLCBcInNlYXJjaFwiLCBcInRlbFwiLCBcInVybFwiLCBcImRhdGVcIiwgXCJ0aW1lXCIsIFwiZGF0ZXRpbWUtbG9jYWxcIiwgXCJjb2xvclwiLCBcInJhbmdlXCJdXG5leHBvcnQgY29uc3QgQ0hFQ0tBQkxFX0lOUFVUUyA9IFtcImNoZWNrYm94XCIsIFwicmFkaW9cIl1cbmV4cG9ydCBjb25zdCBQSFhfSEFTX1NVQk1JVFRFRCA9IFwicGh4LWhhcy1zdWJtaXR0ZWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9TRVNTSU9OID0gXCJkYXRhLXBoeC1zZXNzaW9uXCJcbmV4cG9ydCBjb25zdCBQSFhfVklFV19TRUxFQ1RPUiA9IGBbJHtQSFhfU0VTU0lPTn1dYFxuZXhwb3J0IGNvbnN0IFBIWF9TVElDS1kgPSBcImRhdGEtcGh4LXN0aWNreVwiXG5leHBvcnQgY29uc3QgUEhYX1NUQVRJQyA9IFwiZGF0YS1waHgtc3RhdGljXCJcbmV4cG9ydCBjb25zdCBQSFhfUkVBRE9OTFkgPSBcImRhdGEtcGh4LXJlYWRvbmx5XCJcbmV4cG9ydCBjb25zdCBQSFhfRElTQUJMRUQgPSBcImRhdGEtcGh4LWRpc2FibGVkXCJcbmV4cG9ydCBjb25zdCBQSFhfRElTQUJMRV9XSVRIID0gXCJkaXNhYmxlLXdpdGhcIlxuZXhwb3J0IGNvbnN0IFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSA9IFwiZGF0YS1waHgtZGlzYWJsZS13aXRoLXJlc3RvcmVcIlxuZXhwb3J0IGNvbnN0IFBIWF9IT09LID0gXCJob29rXCJcbmV4cG9ydCBjb25zdCBQSFhfREVCT1VOQ0UgPSBcImRlYm91bmNlXCJcbmV4cG9ydCBjb25zdCBQSFhfVEhST1RUTEUgPSBcInRocm90dGxlXCJcbmV4cG9ydCBjb25zdCBQSFhfVVBEQVRFID0gXCJ1cGRhdGVcIlxuZXhwb3J0IGNvbnN0IFBIWF9TVFJFQU0gPSBcInN0cmVhbVwiXG5leHBvcnQgY29uc3QgUEhYX1NUUkVBTV9SRUYgPSBcImRhdGEtcGh4LXN0cmVhbVwiXG5leHBvcnQgY29uc3QgUEhYX0tFWSA9IFwia2V5XCJcbmV4cG9ydCBjb25zdCBQSFhfUFJJVkFURSA9IFwicGh4UHJpdmF0ZVwiXG5leHBvcnQgY29uc3QgUEhYX0FVVE9fUkVDT1ZFUiA9IFwiYXV0by1yZWNvdmVyXCJcbmV4cG9ydCBjb25zdCBQSFhfTFZfREVCVUcgPSBcInBoeDpsaXZlLXNvY2tldDpkZWJ1Z1wiXG5leHBvcnQgY29uc3QgUEhYX0xWX1BST0ZJTEUgPSBcInBoeDpsaXZlLXNvY2tldDpwcm9maWxpbmdcIlxuZXhwb3J0IGNvbnN0IFBIWF9MVl9MQVRFTkNZX1NJTSA9IFwicGh4OmxpdmUtc29ja2V0OmxhdGVuY3ktc2ltXCJcbmV4cG9ydCBjb25zdCBQSFhfUFJPR1JFU1MgPSBcInByb2dyZXNzXCJcbmV4cG9ydCBjb25zdCBQSFhfTU9VTlRFRCA9IFwibW91bnRlZFwiXG5leHBvcnQgY29uc3QgTE9BREVSX1RJTUVPVVQgPSAxXG5leHBvcnQgY29uc3QgQkVGT1JFX1VOTE9BRF9MT0FERVJfVElNRU9VVCA9IDIwMFxuZXhwb3J0IGNvbnN0IEJJTkRJTkdfUFJFRklYID0gXCJwaHgtXCJcbmV4cG9ydCBjb25zdCBQVVNIX1RJTUVPVVQgPSAzMDAwMFxuZXhwb3J0IGNvbnN0IExJTktfSEVBREVSID0gXCJ4LXJlcXVlc3RlZC13aXRoXCJcbmV4cG9ydCBjb25zdCBSRVNQT05TRV9VUkxfSEVBREVSID0gXCJ4LXJlc3BvbnNlLXVybFwiXG5leHBvcnQgY29uc3QgREVCT1VOQ0VfVFJJR0dFUiA9IFwiZGVib3VuY2UtdHJpZ2dlclwiXG5leHBvcnQgY29uc3QgVEhST1RUTEVEID0gXCJ0aHJvdHRsZWRcIlxuZXhwb3J0IGNvbnN0IERFQk9VTkNFX1BSRVZfS0VZID0gXCJkZWJvdW5jZS1wcmV2LWtleVwiXG5leHBvcnQgY29uc3QgREVGQVVMVFMgPSB7XG4gIGRlYm91bmNlOiAzMDAsXG4gIHRocm90dGxlOiAzMDBcbn1cblxuLy8gUmVuZGVyZWRcbmV4cG9ydCBjb25zdCBEWU5BTUlDUyA9IFwiZFwiXG5leHBvcnQgY29uc3QgU1RBVElDID0gXCJzXCJcbmV4cG9ydCBjb25zdCBST09UID0gXCJyXCJcbmV4cG9ydCBjb25zdCBDT01QT05FTlRTID0gXCJjXCJcbmV4cG9ydCBjb25zdCBFVkVOVFMgPSBcImVcIlxuZXhwb3J0IGNvbnN0IFJFUExZID0gXCJyXCJcbmV4cG9ydCBjb25zdCBUSVRMRSA9IFwidFwiXG5leHBvcnQgY29uc3QgVEVNUExBVEVTID0gXCJwXCJcbmV4cG9ydCBjb25zdCBTVFJFQU0gPSBcInN0cmVhbVwiIiwgImltcG9ydCB7XG4gIGxvZ0Vycm9yXG59IGZyb20gXCIuL3V0aWxzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW50cnlVcGxvYWRlciB7XG4gIGNvbnN0cnVjdG9yKGVudHJ5LCBjaHVua1NpemUsIGxpdmVTb2NrZXQpe1xuICAgIHRoaXMubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXRcbiAgICB0aGlzLmVudHJ5ID0gZW50cnlcbiAgICB0aGlzLm9mZnNldCA9IDBcbiAgICB0aGlzLmNodW5rU2l6ZSA9IGNodW5rU2l6ZVxuICAgIHRoaXMuY2h1bmtUaW1lciA9IG51bGxcbiAgICB0aGlzLmVycm9yZWQgPSBmYWxzZVxuICAgIHRoaXMudXBsb2FkQ2hhbm5lbCA9IGxpdmVTb2NrZXQuY2hhbm5lbChgbHZ1OiR7ZW50cnkucmVmfWAsIHt0b2tlbjogZW50cnkubWV0YWRhdGEoKX0pXG4gIH1cblxuICBlcnJvcihyZWFzb24pe1xuICAgIGlmKHRoaXMuZXJyb3JlZCl7IHJldHVybiB9XG4gICAgdGhpcy51cGxvYWRDaGFubmVsLmxlYXZlKClcbiAgICB0aGlzLmVycm9yZWQgPSB0cnVlXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuY2h1bmtUaW1lcilcbiAgICB0aGlzLmVudHJ5LmVycm9yKHJlYXNvbilcbiAgfVxuXG4gIHVwbG9hZCgpe1xuICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5vbkVycm9yKHJlYXNvbiA9PiB0aGlzLmVycm9yKHJlYXNvbikpXG4gICAgdGhpcy51cGxvYWRDaGFubmVsLmpvaW4oKVxuICAgICAgLnJlY2VpdmUoXCJva1wiLCBfZGF0YSA9PiB0aGlzLnJlYWROZXh0Q2h1bmsoKSlcbiAgICAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgcmVhc29uID0+IHRoaXMuZXJyb3IocmVhc29uKSlcbiAgfVxuXG4gIGlzRG9uZSgpeyByZXR1cm4gdGhpcy5vZmZzZXQgPj0gdGhpcy5lbnRyeS5maWxlLnNpemUgfVxuXG4gIHJlYWROZXh0Q2h1bmsoKXtcbiAgICBsZXQgcmVhZGVyID0gbmV3IHdpbmRvdy5GaWxlUmVhZGVyKClcbiAgICBsZXQgYmxvYiA9IHRoaXMuZW50cnkuZmlsZS5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5jaHVua1NpemUgKyB0aGlzLm9mZnNldClcbiAgICByZWFkZXIub25sb2FkID0gKGUpID0+IHtcbiAgICAgIGlmKGUudGFyZ2V0LmVycm9yID09PSBudWxsKXtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gZS50YXJnZXQucmVzdWx0LmJ5dGVMZW5ndGhcbiAgICAgICAgdGhpcy5wdXNoQ2h1bmsoZS50YXJnZXQucmVzdWx0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxvZ0Vycm9yKFwiUmVhZCBlcnJvcjogXCIgKyBlLnRhcmdldC5lcnJvcilcbiAgICAgIH1cbiAgICB9XG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gIH1cblxuICBwdXNoQ2h1bmsoY2h1bmspe1xuICAgIGlmKCF0aGlzLnVwbG9hZENoYW5uZWwuaXNKb2luZWQoKSl7IHJldHVybiB9XG4gICAgdGhpcy51cGxvYWRDaGFubmVsLnB1c2goXCJjaHVua1wiLCBjaHVuaylcbiAgICAgIC5yZWNlaXZlKFwib2tcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLmVudHJ5LnByb2dyZXNzKCh0aGlzLm9mZnNldCAvIHRoaXMuZW50cnkuZmlsZS5zaXplKSAqIDEwMClcbiAgICAgICAgaWYoIXRoaXMuaXNEb25lKCkpe1xuICAgICAgICAgIHRoaXMuY2h1bmtUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZWFkTmV4dENodW5rKCksIHRoaXMubGl2ZVNvY2tldC5nZXRMYXRlbmN5U2ltKCkgfHwgMClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgKHtyZWFzb259KSA9PiB0aGlzLmVycm9yKHJlYXNvbikpXG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBQSFhfVklFV19TRUxFQ1RPUlxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQgRW50cnlVcGxvYWRlciBmcm9tIFwiLi9lbnRyeV91cGxvYWRlclwiXG5cbmV4cG9ydCBsZXQgbG9nRXJyb3IgPSAobXNnLCBvYmopID0+IGNvbnNvbGUuZXJyb3IgJiYgY29uc29sZS5lcnJvcihtc2csIG9iailcblxuZXhwb3J0IGxldCBpc0NpZCA9IChjaWQpID0+IHtcbiAgbGV0IHR5cGUgPSB0eXBlb2YoY2lkKVxuICByZXR1cm4gdHlwZSA9PT0gXCJudW1iZXJcIiB8fCAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAvXigwfFsxLTldXFxkKikkLy50ZXN0KGNpZCkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3REdXBsaWNhdGVJZHMoKXtcbiAgbGV0IGlkcyA9IG5ldyBTZXQoKVxuICBsZXQgZWxlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiKltpZF1cIilcbiAgZm9yKGxldCBpID0gMCwgbGVuID0gZWxlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgIGlmKGlkcy5oYXMoZWxlbXNbaV0uaWQpKXtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYE11bHRpcGxlIElEcyBkZXRlY3RlZDogJHtlbGVtc1tpXS5pZH0uIEVuc3VyZSB1bmlxdWUgZWxlbWVudCBpZHMuYClcbiAgICB9IGVsc2Uge1xuICAgICAgaWRzLmFkZChlbGVtc1tpXS5pZClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGxldCBkZWJ1ZyA9ICh2aWV3LCBraW5kLCBtc2csIG9iaikgPT4ge1xuICBpZih2aWV3LmxpdmVTb2NrZXQuaXNEZWJ1Z0VuYWJsZWQoKSl7XG4gICAgY29uc29sZS5sb2coYCR7dmlldy5pZH0gJHtraW5kfTogJHttc2d9IC0gYCwgb2JqKVxuICB9XG59XG5cbi8vIHdyYXBzIHZhbHVlIGluIGNsb3N1cmUgb3IgcmV0dXJucyBjbG9zdXJlXG5leHBvcnQgbGV0IGNsb3N1cmUgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCIgPyB2YWwgOiBmdW5jdGlvbiAoKXsgcmV0dXJuIHZhbCB9XG5cbmV4cG9ydCBsZXQgY2xvbmUgPSAob2JqKSA9PiB7IHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpIH1cblxuZXhwb3J0IGxldCBjbG9zZXN0UGh4QmluZGluZyA9IChlbCwgYmluZGluZywgYm9yZGVyRWwpID0+IHtcbiAgZG8ge1xuICAgIGlmKGVsLm1hdGNoZXMoYFske2JpbmRpbmd9XWApICYmICFlbC5kaXNhYmxlZCl7IHJldHVybiBlbCB9XG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50IHx8IGVsLnBhcmVudE5vZGVcbiAgfSB3aGlsZShlbCAhPT0gbnVsbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSAmJiAhKChib3JkZXJFbCAmJiBib3JkZXJFbC5pc1NhbWVOb2RlKGVsKSkgfHwgZWwubWF0Y2hlcyhQSFhfVklFV19TRUxFQ1RPUikpKVxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgbGV0IGlzT2JqZWN0ID0gKG9iaikgPT4ge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgIShvYmogaW5zdGFuY2VvZiBBcnJheSlcbn1cblxuZXhwb3J0IGxldCBpc0VxdWFsT2JqID0gKG9iajEsIG9iajIpID0+IEpTT04uc3RyaW5naWZ5KG9iajEpID09PSBKU09OLnN0cmluZ2lmeShvYmoyKVxuXG5leHBvcnQgbGV0IGlzRW1wdHkgPSAob2JqKSA9PiB7XG4gIGZvcihsZXQgeCBpbiBvYmopeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgbGV0IG1heWJlID0gKGVsLCBjYWxsYmFjaykgPT4gZWwgJiYgY2FsbGJhY2soZWwpXG5cbmV4cG9ydCBsZXQgY2hhbm5lbFVwbG9hZGVyID0gZnVuY3Rpb24gKGVudHJpZXMsIG9uRXJyb3IsIHJlc3AsIGxpdmVTb2NrZXQpe1xuICBlbnRyaWVzLmZvckVhY2goZW50cnkgPT4ge1xuICAgIGxldCBlbnRyeVVwbG9hZGVyID0gbmV3IEVudHJ5VXBsb2FkZXIoZW50cnksIHJlc3AuY29uZmlnLmNodW5rX3NpemUsIGxpdmVTb2NrZXQpXG4gICAgZW50cnlVcGxvYWRlci51cGxvYWQoKVxuICB9KVxufVxuIiwgImxldCBCcm93c2VyID0ge1xuICBjYW5QdXNoU3RhdGUoKXsgcmV0dXJuICh0eXBlb2YgKGhpc3RvcnkucHVzaFN0YXRlKSAhPT0gXCJ1bmRlZmluZWRcIikgfSxcblxuICBkcm9wTG9jYWwobG9jYWxTdG9yYWdlLCBuYW1lc3BhY2UsIHN1YmtleSl7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMubG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpKVxuICB9LFxuXG4gIHVwZGF0ZUxvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXksIGluaXRpYWwsIGZ1bmMpe1xuICAgIGxldCBjdXJyZW50ID0gdGhpcy5nZXRMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5KVxuICAgIGxldCBrZXkgPSB0aGlzLmxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KVxuICAgIGxldCBuZXdWYWwgPSBjdXJyZW50ID09PSBudWxsID8gaW5pdGlhbCA6IGZ1bmMoY3VycmVudClcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KG5ld1ZhbCkpXG4gICAgcmV0dXJuIG5ld1ZhbFxuICB9LFxuXG4gIGdldExvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXkpe1xuICAgIHJldHVybiBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMubG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpKSlcbiAgfSxcblxuICB1cGRhdGVDdXJyZW50U3RhdGUoY2FsbGJhY2spe1xuICAgIGlmKCF0aGlzLmNhblB1c2hTdGF0ZSgpKXsgcmV0dXJuIH1cbiAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShjYWxsYmFjayhoaXN0b3J5LnN0YXRlIHx8IHt9KSwgXCJcIiwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gIH0sXG5cbiAgcHVzaFN0YXRlKGtpbmQsIG1ldGEsIHRvKXtcbiAgICBpZih0aGlzLmNhblB1c2hTdGF0ZSgpKXtcbiAgICAgIGlmKHRvICE9PSB3aW5kb3cubG9jYXRpb24uaHJlZil7XG4gICAgICAgIGlmKG1ldGEudHlwZSA9PSBcInJlZGlyZWN0XCIgJiYgbWV0YS5zY3JvbGwpe1xuICAgICAgICAgIC8vIElmIHdlJ3JlIHJlZGlyZWN0aW5nIHN0b3JlIHRoZSBjdXJyZW50IHNjcm9sbFkgZm9yIHRoZSBjdXJyZW50IGhpc3Rvcnkgc3RhdGUuXG4gICAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZSA9IGhpc3Rvcnkuc3RhdGUgfHwge31cbiAgICAgICAgICBjdXJyZW50U3RhdGUuc2Nyb2xsID0gbWV0YS5zY3JvbGxcbiAgICAgICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShjdXJyZW50U3RhdGUsIFwiXCIsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIG1ldGEuc2Nyb2xsIC8vIE9ubHkgc3RvcmUgdGhlIHNjcm9sbCBpbiB0aGUgcmVkaXJlY3QgY2FzZS5cbiAgICAgICAgaGlzdG9yeVtraW5kICsgXCJTdGF0ZVwiXShtZXRhLCBcIlwiLCB0byB8fCBudWxsKSAvLyBJRSB3aWxsIGNvZXJjZSB1bmRlZmluZWQgdG8gc3RyaW5nXG4gICAgICAgIGxldCBoYXNoRWwgPSB0aGlzLmdldEhhc2hUYXJnZXRFbCh3aW5kb3cubG9jYXRpb24uaGFzaClcblxuICAgICAgICBpZihoYXNoRWwpe1xuICAgICAgICAgIGhhc2hFbC5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgIH0gZWxzZSBpZihtZXRhLnR5cGUgPT09IFwicmVkaXJlY3RcIil7XG4gICAgICAgICAgd2luZG93LnNjcm9sbCgwLCAwKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVkaXJlY3QodG8pXG4gICAgfVxuICB9LFxuXG4gIHNldENvb2tpZShuYW1lLCB2YWx1ZSl7XG4gICAgZG9jdW1lbnQuY29va2llID0gYCR7bmFtZX09JHt2YWx1ZX1gXG4gIH0sXG5cbiAgZ2V0Q29va2llKG5hbWUpe1xuICAgIHJldHVybiBkb2N1bWVudC5jb29raWUucmVwbGFjZShuZXcgUmVnRXhwKGAoPzooPzpefC4qO1xccyopJHtuYW1lfVxccypcXD1cXHMqKFteO10qKS4qJCl8Xi4qJGApLCBcIiQxXCIpXG4gIH0sXG5cbiAgcmVkaXJlY3QodG9VUkwsIGZsYXNoKXtcbiAgICBpZihmbGFzaCl7IEJyb3dzZXIuc2V0Q29va2llKFwiX19waG9lbml4X2ZsYXNoX19cIiwgZmxhc2ggKyBcIjsgbWF4LWFnZT02MDAwMDsgcGF0aD0vXCIpIH1cbiAgICB3aW5kb3cubG9jYXRpb24gPSB0b1VSTFxuICB9LFxuXG4gIGxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KXsgcmV0dXJuIGAke25hbWVzcGFjZX0tJHtzdWJrZXl9YCB9LFxuXG4gIGdldEhhc2hUYXJnZXRFbChtYXliZUhhc2gpe1xuICAgIGxldCBoYXNoID0gbWF5YmVIYXNoLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDEpXG4gICAgaWYoaGFzaCA9PT0gXCJcIil7IHJldHVybiB9XG4gICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpIHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYGFbbmFtZT1cIiR7aGFzaH1cIl1gKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJyb3dzZXJcbiIsICJsZXQgQVJJQSA9IHtcbiAgZm9jdXNNYWluKCl7XG4gICAgbGV0IHRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJtYWluIGgxLCBtYWluLCBoMVwiKVxuICAgIGlmKHRhcmdldCl7XG4gICAgICBsZXQgb3JpZ1RhYkluZGV4ID0gdGFyZ2V0LnRhYkluZGV4XG4gICAgICB0YXJnZXQudGFiSW5kZXggPSAtMVxuICAgICAgdGFyZ2V0LmZvY3VzKClcbiAgICAgIHRhcmdldC50YWJJbmRleCA9IG9yaWdUYWJJbmRleFxuICAgIH1cbiAgfSxcblxuICBhbnlPZihpbnN0YW5jZSwgY2xhc3Nlcyl7IHJldHVybiBjbGFzc2VzLmZpbmQobmFtZSA9PiBpbnN0YW5jZSBpbnN0YW5jZW9mIG5hbWUpIH0sXG5cbiAgaXNGb2N1c2FibGUoZWwsIGludGVyYWN0aXZlT25seSl7XG4gICAgcmV0dXJuKFxuICAgICAgKGVsIGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQgJiYgZWwucmVsICE9PSBcImlnbm9yZVwiKSB8fFxuICAgICAgKGVsIGluc3RhbmNlb2YgSFRNTEFyZWFFbGVtZW50ICYmIGVsLmhyZWYgIT09IHVuZGVmaW5lZCkgfHxcbiAgICAgICghZWwuZGlzYWJsZWQgJiYgKHRoaXMuYW55T2YoZWwsIFtIVE1MSW5wdXRFbGVtZW50LCBIVE1MU2VsZWN0RWxlbWVudCwgSFRNTFRleHRBcmVhRWxlbWVudCwgSFRNTEJ1dHRvbkVsZW1lbnRdKSkpIHx8XG4gICAgICAoZWwgaW5zdGFuY2VvZiBIVE1MSUZyYW1lRWxlbWVudCkgfHxcbiAgICAgIChlbC50YWJJbmRleCA+IDAgfHwgKCFpbnRlcmFjdGl2ZU9ubHkgJiYgZWwuZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIikgIT09IG51bGwgJiYgZWwuZ2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIikgIT09IFwidHJ1ZVwiKSlcbiAgICApXG4gIH0sXG5cbiAgYXR0ZW1wdEZvY3VzKGVsLCBpbnRlcmFjdGl2ZU9ubHkpe1xuICAgIGlmKHRoaXMuaXNGb2N1c2FibGUoZWwsIGludGVyYWN0aXZlT25seSkpeyB0cnl7IGVsLmZvY3VzKCkgfSBjYXRjaChlKXt9IH1cbiAgICByZXR1cm4gISFkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuaXNTYW1lTm9kZShlbClcbiAgfSxcblxuICBmb2N1c0ZpcnN0SW50ZXJhY3RpdmUoZWwpe1xuICAgIGxldCBjaGlsZCA9IGVsLmZpcnN0RWxlbWVudENoaWxkXG4gICAgd2hpbGUoY2hpbGQpe1xuICAgICAgaWYodGhpcy5hdHRlbXB0Rm9jdXMoY2hpbGQsIHRydWUpIHx8IHRoaXMuZm9jdXNGaXJzdEludGVyYWN0aXZlKGNoaWxkLCB0cnVlKSl7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLm5leHRFbGVtZW50U2libGluZ1xuICAgIH1cbiAgfSxcblxuICBmb2N1c0ZpcnN0KGVsKXtcbiAgICBsZXQgY2hpbGQgPSBlbC5maXJzdEVsZW1lbnRDaGlsZFxuICAgIHdoaWxlKGNoaWxkKXtcbiAgICAgIGlmKHRoaXMuYXR0ZW1wdEZvY3VzKGNoaWxkKSB8fCB0aGlzLmZvY3VzRmlyc3QoY2hpbGQpKXtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQubmV4dEVsZW1lbnRTaWJsaW5nXG4gICAgfVxuICB9LFxuXG4gIGZvY3VzTGFzdChlbCl7XG4gICAgbGV0IGNoaWxkID0gZWwubGFzdEVsZW1lbnRDaGlsZFxuICAgIHdoaWxlKGNoaWxkKXtcbiAgICAgIGlmKHRoaXMuYXR0ZW1wdEZvY3VzKGNoaWxkKSB8fCB0aGlzLmZvY3VzTGFzdChjaGlsZCkpe1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nXG4gICAgfVxuICB9XG59XG5leHBvcnQgZGVmYXVsdCBBUklBIiwgImltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcbmltcG9ydCBBUklBIGZyb20gXCIuL2FyaWFcIlxuXG5sZXQgZm9jdXNTdGFjayA9IG51bGxcbmxldCBkZWZhdWx0X3RyYW5zaXRpb25fdGltZSA9IDIwMFxuXG5sZXQgSlMgPSB7XG4gIGV4ZWMoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGRlZmF1bHRzKXtcbiAgICBsZXQgW2RlZmF1bHRLaW5kLCBkZWZhdWx0QXJnc10gPSBkZWZhdWx0cyB8fCBbbnVsbCwge2NhbGxiYWNrOiBkZWZhdWx0cyAmJiBkZWZhdWx0cy5jYWxsYmFja31dXG4gICAgbGV0IGNvbW1hbmRzID0gcGh4RXZlbnQuY2hhckF0KDApID09PSBcIltcIiA/XG4gICAgICBKU09OLnBhcnNlKHBoeEV2ZW50KSA6IFtbZGVmYXVsdEtpbmQsIGRlZmF1bHRBcmdzXV1cblxuICAgIGNvbW1hbmRzLmZvckVhY2goKFtraW5kLCBhcmdzXSkgPT4ge1xuICAgICAgaWYoa2luZCA9PT0gZGVmYXVsdEtpbmQgJiYgZGVmYXVsdEFyZ3MuZGF0YSl7XG4gICAgICAgIGFyZ3MuZGF0YSA9IE9iamVjdC5hc3NpZ24oYXJncy5kYXRhIHx8IHt9LCBkZWZhdWx0QXJncy5kYXRhKVxuICAgICAgICBhcmdzLmNhbGxiYWNrID0gYXJncy5jYWxsYmFjayB8fCBkZWZhdWx0QXJncy5jYWxsYmFja1xuICAgICAgfVxuICAgICAgdGhpcy5maWx0ZXJUb0Vscyhzb3VyY2VFbCwgYXJncykuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIHRoaXNbYGV4ZWNfJHtraW5kfWBdKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwgYXJncylcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcblxuICBpc1Zpc2libGUoZWwpe1xuICAgIHJldHVybiAhIShlbC5vZmZzZXRXaWR0aCB8fCBlbC5vZmZzZXRIZWlnaHQgfHwgZWwuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPiAwKVxuICB9LFxuXG4gIC8vIHJldHVybnMgdHJ1ZSBpZiBhbnkgcGFydCBvZiB0aGUgZWxlbWVudCBpcyBpbnNpZGUgdGhlIHZpZXdwb3J0XG4gIGlzSW5WaWV3cG9ydChlbCl7XG4gICAgY29uc3QgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3Qgd2luZG93SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICBjb25zdCB3aW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aFxuXG4gICAgcmV0dXJuIChcbiAgICAgIHJlY3QucmlnaHQgPiAwICYmXG4gICAgICByZWN0LmJvdHRvbSA+IDAgJiZcbiAgICAgIHJlY3QubGVmdCA8IHdpbmRvd1dpZHRoICYmXG4gICAgICByZWN0LnRvcCA8IHdpbmRvd0hlaWdodFxuICAgIClcbiAgfSxcblxuICAvLyBwcml2YXRlXG5cbiAgLy8gY29tbWFuZHNcblxuICBleGVjX2V4ZWMoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7YXR0ciwgdG99KXtcbiAgICBsZXQgbm9kZXMgPSB0byA/IERPTS5hbGwoZG9jdW1lbnQsIHRvKSA6IFtzb3VyY2VFbF1cbiAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgbGV0IGVuY29kZWRKUyA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHIpXG4gICAgICBpZighZW5jb2RlZEpTKXsgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke2F0dHJ9IHRvIGNvbnRhaW4gSlMgY29tbWFuZCBvbiBcIiR7dG99XCJgKSB9XG4gICAgICB2aWV3LmxpdmVTb2NrZXQuZXhlY0pTKG5vZGUsIGVuY29kZWRKUywgZXZlbnRUeXBlKVxuICAgIH0pXG4gIH0sXG5cbiAgZXhlY19kaXNwYXRjaChldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHt0bywgZXZlbnQsIGRldGFpbCwgYnViYmxlc30pe1xuICAgIGRldGFpbCA9IGRldGFpbCB8fCB7fVxuICAgIGRldGFpbC5kaXNwYXRjaGVyID0gc291cmNlRWxcbiAgICBET00uZGlzcGF0Y2hFdmVudChlbCwgZXZlbnQsIHtkZXRhaWwsIGJ1YmJsZXN9KVxuICB9LFxuXG4gIGV4ZWNfcHVzaChldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIGFyZ3Mpe1xuICAgIGxldCB7ZXZlbnQsIGRhdGEsIHRhcmdldCwgcGFnZV9sb2FkaW5nLCBsb2FkaW5nLCB2YWx1ZSwgZGlzcGF0Y2hlciwgY2FsbGJhY2t9ID0gYXJnc1xuICAgIGxldCBwdXNoT3B0cyA9IHtsb2FkaW5nLCB2YWx1ZSwgdGFyZ2V0LCBwYWdlX2xvYWRpbmc6ICEhcGFnZV9sb2FkaW5nfVxuICAgIGxldCB0YXJnZXRTcmMgPSBldmVudFR5cGUgPT09IFwiY2hhbmdlXCIgJiYgZGlzcGF0Y2hlciA/IGRpc3BhdGNoZXIgOiBzb3VyY2VFbFxuICAgIGxldCBwaHhUYXJnZXQgPSB0YXJnZXQgfHwgdGFyZ2V0U3JjLmdldEF0dHJpYnV0ZSh2aWV3LmJpbmRpbmcoXCJ0YXJnZXRcIikpIHx8IHRhcmdldFNyY1xuICAgIHZpZXcud2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsICh0YXJnZXRWaWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgIGlmKCF0YXJnZXRWaWV3LmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gfVxuICAgICAgaWYoZXZlbnRUeXBlID09PSBcImNoYW5nZVwiKXtcbiAgICAgICAgbGV0IHtuZXdDaWQsIF90YXJnZXR9ID0gYXJnc1xuICAgICAgICBfdGFyZ2V0ID0gX3RhcmdldCB8fCAoRE9NLmlzRm9ybUlucHV0KHNvdXJjZUVsKSA/IHNvdXJjZUVsLm5hbWUgOiB1bmRlZmluZWQpXG4gICAgICAgIGlmKF90YXJnZXQpeyBwdXNoT3B0cy5fdGFyZ2V0ID0gX3RhcmdldCB9XG4gICAgICAgIHRhcmdldFZpZXcucHVzaElucHV0KHNvdXJjZUVsLCB0YXJnZXRDdHgsIG5ld0NpZCwgZXZlbnQgfHwgcGh4RXZlbnQsIHB1c2hPcHRzLCBjYWxsYmFjaylcbiAgICAgIH0gZWxzZSBpZihldmVudFR5cGUgPT09IFwic3VibWl0XCIpe1xuICAgICAgICBsZXQge3N1Ym1pdHRlcn0gPSBhcmdzXG4gICAgICAgIHRhcmdldFZpZXcuc3VibWl0Rm9ybShzb3VyY2VFbCwgdGFyZ2V0Q3R4LCBldmVudCB8fCBwaHhFdmVudCwgc3VibWl0dGVyLCBwdXNoT3B0cywgY2FsbGJhY2spXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRWaWV3LnB1c2hFdmVudChldmVudFR5cGUsIHNvdXJjZUVsLCB0YXJnZXRDdHgsIGV2ZW50IHx8IHBoeEV2ZW50LCBkYXRhLCBwdXNoT3B0cywgY2FsbGJhY2spXG4gICAgICB9XG4gICAgfSlcbiAgfSxcblxuICBleGVjX25hdmlnYXRlKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2hyZWYsIHJlcGxhY2V9KXtcbiAgICB2aWV3LmxpdmVTb2NrZXQuaGlzdG9yeVJlZGlyZWN0KGhyZWYsIHJlcGxhY2UgPyBcInJlcGxhY2VcIiA6IFwicHVzaFwiKVxuICB9LFxuXG4gIGV4ZWNfcGF0Y2goZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7aHJlZiwgcmVwbGFjZX0pe1xuICAgIHZpZXcubGl2ZVNvY2tldC5wdXNoSGlzdG9yeVBhdGNoKGhyZWYsIHJlcGxhY2UgPyBcInJlcGxhY2VcIiA6IFwicHVzaFwiLCBzb3VyY2VFbClcbiAgfSxcblxuICBleGVjX2ZvY3VzKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCl7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBBUklBLmF0dGVtcHRGb2N1cyhlbCkpXG4gIH0sXG5cbiAgZXhlY19mb2N1c19maXJzdChldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwpe1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gQVJJQS5mb2N1c0ZpcnN0SW50ZXJhY3RpdmUoZWwpIHx8IEFSSUEuZm9jdXNGaXJzdChlbCkpXG4gIH0sXG5cbiAgZXhlY19wdXNoX2ZvY3VzKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCl7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBmb2N1c1N0YWNrID0gZWwgfHwgc291cmNlRWwpXG4gIH0sXG5cbiAgZXhlY19wb3BfZm9jdXMoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsKXtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmKGZvY3VzU3RhY2speyBmb2N1c1N0YWNrLmZvY3VzKCkgfVxuICAgICAgZm9jdXNTdGFjayA9IG51bGxcbiAgICB9KVxuICB9LFxuXG4gIGV4ZWNfYWRkX2NsYXNzKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge25hbWVzLCB0cmFuc2l0aW9uLCB0aW1lfSl7XG4gICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG5hbWVzLCBbXSwgdHJhbnNpdGlvbiwgdGltZSwgdmlldylcbiAgfSxcblxuICBleGVjX3JlbW92ZV9jbGFzcyhldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtuYW1lcywgdHJhbnNpdGlvbiwgdGltZX0pe1xuICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBbXSwgbmFtZXMsIHRyYW5zaXRpb24sIHRpbWUsIHZpZXcpXG4gIH0sXG5cbiAgZXhlY190b2dnbGVfY2xhc3MoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7dG8sIG5hbWVzLCB0cmFuc2l0aW9uLCB0aW1lfSl7XG4gICAgdGhpcy50b2dnbGVDbGFzc2VzKGVsLCBuYW1lcywgdHJhbnNpdGlvbiwgdmlldylcbiAgfSxcblxuICBleGVjX3RvZ2dsZV9hdHRyKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2F0dHI6IFthdHRyLCB2YWwxLCB2YWwyXX0pe1xuICAgIGlmKGVsLmhhc0F0dHJpYnV0ZShhdHRyKSl7XG4gICAgICBpZih2YWwyICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAvLyB0b2dnbGUgYmV0d2VlbiB2YWwxIGFuZCB2YWwyXG4gICAgICAgIGlmKGVsLmdldEF0dHJpYnV0ZShhdHRyKSA9PT0gdmFsMSl7XG4gICAgICAgICAgdGhpcy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbW2F0dHIsIHZhbDJdXSwgW10pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbW2F0dHIsIHZhbDFdXSwgW10pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlbW92ZSBhdHRyXG4gICAgICAgIHRoaXMuc2V0T3JSZW1vdmVBdHRycyhlbCwgW10sIFthdHRyXSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbW2F0dHIsIHZhbDFdXSwgW10pXG4gICAgfVxuICB9LFxuXG4gIGV4ZWNfdHJhbnNpdGlvbihldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHt0aW1lLCB0cmFuc2l0aW9ufSl7XG4gICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBbXSwgdHJhbnNpdGlvbiwgdGltZSwgdmlldylcbiAgfSxcblxuICBleGVjX3RvZ2dsZShldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtkaXNwbGF5LCBpbnMsIG91dHMsIHRpbWV9KXtcbiAgICB0aGlzLnRvZ2dsZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCBpbnMsIG91dHMsIHRpbWUpXG4gIH0sXG5cbiAgZXhlY19zaG93KGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2Rpc3BsYXksIHRyYW5zaXRpb24sIHRpbWV9KXtcbiAgICB0aGlzLnNob3coZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZSlcbiAgfSxcblxuICBleGVjX2hpZGUoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7ZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZX0pe1xuICAgIHRoaXMuaGlkZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lKVxuICB9LFxuXG4gIGV4ZWNfc2V0X2F0dHIoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7YXR0cjogW2F0dHIsIHZhbF19KXtcbiAgICB0aGlzLnNldE9yUmVtb3ZlQXR0cnMoZWwsIFtbYXR0ciwgdmFsXV0sIFtdKVxuICB9LFxuXG4gIGV4ZWNfcmVtb3ZlX2F0dHIoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7YXR0cn0pe1xuICAgIHRoaXMuc2V0T3JSZW1vdmVBdHRycyhlbCwgW10sIFthdHRyXSlcbiAgfSxcblxuICAvLyB1dGlscyBmb3IgY29tbWFuZHNcblxuICBzaG93KGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUpe1xuICAgIGlmKCF0aGlzLmlzVmlzaWJsZShlbCkpe1xuICAgICAgdGhpcy50b2dnbGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgdHJhbnNpdGlvbiwgbnVsbCwgdGltZSlcbiAgICB9XG4gIH0sXG5cbiAgaGlkZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lKXtcbiAgICBpZih0aGlzLmlzVmlzaWJsZShlbCkpe1xuICAgICAgdGhpcy50b2dnbGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgbnVsbCwgdHJhbnNpdGlvbiwgdGltZSlcbiAgICB9XG4gIH0sXG5cbiAgdG9nZ2xlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIGlucywgb3V0cywgdGltZSl7XG4gICAgdGltZSA9IHRpbWUgfHwgZGVmYXVsdF90cmFuc2l0aW9uX3RpbWVcbiAgICBsZXQgW2luQ2xhc3NlcywgaW5TdGFydENsYXNzZXMsIGluRW5kQ2xhc3Nlc10gPSBpbnMgfHwgW1tdLCBbXSwgW11dXG4gICAgbGV0IFtvdXRDbGFzc2VzLCBvdXRTdGFydENsYXNzZXMsIG91dEVuZENsYXNzZXNdID0gb3V0cyB8fCBbW10sIFtdLCBbXV1cbiAgICBpZihpbkNsYXNzZXMubGVuZ3RoID4gMCB8fCBvdXRDbGFzc2VzLmxlbmd0aCA+IDApe1xuICAgICAgaWYodGhpcy5pc1Zpc2libGUoZWwpKXtcbiAgICAgICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG91dFN0YXJ0Q2xhc3NlcywgaW5DbGFzc2VzLmNvbmNhdChpblN0YXJ0Q2xhc3NlcykuY29uY2F0KGluRW5kQ2xhc3NlcykpXG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgb3V0Q2xhc3NlcywgW10pXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBvdXRFbmRDbGFzc2VzLCBvdXRTdGFydENsYXNzZXMpKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6aGlkZS1zdGFydFwiKSlcbiAgICAgICAgdmlldy50cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgW10sIG91dENsYXNzZXMuY29uY2F0KG91dEVuZENsYXNzZXMpKVxuICAgICAgICAgIERPTS5wdXRTdGlja3koZWwsIFwidG9nZ2xlXCIsIGN1cnJlbnRFbCA9PiBjdXJyZW50RWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiKVxuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OmhpZGUtZW5kXCIpKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoZXZlbnRUeXBlID09PSBcInJlbW92ZVwiKXsgcmV0dXJuIH1cbiAgICAgICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGluU3RhcnRDbGFzc2VzLCBvdXRDbGFzc2VzLmNvbmNhdChvdXRTdGFydENsYXNzZXMpLmNvbmNhdChvdXRFbmRDbGFzc2VzKSlcbiAgICAgICAgICBsZXQgc3RpY2t5RGlzcGxheSA9IGRpc3BsYXkgfHwgdGhpcy5kZWZhdWx0RGlzcGxheShlbClcbiAgICAgICAgICBET00ucHV0U3RpY2t5KGVsLCBcInRvZ2dsZVwiLCBjdXJyZW50RWwgPT4gY3VycmVudEVsLnN0eWxlLmRpc3BsYXkgPSBzdGlja3lEaXNwbGF5KVxuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGluQ2xhc3NlcywgW10pXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBpbkVuZENsYXNzZXMsIGluU3RhcnRDbGFzc2VzKSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OnNob3ctc3RhcnRcIikpXG4gICAgICAgIHZpZXcudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBpbkNsYXNzZXMuY29uY2F0KGluRW5kQ2xhc3NlcykpXG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6c2hvdy1lbmRcIikpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKHRoaXMuaXNWaXNpYmxlKGVsKSl7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OmhpZGUtc3RhcnRcIikpXG4gICAgICAgICAgRE9NLnB1dFN0aWNreShlbCwgXCJ0b2dnbGVcIiwgY3VycmVudEVsID0+IGN1cnJlbnRFbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIpXG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6aGlkZS1lbmRcIikpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LXN0YXJ0XCIpKVxuICAgICAgICAgIGxldCBzdGlja3lEaXNwbGF5ID0gZGlzcGxheSB8fCB0aGlzLmRlZmF1bHREaXNwbGF5KGVsKVxuICAgICAgICAgIERPTS5wdXRTdGlja3koZWwsIFwidG9nZ2xlXCIsIGN1cnJlbnRFbCA9PiBjdXJyZW50RWwuc3R5bGUuZGlzcGxheSA9IHN0aWNreURpc3BsYXkpXG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6c2hvdy1lbmRcIikpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHRvZ2dsZUNsYXNzZXMoZWwsIGNsYXNzZXMsIHRyYW5zaXRpb24sIHRpbWUsIHZpZXcpe1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgbGV0IFtwcmV2QWRkcywgcHJldlJlbW92ZXNdID0gRE9NLmdldFN0aWNreShlbCwgXCJjbGFzc2VzXCIsIFtbXSwgW11dKVxuICAgICAgbGV0IG5ld0FkZHMgPSBjbGFzc2VzLmZpbHRlcihuYW1lID0+IHByZXZBZGRzLmluZGV4T2YobmFtZSkgPCAwICYmICFlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSkpXG4gICAgICBsZXQgbmV3UmVtb3ZlcyA9IGNsYXNzZXMuZmlsdGVyKG5hbWUgPT4gcHJldlJlbW92ZXMuaW5kZXhPZihuYW1lKSA8IDAgJiYgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpKVxuICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG5ld0FkZHMsIG5ld1JlbW92ZXMsIHRyYW5zaXRpb24sIHRpbWUsIHZpZXcpXG4gICAgfSlcbiAgfSxcblxuICBhZGRPclJlbW92ZUNsYXNzZXMoZWwsIGFkZHMsIHJlbW92ZXMsIHRyYW5zaXRpb24sIHRpbWUsIHZpZXcpe1xuICAgIHRpbWUgPSB0aW1lIHx8IGRlZmF1bHRfdHJhbnNpdGlvbl90aW1lXG4gICAgbGV0IFt0cmFuc2l0aW9uUnVuLCB0cmFuc2l0aW9uU3RhcnQsIHRyYW5zaXRpb25FbmRdID0gdHJhbnNpdGlvbiB8fCBbW10sIFtdLCBbXV1cbiAgICBpZih0cmFuc2l0aW9uUnVuLmxlbmd0aCA+IDApe1xuICAgICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCB0cmFuc2l0aW9uU3RhcnQsIFtdLmNvbmNhdCh0cmFuc2l0aW9uUnVuKS5jb25jYXQodHJhbnNpdGlvbkVuZCkpXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCB0cmFuc2l0aW9uUnVuLCBbXSlcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCB0cmFuc2l0aW9uRW5kLCB0cmFuc2l0aW9uU3RhcnQpKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgbGV0IG9uRG9uZSA9ICgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBhZGRzLmNvbmNhdCh0cmFuc2l0aW9uRW5kKSwgcmVtb3Zlcy5jb25jYXQodHJhbnNpdGlvblJ1bikuY29uY2F0KHRyYW5zaXRpb25TdGFydCkpXG4gICAgICByZXR1cm4gdmlldy50cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSlcbiAgICB9XG5cbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGxldCBbcHJldkFkZHMsIHByZXZSZW1vdmVzXSA9IERPTS5nZXRTdGlja3koZWwsIFwiY2xhc3Nlc1wiLCBbW10sIFtdXSlcbiAgICAgIGxldCBrZWVwQWRkcyA9IGFkZHMuZmlsdGVyKG5hbWUgPT4gcHJldkFkZHMuaW5kZXhPZihuYW1lKSA8IDAgJiYgIWVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKSlcbiAgICAgIGxldCBrZWVwUmVtb3ZlcyA9IHJlbW92ZXMuZmlsdGVyKG5hbWUgPT4gcHJldlJlbW92ZXMuaW5kZXhPZihuYW1lKSA8IDAgJiYgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpKVxuICAgICAgbGV0IG5ld0FkZHMgPSBwcmV2QWRkcy5maWx0ZXIobmFtZSA9PiByZW1vdmVzLmluZGV4T2YobmFtZSkgPCAwKS5jb25jYXQoa2VlcEFkZHMpXG4gICAgICBsZXQgbmV3UmVtb3ZlcyA9IHByZXZSZW1vdmVzLmZpbHRlcihuYW1lID0+IGFkZHMuaW5kZXhPZihuYW1lKSA8IDApLmNvbmNhdChrZWVwUmVtb3ZlcylcblxuICAgICAgRE9NLnB1dFN0aWNreShlbCwgXCJjbGFzc2VzXCIsIGN1cnJlbnRFbCA9PiB7XG4gICAgICAgIGN1cnJlbnRFbC5jbGFzc0xpc3QucmVtb3ZlKC4uLm5ld1JlbW92ZXMpXG4gICAgICAgIGN1cnJlbnRFbC5jbGFzc0xpc3QuYWRkKC4uLm5ld0FkZHMpXG4gICAgICAgIHJldHVybiBbbmV3QWRkcywgbmV3UmVtb3Zlc11cbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcblxuICBzZXRPclJlbW92ZUF0dHJzKGVsLCBzZXRzLCByZW1vdmVzKXtcbiAgICBsZXQgW3ByZXZTZXRzLCBwcmV2UmVtb3Zlc10gPSBET00uZ2V0U3RpY2t5KGVsLCBcImF0dHJzXCIsIFtbXSwgW11dKVxuXG4gICAgbGV0IGFsdGVyZWRBdHRycyA9IHNldHMubWFwKChbYXR0ciwgX3ZhbF0pID0+IGF0dHIpLmNvbmNhdChyZW1vdmVzKVxuICAgIGxldCBuZXdTZXRzID0gcHJldlNldHMuZmlsdGVyKChbYXR0ciwgX3ZhbF0pID0+ICFhbHRlcmVkQXR0cnMuaW5jbHVkZXMoYXR0cikpLmNvbmNhdChzZXRzKVxuICAgIGxldCBuZXdSZW1vdmVzID0gcHJldlJlbW92ZXMuZmlsdGVyKChhdHRyKSA9PiAhYWx0ZXJlZEF0dHJzLmluY2x1ZGVzKGF0dHIpKS5jb25jYXQocmVtb3ZlcylcblxuICAgIERPTS5wdXRTdGlja3koZWwsIFwiYXR0cnNcIiwgY3VycmVudEVsID0+IHtcbiAgICAgIG5ld1JlbW92ZXMuZm9yRWFjaChhdHRyID0+IGN1cnJlbnRFbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cikpXG4gICAgICBuZXdTZXRzLmZvckVhY2goKFthdHRyLCB2YWxdKSA9PiBjdXJyZW50RWwuc2V0QXR0cmlidXRlKGF0dHIsIHZhbCkpXG4gICAgICByZXR1cm4gW25ld1NldHMsIG5ld1JlbW92ZXNdXG4gICAgfSlcbiAgfSxcblxuICBoYXNBbGxDbGFzc2VzKGVsLCBjbGFzc2VzKXsgcmV0dXJuIGNsYXNzZXMuZXZlcnkobmFtZSA9PiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSkpIH0sXG5cbiAgaXNUb2dnbGVkT3V0KGVsLCBvdXRDbGFzc2VzKXtcbiAgICByZXR1cm4gIXRoaXMuaXNWaXNpYmxlKGVsKSB8fCB0aGlzLmhhc0FsbENsYXNzZXMoZWwsIG91dENsYXNzZXMpXG4gIH0sXG5cbiAgZmlsdGVyVG9FbHMoc291cmNlRWwsIHt0b30pe1xuICAgIHJldHVybiB0byA/IERPTS5hbGwoZG9jdW1lbnQsIHRvKSA6IFtzb3VyY2VFbF1cbiAgfSxcblxuICBkZWZhdWx0RGlzcGxheShlbCl7XG4gICAgcmV0dXJuIHt0cjogXCJ0YWJsZS1yb3dcIiwgdGQ6IFwidGFibGUtY2VsbFwifVtlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCldIHx8IFwiYmxvY2tcIlxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEpTIiwgImltcG9ydCB7XG4gIENIRUNLQUJMRV9JTlBVVFMsXG4gIERFQk9VTkNFX1BSRVZfS0VZLFxuICBERUJPVU5DRV9UUklHR0VSLFxuICBGT0NVU0FCTEVfSU5QVVRTLFxuICBQSFhfQ09NUE9ORU5ULFxuICBQSFhfRVZFTlRfQ0xBU1NFUyxcbiAgUEhYX0hBU19GT0NVU0VELFxuICBQSFhfSEFTX1NVQk1JVFRFRCxcbiAgUEhYX01BSU4sXG4gIFBIWF9OT19GRUVEQkFDS19DTEFTUyxcbiAgUEhYX1BBUkVOVF9JRCxcbiAgUEhYX1BSSVZBVEUsXG4gIFBIWF9SRUYsXG4gIFBIWF9SRUZfU1JDLFxuICBQSFhfUk9PVF9JRCxcbiAgUEhYX1NFU1NJT04sXG4gIFBIWF9TVEFUSUMsXG4gIFBIWF9VUExPQURfUkVGLFxuICBQSFhfVklFV19TRUxFQ1RPUixcbiAgUEhYX1NUSUNLWSxcbiAgVEhST1RUTEVEXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBKUyBmcm9tIFwiLi9qc1wiXG5cbmltcG9ydCB7XG4gIGxvZ0Vycm9yXG59IGZyb20gXCIuL3V0aWxzXCJcblxubGV0IERPTSA9IHtcbiAgYnlJZChpZCl7IHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgfHwgbG9nRXJyb3IoYG5vIGlkIGZvdW5kIGZvciAke2lkfWApIH0sXG5cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNsYXNzTmFtZSl7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpXG4gICAgaWYoZWwuY2xhc3NMaXN0Lmxlbmd0aCA9PT0gMCl7IGVsLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpIH1cbiAgfSxcblxuICBhbGwobm9kZSwgcXVlcnksIGNhbGxiYWNrKXtcbiAgICBpZighbm9kZSl7IHJldHVybiBbXSB9XG4gICAgbGV0IGFycmF5ID0gQXJyYXkuZnJvbShub2RlLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpKVxuICAgIHJldHVybiBjYWxsYmFjayA/IGFycmF5LmZvckVhY2goY2FsbGJhY2spIDogYXJyYXlcbiAgfSxcblxuICBjaGlsZE5vZGVMZW5ndGgoaHRtbCl7XG4gICAgbGV0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpXG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbFxuICAgIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50LmNoaWxkRWxlbWVudENvdW50XG4gIH0sXG5cbiAgaXNVcGxvYWRJbnB1dChlbCl7IHJldHVybiBlbC50eXBlID09PSBcImZpbGVcIiAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpICE9PSBudWxsIH0sXG5cbiAgaXNBdXRvVXBsb2FkKGlucHV0RWwpeyByZXR1cm4gaW5wdXRFbC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXBoeC1hdXRvLXVwbG9hZFwiKSB9LFxuXG4gIGZpbmRVcGxvYWRJbnB1dHMobm9kZSl7XG4gICAgY29uc3QgZm9ybUlkID0gbm9kZS5pZFxuICAgIGNvbnN0IGlucHV0c091dHNpZGVGb3JtID0gdGhpcy5hbGwoZG9jdW1lbnQsIGBpbnB1dFt0eXBlPVwiZmlsZVwiXVske1BIWF9VUExPQURfUkVGfV1bZm9ybT1cIiR7Zm9ybUlkfVwiXWApXG4gICAgcmV0dXJuIHRoaXMuYWxsKG5vZGUsIGBpbnB1dFt0eXBlPVwiZmlsZVwiXVske1BIWF9VUExPQURfUkVGfV1gKS5jb25jYXQoaW5wdXRzT3V0c2lkZUZvcm0pXG4gIH0sXG5cbiAgZmluZENvbXBvbmVudE5vZGVMaXN0KG5vZGUsIGNpZCl7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyV2l0aGluU2FtZUxpdmVWaWV3KHRoaXMuYWxsKG5vZGUsIGBbJHtQSFhfQ09NUE9ORU5UfT1cIiR7Y2lkfVwiXWApLCBub2RlKVxuICB9LFxuXG4gIGlzUGh4RGVzdHJveWVkKG5vZGUpe1xuICAgIHJldHVybiBub2RlLmlkICYmIERPTS5wcml2YXRlKG5vZGUsIFwiZGVzdHJveWVkXCIpID8gdHJ1ZSA6IGZhbHNlXG4gIH0sXG5cbiAgd2FudHNOZXdUYWIoZSl7XG4gICAgbGV0IHdhbnRzTmV3VGFiID0gZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkgfHwgZS5tZXRhS2V5IHx8IChlLmJ1dHRvbiAmJiBlLmJ1dHRvbiA9PT0gMSlcbiAgICBsZXQgaXNEb3dubG9hZCA9IChlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50ICYmIGUudGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImRvd25sb2FkXCIpKVxuICAgIGxldCBpc1RhcmdldEJsYW5rID0gZS50YXJnZXQuaGFzQXR0cmlidXRlKFwidGFyZ2V0XCIpICYmIGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcInRhcmdldFwiKS50b0xvd2VyQ2FzZSgpID09PSBcIl9ibGFua1wiXG4gICAgcmV0dXJuIHdhbnRzTmV3VGFiIHx8IGlzVGFyZ2V0QmxhbmsgfHwgaXNEb3dubG9hZFxuICB9LFxuXG4gIGlzVW5sb2FkYWJsZUZvcm1TdWJtaXQoZSl7XG4gICAgLy8gSWdub3JlIGZvcm0gc3VibWlzc2lvbnMgaW50ZW5kZWQgdG8gY2xvc2UgYSBuYXRpdmUgPGRpYWxvZz4gZWxlbWVudFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9kaWFsb2cjdXNhZ2Vfbm90ZXNcbiAgICBsZXQgaXNEaWFsb2dTdWJtaXQgPSAoZS50YXJnZXQgJiYgZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwibWV0aG9kXCIpID09PSBcImRpYWxvZ1wiKSB8fFxuICAgICAgKGUuc3VibWl0dGVyICYmIGUuc3VibWl0dGVyLmdldEF0dHJpYnV0ZShcImZvcm1tZXRob2RcIikgPT09IFwiZGlhbG9nXCIpXG5cbiAgICBpZihpc0RpYWxvZ1N1Ym1pdCl7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICFlLmRlZmF1bHRQcmV2ZW50ZWQgJiYgIXRoaXMud2FudHNOZXdUYWIoZSlcbiAgICB9XG4gIH0sXG5cbiAgaXNOZXdQYWdlQ2xpY2soZSwgY3VycmVudExvY2F0aW9uKXtcbiAgICBsZXQgaHJlZiA9IGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQgPyBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpIDogbnVsbFxuICAgIGxldCB1cmxcblxuICAgIGlmKGUuZGVmYXVsdFByZXZlbnRlZCB8fCBocmVmID09PSBudWxsIHx8IHRoaXMud2FudHNOZXdUYWIoZSkpeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmKGhyZWYuc3RhcnRzV2l0aChcIm1haWx0bzpcIikgfHwgaHJlZi5zdGFydHNXaXRoKFwidGVsOlwiKSl7IHJldHVybiBmYWxzZSB9XG4gICAgaWYoZS50YXJnZXQuaXNDb250ZW50RWRpdGFibGUpeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHVybCA9IG5ldyBVUkwoaHJlZilcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHVybCA9IG5ldyBVUkwoaHJlZiwgY3VycmVudExvY2F0aW9uKVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIC8vIGJhZCBVUkwsIGZhbGxiYWNrIHRvIGxldCBicm93c2VyIHRyeSBpdCBhcyBleHRlcm5hbFxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKHVybC5ob3N0ID09PSBjdXJyZW50TG9jYXRpb24uaG9zdCAmJiB1cmwucHJvdG9jb2wgPT09IGN1cnJlbnRMb2NhdGlvbi5wcm90b2NvbCl7XG4gICAgICBpZih1cmwucGF0aG5hbWUgPT09IGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSAmJiB1cmwuc2VhcmNoID09PSBjdXJyZW50TG9jYXRpb24uc2VhcmNoKXtcbiAgICAgICAgcmV0dXJuIHVybC5oYXNoID09PSBcIlwiICYmICF1cmwuaHJlZi5lbmRzV2l0aChcIiNcIilcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVybC5wcm90b2NvbC5zdGFydHNXaXRoKFwiaHR0cFwiKVxuICB9LFxuXG4gIG1hcmtQaHhDaGlsZERlc3Ryb3llZChlbCl7XG4gICAgaWYodGhpcy5pc1BoeENoaWxkKGVsKSl7IGVsLnNldEF0dHJpYnV0ZShQSFhfU0VTU0lPTiwgXCJcIikgfVxuICAgIHRoaXMucHV0UHJpdmF0ZShlbCwgXCJkZXN0cm95ZWRcIiwgdHJ1ZSlcbiAgfSxcblxuICBmaW5kUGh4Q2hpbGRyZW5JbkZyYWdtZW50KGh0bWwsIHBhcmVudElkKXtcbiAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIilcbiAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sXG4gICAgcmV0dXJuIHRoaXMuZmluZFBoeENoaWxkcmVuKHRlbXBsYXRlLmNvbnRlbnQsIHBhcmVudElkKVxuICB9LFxuXG4gIGlzSWdub3JlZChlbCwgcGh4VXBkYXRlKXtcbiAgICByZXR1cm4gKGVsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpIHx8IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXVwZGF0ZVwiKSkgPT09IFwiaWdub3JlXCJcbiAgfSxcblxuICBpc1BoeFVwZGF0ZShlbCwgcGh4VXBkYXRlLCB1cGRhdGVUeXBlcyl7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiB1cGRhdGVUeXBlcy5pbmRleE9mKGVsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpKSA+PSAwXG4gIH0sXG5cbiAgZmluZFBoeFN0aWNreShlbCl7IHJldHVybiB0aGlzLmFsbChlbCwgYFske1BIWF9TVElDS1l9XWApIH0sXG5cbiAgZmluZFBoeENoaWxkcmVuKGVsLCBwYXJlbnRJZCl7XG4gICAgcmV0dXJuIHRoaXMuYWxsKGVsLCBgJHtQSFhfVklFV19TRUxFQ1RPUn1bJHtQSFhfUEFSRU5UX0lEfT1cIiR7cGFyZW50SWR9XCJdYClcbiAgfSxcblxuICBmaW5kRXhpc3RpbmdQYXJlbnRDSURzKG5vZGUsIGNpZHMpe1xuICAgIC8vIHdlIG9ubHkgd2FudCB0byBmaW5kIHBhcmVudHMgdGhhdCBleGlzdCBvbiB0aGUgcGFnZVxuICAgIC8vIGlmIGEgY2lkIGlzIG5vdCBvbiB0aGUgcGFnZSwgdGhlIG9ubHkgd2F5IGl0IGNhbiBiZSBhZGRlZCBiYWNrIHRvIHRoZSBwYWdlXG4gICAgLy8gaXMgaWYgYSBwYXJlbnQgYWRkcyBpdCBiYWNrLCB0aGVyZWZvcmUgaWYgYSBjaWQgZG9lcyBub3QgZXhpc3Qgb24gdGhlIHBhZ2UsXG4gICAgLy8gd2Ugc2hvdWxkIG5vdCB0cnkgdG8gcmVuZGVyIGl0IGJ5IGl0c2VsZiAoYmVjYXVzZSBpdCB3b3VsZCBiZSByZW5kZXJlZCB0d2ljZSxcbiAgICAvLyBvbmUgYnkgdGhlIHBhcmVudCwgYW5kIGEgc2Vjb25kIHRpbWUgYnkgaXRzZWxmKVxuICAgIGxldCBwYXJlbnRDaWRzID0gbmV3IFNldCgpXG4gICAgbGV0IGNoaWxkcmVuQ2lkcyA9IG5ldyBTZXQoKVxuXG4gICAgY2lkcy5mb3JFYWNoKGNpZCA9PiB7XG4gICAgICB0aGlzLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyh0aGlzLmFsbChub2RlLCBgWyR7UEhYX0NPTVBPTkVOVH09XCIke2NpZH1cIl1gKSwgbm9kZSkuZm9yRWFjaChwYXJlbnQgPT4ge1xuICAgICAgICBwYXJlbnRDaWRzLmFkZChjaWQpXG4gICAgICAgIHRoaXMuYWxsKHBhcmVudCwgYFske1BIWF9DT01QT05FTlR9XWApXG4gICAgICAgICAgLm1hcChlbCA9PiBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkpKVxuICAgICAgICAgIC5mb3JFYWNoKGNoaWxkQ0lEID0+IGNoaWxkcmVuQ2lkcy5hZGQoY2hpbGRDSUQpKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgY2hpbGRyZW5DaWRzLmZvckVhY2goY2hpbGRDaWQgPT4gcGFyZW50Q2lkcy5kZWxldGUoY2hpbGRDaWQpKVxuXG4gICAgcmV0dXJuIHBhcmVudENpZHNcbiAgfSxcblxuICBmaWx0ZXJXaXRoaW5TYW1lTGl2ZVZpZXcobm9kZXMsIHBhcmVudCl7XG4gICAgaWYocGFyZW50LnF1ZXJ5U2VsZWN0b3IoUEhYX1ZJRVdfU0VMRUNUT1IpKXtcbiAgICAgIHJldHVybiBub2Rlcy5maWx0ZXIoZWwgPT4gdGhpcy53aXRoaW5TYW1lTGl2ZVZpZXcoZWwsIHBhcmVudCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2Rlc1xuICAgIH1cbiAgfSxcblxuICB3aXRoaW5TYW1lTGl2ZVZpZXcobm9kZSwgcGFyZW50KXtcbiAgICB3aGlsZShub2RlID0gbm9kZS5wYXJlbnROb2RlKXtcbiAgICAgIGlmKG5vZGUuaXNTYW1lTm9kZShwYXJlbnQpKXsgcmV0dXJuIHRydWUgfVxuICAgICAgaWYobm9kZS5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pICE9PSBudWxsKXsgcmV0dXJuIGZhbHNlIH1cbiAgICB9XG4gIH0sXG5cbiAgcHJpdmF0ZShlbCwga2V5KXsgcmV0dXJuIGVsW1BIWF9QUklWQVRFXSAmJiBlbFtQSFhfUFJJVkFURV1ba2V5XSB9LFxuXG4gIGRlbGV0ZVByaXZhdGUoZWwsIGtleSl7IGVsW1BIWF9QUklWQVRFXSAmJiBkZWxldGUgKGVsW1BIWF9QUklWQVRFXVtrZXldKSB9LFxuXG4gIHB1dFByaXZhdGUoZWwsIGtleSwgdmFsdWUpe1xuICAgIGlmKCFlbFtQSFhfUFJJVkFURV0peyBlbFtQSFhfUFJJVkFURV0gPSB7fSB9XG4gICAgZWxbUEhYX1BSSVZBVEVdW2tleV0gPSB2YWx1ZVxuICB9LFxuXG4gIHVwZGF0ZVByaXZhdGUoZWwsIGtleSwgZGVmYXVsdFZhbCwgdXBkYXRlRnVuYyl7XG4gICAgbGV0IGV4aXN0aW5nID0gdGhpcy5wcml2YXRlKGVsLCBrZXkpXG4gICAgaWYoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCl7XG4gICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgdXBkYXRlRnVuYyhkZWZhdWx0VmFsKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBrZXksIHVwZGF0ZUZ1bmMoZXhpc3RpbmcpKVxuICAgIH1cbiAgfSxcblxuICBjb3B5UHJpdmF0ZXModGFyZ2V0LCBzb3VyY2Upe1xuICAgIGlmKHNvdXJjZVtQSFhfUFJJVkFURV0pe1xuICAgICAgdGFyZ2V0W1BIWF9QUklWQVRFXSA9IHNvdXJjZVtQSFhfUFJJVkFURV1cbiAgICB9XG4gIH0sXG5cbiAgcHV0VGl0bGUoc3RyKXtcbiAgICBsZXQgdGl0bGVFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0aXRsZVwiKVxuICAgIGlmKHRpdGxlRWwpe1xuICAgICAgbGV0IHtwcmVmaXgsIHN1ZmZpeH0gPSB0aXRsZUVsLmRhdGFzZXRcbiAgICAgIGRvY3VtZW50LnRpdGxlID0gYCR7cHJlZml4IHx8IFwiXCJ9JHtzdHJ9JHtzdWZmaXggfHwgXCJcIn1gXG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LnRpdGxlID0gc3RyXG4gICAgfVxuICB9LFxuXG4gIGRlYm91bmNlKGVsLCBldmVudCwgcGh4RGVib3VuY2UsIGRlZmF1bHREZWJvdW5jZSwgcGh4VGhyb3R0bGUsIGRlZmF1bHRUaHJvdHRsZSwgYXN5bmNGaWx0ZXIsIGNhbGxiYWNrKXtcbiAgICBsZXQgZGVib3VuY2UgPSBlbC5nZXRBdHRyaWJ1dGUocGh4RGVib3VuY2UpXG4gICAgbGV0IHRocm90dGxlID0gZWwuZ2V0QXR0cmlidXRlKHBoeFRocm90dGxlKVxuXG4gICAgaWYoZGVib3VuY2UgPT09IFwiXCIpeyBkZWJvdW5jZSA9IGRlZmF1bHREZWJvdW5jZSB9XG4gICAgaWYodGhyb3R0bGUgPT09IFwiXCIpeyB0aHJvdHRsZSA9IGRlZmF1bHRUaHJvdHRsZSB9XG4gICAgbGV0IHZhbHVlID0gZGVib3VuY2UgfHwgdGhyb3R0bGVcbiAgICBzd2l0Y2godmFsdWUpe1xuICAgICAgY2FzZSBudWxsOiByZXR1cm4gY2FsbGJhY2soKVxuXG4gICAgICBjYXNlIFwiYmx1clwiOlxuICAgICAgICBpZih0aGlzLm9uY2UoZWwsIFwiZGVib3VuY2UtYmx1clwiKSl7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgKCkgPT4gY2FsbGJhY2soKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGV0IHRpbWVvdXQgPSBwYXJzZUludCh2YWx1ZSlcbiAgICAgICAgbGV0IHRyaWdnZXIgPSAoKSA9PiB0aHJvdHRsZSA/IHRoaXMuZGVsZXRlUHJpdmF0ZShlbCwgVEhST1RUTEVEKSA6IGNhbGxiYWNrKClcbiAgICAgICAgbGV0IGN1cnJlbnRDeWNsZSA9IHRoaXMuaW5jQ3ljbGUoZWwsIERFQk9VTkNFX1RSSUdHRVIsIHRyaWdnZXIpXG4gICAgICAgIGlmKGlzTmFOKHRpbWVvdXQpKXsgcmV0dXJuIGxvZ0Vycm9yKGBpbnZhbGlkIHRocm90dGxlL2RlYm91bmNlIHZhbHVlOiAke3ZhbHVlfWApIH1cbiAgICAgICAgaWYodGhyb3R0bGUpe1xuICAgICAgICAgIGxldCBuZXdLZXlEb3duID0gZmFsc2VcbiAgICAgICAgICBpZihldmVudC50eXBlID09PSBcImtleWRvd25cIil7XG4gICAgICAgICAgICBsZXQgcHJldktleSA9IHRoaXMucHJpdmF0ZShlbCwgREVCT1VOQ0VfUFJFVl9LRVkpXG4gICAgICAgICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIERFQk9VTkNFX1BSRVZfS0VZLCBldmVudC5rZXkpXG4gICAgICAgICAgICBuZXdLZXlEb3duID0gcHJldktleSAhPT0gZXZlbnQua2V5XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIW5ld0tleURvd24gJiYgdGhpcy5wcml2YXRlKGVsLCBUSFJPVFRMRUQpKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgICBjb25zdCB0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmKGFzeW5jRmlsdGVyKCkpeyB0aGlzLnRyaWdnZXJDeWNsZShlbCwgREVCT1VOQ0VfVFJJR0dFUikgfVxuICAgICAgICAgICAgfSwgdGltZW91dClcbiAgICAgICAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwgVEhST1RUTEVELCB0KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmKGFzeW5jRmlsdGVyKCkpeyB0aGlzLnRyaWdnZXJDeWNsZShlbCwgREVCT1VOQ0VfVFJJR0dFUiwgY3VycmVudEN5Y2xlKSB9XG4gICAgICAgICAgfSwgdGltZW91dClcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmb3JtID0gZWwuZm9ybVxuICAgICAgICBpZihmb3JtICYmIHRoaXMub25jZShmb3JtLCBcImJpbmQtZGVib3VuY2VcIikpe1xuICAgICAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBBcnJheS5mcm9tKChuZXcgRm9ybURhdGEoZm9ybSkpLmVudHJpZXMoKSwgKFtuYW1lXSkgPT4ge1xuICAgICAgICAgICAgICBsZXQgaW5wdXQgPSBmb3JtLnF1ZXJ5U2VsZWN0b3IoYFtuYW1lPVwiJHtuYW1lfVwiXWApXG4gICAgICAgICAgICAgIHRoaXMuaW5jQ3ljbGUoaW5wdXQsIERFQk9VTkNFX1RSSUdHRVIpXG4gICAgICAgICAgICAgIHRoaXMuZGVsZXRlUHJpdmF0ZShpbnB1dCwgVEhST1RUTEVEKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMub25jZShlbCwgXCJiaW5kLWRlYm91bmNlXCIpKXtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBiZWNhdXNlIHdlIHRyaWdnZXIgdGhlIGNhbGxiYWNrIGhlcmUsXG4gICAgICAgICAgICAvLyB3ZSBhbHNvIGNsZWFyIHRoZSB0aHJvdHRsZSB0aW1lb3V0IHRvIHByZXZlbnQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAvLyBmcm9tIGJlaW5nIGNhbGxlZCBhZ2FpbiBhZnRlciB0aGUgdGltZW91dCBmaXJlc1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucHJpdmF0ZShlbCwgVEhST1RUTEVEKSlcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdHJpZ2dlckN5Y2xlKGVsLCBrZXksIGN1cnJlbnRDeWNsZSl7XG4gICAgbGV0IFtjeWNsZSwgdHJpZ2dlcl0gPSB0aGlzLnByaXZhdGUoZWwsIGtleSlcbiAgICBpZighY3VycmVudEN5Y2xlKXsgY3VycmVudEN5Y2xlID0gY3ljbGUgfVxuICAgIGlmKGN1cnJlbnRDeWNsZSA9PT0gY3ljbGUpe1xuICAgICAgdGhpcy5pbmNDeWNsZShlbCwga2V5KVxuICAgICAgdHJpZ2dlcigpXG4gICAgfVxuICB9LFxuXG4gIG9uY2UoZWwsIGtleSl7XG4gICAgaWYodGhpcy5wcml2YXRlKGVsLCBrZXkpID09PSB0cnVlKXsgcmV0dXJuIGZhbHNlIH1cbiAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgdHJ1ZSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9LFxuXG4gIGluY0N5Y2xlKGVsLCBrZXksIHRyaWdnZXIgPSBmdW5jdGlvbiAoKXsgfSl7XG4gICAgbGV0IFtjdXJyZW50Q3ljbGVdID0gdGhpcy5wcml2YXRlKGVsLCBrZXkpIHx8IFswLCB0cmlnZ2VyXVxuICAgIGN1cnJlbnRDeWNsZSsrXG4gICAgdGhpcy5wdXRQcml2YXRlKGVsLCBrZXksIFtjdXJyZW50Q3ljbGUsIHRyaWdnZXJdKVxuICAgIHJldHVybiBjdXJyZW50Q3ljbGVcbiAgfSxcblxuICBtYXliZUFkZFByaXZhdGVIb29rcyhlbCwgcGh4Vmlld3BvcnRUb3AsIHBoeFZpZXdwb3J0Qm90dG9tKXtcbiAgICBpZihlbC5oYXNBdHRyaWJ1dGUgJiYgKGVsLmhhc0F0dHJpYnV0ZShwaHhWaWV3cG9ydFRvcCkgfHwgZWwuaGFzQXR0cmlidXRlKHBoeFZpZXdwb3J0Qm90dG9tKSkpe1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1waHgtaG9va1wiLCBcIlBob2VuaXguSW5maW5pdGVTY3JvbGxcIilcbiAgICB9XG4gIH0sXG5cbiAgaXNGZWVkYmFja0NvbnRhaW5lcihlbCwgcGh4RmVlZGJhY2tGb3Ipe1xuICAgIHJldHVybiBlbC5oYXNBdHRyaWJ1dGUgJiYgZWwuaGFzQXR0cmlidXRlKHBoeEZlZWRiYWNrRm9yKVxuICB9LFxuXG4gIG1heWJlSGlkZUZlZWRiYWNrKGNvbnRhaW5lciwgZmVlZGJhY2tDb250YWluZXJzLCBwaHhGZWVkYmFja0ZvciwgcGh4RmVlZGJhY2tHcm91cCl7XG4gICAgLy8gYmVjYXVzZSB3ZSBjYW4gaGF2ZSBtdWx0aXBsZSBjb250YWluZXJzIHdpdGggdGhlIHNhbWUgcGh4RmVlZGJhY2tGb3IgdmFsdWVcbiAgICAvLyB3ZSBwZXJmb3JtIHRoZSBjaGVjayBvbmx5IG9uY2UgYW5kIHN0b3JlIHRoZSByZXN1bHQ7XG4gICAgLy8gd2Ugb2Z0ZW4gaGF2ZSBtdWx0aXBsZSBjb250YWluZXJzLCBiZWNhdXNlIHdlIHB1c2ggYm90aCBmcm9tRWwgYW5kIHRvRWwgaW4gZG9tcGF0Y2hcbiAgICAvLyB3aGVuIGEgY29udGFpbmVyIGlzIHVwZGF0ZWRcbiAgICBjb25zdCBmZWVkYmFja1Jlc3VsdHMgPSB7fVxuICAgIGZlZWRiYWNrQ29udGFpbmVycy5mb3JFYWNoKGVsID0+IHtcbiAgICAgIC8vIHNraXAgZWxlbWVudHMgdGhhdCBhcmUgbm90IGluIHRoZSBET01cbiAgICAgIGlmKCFjb250YWluZXIuY29udGFpbnMoZWwpKSByZXR1cm5cbiAgICAgIGNvbnN0IGZlZWRiYWNrID0gZWwuZ2V0QXR0cmlidXRlKHBoeEZlZWRiYWNrRm9yKVxuICAgICAgaWYoIWZlZWRiYWNrKXtcbiAgICAgICAgLy8gdGhlIGNvbnRhaW5lciBwcmV2aW91c2x5IGhhZCBwaHgtZmVlZGJhY2stZm9yLCBidXQgbm93IGl0IGRvZXNuJ3RcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBjbGFzcyBmcm9tIHRoZSBjb250YWluZXIgKGlmIGl0IGV4aXN0cylcbiAgICAgICAgSlMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBbXSwgW1BIWF9OT19GRUVEQkFDS19DTEFTU10pXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYoZmVlZGJhY2tSZXN1bHRzW2ZlZWRiYWNrXSA9PT0gdHJ1ZSl7XG4gICAgICAgIHRoaXMuaGlkZUZlZWRiYWNrKGVsKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGZlZWRiYWNrUmVzdWx0c1tmZWVkYmFja10gPSB0aGlzLnNob3VsZEhpZGVGZWVkYmFjayhjb250YWluZXIsIGZlZWRiYWNrLCBwaHhGZWVkYmFja0dyb3VwKVxuICAgICAgaWYoZmVlZGJhY2tSZXN1bHRzW2ZlZWRiYWNrXSA9PT0gdHJ1ZSl7XG4gICAgICAgIHRoaXMuaGlkZUZlZWRiYWNrKGVsKVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG5cbiAgaGlkZUZlZWRiYWNrKGNvbnRhaW5lcil7XG4gICAgSlMuYWRkT3JSZW1vdmVDbGFzc2VzKGNvbnRhaW5lciwgW1BIWF9OT19GRUVEQkFDS19DTEFTU10sIFtdKVxuICB9LFxuXG4gIHNob3VsZEhpZGVGZWVkYmFjayhjb250YWluZXIsIG5hbWVPckdyb3VwLCBwaHhGZWVkYmFja0dyb3VwKXtcbiAgICBjb25zdCBxdWVyeSA9IGBbbmFtZT1cIiR7bmFtZU9yR3JvdXB9XCJdLFxuICAgICAgICAgICAgICAgICAgIFtuYW1lPVwiJHtuYW1lT3JHcm91cH1bXVwiXSxcbiAgICAgICAgICAgICAgICAgICBbJHtwaHhGZWVkYmFja0dyb3VwfT1cIiR7bmFtZU9yR3JvdXB9XCJdYFxuICAgIGxldCBmb2N1c2VkID0gZmFsc2VcbiAgICBET00uYWxsKGNvbnRhaW5lciwgcXVlcnksIChpbnB1dCkgPT4ge1xuICAgICAgaWYodGhpcy5wcml2YXRlKGlucHV0LCBQSFhfSEFTX0ZPQ1VTRUQpIHx8IHRoaXMucHJpdmF0ZShpbnB1dCwgUEhYX0hBU19TVUJNSVRURUQpKXtcbiAgICAgICAgZm9jdXNlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiAhZm9jdXNlZFxuICB9LFxuXG4gIGZlZWRiYWNrU2VsZWN0b3IoaW5wdXQsIHBoeEZlZWRiYWNrRm9yLCBwaHhGZWVkYmFja0dyb3VwKXtcbiAgICBsZXQgcXVlcnkgPSBgWyR7cGh4RmVlZGJhY2tGb3J9PVwiJHtpbnB1dC5uYW1lfVwiXSxcbiAgICAgICAgICAgICAgICAgWyR7cGh4RmVlZGJhY2tGb3J9PVwiJHtpbnB1dC5uYW1lLnJlcGxhY2UoL1xcW1xcXSQvLCBcIlwiKX1cIl1gXG4gICAgaWYoaW5wdXQuZ2V0QXR0cmlidXRlKHBoeEZlZWRiYWNrR3JvdXApKXtcbiAgICAgIHF1ZXJ5ICs9IGAsWyR7cGh4RmVlZGJhY2tGb3J9PVwiJHtpbnB1dC5nZXRBdHRyaWJ1dGUocGh4RmVlZGJhY2tHcm91cCl9XCJdYFxuICAgIH1cbiAgICByZXR1cm4gcXVlcnlcbiAgfSxcblxuICByZXNldEZvcm0oZm9ybSwgcGh4RmVlZGJhY2tGb3IsIHBoeEZlZWRiYWNrR3JvdXApe1xuICAgIEFycmF5LmZyb20oZm9ybS5lbGVtZW50cykuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICBsZXQgcXVlcnkgPSB0aGlzLmZlZWRiYWNrU2VsZWN0b3IoaW5wdXQsIHBoeEZlZWRiYWNrRm9yLCBwaHhGZWVkYmFja0dyb3VwKVxuICAgICAgdGhpcy5kZWxldGVQcml2YXRlKGlucHV0LCBQSFhfSEFTX0ZPQ1VTRUQpXG4gICAgICB0aGlzLmRlbGV0ZVByaXZhdGUoaW5wdXQsIFBIWF9IQVNfU1VCTUlUVEVEKVxuICAgICAgdGhpcy5hbGwoZG9jdW1lbnQsIHF1ZXJ5LCBmZWVkYmFja0VsID0+IHtcbiAgICAgICAgSlMuYWRkT3JSZW1vdmVDbGFzc2VzKGZlZWRiYWNrRWwsIFtQSFhfTk9fRkVFREJBQ0tfQ0xBU1NdLCBbXSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcblxuICBzaG93RXJyb3IoaW5wdXRFbCwgcGh4RmVlZGJhY2tGb3IsIHBoeEZlZWRiYWNrR3JvdXApe1xuICAgIGlmKGlucHV0RWwubmFtZSl7XG4gICAgICBsZXQgcXVlcnkgPSB0aGlzLmZlZWRiYWNrU2VsZWN0b3IoaW5wdXRFbCwgcGh4RmVlZGJhY2tGb3IsIHBoeEZlZWRiYWNrR3JvdXApXG4gICAgICB0aGlzLmFsbChkb2N1bWVudCwgcXVlcnksIChlbCkgPT4ge1xuICAgICAgICBKUy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBbUEhYX05PX0ZFRURCQUNLX0NMQVNTXSlcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIGlzUGh4Q2hpbGQobm9kZSl7XG4gICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKFBIWF9QQVJFTlRfSUQpXG4gIH0sXG5cbiAgaXNQaHhTdGlja3kobm9kZSl7XG4gICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKFBIWF9TVElDS1kpICE9PSBudWxsXG4gIH0sXG5cbiAgaXNDaGlsZE9mQW55KGVsLCBwYXJlbnRzKXtcbiAgICByZXR1cm4gISFwYXJlbnRzLmZpbmQocGFyZW50ID0+IHBhcmVudC5jb250YWlucyhlbCkpXG4gIH0sXG5cbiAgZmlyc3RQaHhDaGlsZChlbCl7XG4gICAgcmV0dXJuIHRoaXMuaXNQaHhDaGlsZChlbCkgPyBlbCA6IHRoaXMuYWxsKGVsLCBgWyR7UEhYX1BBUkVOVF9JRH1dYClbMF1cbiAgfSxcblxuICBkaXNwYXRjaEV2ZW50KHRhcmdldCwgbmFtZSwgb3B0cyA9IHt9KXtcbiAgICBsZXQgZGVmYXVsdEJ1YmJsZSA9IHRydWVcbiAgICBsZXQgaXNVcGxvYWRUYXJnZXQgPSB0YXJnZXQubm9kZU5hbWUgPT09IFwiSU5QVVRcIiAmJiB0YXJnZXQudHlwZSA9PT0gXCJmaWxlXCJcbiAgICBpZihpc1VwbG9hZFRhcmdldCAmJiBuYW1lID09PSBcImNsaWNrXCIpe1xuICAgICAgZGVmYXVsdEJ1YmJsZSA9IGZhbHNlXG4gICAgfVxuICAgIGxldCBidWJibGVzID0gb3B0cy5idWJibGVzID09PSB1bmRlZmluZWQgPyBkZWZhdWx0QnViYmxlIDogISFvcHRzLmJ1YmJsZXNcbiAgICBsZXQgZXZlbnRPcHRzID0ge2J1YmJsZXM6IGJ1YmJsZXMsIGNhbmNlbGFibGU6IHRydWUsIGRldGFpbDogb3B0cy5kZXRhaWwgfHwge319XG4gICAgbGV0IGV2ZW50ID0gbmFtZSA9PT0gXCJjbGlja1wiID8gbmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiLCBldmVudE9wdHMpIDogbmV3IEN1c3RvbUV2ZW50KG5hbWUsIGV2ZW50T3B0cylcbiAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudClcbiAgfSxcblxuICBjbG9uZU5vZGUobm9kZSwgaHRtbCl7XG4gICAgaWYodHlwZW9mIChodG1sKSA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICByZXR1cm4gbm9kZS5jbG9uZU5vZGUodHJ1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNsb25lZCA9IG5vZGUuY2xvbmVOb2RlKGZhbHNlKVxuICAgICAgY2xvbmVkLmlubmVySFRNTCA9IGh0bWxcbiAgICAgIHJldHVybiBjbG9uZWRcbiAgICB9XG4gIH0sXG5cbiAgLy8gbWVyZ2UgYXR0cmlidXRlcyBmcm9tIHNvdXJjZSB0byB0YXJnZXRcbiAgLy8gaWYgYW4gZWxlbWVudCBpcyBpZ25vcmVkLCB3ZSBvbmx5IG1lcmdlIGRhdGEgYXR0cmlidXRlc1xuICAvLyBpbmNsdWRpbmcgcmVtb3ZpbmcgZGF0YSBhdHRyaWJ1dGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgc291cmNlXG4gIG1lcmdlQXR0cnModGFyZ2V0LCBzb3VyY2UsIG9wdHMgPSB7fSl7XG4gICAgbGV0IGV4Y2x1ZGUgPSBuZXcgU2V0KG9wdHMuZXhjbHVkZSB8fCBbXSlcbiAgICBsZXQgaXNJZ25vcmVkID0gb3B0cy5pc0lnbm9yZWRcbiAgICBsZXQgc291cmNlQXR0cnMgPSBzb3VyY2UuYXR0cmlidXRlc1xuICAgIGZvcihsZXQgaSA9IHNvdXJjZUF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcbiAgICAgIGxldCBuYW1lID0gc291cmNlQXR0cnNbaV0ubmFtZVxuICAgICAgaWYoIWV4Y2x1ZGUuaGFzKG5hbWUpKXtcbiAgICAgICAgY29uc3Qgc291cmNlVmFsdWUgPSBzb3VyY2UuZ2V0QXR0cmlidXRlKG5hbWUpXG4gICAgICAgIGlmKHRhcmdldC5nZXRBdHRyaWJ1dGUobmFtZSkgIT09IHNvdXJjZVZhbHVlICYmICghaXNJZ25vcmVkIHx8IChpc0lnbm9yZWQgJiYgbmFtZS5zdGFydHNXaXRoKFwiZGF0YS1cIikpKSl7XG4gICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShuYW1lLCBzb3VyY2VWYWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgZXhjbHVkZSB0aGUgdmFsdWUgZnJvbSBiZWluZyBtZXJnZWQgb24gZm9jdXNlZCBpbnB1dHMsIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIHVzZXIncyBpbnB1dCBzaG91bGQgYWx3YXlzIHdpbi5cbiAgICAgICAgLy8gV2UgY2FuIHN0aWxsIGFzc2lnbiBpdCBhcyBsb25nIGFzIHRoZSB2YWx1ZSBwcm9wZXJ0eSBpcyB0aGUgc2FtZSwgdGhvdWdoLlxuICAgICAgICAvLyBUaGlzIHByZXZlbnRzIGEgc2l0dWF0aW9uIHdoZXJlIHRoZSB1cGRhdGVkIGhvb2sgaXMgbm90IGJlaW5nIHRyaWdnZXJlZFxuICAgICAgICAvLyB3aGVuIGFuIGlucHV0IGlzIGJhY2sgaW4gaXRzIFwib3JpZ2luYWwgc3RhdGVcIiwgYmVjYXVzZSB0aGUgYXR0cmlidXRlXG4gICAgICAgIC8vIHdhcyBuZXZlciBjaGFuZ2VkLCBzZWU6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXhfbGl2ZV92aWV3L2lzc3Vlcy8yMTYzXG4gICAgICAgIGlmKG5hbWUgPT09IFwidmFsdWVcIiAmJiB0YXJnZXQudmFsdWUgPT09IHNvdXJjZS52YWx1ZSl7XG4gICAgICAgICAgLy8gYWN0dWFsbHkgc2V0IHRoZSB2YWx1ZSBhdHRyaWJ1dGUgdG8gc3luYyBpdCB3aXRoIHRoZSB2YWx1ZSBwcm9wZXJ0eVxuICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBzb3VyY2UuZ2V0QXR0cmlidXRlKG5hbWUpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHRhcmdldEF0dHJzID0gdGFyZ2V0LmF0dHJpYnV0ZXNcbiAgICBmb3IobGV0IGkgPSB0YXJnZXRBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG4gICAgICBsZXQgbmFtZSA9IHRhcmdldEF0dHJzW2ldLm5hbWVcbiAgICAgIGlmKGlzSWdub3JlZCl7XG4gICAgICAgIGlmKG5hbWUuc3RhcnRzV2l0aChcImRhdGEtXCIpICYmICFzb3VyY2UuaGFzQXR0cmlidXRlKG5hbWUpICYmICFbUEhYX1JFRiwgUEhYX1JFRl9TUkNdLmluY2x1ZGVzKG5hbWUpKXsgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShuYW1lKSB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZighc291cmNlLmhhc0F0dHJpYnV0ZShuYW1lKSl7IHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUobmFtZSkgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBtZXJnZUZvY3VzZWRJbnB1dCh0YXJnZXQsIHNvdXJjZSl7XG4gICAgLy8gc2tpcCBzZWxlY3RzIGJlY2F1c2UgRkYgd2lsbCByZXNldCBoaWdobGlnaHRlZCBpbmRleCBmb3IgYW55IHNldEF0dHJpYnV0ZVxuICAgIGlmKCEodGFyZ2V0IGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpKXsgRE9NLm1lcmdlQXR0cnModGFyZ2V0LCBzb3VyY2UsIHtleGNsdWRlOiBbXCJ2YWx1ZVwiXX0pIH1cblxuICAgIGlmKHNvdXJjZS5yZWFkT25seSl7XG4gICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwicmVhZG9ubHlcIiwgdHJ1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcInJlYWRvbmx5XCIpXG4gICAgfVxuICB9LFxuXG4gIGhhc1NlbGVjdGlvblJhbmdlKGVsKXtcbiAgICByZXR1cm4gZWwuc2V0U2VsZWN0aW9uUmFuZ2UgJiYgKGVsLnR5cGUgPT09IFwidGV4dFwiIHx8IGVsLnR5cGUgPT09IFwidGV4dGFyZWFcIilcbiAgfSxcblxuICByZXN0b3JlRm9jdXMoZm9jdXNlZCwgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCl7XG4gICAgaWYoZm9jdXNlZCBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50KXsgZm9jdXNlZC5mb2N1cygpIH1cbiAgICBpZighRE9NLmlzVGV4dHVhbElucHV0KGZvY3VzZWQpKXsgcmV0dXJuIH1cblxuICAgIGxldCB3YXNGb2N1c2VkID0gZm9jdXNlZC5tYXRjaGVzKFwiOmZvY3VzXCIpXG4gICAgaWYoZm9jdXNlZC5yZWFkT25seSl7IGZvY3VzZWQuYmx1cigpIH1cbiAgICBpZighd2FzRm9jdXNlZCl7IGZvY3VzZWQuZm9jdXMoKSB9XG4gICAgaWYodGhpcy5oYXNTZWxlY3Rpb25SYW5nZShmb2N1c2VkKSl7XG4gICAgICBmb2N1c2VkLnNldFNlbGVjdGlvblJhbmdlKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpXG4gICAgfVxuICB9LFxuXG4gIGlzRm9ybUlucHV0KGVsKXsgcmV0dXJuIC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhKSQvaS50ZXN0KGVsLnRhZ05hbWUpICYmIGVsLnR5cGUgIT09IFwiYnV0dG9uXCIgfSxcblxuICBzeW5jQXR0cnNUb1Byb3BzKGVsKXtcbiAgICBpZihlbCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgJiYgQ0hFQ0tBQkxFX0lOUFVUUy5pbmRleE9mKGVsLnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSkgPj0gMCl7XG4gICAgICBlbC5jaGVja2VkID0gZWwuZ2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiKSAhPT0gbnVsbFxuICAgIH1cbiAgfSxcblxuICBpc1RleHR1YWxJbnB1dChlbCl7IHJldHVybiBGT0NVU0FCTEVfSU5QVVRTLmluZGV4T2YoZWwudHlwZSkgPj0gMCB9LFxuXG4gIGlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlbCwgcGh4VHJpZ2dlckV4dGVybmFsKXtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShwaHhUcmlnZ2VyRXh0ZXJuYWwpICE9PSBudWxsXG4gIH0sXG5cbiAgc3luY1BlbmRpbmdSZWYoZnJvbUVsLCB0b0VsLCBkaXNhYmxlV2l0aCl7XG4gICAgbGV0IHJlZiA9IGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1JFRilcbiAgICBpZihyZWYgPT09IG51bGwpeyByZXR1cm4gdHJ1ZSB9XG4gICAgbGV0IHJlZlNyYyA9IGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1JFRl9TUkMpXG5cbiAgICBpZihET00uaXNGb3JtSW5wdXQoZnJvbUVsKSB8fCBmcm9tRWwuZ2V0QXR0cmlidXRlKGRpc2FibGVXaXRoKSAhPT0gbnVsbCl7XG4gICAgICBpZihET00uaXNVcGxvYWRJbnB1dChmcm9tRWwpKXsgRE9NLm1lcmdlQXR0cnMoZnJvbUVsLCB0b0VsLCB7aXNJZ25vcmVkOiB0cnVlfSkgfVxuICAgICAgRE9NLnB1dFByaXZhdGUoZnJvbUVsLCBQSFhfUkVGLCB0b0VsKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIFBIWF9FVkVOVF9DTEFTU0VTLmZvckVhY2goY2xhc3NOYW1lID0+IHtcbiAgICAgICAgZnJvbUVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpICYmIHRvRWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpXG4gICAgICB9KVxuICAgICAgdG9FbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRiwgcmVmKVxuICAgICAgdG9FbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRl9TUkMsIHJlZlNyYylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9LFxuXG4gIGNsZWFuQ2hpbGROb2Rlcyhjb250YWluZXIsIHBoeFVwZGF0ZSl7XG4gICAgaWYoRE9NLmlzUGh4VXBkYXRlKGNvbnRhaW5lciwgcGh4VXBkYXRlLCBbXCJhcHBlbmRcIiwgXCJwcmVwZW5kXCJdKSl7XG4gICAgICBsZXQgdG9SZW1vdmUgPSBbXVxuICAgICAgY29udGFpbmVyLmNoaWxkTm9kZXMuZm9yRWFjaChjaGlsZE5vZGUgPT4ge1xuICAgICAgICBpZighY2hpbGROb2RlLmlkKXtcbiAgICAgICAgICAvLyBTa2lwIHdhcm5pbmcgaWYgaXQncyBhbiBlbXB0eSB0ZXh0IG5vZGUgKGUuZy4gYSBuZXctbGluZSlcbiAgICAgICAgICBsZXQgaXNFbXB0eVRleHROb2RlID0gY2hpbGROb2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSAmJiBjaGlsZE5vZGUubm9kZVZhbHVlLnRyaW0oKSA9PT0gXCJcIlxuICAgICAgICAgIGlmKCFpc0VtcHR5VGV4dE5vZGUpe1xuICAgICAgICAgICAgbG9nRXJyb3IoXCJvbmx5IEhUTUwgZWxlbWVudCB0YWdzIHdpdGggYW4gaWQgYXJlIGFsbG93ZWQgaW5zaWRlIGNvbnRhaW5lcnMgd2l0aCBwaHgtdXBkYXRlLlxcblxcblwiICtcbiAgICAgICAgICAgICAgYHJlbW92aW5nIGlsbGVnYWwgbm9kZTogXCIkeyhjaGlsZE5vZGUub3V0ZXJIVE1MIHx8IGNoaWxkTm9kZS5ub2RlVmFsdWUpLnRyaW0oKX1cIlxcblxcbmApXG4gICAgICAgICAgfVxuICAgICAgICAgIHRvUmVtb3ZlLnB1c2goY2hpbGROb2RlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdG9SZW1vdmUuZm9yRWFjaChjaGlsZE5vZGUgPT4gY2hpbGROb2RlLnJlbW92ZSgpKVxuICAgIH1cbiAgfSxcblxuICByZXBsYWNlUm9vdENvbnRhaW5lcihjb250YWluZXIsIHRhZ05hbWUsIGF0dHJzKXtcbiAgICBsZXQgcmV0YWluZWRBdHRycyA9IG5ldyBTZXQoW1wiaWRcIiwgUEhYX1NFU1NJT04sIFBIWF9TVEFUSUMsIFBIWF9NQUlOLCBQSFhfUk9PVF9JRF0pXG4gICAgaWYoY29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpKXtcbiAgICAgIEFycmF5LmZyb20oY29udGFpbmVyLmF0dHJpYnV0ZXMpXG4gICAgICAgIC5maWx0ZXIoYXR0ciA9PiAhcmV0YWluZWRBdHRycy5oYXMoYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICAuZm9yRWFjaChhdHRyID0+IGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoYXR0ci5uYW1lKSlcblxuICAgICAgT2JqZWN0LmtleXMoYXR0cnMpXG4gICAgICAgIC5maWx0ZXIobmFtZSA9PiAhcmV0YWluZWRBdHRycy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgLmZvckVhY2goYXR0ciA9PiBjb250YWluZXIuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKSlcblxuICAgICAgcmV0dXJuIGNvbnRhaW5lclxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZXdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpXG4gICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChhdHRyID0+IG5ld0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pKVxuICAgICAgcmV0YWluZWRBdHRycy5mb3JFYWNoKGF0dHIgPT4gbmV3Q29udGFpbmVyLnNldEF0dHJpYnV0ZShhdHRyLCBjb250YWluZXIuZ2V0QXR0cmlidXRlKGF0dHIpKSlcbiAgICAgIG5ld0NvbnRhaW5lci5pbm5lckhUTUwgPSBjb250YWluZXIuaW5uZXJIVE1MXG4gICAgICBjb250YWluZXIucmVwbGFjZVdpdGgobmV3Q29udGFpbmVyKVxuICAgICAgcmV0dXJuIG5ld0NvbnRhaW5lclxuICAgIH1cbiAgfSxcblxuICBnZXRTdGlja3koZWwsIG5hbWUsIGRlZmF1bHRWYWwpe1xuICAgIGxldCBvcCA9IChET00ucHJpdmF0ZShlbCwgXCJzdGlja3lcIikgfHwgW10pLmZpbmQoKFtleGlzdGluZ05hbWUsIF0pID0+IG5hbWUgPT09IGV4aXN0aW5nTmFtZSlcbiAgICBpZihvcCl7XG4gICAgICBsZXQgW19uYW1lLCBfb3AsIHN0YXNoZWRSZXN1bHRdID0gb3BcbiAgICAgIHJldHVybiBzdGFzaGVkUmVzdWx0XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0eXBlb2YoZGVmYXVsdFZhbCkgPT09IFwiZnVuY3Rpb25cIiA/IGRlZmF1bHRWYWwoKSA6IGRlZmF1bHRWYWxcbiAgICB9XG4gIH0sXG5cbiAgZGVsZXRlU3RpY2t5KGVsLCBuYW1lKXtcbiAgICB0aGlzLnVwZGF0ZVByaXZhdGUoZWwsIFwic3RpY2t5XCIsIFtdLCBvcHMgPT4ge1xuICAgICAgcmV0dXJuIG9wcy5maWx0ZXIoKFtleGlzdGluZ05hbWUsIF9dKSA9PiBleGlzdGluZ05hbWUgIT09IG5hbWUpXG4gICAgfSlcbiAgfSxcblxuICBwdXRTdGlja3koZWwsIG5hbWUsIG9wKXtcbiAgICBsZXQgc3Rhc2hlZFJlc3VsdCA9IG9wKGVsKVxuICAgIHRoaXMudXBkYXRlUHJpdmF0ZShlbCwgXCJzdGlja3lcIiwgW10sIG9wcyA9PiB7XG4gICAgICBsZXQgZXhpc3RpbmdJbmRleCA9IG9wcy5maW5kSW5kZXgoKFtleGlzdGluZ05hbWUsIF0pID0+IG5hbWUgPT09IGV4aXN0aW5nTmFtZSlcbiAgICAgIGlmKGV4aXN0aW5nSW5kZXggPj0gMCl7XG4gICAgICAgIG9wc1tleGlzdGluZ0luZGV4XSA9IFtuYW1lLCBvcCwgc3Rhc2hlZFJlc3VsdF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wcy5wdXNoKFtuYW1lLCBvcCwgc3Rhc2hlZFJlc3VsdF0pXG4gICAgICB9XG4gICAgICByZXR1cm4gb3BzXG4gICAgfSlcbiAgfSxcblxuICBhcHBseVN0aWNreU9wZXJhdGlvbnMoZWwpe1xuICAgIGxldCBvcHMgPSBET00ucHJpdmF0ZShlbCwgXCJzdGlja3lcIilcbiAgICBpZighb3BzKXsgcmV0dXJuIH1cblxuICAgIG9wcy5mb3JFYWNoKChbbmFtZSwgb3AsIF9zdGFzaGVkXSkgPT4gdGhpcy5wdXRTdGlja3koZWwsIG5hbWUsIG9wKSlcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBET01cbiIsICJpbXBvcnQge1xuICBQSFhfQUNUSVZFX0VOVFJZX1JFRlMsXG4gIFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCxcbiAgUEhYX1BSRUZMSUdIVEVEX1JFRlNcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgY2hhbm5lbFVwbG9hZGVyLFxuICBsb2dFcnJvclxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBMaXZlVXBsb2FkZXIgZnJvbSBcIi4vbGl2ZV91cGxvYWRlclwiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVwbG9hZEVudHJ5IHtcbiAgc3RhdGljIGlzQWN0aXZlKGZpbGVFbCwgZmlsZSl7XG4gICAgbGV0IGlzTmV3ID0gZmlsZS5fcGh4UmVmID09PSB1bmRlZmluZWRcbiAgICBsZXQgYWN0aXZlUmVmcyA9IGZpbGVFbC5nZXRBdHRyaWJ1dGUoUEhYX0FDVElWRV9FTlRSWV9SRUZTKS5zcGxpdChcIixcIilcbiAgICBsZXQgaXNBY3RpdmUgPSBhY3RpdmVSZWZzLmluZGV4T2YoTGl2ZVVwbG9hZGVyLmdlbkZpbGVSZWYoZmlsZSkpID49IDBcbiAgICByZXR1cm4gZmlsZS5zaXplID4gMCAmJiAoaXNOZXcgfHwgaXNBY3RpdmUpXG4gIH1cblxuICBzdGF0aWMgaXNQcmVmbGlnaHRlZChmaWxlRWwsIGZpbGUpe1xuICAgIGxldCBwcmVmbGlnaHRlZFJlZnMgPSBmaWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9QUkVGTElHSFRFRF9SRUZTKS5zcGxpdChcIixcIilcbiAgICBsZXQgaXNQcmVmbGlnaHRlZCA9IHByZWZsaWdodGVkUmVmcy5pbmRleE9mKExpdmVVcGxvYWRlci5nZW5GaWxlUmVmKGZpbGUpKSA+PSAwXG4gICAgcmV0dXJuIGlzUHJlZmxpZ2h0ZWQgJiYgdGhpcy5pc0FjdGl2ZShmaWxlRWwsIGZpbGUpXG4gIH1cblxuICBzdGF0aWMgaXNQcmVmbGlnaHRJblByb2dyZXNzKGZpbGUpe1xuICAgIHJldHVybiBmaWxlLl9wcmVmbGlnaHRJblByb2dyZXNzID09PSB0cnVlXG4gIH1cblxuICBzdGF0aWMgbWFya1ByZWZsaWdodEluUHJvZ3Jlc3MoZmlsZSl7XG4gICAgZmlsZS5fcHJlZmxpZ2h0SW5Qcm9ncmVzcyA9IHRydWVcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGZpbGVFbCwgZmlsZSwgdmlldywgYXV0b1VwbG9hZCl7XG4gICAgdGhpcy5yZWYgPSBMaXZlVXBsb2FkZXIuZ2VuRmlsZVJlZihmaWxlKVxuICAgIHRoaXMuZmlsZUVsID0gZmlsZUVsXG4gICAgdGhpcy5maWxlID0gZmlsZVxuICAgIHRoaXMudmlldyA9IHZpZXdcbiAgICB0aGlzLm1ldGEgPSBudWxsXG4gICAgdGhpcy5faXNDYW5jZWxsZWQgPSBmYWxzZVxuICAgIHRoaXMuX2lzRG9uZSA9IGZhbHNlXG4gICAgdGhpcy5fcHJvZ3Jlc3MgPSAwXG4gICAgdGhpcy5fbGFzdFByb2dyZXNzU2VudCA9IC0xXG4gICAgdGhpcy5fb25Eb25lID0gZnVuY3Rpb24oKXsgfVxuICAgIHRoaXMuX29uRWxVcGRhdGVkID0gdGhpcy5vbkVsVXBkYXRlZC5iaW5kKHRoaXMpXG4gICAgdGhpcy5maWxlRWwuYWRkRXZlbnRMaXN0ZW5lcihQSFhfTElWRV9GSUxFX1VQREFURUQsIHRoaXMuX29uRWxVcGRhdGVkKVxuICAgIHRoaXMuYXV0b1VwbG9hZCA9IGF1dG9VcGxvYWRcbiAgfVxuXG4gIG1ldGFkYXRhKCl7IHJldHVybiB0aGlzLm1ldGEgfVxuXG4gIHByb2dyZXNzKHByb2dyZXNzKXtcbiAgICB0aGlzLl9wcm9ncmVzcyA9IE1hdGguZmxvb3IocHJvZ3Jlc3MpXG4gICAgaWYodGhpcy5fcHJvZ3Jlc3MgPiB0aGlzLl9sYXN0UHJvZ3Jlc3NTZW50KXtcbiAgICAgIGlmKHRoaXMuX3Byb2dyZXNzID49IDEwMCl7XG4gICAgICAgIHRoaXMuX3Byb2dyZXNzID0gMTAwXG4gICAgICAgIHRoaXMuX2xhc3RQcm9ncmVzc1NlbnQgPSAxMDBcbiAgICAgICAgdGhpcy5faXNEb25lID0gdHJ1ZVxuICAgICAgICB0aGlzLnZpZXcucHVzaEZpbGVQcm9ncmVzcyh0aGlzLmZpbGVFbCwgdGhpcy5yZWYsIDEwMCwgKCkgPT4ge1xuICAgICAgICAgIExpdmVVcGxvYWRlci51bnRyYWNrRmlsZSh0aGlzLmZpbGVFbCwgdGhpcy5maWxlKVxuICAgICAgICAgIHRoaXMuX29uRG9uZSgpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3NTZW50ID0gdGhpcy5fcHJvZ3Jlc3NcbiAgICAgICAgdGhpcy52aWV3LnB1c2hGaWxlUHJvZ3Jlc3ModGhpcy5maWxlRWwsIHRoaXMucmVmLCB0aGlzLl9wcm9ncmVzcylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc0NhbmNlbGxlZCgpeyByZXR1cm4gdGhpcy5faXNDYW5jZWxsZWQgfVxuXG4gIGNhbmNlbCgpe1xuICAgIHRoaXMuZmlsZS5fcHJlZmxpZ2h0SW5Qcm9ncmVzcyA9IGZhbHNlXG4gICAgdGhpcy5faXNDYW5jZWxsZWQgPSB0cnVlXG4gICAgdGhpcy5faXNEb25lID0gdHJ1ZVxuICAgIHRoaXMuX29uRG9uZSgpXG4gIH1cblxuICBpc0RvbmUoKXsgcmV0dXJuIHRoaXMuX2lzRG9uZSB9XG5cbiAgZXJyb3IocmVhc29uID0gXCJmYWlsZWRcIil7XG4gICAgdGhpcy5maWxlRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihQSFhfTElWRV9GSUxFX1VQREFURUQsIHRoaXMuX29uRWxVcGRhdGVkKVxuICAgIHRoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLCB0aGlzLnJlZiwge2Vycm9yOiByZWFzb259KVxuICAgIGlmKCF0aGlzLmlzQXV0b1VwbG9hZCgpKXsgTGl2ZVVwbG9hZGVyLmNsZWFyRmlsZXModGhpcy5maWxlRWwpIH1cbiAgfVxuXG4gIGlzQXV0b1VwbG9hZCgpeyByZXR1cm4gdGhpcy5hdXRvVXBsb2FkIH1cblxuICAvL3ByaXZhdGVcblxuICBvbkRvbmUoY2FsbGJhY2spe1xuICAgIHRoaXMuX29uRG9uZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuZmlsZUVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoUEhYX0xJVkVfRklMRV9VUERBVEVELCB0aGlzLl9vbkVsVXBkYXRlZClcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH1cblxuICBvbkVsVXBkYXRlZCgpe1xuICAgIGxldCBhY3RpdmVSZWZzID0gdGhpcy5maWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUykuc3BsaXQoXCIsXCIpXG4gICAgaWYoYWN0aXZlUmVmcy5pbmRleE9mKHRoaXMucmVmKSA9PT0gLTEpe1xuICAgICAgTGl2ZVVwbG9hZGVyLnVudHJhY2tGaWxlKHRoaXMuZmlsZUVsLCB0aGlzLmZpbGUpXG4gICAgICB0aGlzLmNhbmNlbCgpXG4gICAgfVxuICB9XG5cbiAgdG9QcmVmbGlnaHRQYXlsb2FkKCl7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhc3RfbW9kaWZpZWQ6IHRoaXMuZmlsZS5sYXN0TW9kaWZpZWQsXG4gICAgICBuYW1lOiB0aGlzLmZpbGUubmFtZSxcbiAgICAgIHJlbGF0aXZlX3BhdGg6IHRoaXMuZmlsZS53ZWJraXRSZWxhdGl2ZVBhdGgsXG4gICAgICBzaXplOiB0aGlzLmZpbGUuc2l6ZSxcbiAgICAgIHR5cGU6IHRoaXMuZmlsZS50eXBlLFxuICAgICAgcmVmOiB0aGlzLnJlZixcbiAgICAgIG1ldGE6IHR5cGVvZih0aGlzLmZpbGUubWV0YSkgPT09IFwiZnVuY3Rpb25cIiA/IHRoaXMuZmlsZS5tZXRhKCkgOiB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICB1cGxvYWRlcih1cGxvYWRlcnMpe1xuICAgIGlmKHRoaXMubWV0YS51cGxvYWRlcil7XG4gICAgICBsZXQgY2FsbGJhY2sgPSB1cGxvYWRlcnNbdGhpcy5tZXRhLnVwbG9hZGVyXSB8fCBsb2dFcnJvcihgbm8gdXBsb2FkZXIgY29uZmlndXJlZCBmb3IgJHt0aGlzLm1ldGEudXBsb2FkZXJ9YClcbiAgICAgIHJldHVybiB7bmFtZTogdGhpcy5tZXRhLnVwbG9hZGVyLCBjYWxsYmFjazogY2FsbGJhY2t9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7bmFtZTogXCJjaGFubmVsXCIsIGNhbGxiYWNrOiBjaGFubmVsVXBsb2FkZXJ9XG4gICAgfVxuICB9XG5cbiAgemlwUG9zdEZsaWdodChyZXNwKXtcbiAgICB0aGlzLm1ldGEgPSByZXNwLmVudHJpZXNbdGhpcy5yZWZdXG4gICAgaWYoIXRoaXMubWV0YSl7IGxvZ0Vycm9yKGBubyBwcmVmbGlnaHQgdXBsb2FkIHJlc3BvbnNlIHJldHVybmVkIHdpdGggcmVmICR7dGhpcy5yZWZ9YCwge2lucHV0OiB0aGlzLmZpbGVFbCwgcmVzcG9uc2U6IHJlc3B9KSB9XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBQSFhfRE9ORV9SRUZTLFxuICBQSFhfUFJFRkxJR0hURURfUkVGUyxcbiAgUEhYX1VQTE9BRF9SRUZcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5pbXBvcnQgVXBsb2FkRW50cnkgZnJvbSBcIi4vdXBsb2FkX2VudHJ5XCJcblxubGV0IGxpdmVVcGxvYWRlckZpbGVSZWYgPSAwXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpdmVVcGxvYWRlciB7XG4gIHN0YXRpYyBnZW5GaWxlUmVmKGZpbGUpe1xuICAgIGxldCByZWYgPSBmaWxlLl9waHhSZWZcbiAgICBpZihyZWYgIT09IHVuZGVmaW5lZCl7XG4gICAgICByZXR1cm4gcmVmXG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGUuX3BoeFJlZiA9IChsaXZlVXBsb2FkZXJGaWxlUmVmKyspLnRvU3RyaW5nKClcbiAgICAgIHJldHVybiBmaWxlLl9waHhSZWZcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0RW50cnlEYXRhVVJMKGlucHV0RWwsIHJlZiwgY2FsbGJhY2spe1xuICAgIGxldCBmaWxlID0gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKS5maW5kKGZpbGUgPT4gdGhpcy5nZW5GaWxlUmVmKGZpbGUpID09PSByZWYpXG4gICAgY2FsbGJhY2soVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKSlcbiAgfVxuXG4gIHN0YXRpYyBoYXNVcGxvYWRzSW5Qcm9ncmVzcyhmb3JtRWwpe1xuICAgIGxldCBhY3RpdmUgPSAwXG4gICAgRE9NLmZpbmRVcGxvYWRJbnB1dHMoZm9ybUVsKS5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgIGlmKGlucHV0LmdldEF0dHJpYnV0ZShQSFhfUFJFRkxJR0hURURfUkVGUykgIT09IGlucHV0LmdldEF0dHJpYnV0ZShQSFhfRE9ORV9SRUZTKSl7XG4gICAgICAgIGFjdGl2ZSsrXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gYWN0aXZlID4gMFxuICB9XG5cbiAgc3RhdGljIHNlcmlhbGl6ZVVwbG9hZHMoaW5wdXRFbCl7XG4gICAgbGV0IGZpbGVzID0gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKVxuICAgIGxldCBmaWxlRGF0YSA9IHt9XG4gICAgZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgIGxldCBlbnRyeSA9IHtwYXRoOiBpbnB1dEVsLm5hbWV9XG4gICAgICBsZXQgdXBsb2FkUmVmID0gaW5wdXRFbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpXG4gICAgICBmaWxlRGF0YVt1cGxvYWRSZWZdID0gZmlsZURhdGFbdXBsb2FkUmVmXSB8fCBbXVxuICAgICAgZW50cnkucmVmID0gdGhpcy5nZW5GaWxlUmVmKGZpbGUpXG4gICAgICBlbnRyeS5sYXN0X21vZGlmaWVkID0gZmlsZS5sYXN0TW9kaWZpZWRcbiAgICAgIGVudHJ5Lm5hbWUgPSBmaWxlLm5hbWUgfHwgZW50cnkucmVmXG4gICAgICBlbnRyeS5yZWxhdGl2ZV9wYXRoID0gZmlsZS53ZWJraXRSZWxhdGl2ZVBhdGhcbiAgICAgIGVudHJ5LnR5cGUgPSBmaWxlLnR5cGVcbiAgICAgIGVudHJ5LnNpemUgPSBmaWxlLnNpemVcbiAgICAgIGlmKHR5cGVvZihmaWxlLm1ldGEpID09PSBcImZ1bmN0aW9uXCIpeyBlbnRyeS5tZXRhID0gZmlsZS5tZXRhKCkgfVxuICAgICAgZmlsZURhdGFbdXBsb2FkUmVmXS5wdXNoKGVudHJ5KVxuICAgIH0pXG4gICAgcmV0dXJuIGZpbGVEYXRhXG4gIH1cblxuICBzdGF0aWMgY2xlYXJGaWxlcyhpbnB1dEVsKXtcbiAgICBpbnB1dEVsLnZhbHVlID0gbnVsbFxuICAgIGlucHV0RWwucmVtb3ZlQXR0cmlidXRlKFBIWF9VUExPQURfUkVGKVxuICAgIERPTS5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgW10pXG4gIH1cblxuICBzdGF0aWMgdW50cmFja0ZpbGUoaW5wdXRFbCwgZmlsZSl7XG4gICAgRE9NLnB1dFByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiLCBET00ucHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIpLmZpbHRlcihmID0+ICFPYmplY3QuaXMoZiwgZmlsZSkpKVxuICB9XG5cbiAgc3RhdGljIHRyYWNrRmlsZXMoaW5wdXRFbCwgZmlsZXMsIGRhdGFUcmFuc2Zlcil7XG4gICAgaWYoaW5wdXRFbC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSAhPT0gbnVsbCl7XG4gICAgICBsZXQgbmV3RmlsZXMgPSBmaWxlcy5maWx0ZXIoZmlsZSA9PiAhdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKS5maW5kKGYgPT4gT2JqZWN0LmlzKGYsIGZpbGUpKSlcbiAgICAgIERPTS51cGRhdGVQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgW10sIChleGlzdGluZykgPT4gZXhpc3RpbmcuY29uY2F0KG5ld0ZpbGVzKSlcbiAgICAgIGlucHV0RWwudmFsdWUgPSBudWxsXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc2V0IGlucHV0RWwgZmlsZXMgdG8gYWxpZ24gb3V0cHV0IHdpdGggcHJvZ3JhbW1hdGljIGNoYW5nZXMgKGkuZS4gZHJhZyBhbmQgZHJvcClcbiAgICAgIGlmKGRhdGFUcmFuc2ZlciAmJiBkYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoID4gMCl7IGlucHV0RWwuZmlsZXMgPSBkYXRhVHJhbnNmZXIuZmlsZXMgfVxuICAgICAgRE9NLnB1dFByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiLCBmaWxlcylcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgYWN0aXZlRmlsZUlucHV0cyhmb3JtRWwpe1xuICAgIGxldCBmaWxlSW5wdXRzID0gRE9NLmZpbmRVcGxvYWRJbnB1dHMoZm9ybUVsKVxuICAgIHJldHVybiBBcnJheS5mcm9tKGZpbGVJbnB1dHMpLmZpbHRlcihlbCA9PiBlbC5maWxlcyAmJiB0aGlzLmFjdGl2ZUZpbGVzKGVsKS5sZW5ndGggPiAwKVxuICB9XG5cbiAgc3RhdGljIGFjdGl2ZUZpbGVzKGlucHV0KXtcbiAgICByZXR1cm4gKERPTS5wcml2YXRlKGlucHV0LCBcImZpbGVzXCIpIHx8IFtdKS5maWx0ZXIoZiA9PiBVcGxvYWRFbnRyeS5pc0FjdGl2ZShpbnB1dCwgZikpXG4gIH1cblxuICBzdGF0aWMgaW5wdXRzQXdhaXRpbmdQcmVmbGlnaHQoZm9ybUVsKXtcbiAgICBsZXQgZmlsZUlucHV0cyA9IERPTS5maW5kVXBsb2FkSW5wdXRzKGZvcm1FbClcbiAgICByZXR1cm4gQXJyYXkuZnJvbShmaWxlSW5wdXRzKS5maWx0ZXIoaW5wdXQgPT4gdGhpcy5maWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0KS5sZW5ndGggPiAwKVxuICB9XG5cbiAgc3RhdGljIGZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoaW5wdXQpe1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZUZpbGVzKGlucHV0KS5maWx0ZXIoZiA9PiAhVXBsb2FkRW50cnkuaXNQcmVmbGlnaHRlZChpbnB1dCwgZikgJiYgIVVwbG9hZEVudHJ5LmlzUHJlZmxpZ2h0SW5Qcm9ncmVzcyhmKSlcbiAgfVxuXG4gIHN0YXRpYyBtYXJrUHJlZmxpZ2h0SW5Qcm9ncmVzcyhlbnRyaWVzKXtcbiAgICBlbnRyaWVzLmZvckVhY2goZW50cnkgPT4gVXBsb2FkRW50cnkubWFya1ByZWZsaWdodEluUHJvZ3Jlc3MoZW50cnkuZmlsZSkpXG4gIH1cblxuICBjb25zdHJ1Y3RvcihpbnB1dEVsLCB2aWV3LCBvbkNvbXBsZXRlKXtcbiAgICB0aGlzLmF1dG9VcGxvYWQgPSBET00uaXNBdXRvVXBsb2FkKGlucHV0RWwpXG4gICAgdGhpcy52aWV3ID0gdmlld1xuICAgIHRoaXMub25Db21wbGV0ZSA9IG9uQ29tcGxldGVcbiAgICB0aGlzLl9lbnRyaWVzID1cbiAgICAgIEFycmF5LmZyb20oTGl2ZVVwbG9hZGVyLmZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoaW5wdXRFbCkgfHwgW10pXG4gICAgICAgIC5tYXAoZmlsZSA9PiBuZXcgVXBsb2FkRW50cnkoaW5wdXRFbCwgZmlsZSwgdmlldywgdGhpcy5hdXRvVXBsb2FkKSlcblxuICAgIC8vIHByZXZlbnQgc2VuZGluZyBkdXBsaWNhdGUgcHJlZmxpZ2h0IHJlcXVlc3RzXG4gICAgTGl2ZVVwbG9hZGVyLm1hcmtQcmVmbGlnaHRJblByb2dyZXNzKHRoaXMuX2VudHJpZXMpXG5cbiAgICB0aGlzLm51bUVudHJpZXNJblByb2dyZXNzID0gdGhpcy5fZW50cmllcy5sZW5ndGhcbiAgfVxuXG4gIGlzQXV0b1VwbG9hZCgpeyByZXR1cm4gdGhpcy5hdXRvVXBsb2FkIH1cblxuICBlbnRyaWVzKCl7IHJldHVybiB0aGlzLl9lbnRyaWVzIH1cblxuICBpbml0QWRhcHRlclVwbG9hZChyZXNwLCBvbkVycm9yLCBsaXZlU29ja2V0KXtcbiAgICB0aGlzLl9lbnRyaWVzID1cbiAgICAgIHRoaXMuX2VudHJpZXMubWFwKGVudHJ5ID0+IHtcbiAgICAgICAgaWYoZW50cnkuaXNDYW5jZWxsZWQoKSl7XG4gICAgICAgICAgdGhpcy5udW1FbnRyaWVzSW5Qcm9ncmVzcy0tXG4gICAgICAgICAgaWYodGhpcy5udW1FbnRyaWVzSW5Qcm9ncmVzcyA9PT0gMCl7IHRoaXMub25Db21wbGV0ZSgpIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbnRyeS56aXBQb3N0RmxpZ2h0KHJlc3ApXG4gICAgICAgICAgZW50cnkub25Eb25lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3MtLVxuICAgICAgICAgICAgaWYodGhpcy5udW1FbnRyaWVzSW5Qcm9ncmVzcyA9PT0gMCl7IHRoaXMub25Db21wbGV0ZSgpIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeVxuICAgICAgfSlcblxuICAgIGxldCBncm91cGVkRW50cmllcyA9IHRoaXMuX2VudHJpZXMucmVkdWNlKChhY2MsIGVudHJ5KSA9PiB7XG4gICAgICBpZighZW50cnkubWV0YSl7IHJldHVybiBhY2MgfVxuICAgICAgbGV0IHtuYW1lLCBjYWxsYmFja30gPSBlbnRyeS51cGxvYWRlcihsaXZlU29ja2V0LnVwbG9hZGVycylcbiAgICAgIGFjY1tuYW1lXSA9IGFjY1tuYW1lXSB8fCB7Y2FsbGJhY2s6IGNhbGxiYWNrLCBlbnRyaWVzOiBbXX1cbiAgICAgIGFjY1tuYW1lXS5lbnRyaWVzLnB1c2goZW50cnkpXG4gICAgICByZXR1cm4gYWNjXG4gICAgfSwge30pXG5cbiAgICBmb3IobGV0IG5hbWUgaW4gZ3JvdXBlZEVudHJpZXMpe1xuICAgICAgbGV0IHtjYWxsYmFjaywgZW50cmllc30gPSBncm91cGVkRW50cmllc1tuYW1lXVxuICAgICAgY2FsbGJhY2soZW50cmllcywgb25FcnJvciwgcmVzcCwgbGl2ZVNvY2tldClcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBQSFhfQUNUSVZFX0VOVFJZX1JFRlMsXG4gIFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCxcbiAgUEhYX1BSRUZMSUdIVEVEX1JFRlMsXG4gIFBIWF9VUExPQURfUkVGXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBMaXZlVXBsb2FkZXIgZnJvbSBcIi4vbGl2ZV91cGxvYWRlclwiXG5pbXBvcnQgQVJJQSBmcm9tIFwiLi9hcmlhXCJcblxubGV0IEhvb2tzID0ge1xuICBMaXZlRmlsZVVwbG9hZDoge1xuICAgIGFjdGl2ZVJlZnMoKXsgcmV0dXJuIHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUykgfSxcblxuICAgIHByZWZsaWdodGVkUmVmcygpeyByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1BSRUZMSUdIVEVEX1JFRlMpIH0sXG5cbiAgICBtb3VudGVkKCl7IHRoaXMucHJlZmxpZ2h0ZWRXYXMgPSB0aGlzLnByZWZsaWdodGVkUmVmcygpIH0sXG5cbiAgICB1cGRhdGVkKCl7XG4gICAgICBsZXQgbmV3UHJlZmxpZ2h0cyA9IHRoaXMucHJlZmxpZ2h0ZWRSZWZzKClcbiAgICAgIGlmKHRoaXMucHJlZmxpZ2h0ZWRXYXMgIT09IG5ld1ByZWZsaWdodHMpe1xuICAgICAgICB0aGlzLnByZWZsaWdodGVkV2FzID0gbmV3UHJlZmxpZ2h0c1xuICAgICAgICBpZihuZXdQcmVmbGlnaHRzID09PSBcIlwiKXtcbiAgICAgICAgICB0aGlzLl9fdmlldy5jYW5jZWxTdWJtaXQodGhpcy5lbC5mb3JtKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKHRoaXMuYWN0aXZlUmVmcygpID09PSBcIlwiKXsgdGhpcy5lbC52YWx1ZSA9IG51bGwgfVxuICAgICAgdGhpcy5lbC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChQSFhfTElWRV9GSUxFX1VQREFURUQpKVxuICAgIH1cbiAgfSxcblxuICBMaXZlSW1nUHJldmlldzoge1xuICAgIG1vdW50ZWQoKXtcbiAgICAgIHRoaXMucmVmID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1lbnRyeS1yZWZcIilcbiAgICAgIHRoaXMuaW5wdXRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSlcbiAgICAgIExpdmVVcGxvYWRlci5nZXRFbnRyeURhdGFVUkwodGhpcy5pbnB1dEVsLCB0aGlzLnJlZiwgdXJsID0+IHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmxcbiAgICAgICAgdGhpcy5lbC5zcmMgPSB1cmxcbiAgICAgIH0pXG4gICAgfSxcbiAgICBkZXN0cm95ZWQoKXtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy51cmwpXG4gICAgfVxuICB9LFxuICBGb2N1c1dyYXA6IHtcbiAgICBtb3VudGVkKCl7XG4gICAgICB0aGlzLmZvY3VzU3RhcnQgPSB0aGlzLmVsLmZpcnN0RWxlbWVudENoaWxkXG4gICAgICB0aGlzLmZvY3VzRW5kID0gdGhpcy5lbC5sYXN0RWxlbWVudENoaWxkXG4gICAgICB0aGlzLmZvY3VzU3RhcnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsICgpID0+IEFSSUEuZm9jdXNMYXN0KHRoaXMuZWwpKVxuICAgICAgdGhpcy5mb2N1c0VuZC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgKCkgPT4gQVJJQS5mb2N1c0ZpcnN0KHRoaXMuZWwpKVxuICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKFwicGh4OnNob3ctZW5kXCIsICgpID0+IHRoaXMuZWwuZm9jdXMoKSlcbiAgICAgIGlmKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWwpLmRpc3BsYXkgIT09IFwibm9uZVwiKXtcbiAgICAgICAgQVJJQS5mb2N1c0ZpcnN0KHRoaXMuZWwpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmxldCBmaW5kU2Nyb2xsQ29udGFpbmVyID0gKGVsKSA9PiB7XG4gIGlmKFtcInNjcm9sbFwiLCBcImF1dG9cIl0uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKGVsKS5vdmVyZmxvd1kpID49IDApIHJldHVybiBlbFxuICBpZihkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPT09IGVsKSByZXR1cm4gbnVsbFxuICByZXR1cm4gZmluZFNjcm9sbENvbnRhaW5lcihlbC5wYXJlbnRFbGVtZW50KVxufVxuXG5sZXQgc2Nyb2xsVG9wID0gKHNjcm9sbENvbnRhaW5lcikgPT4ge1xuICBpZihzY3JvbGxDb250YWluZXIpe1xuICAgIHJldHVybiBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3BcbiAgfVxufVxuXG5sZXQgYm90dG9tID0gKHNjcm9sbENvbnRhaW5lcikgPT4ge1xuICBpZihzY3JvbGxDb250YWluZXIpe1xuICAgIHJldHVybiBzY3JvbGxDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tXG4gIH0gZWxzZSB7XG4gICAgLy8gd2hlbiB3ZSBoYXZlIG5vIGNvbnRhaW5lciwgdGhlIHdob2xlIHBhZ2Ugc2Nyb2xscyxcbiAgICAvLyB0aGVyZWZvcmUgdGhlIGJvdHRvbSBjb29yZGluYXRlIGlzIHRoZSB2aWV3cG9ydCBoZWlnaHRcbiAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgfVxufVxuXG5sZXQgdG9wID0gKHNjcm9sbENvbnRhaW5lcikgPT4ge1xuICBpZihzY3JvbGxDb250YWluZXIpe1xuICAgIHJldHVybiBzY3JvbGxDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gIH0gZWxzZSB7XG4gICAgLy8gd2hlbiB3ZSBoYXZlIG5vIGNvbnRhaW5lciB0aGUgd2hvbGUgcGFnZSBzY3JvbGxzLFxuICAgIC8vIHRoZXJlZm9yZSB0aGUgdG9wIGNvb3JkaW5hdGUgaXMgMFxuICAgIHJldHVybiAwXG4gIH1cbn1cblxubGV0IGlzQXRWaWV3cG9ydFRvcCA9IChlbCwgc2Nyb2xsQ29udGFpbmVyKSA9PiB7XG4gIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgcmV0dXJuIHJlY3QudG9wID49IHRvcChzY3JvbGxDb250YWluZXIpICYmIHJlY3QubGVmdCA+PSAwICYmIHJlY3QudG9wIDw9IGJvdHRvbShzY3JvbGxDb250YWluZXIpXG59XG5cbmxldCBpc0F0Vmlld3BvcnRCb3R0b20gPSAoZWwsIHNjcm9sbENvbnRhaW5lcikgPT4ge1xuICBsZXQgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gIHJldHVybiByZWN0LnJpZ2h0ID49IHRvcChzY3JvbGxDb250YWluZXIpICYmIHJlY3QubGVmdCA+PSAwICYmIHJlY3QuYm90dG9tIDw9IGJvdHRvbShzY3JvbGxDb250YWluZXIpXG59XG5cbmxldCBpc1dpdGhpblZpZXdwb3J0ID0gKGVsLCBzY3JvbGxDb250YWluZXIpID0+IHtcbiAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICByZXR1cm4gcmVjdC50b3AgPj0gdG9wKHNjcm9sbENvbnRhaW5lcikgJiYgcmVjdC5sZWZ0ID49IDAgJiYgcmVjdC50b3AgPD0gYm90dG9tKHNjcm9sbENvbnRhaW5lcilcbn1cblxuSG9va3MuSW5maW5pdGVTY3JvbGwgPSB7XG4gIG1vdW50ZWQoKXtcbiAgICB0aGlzLnNjcm9sbENvbnRhaW5lciA9IGZpbmRTY3JvbGxDb250YWluZXIodGhpcy5lbClcbiAgICBsZXQgc2Nyb2xsQmVmb3JlID0gc2Nyb2xsVG9wKHRoaXMuc2Nyb2xsQ29udGFpbmVyKVxuICAgIGxldCB0b3BPdmVycmFuID0gZmFsc2VcbiAgICBsZXQgdGhyb3R0bGVJbnRlcnZhbCA9IDUwMFxuICAgIGxldCBwZW5kaW5nT3AgPSBudWxsXG5cbiAgICBsZXQgb25Ub3BPdmVycnVuID0gdGhpcy50aHJvdHRsZSh0aHJvdHRsZUludGVydmFsLCAodG9wRXZlbnQsIGZpcnN0Q2hpbGQpID0+IHtcbiAgICAgIHBlbmRpbmdPcCA9ICgpID0+IHRydWVcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5leGVjSlNIb29rUHVzaCh0aGlzLmVsLCB0b3BFdmVudCwge2lkOiBmaXJzdENoaWxkLmlkLCBfb3ZlcnJhbjogdHJ1ZX0sICgpID0+IHtcbiAgICAgICAgcGVuZGluZ09wID0gbnVsbFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgbGV0IG9uRmlyc3RDaGlsZEF0VG9wID0gdGhpcy50aHJvdHRsZSh0aHJvdHRsZUludGVydmFsLCAodG9wRXZlbnQsIGZpcnN0Q2hpbGQpID0+IHtcbiAgICAgIHBlbmRpbmdPcCA9ICgpID0+IGZpcnN0Q2hpbGQuc2Nyb2xsSW50b1ZpZXcoe2Jsb2NrOiBcInN0YXJ0XCJ9KVxuICAgICAgdGhpcy5saXZlU29ja2V0LmV4ZWNKU0hvb2tQdXNoKHRoaXMuZWwsIHRvcEV2ZW50LCB7aWQ6IGZpcnN0Q2hpbGQuaWR9LCAoKSA9PiB7XG4gICAgICAgIHBlbmRpbmdPcCA9IG51bGxcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIERPTSBpcyBwYXRjaGVkIGJ5IHdhaXRpbmcgZm9yIHRoZSBuZXh0IHRpY2tcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgaWYoIWlzV2l0aGluVmlld3BvcnQoZmlyc3RDaGlsZCwgdGhpcy5zY3JvbGxDb250YWluZXIpKXtcbiAgICAgICAgICAgIGZpcnN0Q2hpbGQuc2Nyb2xsSW50b1ZpZXcoe2Jsb2NrOiBcInN0YXJ0XCJ9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGxldCBvbkxhc3RDaGlsZEF0Qm90dG9tID0gdGhpcy50aHJvdHRsZSh0aHJvdHRsZUludGVydmFsLCAoYm90dG9tRXZlbnQsIGxhc3RDaGlsZCkgPT4ge1xuICAgICAgcGVuZGluZ09wID0gKCkgPT4gbGFzdENoaWxkLnNjcm9sbEludG9WaWV3KHtibG9jazogXCJlbmRcIn0pXG4gICAgICB0aGlzLmxpdmVTb2NrZXQuZXhlY0pTSG9va1B1c2godGhpcy5lbCwgYm90dG9tRXZlbnQsIHtpZDogbGFzdENoaWxkLmlkfSwgKCkgPT4ge1xuICAgICAgICBwZW5kaW5nT3AgPSBudWxsXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSBET00gaXMgcGF0Y2hlZCBieSB3YWl0aW5nIGZvciB0aGUgbmV4dCB0aWNrXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIGlmKCFpc1dpdGhpblZpZXdwb3J0KGxhc3RDaGlsZCwgdGhpcy5zY3JvbGxDb250YWluZXIpKXtcbiAgICAgICAgICAgIGxhc3RDaGlsZC5zY3JvbGxJbnRvVmlldyh7YmxvY2s6IFwiZW5kXCJ9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHRoaXMub25TY3JvbGwgPSAoX2UpID0+IHtcbiAgICAgIGxldCBzY3JvbGxOb3cgPSBzY3JvbGxUb3AodGhpcy5zY3JvbGxDb250YWluZXIpXG5cbiAgICAgIGlmKHBlbmRpbmdPcCl7XG4gICAgICAgIHNjcm9sbEJlZm9yZSA9IHNjcm9sbE5vd1xuICAgICAgICByZXR1cm4gcGVuZGluZ09wKClcbiAgICAgIH1cbiAgICAgIGxldCByZWN0ID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgbGV0IHRvcEV2ZW50ID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUodGhpcy5saXZlU29ja2V0LmJpbmRpbmcoXCJ2aWV3cG9ydC10b3BcIikpXG4gICAgICBsZXQgYm90dG9tRXZlbnQgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZSh0aGlzLmxpdmVTb2NrZXQuYmluZGluZyhcInZpZXdwb3J0LWJvdHRvbVwiKSlcbiAgICAgIGxldCBsYXN0Q2hpbGQgPSB0aGlzLmVsLmxhc3RFbGVtZW50Q2hpbGRcbiAgICAgIGxldCBmaXJzdENoaWxkID0gdGhpcy5lbC5maXJzdEVsZW1lbnRDaGlsZFxuICAgICAgbGV0IGlzU2Nyb2xsaW5nVXAgPSBzY3JvbGxOb3cgPCBzY3JvbGxCZWZvcmVcbiAgICAgIGxldCBpc1Njcm9sbGluZ0Rvd24gPSBzY3JvbGxOb3cgPiBzY3JvbGxCZWZvcmVcblxuICAgICAgLy8gZWwgb3ZlcnJhbiB3aGlsZSBzY3JvbGxpbmcgdXBcbiAgICAgIGlmKGlzU2Nyb2xsaW5nVXAgJiYgdG9wRXZlbnQgJiYgIXRvcE92ZXJyYW4gJiYgcmVjdC50b3AgPj0gMCl7XG4gICAgICAgIHRvcE92ZXJyYW4gPSB0cnVlXG4gICAgICAgIG9uVG9wT3ZlcnJ1bih0b3BFdmVudCwgZmlyc3RDaGlsZClcbiAgICAgIH0gZWxzZSBpZihpc1Njcm9sbGluZ0Rvd24gJiYgdG9wT3ZlcnJhbiAmJiByZWN0LnRvcCA8PSAwKXtcbiAgICAgICAgdG9wT3ZlcnJhbiA9IGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmKHRvcEV2ZW50ICYmIGlzU2Nyb2xsaW5nVXAgJiYgaXNBdFZpZXdwb3J0VG9wKGZpcnN0Q2hpbGQsIHRoaXMuc2Nyb2xsQ29udGFpbmVyKSl7XG4gICAgICAgIG9uRmlyc3RDaGlsZEF0VG9wKHRvcEV2ZW50LCBmaXJzdENoaWxkKVxuICAgICAgfSBlbHNlIGlmKGJvdHRvbUV2ZW50ICYmIGlzU2Nyb2xsaW5nRG93biAmJiBpc0F0Vmlld3BvcnRCb3R0b20obGFzdENoaWxkLCB0aGlzLnNjcm9sbENvbnRhaW5lcikpe1xuICAgICAgICBvbkxhc3RDaGlsZEF0Qm90dG9tKGJvdHRvbUV2ZW50LCBsYXN0Q2hpbGQpXG4gICAgICB9XG4gICAgICBzY3JvbGxCZWZvcmUgPSBzY3JvbGxOb3dcbiAgICB9XG5cbiAgICBpZih0aGlzLnNjcm9sbENvbnRhaW5lcil7XG4gICAgICB0aGlzLnNjcm9sbENvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpXG4gICAgfVxuICB9LFxuICBcbiAgZGVzdHJveWVkKCl7XG4gICAgaWYodGhpcy5zY3JvbGxDb250YWluZXIpe1xuICAgICAgdGhpcy5zY3JvbGxDb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKVxuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKVxuICAgIH1cbiAgfSxcblxuICB0aHJvdHRsZShpbnRlcnZhbCwgY2FsbGJhY2spe1xuICAgIGxldCBsYXN0Q2FsbEF0ID0gMFxuICAgIGxldCB0aW1lclxuXG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKVxuICAgICAgbGV0IHJlbWFpbmluZ1RpbWUgPSBpbnRlcnZhbCAtIChub3cgLSBsYXN0Q2FsbEF0KVxuXG4gICAgICBpZihyZW1haW5pbmdUaW1lIDw9IDAgfHwgcmVtYWluaW5nVGltZSA+IGludGVydmFsKXtcbiAgICAgICAgaWYodGltZXIpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpXG4gICAgICAgICAgdGltZXIgPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgbGFzdENhbGxBdCA9IG5vd1xuICAgICAgICBjYWxsYmFjayguLi5hcmdzKVxuICAgICAgfSBlbHNlIGlmKCF0aW1lcil7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgbGFzdENhbGxBdCA9IERhdGUubm93KClcbiAgICAgICAgICB0aW1lciA9IG51bGxcbiAgICAgICAgICBjYWxsYmFjayguLi5hcmdzKVxuICAgICAgICB9LCByZW1haW5pbmdUaW1lKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgSG9va3NcbiIsICJpbXBvcnQge1xuICBtYXliZVxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRE9NUG9zdE1vcnBoUmVzdG9yZXIge1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXJCZWZvcmUsIGNvbnRhaW5lckFmdGVyLCB1cGRhdGVUeXBlKXtcbiAgICBsZXQgaWRzQmVmb3JlID0gbmV3IFNldCgpXG4gICAgbGV0IGlkc0FmdGVyID0gbmV3IFNldChbLi4uY29udGFpbmVyQWZ0ZXIuY2hpbGRyZW5dLm1hcChjaGlsZCA9PiBjaGlsZC5pZCkpXG5cbiAgICBsZXQgZWxlbWVudHNUb01vZGlmeSA9IFtdXG5cbiAgICBBcnJheS5mcm9tKGNvbnRhaW5lckJlZm9yZS5jaGlsZHJlbikuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBpZihjaGlsZC5pZCl7IC8vIGFsbCBvZiBvdXIgY2hpbGRyZW4gc2hvdWxkIGJlIGVsZW1lbnRzIHdpdGggaWRzXG4gICAgICAgIGlkc0JlZm9yZS5hZGQoY2hpbGQuaWQpXG4gICAgICAgIGlmKGlkc0FmdGVyLmhhcyhjaGlsZC5pZCkpe1xuICAgICAgICAgIGxldCBwcmV2aW91c0VsZW1lbnRJZCA9IGNoaWxkLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgY2hpbGQucHJldmlvdXNFbGVtZW50U2libGluZy5pZFxuICAgICAgICAgIGVsZW1lbnRzVG9Nb2RpZnkucHVzaCh7ZWxlbWVudElkOiBjaGlsZC5pZCwgcHJldmlvdXNFbGVtZW50SWQ6IHByZXZpb3VzRWxlbWVudElkfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmNvbnRhaW5lcklkID0gY29udGFpbmVyQWZ0ZXIuaWRcbiAgICB0aGlzLnVwZGF0ZVR5cGUgPSB1cGRhdGVUeXBlXG4gICAgdGhpcy5lbGVtZW50c1RvTW9kaWZ5ID0gZWxlbWVudHNUb01vZGlmeVxuICAgIHRoaXMuZWxlbWVudElkc1RvQWRkID0gWy4uLmlkc0FmdGVyXS5maWx0ZXIoaWQgPT4gIWlkc0JlZm9yZS5oYXMoaWQpKVxuICB9XG5cbiAgLy8gV2UgZG8gdGhlIGZvbGxvd2luZyB0byBvcHRpbWl6ZSBhcHBlbmQvcHJlcGVuZCBvcGVyYXRpb25zOlxuICAvLyAgIDEpIFRyYWNrIGlkcyBvZiBtb2RpZmllZCBlbGVtZW50cyAmIG9mIG5ldyBlbGVtZW50c1xuICAvLyAgIDIpIEFsbCB0aGUgbW9kaWZpZWQgZWxlbWVudHMgYXJlIHB1dCBiYWNrIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGluIHRoZSBET00gdHJlZVxuICAvLyAgICAgIGJ5IHN0b3JpbmcgdGhlIGlkIG9mIHRoZWlyIHByZXZpb3VzIHNpYmxpbmdcbiAgLy8gICAzKSBOZXcgZWxlbWVudHMgYXJlIGdvaW5nIHRvIGJlIHB1dCBpbiB0aGUgcmlnaHQgcGxhY2UgYnkgbW9ycGhkb20gZHVyaW5nIGFwcGVuZC5cbiAgLy8gICAgICBGb3IgcHJlcGVuZCwgd2UgbW92ZSB0aGVtIHRvIHRoZSBmaXJzdCBwb3NpdGlvbiBpbiB0aGUgY29udGFpbmVyXG4gIHBlcmZvcm0oKXtcbiAgICBsZXQgY29udGFpbmVyID0gRE9NLmJ5SWQodGhpcy5jb250YWluZXJJZClcbiAgICB0aGlzLmVsZW1lbnRzVG9Nb2RpZnkuZm9yRWFjaChlbGVtZW50VG9Nb2RpZnkgPT4ge1xuICAgICAgaWYoZWxlbWVudFRvTW9kaWZ5LnByZXZpb3VzRWxlbWVudElkKXtcbiAgICAgICAgbWF5YmUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudFRvTW9kaWZ5LnByZXZpb3VzRWxlbWVudElkKSwgcHJldmlvdXNFbGVtID0+IHtcbiAgICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkuZWxlbWVudElkKSwgZWxlbSA9PiB7XG4gICAgICAgICAgICBsZXQgaXNJblJpZ2h0UGxhY2UgPSBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgZWxlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmlkID09IHByZXZpb3VzRWxlbS5pZFxuICAgICAgICAgICAgaWYoIWlzSW5SaWdodFBsYWNlKXtcbiAgICAgICAgICAgICAgcHJldmlvdXNFbGVtLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyZW5kXCIsIGVsZW0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGNvbnRhaW5lclxuICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkuZWxlbWVudElkKSwgZWxlbSA9PiB7XG4gICAgICAgICAgbGV0IGlzSW5SaWdodFBsYWNlID0gZWxlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nID09IG51bGxcbiAgICAgICAgICBpZighaXNJblJpZ2h0UGxhY2Upe1xuICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyYmVnaW5cIiwgZWxlbSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcblxuICAgIGlmKHRoaXMudXBkYXRlVHlwZSA9PSBcInByZXBlbmRcIil7XG4gICAgICB0aGlzLmVsZW1lbnRJZHNUb0FkZC5yZXZlcnNlKCkuZm9yRWFjaChlbGVtSWQgPT4ge1xuICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtSWQpLCBlbGVtID0+IGNvbnRhaW5lci5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmJlZ2luXCIsIGVsZW0pKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cbiIsICJ2YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IDExO1xuXG5mdW5jdGlvbiBtb3JwaEF0dHJzKGZyb21Ob2RlLCB0b05vZGUpIHtcbiAgICB2YXIgdG9Ob2RlQXR0cnMgPSB0b05vZGUuYXR0cmlidXRlcztcbiAgICB2YXIgYXR0cjtcbiAgICB2YXIgYXR0ck5hbWU7XG4gICAgdmFyIGF0dHJOYW1lc3BhY2VVUkk7XG4gICAgdmFyIGF0dHJWYWx1ZTtcbiAgICB2YXIgZnJvbVZhbHVlO1xuXG4gICAgLy8gZG9jdW1lbnQtZnJhZ21lbnRzIGRvbnQgaGF2ZSBhdHRyaWJ1dGVzIHNvIGxldHMgbm90IGRvIGFueXRoaW5nXG4gICAgaWYgKHRvTm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBmcm9tTm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBhdHRyaWJ1dGVzIG9uIG9yaWdpbmFsIERPTSBlbGVtZW50XG4gICAgZm9yICh2YXIgaSA9IHRvTm9kZUF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGF0dHIgPSB0b05vZGVBdHRyc1tpXTtcbiAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7XG4gICAgICAgIGF0dHJOYW1lc3BhY2VVUkkgPSBhdHRyLm5hbWVzcGFjZVVSSTtcbiAgICAgICAgYXR0clZhbHVlID0gYXR0ci52YWx1ZTtcblxuICAgICAgICBpZiAoYXR0ck5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLmxvY2FsTmFtZSB8fCBhdHRyTmFtZTtcbiAgICAgICAgICAgIGZyb21WYWx1ZSA9IGZyb21Ob2RlLmdldEF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKTtcblxuICAgICAgICAgICAgaWYgKGZyb21WYWx1ZSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIucHJlZml4ID09PSAneG1sbnMnKXtcbiAgICAgICAgICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7IC8vIEl0J3Mgbm90IGFsbG93ZWQgdG8gc2V0IGFuIGF0dHJpYnV0ZSB3aXRoIHRoZSBYTUxOUyBuYW1lc3BhY2Ugd2l0aG91dCBzcGVjaWZ5aW5nIHRoZSBgeG1sbnNgIHByZWZpeFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5zZXRBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21WYWx1ZSA9IGZyb21Ob2RlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChmcm9tVmFsdWUgIT09IGF0dHJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGZyb21Ob2RlLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbnkgZXh0cmEgYXR0cmlidXRlcyBmb3VuZCBvbiB0aGUgb3JpZ2luYWwgRE9NIGVsZW1lbnQgdGhhdFxuICAgIC8vIHdlcmVuJ3QgZm91bmQgb24gdGhlIHRhcmdldCBlbGVtZW50LlxuICAgIHZhciBmcm9tTm9kZUF0dHJzID0gZnJvbU5vZGUuYXR0cmlidXRlcztcblxuICAgIGZvciAodmFyIGQgPSBmcm9tTm9kZUF0dHJzLmxlbmd0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGF0dHIgPSBmcm9tTm9kZUF0dHJzW2RdO1xuICAgICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgYXR0ck5hbWVzcGFjZVVSSSA9IGF0dHIubmFtZXNwYWNlVVJJO1xuXG4gICAgICAgIGlmIChhdHRyTmFtZXNwYWNlVVJJKSB7XG4gICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHIubG9jYWxOYW1lIHx8IGF0dHJOYW1lO1xuXG4gICAgICAgICAgICBpZiAoIXRvTm9kZS5oYXNBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5yZW1vdmVBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRvTm9kZS5oYXNBdHRyaWJ1dGUoYXR0ck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZnJvbU5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIHJhbmdlOyAvLyBDcmVhdGUgYSByYW5nZSBvYmplY3QgZm9yIGVmZmljZW50bHkgcmVuZGVyaW5nIHN0cmluZ3MgdG8gZWxlbWVudHMuXG52YXIgTlNfWEhUTUwgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5cbnZhciBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogZG9jdW1lbnQ7XG52YXIgSEFTX1RFTVBMQVRFX1NVUFBPUlQgPSAhIWRvYyAmJiAnY29udGVudCcgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG52YXIgSEFTX1JBTkdFX1NVUFBPUlQgPSAhIWRvYyAmJiBkb2MuY3JlYXRlUmFuZ2UgJiYgJ2NyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCcgaW4gZG9jLmNyZWF0ZVJhbmdlKCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVRlbXBsYXRlKHN0cikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IGRvYy5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHN0cjtcbiAgICByZXR1cm4gdGVtcGxhdGUuY29udGVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudEZyb21SYW5nZShzdHIpIHtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIHJhbmdlID0gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGUoZG9jLmJvZHkpO1xuICAgIH1cblxuICAgIHZhciBmcmFnbWVudCA9IHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChzdHIpO1xuICAgIHJldHVybiBmcmFnbWVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudEZyb21XcmFwKHN0cikge1xuICAgIHZhciBmcmFnbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KCdib2R5Jyk7XG4gICAgZnJhZ21lbnQuaW5uZXJIVE1MID0gc3RyO1xuICAgIHJldHVybiBmcmFnbWVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgYWJvdXQgdGhlIHNhbWVcbiAqIHZhciBodG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzdHIsICd0ZXh0L2h0bWwnKTtcbiAqIHJldHVybiBodG1sLmJvZHkuZmlyc3RDaGlsZDtcbiAqXG4gKiBAbWV0aG9kIHRvRWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICovXG5mdW5jdGlvbiB0b0VsZW1lbnQoc3RyKSB7XG4gICAgc3RyID0gc3RyLnRyaW0oKTtcbiAgICBpZiAoSEFTX1RFTVBMQVRFX1NVUFBPUlQpIHtcbiAgICAgIC8vIGF2b2lkIHJlc3RyaWN0aW9ucyBvbiBjb250ZW50IGZvciB0aGluZ3MgbGlrZSBgPHRyPjx0aD5IaTwvdGg+PC90cj5gIHdoaWNoXG4gICAgICAvLyBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQgZG9lc24ndCBzdXBwb3J0XG4gICAgICAvLyA8dGVtcGxhdGU+IHN1cHBvcnQgbm90IGF2YWlsYWJsZSBpbiBJRVxuICAgICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVRlbXBsYXRlKHN0cik7XG4gICAgfSBlbHNlIGlmIChIQVNfUkFOR0VfU1VQUE9SVCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVJhbmdlKHN0cik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVdyYXAoc3RyKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdHdvIG5vZGUncyBuYW1lcyBhcmUgdGhlIHNhbWUuXG4gKlxuICogTk9URTogV2UgZG9uJ3QgYm90aGVyIGNoZWNraW5nIGBuYW1lc3BhY2VVUklgIGJlY2F1c2UgeW91IHdpbGwgbmV2ZXIgZmluZCB0d28gSFRNTCBlbGVtZW50cyB3aXRoIHRoZSBzYW1lXG4gKiAgICAgICBub2RlTmFtZSBhbmQgZGlmZmVyZW50IG5hbWVzcGFjZSBVUklzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiIFRoZSB0YXJnZXQgZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29tcGFyZU5vZGVOYW1lcyhmcm9tRWwsIHRvRWwpIHtcbiAgICB2YXIgZnJvbU5vZGVOYW1lID0gZnJvbUVsLm5vZGVOYW1lO1xuICAgIHZhciB0b05vZGVOYW1lID0gdG9FbC5ub2RlTmFtZTtcbiAgICB2YXIgZnJvbUNvZGVTdGFydCwgdG9Db2RlU3RhcnQ7XG5cbiAgICBpZiAoZnJvbU5vZGVOYW1lID09PSB0b05vZGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZyb21Db2RlU3RhcnQgPSBmcm9tTm9kZU5hbWUuY2hhckNvZGVBdCgwKTtcbiAgICB0b0NvZGVTdGFydCA9IHRvTm9kZU5hbWUuY2hhckNvZGVBdCgwKTtcblxuICAgIC8vIElmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBhIHZpcnR1YWwgRE9NIG5vZGUgb3IgU1ZHIG5vZGUgdGhlbiB3ZSBtYXlcbiAgICAvLyBuZWVkIHRvIG5vcm1hbGl6ZSB0aGUgdGFnIG5hbWUgYmVmb3JlIGNvbXBhcmluZy4gTm9ybWFsIEhUTUwgZWxlbWVudHMgdGhhdCBhcmVcbiAgICAvLyBpbiB0aGUgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCJcbiAgICAvLyBhcmUgY29udmVydGVkIHRvIHVwcGVyIGNhc2VcbiAgICBpZiAoZnJvbUNvZGVTdGFydCA8PSA5MCAmJiB0b0NvZGVTdGFydCA+PSA5NykgeyAvLyBmcm9tIGlzIHVwcGVyIGFuZCB0byBpcyBsb3dlclxuICAgICAgICByZXR1cm4gZnJvbU5vZGVOYW1lID09PSB0b05vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmICh0b0NvZGVTdGFydCA8PSA5MCAmJiBmcm9tQ29kZVN0YXJ0ID49IDk3KSB7IC8vIHRvIGlzIHVwcGVyIGFuZCBmcm9tIGlzIGxvd2VyXG4gICAgICAgIHJldHVybiB0b05vZGVOYW1lID09PSBmcm9tTm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBlbGVtZW50LCBvcHRpb25hbGx5IHdpdGggYSBrbm93biBuYW1lc3BhY2UgVVJJLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBlbGVtZW50IG5hbWUsIGUuZy4gJ2Rpdicgb3IgJ3N2ZydcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZXNwYWNlVVJJXSB0aGUgZWxlbWVudCdzIG5hbWVzcGFjZSBVUkksIGkuZS4gdGhlIHZhbHVlIG9mXG4gKiBpdHMgYHhtbG5zYCBhdHRyaWJ1dGUgb3IgaXRzIGluZmVycmVkIG5hbWVzcGFjZS5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZSwgbmFtZXNwYWNlVVJJKSB7XG4gICAgcmV0dXJuICFuYW1lc3BhY2VVUkkgfHwgbmFtZXNwYWNlVVJJID09PSBOU19YSFRNTCA/XG4gICAgICAgIGRvYy5jcmVhdGVFbGVtZW50KG5hbWUpIDpcbiAgICAgICAgZG9jLmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIG5hbWUpO1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgY2hpbGRyZW4gb2Ygb25lIERPTSBlbGVtZW50IHRvIGFub3RoZXIgRE9NIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gbW92ZUNoaWxkcmVuKGZyb21FbCwgdG9FbCkge1xuICAgIHZhciBjdXJDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICB2YXIgbmV4dENoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIHRvRWwuYXBwZW5kQ2hpbGQoY3VyQ2hpbGQpO1xuICAgICAgICBjdXJDaGlsZCA9IG5leHRDaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIHRvRWw7XG59XG5cbmZ1bmN0aW9uIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCBuYW1lKSB7XG4gICAgaWYgKGZyb21FbFtuYW1lXSAhPT0gdG9FbFtuYW1lXSkge1xuICAgICAgICBmcm9tRWxbbmFtZV0gPSB0b0VsW25hbWVdO1xuICAgICAgICBpZiAoZnJvbUVsW25hbWVdKSB7XG4gICAgICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKG5hbWUsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBzcGVjaWFsRWxIYW5kbGVycyA9IHtcbiAgICBPUFRJT046IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGZyb21FbC5wYXJlbnROb2RlO1xuICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudE5hbWUgPSBwYXJlbnROb2RlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZSA9PT0gJ09QVEdST1VQJykge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgcGFyZW50TmFtZSA9IHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudE5hbWUgPT09ICdTRUxFQ1QnICYmICFwYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKSkge1xuICAgICAgICAgICAgICAgIGlmIChmcm9tRWwuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpICYmICF0b0VsLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIE1TIEVkZ2UgYnVnIHdoZXJlIHRoZSAnc2VsZWN0ZWQnIGF0dHJpYnV0ZSBjYW4gb25seSBiZVxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmVkIGlmIHNldCB0byBhIG5vbi1lbXB0eSB2YWx1ZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTIwODc2NzkvXG4gICAgICAgICAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gcmVzZXQgc2VsZWN0IGVsZW1lbnQncyBzZWxlY3RlZEluZGV4IHRvIC0xLCBvdGhlcndpc2Ugc2V0dGluZ1xuICAgICAgICAgICAgICAgIC8vIGZyb21FbC5zZWxlY3RlZCB1c2luZyB0aGUgc3luY0Jvb2xlYW5BdHRyUHJvcCBiZWxvdyBoYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgICAgIC8vIFRoZSBjb3JyZWN0IHNlbGVjdGVkSW5kZXggd2lsbCBiZSBzZXQgaW4gdGhlIFNFTEVDVCBzcGVjaWFsIGhhbmRsZXIgYmVsb3cuXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsICdzZWxlY3RlZCcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIFwidmFsdWVcIiBhdHRyaWJ1dGUgaXMgc3BlY2lhbCBmb3IgdGhlIDxpbnB1dD4gZWxlbWVudCBzaW5jZSBpdCBzZXRzXG4gICAgICogdGhlIGluaXRpYWwgdmFsdWUuIENoYW5naW5nIHRoZSBcInZhbHVlXCIgYXR0cmlidXRlIHdpdGhvdXQgY2hhbmdpbmcgdGhlXG4gICAgICogXCJ2YWx1ZVwiIHByb3BlcnR5IHdpbGwgaGF2ZSBubyBlZmZlY3Qgc2luY2UgaXQgaXMgb25seSB1c2VkIHRvIHRoZSBzZXQgdGhlXG4gICAgICogaW5pdGlhbCB2YWx1ZS4gIFNpbWlsYXIgZm9yIHRoZSBcImNoZWNrZWRcIiBhdHRyaWJ1dGUsIGFuZCBcImRpc2FibGVkXCIuXG4gICAgICovXG4gICAgSU5QVVQ6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgJ2NoZWNrZWQnKTtcbiAgICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsICdkaXNhYmxlZCcpO1xuXG4gICAgICAgIGlmIChmcm9tRWwudmFsdWUgIT09IHRvRWwudmFsdWUpIHtcbiAgICAgICAgICAgIGZyb21FbC52YWx1ZSA9IHRvRWwudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRvRWwuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICAgICAgICBmcm9tRWwucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIFRFWFRBUkVBOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gdG9FbC52YWx1ZTtcbiAgICAgICAgaWYgKGZyb21FbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGZyb21FbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIE5lZWRlZCBmb3IgSUUuIEFwcGFyZW50bHkgSUUgc2V0cyB0aGUgcGxhY2Vob2xkZXIgYXMgdGhlXG4gICAgICAgICAgICAvLyBub2RlIHZhbHVlIGFuZCB2aXNlIHZlcnNhLiBUaGlzIGlnbm9yZXMgYW4gZW1wdHkgdXBkYXRlLlxuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gZmlyc3RDaGlsZC5ub2RlVmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSA9PSBuZXdWYWx1ZSB8fCAoIW5ld1ZhbHVlICYmIG9sZFZhbHVlID09IGZyb21FbC5wbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFNFTEVDVDogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIGlmICghdG9FbC5oYXNBdHRyaWJ1dGUoJ211bHRpcGxlJykpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHRvIGxvb3AgdGhyb3VnaCBjaGlsZHJlbiBvZiBmcm9tRWwsIG5vdCB0b0VsIHNpbmNlIG5vZGVzIGNhbiBiZSBtb3ZlZFxuICAgICAgICAgICAgLy8gZnJvbSB0b0VsIHRvIGZyb21FbCBkaXJlY3RseSB3aGVuIG1vcnBoaW5nLlxuICAgICAgICAgICAgLy8gQXQgdGhlIHRpbWUgdGhpcyBzcGVjaWFsIGhhbmRsZXIgaXMgaW52b2tlZCwgYWxsIGNoaWxkcmVuIGhhdmUgYWxyZWFkeSBiZWVuIG1vcnBoZWRcbiAgICAgICAgICAgIC8vIGFuZCBhcHBlbmRlZCB0byAvIHJlbW92ZWQgZnJvbSBmcm9tRWwsIHNvIHVzaW5nIGZyb21FbCBoZXJlIGlzIHNhZmUgYW5kIGNvcnJlY3QuXG4gICAgICAgICAgICB2YXIgY3VyQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHZhciBvcHRncm91cDtcbiAgICAgICAgICAgIHZhciBub2RlTmFtZTtcbiAgICAgICAgICAgIHdoaWxlKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICAgICAgbm9kZU5hbWUgPSBjdXJDaGlsZC5ub2RlTmFtZSAmJiBjdXJDaGlsZC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ09QVEdST1VQJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRncm91cCA9IGN1ckNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IG9wdGdyb3VwLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnT1BUSU9OJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckNoaWxkLmhhc0F0dHJpYnV0ZSgnc2VsZWN0ZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VyQ2hpbGQgJiYgb3B0Z3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gb3B0Z3JvdXAubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRncm91cCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZyb21FbC5zZWxlY3RlZEluZGV4ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBFTEVNRU5UX05PREUgPSAxO1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUkMSA9IDExO1xudmFyIFRFWFRfTk9ERSA9IDM7XG52YXIgQ09NTUVOVF9OT0RFID0gODtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXROb2RlS2V5KG5vZGUpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpKSB8fCBub2RlLmlkO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vcnBoZG9tRmFjdG9yeShtb3JwaEF0dHJzKSB7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIG1vcnBoZG9tKGZyb21Ob2RlLCB0b05vZGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRvTm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChmcm9tTm9kZS5ub2RlTmFtZSA9PT0gJyNkb2N1bWVudCcgfHwgZnJvbU5vZGUubm9kZU5hbWUgPT09ICdIVE1MJyB8fCBmcm9tTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIHZhciB0b05vZGVIdG1sID0gdG9Ob2RlO1xuICAgICAgICB0b05vZGUgPSBkb2MuY3JlYXRlRWxlbWVudCgnaHRtbCcpO1xuICAgICAgICB0b05vZGUuaW5uZXJIVE1MID0gdG9Ob2RlSHRtbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvTm9kZSA9IHRvRWxlbWVudCh0b05vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodG9Ob2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFJDEpIHtcbiAgICAgIHRvTm9kZSA9IHRvTm9kZS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICB9XG5cbiAgICB2YXIgZ2V0Tm9kZUtleSA9IG9wdGlvbnMuZ2V0Tm9kZUtleSB8fCBkZWZhdWx0R2V0Tm9kZUtleTtcbiAgICB2YXIgb25CZWZvcmVOb2RlQWRkZWQgPSBvcHRpb25zLm9uQmVmb3JlTm9kZUFkZGVkIHx8IG5vb3A7XG4gICAgdmFyIG9uTm9kZUFkZGVkID0gb3B0aW9ucy5vbk5vZGVBZGRlZCB8fCBub29wO1xuICAgIHZhciBvbkJlZm9yZUVsVXBkYXRlZCA9IG9wdGlvbnMub25CZWZvcmVFbFVwZGF0ZWQgfHwgbm9vcDtcbiAgICB2YXIgb25FbFVwZGF0ZWQgPSBvcHRpb25zLm9uRWxVcGRhdGVkIHx8IG5vb3A7XG4gICAgdmFyIG9uQmVmb3JlTm9kZURpc2NhcmRlZCA9IG9wdGlvbnMub25CZWZvcmVOb2RlRGlzY2FyZGVkIHx8IG5vb3A7XG4gICAgdmFyIG9uTm9kZURpc2NhcmRlZCA9IG9wdGlvbnMub25Ob2RlRGlzY2FyZGVkIHx8IG5vb3A7XG4gICAgdmFyIG9uQmVmb3JlRWxDaGlsZHJlblVwZGF0ZWQgPSBvcHRpb25zLm9uQmVmb3JlRWxDaGlsZHJlblVwZGF0ZWQgfHwgbm9vcDtcbiAgICB2YXIgc2tpcEZyb21DaGlsZHJlbiA9IG9wdGlvbnMuc2tpcEZyb21DaGlsZHJlbiB8fCBub29wO1xuICAgIHZhciBhZGRDaGlsZCA9IG9wdGlvbnMuYWRkQ2hpbGQgfHwgZnVuY3Rpb24ocGFyZW50LCBjaGlsZCl7IHJldHVybiBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpOyB9O1xuICAgIHZhciBjaGlsZHJlbk9ubHkgPSBvcHRpb25zLmNoaWxkcmVuT25seSA9PT0gdHJ1ZTtcblxuICAgIC8vIFRoaXMgb2JqZWN0IGlzIHVzZWQgYXMgYSBsb29rdXAgdG8gcXVpY2tseSBmaW5kIGFsbCBrZXllZCBlbGVtZW50cyBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUuXG4gICAgdmFyIGZyb21Ob2Rlc0xvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleWVkUmVtb3ZhbExpc3QgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGFkZEtleWVkUmVtb3ZhbChrZXkpIHtcbiAgICAgIGtleWVkUmVtb3ZhbExpc3QucHVzaChrZXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKG5vZGUsIHNraXBLZXllZE5vZGVzKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIHZhciBjdXJDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKGN1ckNoaWxkKSB7XG5cbiAgICAgICAgICB2YXIga2V5ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKHNraXBLZXllZE5vZGVzICYmIChrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKSkpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBza2lwcGluZyBrZXllZCBub2RlcyB0aGVuIHdlIGFkZCB0aGUga2V5XG4gICAgICAgICAgICAvLyB0byBhIGxpc3Qgc28gdGhhdCBpdCBjYW4gYmUgaGFuZGxlZCBhdCB0aGUgdmVyeSBlbmQuXG4gICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoa2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT25seSByZXBvcnQgdGhlIG5vZGUgYXMgZGlzY2FyZGVkIGlmIGl0IGlzIG5vdCBrZXllZC4gV2UgZG8gdGhpcyBiZWNhdXNlXG4gICAgICAgICAgICAvLyBhdCB0aGUgZW5kIHdlIGxvb3AgdGhyb3VnaCBhbGwga2V5ZWQgZWxlbWVudHMgdGhhdCB3ZXJlIHVubWF0Y2hlZFxuICAgICAgICAgICAgLy8gYW5kIHRoZW4gZGlzY2FyZCB0aGVtIGluIG9uZSBmaW5hbCBwYXNzLlxuICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGN1ckNoaWxkKTtcbiAgICAgICAgICAgIGlmIChjdXJDaGlsZC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKGN1ckNoaWxkLCBza2lwS2V5ZWROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogUmVtb3ZlcyBhIERPTSBub2RlIG91dCBvZiB0aGUgb3JpZ2luYWwgRE9NXG4gICAgKlxuICAgICogQHBhcmFtICB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmVcbiAgICAqIEBwYXJhbSAge05vZGV9IHBhcmVudE5vZGUgVGhlIG5vZGVzIHBhcmVudFxuICAgICogQHBhcmFtICB7Qm9vbGVhbn0gc2tpcEtleWVkTm9kZXMgSWYgdHJ1ZSB0aGVuIGVsZW1lbnRzIHdpdGgga2V5cyB3aWxsIGJlIHNraXBwZWQgYW5kIG5vdCBkaXNjYXJkZWQuXG4gICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUsIHBhcmVudE5vZGUsIHNraXBLZXllZE5vZGVzKSB7XG4gICAgICBpZiAob25CZWZvcmVOb2RlRGlzY2FyZGVkKG5vZGUpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIG9uTm9kZURpc2NhcmRlZChub2RlKTtcbiAgICAgIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKG5vZGUsIHNraXBLZXllZE5vZGVzKTtcbiAgICB9XG5cbiAgICAvLyAvLyBUcmVlV2Fsa2VyIGltcGxlbWVudGF0aW9uIGlzIG5vIGZhc3RlciwgYnV0IGtlZXBpbmcgdGhpcyBhcm91bmQgaW4gY2FzZSB0aGlzIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZVxuICAgIC8vIGZ1bmN0aW9uIGluZGV4VHJlZShyb290KSB7XG4gICAgLy8gICAgIHZhciB0cmVlV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihcbiAgICAvLyAgICAgICAgIHJvb3QsXG4gICAgLy8gICAgICAgICBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCk7XG4gICAgLy9cbiAgICAvLyAgICAgdmFyIGVsO1xuICAgIC8vICAgICB3aGlsZSgoZWwgPSB0cmVlV2Fsa2VyLm5leHROb2RlKCkpKSB7XG4gICAgLy8gICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShlbCk7XG4gICAgLy8gICAgICAgICBpZiAoa2V5KSB7XG4gICAgLy8gICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBlbDtcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgfVxuICAgIC8vIH1cblxuICAgIC8vIC8vIE5vZGVJdGVyYXRvciBpbXBsZW1lbnRhdGlvbiBpcyBubyBmYXN0ZXIsIGJ1dCBrZWVwaW5nIHRoaXMgYXJvdW5kIGluIGNhc2UgdGhpcyBjaGFuZ2VzIGluIHRoZSBmdXR1cmVcbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uIGluZGV4VHJlZShub2RlKSB7XG4gICAgLy8gICAgIHZhciBub2RlSXRlcmF0b3IgPSBkb2N1bWVudC5jcmVhdGVOb2RlSXRlcmF0b3Iobm9kZSwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQpO1xuICAgIC8vICAgICB2YXIgZWw7XG4gICAgLy8gICAgIHdoaWxlKChlbCA9IG5vZGVJdGVyYXRvci5uZXh0Tm9kZSgpKSkge1xuICAgIC8vICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoZWwpO1xuICAgIC8vICAgICAgICAgaWYgKGtleSkge1xuICAgIC8vICAgICAgICAgICAgIGZyb21Ob2Rlc0xvb2t1cFtrZXldID0gZWw7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG5cbiAgICBmdW5jdGlvbiBpbmRleFRyZWUobm9kZSkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFJDEpIHtcbiAgICAgICAgdmFyIGN1ckNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCk7XG4gICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBjdXJDaGlsZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBXYWxrIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgaW5kZXhUcmVlKGN1ckNoaWxkKTtcblxuICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbmRleFRyZWUoZnJvbU5vZGUpO1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlTm9kZUFkZGVkKGVsKSB7XG4gICAgICBvbk5vZGVBZGRlZChlbCk7XG5cbiAgICAgIHZhciBjdXJDaGlsZCA9IGVsLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoY3VyQ2hpbGQpO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgdmFyIHVubWF0Y2hlZEZyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtrZXldO1xuICAgICAgICAgIC8vIGlmIHdlIGZpbmQgYSBkdXBsaWNhdGUgI2lkIG5vZGUgaW4gY2FjaGUsIHJlcGxhY2UgYGVsYCB3aXRoIGNhY2hlIHZhbHVlXG4gICAgICAgICAgLy8gYW5kIG1vcnBoIGl0IHRvIHRoZSBjaGlsZCBub2RlLlxuICAgICAgICAgIGlmICh1bm1hdGNoZWRGcm9tRWwgJiYgY29tcGFyZU5vZGVOYW1lcyhjdXJDaGlsZCwgdW5tYXRjaGVkRnJvbUVsKSkge1xuICAgICAgICAgICAgY3VyQ2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodW5tYXRjaGVkRnJvbUVsLCBjdXJDaGlsZCk7XG4gICAgICAgICAgICBtb3JwaEVsKHVubWF0Y2hlZEZyb21FbCwgY3VyQ2hpbGQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyByZWN1cnNpdmVseSBjYWxsIGZvciBjdXJDaGlsZCBhbmQgaXQncyBjaGlsZHJlbiB0byBzZWUgaWYgd2UgZmluZCBzb21ldGhpbmcgaW5cbiAgICAgICAgICAvLyBmcm9tTm9kZXNMb29rdXBcbiAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyQ2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VyQ2hpbGQgPSBuZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwRnJvbUVsKGZyb21FbCwgY3VyRnJvbU5vZGVDaGlsZCwgY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBvZiB0aGUgXCJ0byBub2Rlc1wiLiBJZiBjdXJGcm9tTm9kZUNoaWxkIGlzXG4gICAgICAvLyBub24tbnVsbCB0aGVuIHdlIHN0aWxsIGhhdmUgc29tZSBmcm9tIG5vZGVzIGxlZnQgb3ZlciB0aGF0IG5lZWRcbiAgICAgIC8vIHRvIGJlIHJlbW92ZWRcbiAgICAgIHdoaWxlIChjdXJGcm9tTm9kZUNoaWxkKSB7XG4gICAgICAgIHZhciBmcm9tTmV4dFNpYmxpbmcgPSBjdXJGcm9tTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoKGN1ckZyb21Ob2RlS2V5ID0gZ2V0Tm9kZUtleShjdXJGcm9tTm9kZUNoaWxkKSkpIHtcbiAgICAgICAgICAvLyBTaW5jZSB0aGUgbm9kZSBpcyBrZXllZCBpdCBtaWdodCBiZSBtYXRjaGVkIHVwIGxhdGVyIHNvIHdlIGRlZmVyXG4gICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOT1RFOiB3ZSBza2lwIG5lc3RlZCBrZXllZCBub2RlcyBmcm9tIGJlaW5nIHJlbW92ZWQgc2luY2UgdGhlcmUgaXNcbiAgICAgICAgICAvLyAgICAgICBzdGlsbCBhIGNoYW5jZSB0aGV5IHdpbGwgYmUgbWF0Y2hlZCB1cCBsYXRlclxuICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlIC8qIHNraXAga2V5ZWQgbm9kZXMgKi8pO1xuICAgICAgICB9XG4gICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9ycGhFbChmcm9tRWwsIHRvRWwsIGNoaWxkcmVuT25seSkge1xuICAgICAgdmFyIHRvRWxLZXkgPSBnZXROb2RlS2V5KHRvRWwpO1xuXG4gICAgICBpZiAodG9FbEtleSkge1xuICAgICAgICAvLyBJZiBhbiBlbGVtZW50IHdpdGggYW4gSUQgaXMgYmVpbmcgbW9ycGhlZCB0aGVuIGl0IHdpbGwgYmUgaW4gdGhlIGZpbmFsXG4gICAgICAgIC8vIERPTSBzbyBjbGVhciBpdCBvdXQgb2YgdGhlIHNhdmVkIGVsZW1lbnRzIGNvbGxlY3Rpb25cbiAgICAgICAgZGVsZXRlIGZyb21Ob2Rlc0xvb2t1cFt0b0VsS2V5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjaGlsZHJlbk9ubHkpIHtcbiAgICAgICAgLy8gb3B0aW9uYWxcbiAgICAgICAgaWYgKG9uQmVmb3JlRWxVcGRhdGVkKGZyb21FbCwgdG9FbCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIGF0dHJpYnV0ZXMgb24gb3JpZ2luYWwgRE9NIGVsZW1lbnQgZmlyc3RcbiAgICAgICAgbW9ycGhBdHRycyhmcm9tRWwsIHRvRWwpO1xuICAgICAgICAvLyBvcHRpb25hbFxuICAgICAgICBvbkVsVXBkYXRlZChmcm9tRWwpO1xuXG4gICAgICAgIGlmIChvbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkKGZyb21FbCwgdG9FbCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmcm9tRWwubm9kZU5hbWUgIT09ICdURVhUQVJFQScpIHtcbiAgICAgICAgbW9ycGhDaGlsZHJlbihmcm9tRWwsIHRvRWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BlY2lhbEVsSGFuZGxlcnMuVEVYVEFSRUEoZnJvbUVsLCB0b0VsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3JwaENoaWxkcmVuKGZyb21FbCwgdG9FbCkge1xuICAgICAgdmFyIHNraXBGcm9tID0gc2tpcEZyb21DaGlsZHJlbihmcm9tRWwsIHRvRWwpO1xuICAgICAgdmFyIGN1clRvTm9kZUNoaWxkID0gdG9FbC5maXJzdENoaWxkO1xuICAgICAgdmFyIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgIHZhciBjdXJUb05vZGVLZXk7XG4gICAgICB2YXIgY3VyRnJvbU5vZGVLZXk7XG5cbiAgICAgIHZhciBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICB2YXIgdG9OZXh0U2libGluZztcbiAgICAgIHZhciBtYXRjaGluZ0Zyb21FbDtcblxuICAgICAgLy8gd2FsayB0aGUgY2hpbGRyZW5cbiAgICAgIG91dGVyOiB3aGlsZSAoY3VyVG9Ob2RlQ2hpbGQpIHtcbiAgICAgICAgdG9OZXh0U2libGluZyA9IGN1clRvTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICBjdXJUb05vZGVLZXkgPSBnZXROb2RlS2V5KGN1clRvTm9kZUNoaWxkKTtcblxuICAgICAgICAvLyB3YWxrIHRoZSBmcm9tTm9kZSBjaGlsZHJlbiBhbGwgdGhlIHdheSB0aHJvdWdoXG4gICAgICAgIHdoaWxlICghc2tpcEZyb20gJiYgY3VyRnJvbU5vZGVDaGlsZCkge1xuICAgICAgICAgIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICBpZiAoY3VyVG9Ob2RlQ2hpbGQuaXNTYW1lTm9kZSAmJiBjdXJUb05vZGVDaGlsZC5pc1NhbWVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQpKSB7XG4gICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VyRnJvbU5vZGVLZXkgPSBnZXROb2RlS2V5KGN1ckZyb21Ob2RlQ2hpbGQpO1xuXG4gICAgICAgICAgdmFyIGN1ckZyb21Ob2RlVHlwZSA9IGN1ckZyb21Ob2RlQ2hpbGQubm9kZVR5cGU7XG5cbiAgICAgICAgICAvLyB0aGlzIG1lYW5zIGlmIHRoZSBjdXJGcm9tTm9kZUNoaWxkIGRvZXNudCBoYXZlIGEgbWF0Y2ggd2l0aCB0aGUgY3VyVG9Ob2RlQ2hpbGRcbiAgICAgICAgICB2YXIgaXNDb21wYXRpYmxlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PT0gY3VyVG9Ob2RlQ2hpbGQubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAvLyBCb3RoIG5vZGVzIGJlaW5nIGNvbXBhcmVkIGFyZSBFbGVtZW50IG5vZGVzXG5cbiAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUtleSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB0YXJnZXQgbm9kZSBoYXMgYSBrZXkgc28gd2Ugd2FudCB0byBtYXRjaCBpdCB1cCB3aXRoIHRoZSBjb3JyZWN0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWVcbiAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5ICE9PSBjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnQgZWxlbWVudCBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUgZG9lcyBub3QgaGF2ZSBhIG1hdGNoaW5nIGtleSBzb1xuICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgY2hlY2sgb3VyIGxvb2t1cCB0byBzZWUgaWYgdGhlcmUgaXMgYSBtYXRjaGluZyBlbGVtZW50IGluIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgLy8gRE9NIHRyZWVcbiAgICAgICAgICAgICAgICAgIGlmICgobWF0Y2hpbmdGcm9tRWwgPSBmcm9tTm9kZXNMb29rdXBbY3VyVG9Ob2RlS2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb21OZXh0U2libGluZyA9PT0gbWF0Y2hpbmdGcm9tRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHNpbmdsZSBlbGVtZW50IHJlbW92YWxzLiBUbyBhdm9pZCByZW1vdmluZyB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBET00gbm9kZSBvdXQgb2YgdGhlIHRyZWUgKHNpbmNlIHRoYXQgY2FuIGJyZWFrIENTUyB0cmFuc2l0aW9ucywgZXRjLiksXG4gICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd2lsbCBpbnN0ZWFkIGRpc2NhcmQgdGhlIGN1cnJlbnQgbm9kZSBhbmQgd2FpdCB1bnRpbCB0aGUgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGlvbiB0byBwcm9wZXJseSBtYXRjaCB1cCB0aGUga2V5ZWQgdGFyZ2V0IGVsZW1lbnQgd2l0aCBpdHMgbWF0Y2hpbmdcbiAgICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGluIHRoZSBvcmlnaW5hbCB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgYSBtYXRjaGluZyBrZXllZCBlbGVtZW50IHNvbWV3aGVyZSBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gTGV0J3MgbW92ZSB0aGUgb3JpZ2luYWwgRE9NIG5vZGUgaW50byB0aGUgY3VycmVudCBwb3NpdGlvbiBhbmQgbW9ycGhcbiAgICAgICAgICAgICAgICAgICAgICAvLyBpdC5cblxuICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IFdlIHVzZSBpbnNlcnRCZWZvcmUgaW5zdGVhZCBvZiByZXBsYWNlQ2hpbGQgYmVjYXVzZSB3ZSB3YW50IHRvIGdvIHRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYHJlbW92ZU5vZGUoKWAgZnVuY3Rpb24gZm9yIHRoZSBub2RlIHRoYXQgaXMgYmVpbmcgZGlzY2FyZGVkIHNvIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbGwgbGlmZWN5Y2xlIGhvb2tzIGFyZSBjb3JyZWN0bHkgaW52b2tlZFxuICAgICAgICAgICAgICAgICAgICAgIGZyb21FbC5pbnNlcnRCZWZvcmUobWF0Y2hpbmdGcm9tRWwsIGN1ckZyb21Ob2RlQ2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbU5leHRTaWJsaW5nID0gY3VyRnJvbU5vZGVDaGlsZC5uZXh0U2libGluZztcblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIG5vZGUgaXMga2V5ZWQgaXQgbWlnaHQgYmUgbWF0Y2hlZCB1cCBsYXRlciBzbyB3ZSBkZWZlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBza2lwIG5lc3RlZCBrZXllZCBub2RlcyBmcm9tIGJlaW5nIHJlbW92ZWQgc2luY2UgdGhlcmUgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIHN0aWxsIGEgY2hhbmNlIHRoZXkgd2lsbCBiZSBtYXRjaGVkIHVwIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQsIGZyb21FbCwgdHJ1ZSAvKiBza2lwIGtleWVkIG5vZGVzICovKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gbWF0Y2hpbmdGcm9tRWw7XG4gICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVLZXkgPSBnZXROb2RlS2V5KGN1ckZyb21Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbm9kZXMgYXJlIG5vdCBjb21wYXRpYmxlIHNpbmNlIHRoZSBcInRvXCIgbm9kZSBoYXMgYSBrZXkgYW5kIHRoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIG5vIG1hdGNoaW5nIGtleWVkIG5vZGUgaW4gdGhlIHNvdXJjZSB0cmVlXG4gICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBvcmlnaW5hbCBoYXMgYSBrZXlcbiAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGlzQ29tcGF0aWJsZSAhPT0gZmFsc2UgJiYgY29tcGFyZU5vZGVOYW1lcyhjdXJGcm9tTm9kZUNoaWxkLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgIGlmIChpc0NvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBjb21wYXRpYmxlIERPTSBlbGVtZW50cyBzbyB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBcImZyb21cIiBub2RlIHRvIG1hdGNoIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0IERPTSBub2RlLlxuICAgICAgICAgICAgICAgIC8vIE1PUlBIXG4gICAgICAgICAgICAgICAgbW9ycGhFbChjdXJGcm9tTm9kZUNoaWxkLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IFRFWFRfTk9ERSB8fCBjdXJGcm9tTm9kZVR5cGUgPT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIC8vIEJvdGggbm9kZXMgYmVpbmcgY29tcGFyZWQgYXJlIFRleHQgb3IgQ29tbWVudCBub2Rlc1xuICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyBTaW1wbHkgdXBkYXRlIG5vZGVWYWx1ZSBvbiB0aGUgb3JpZ2luYWwgbm9kZSB0b1xuICAgICAgICAgICAgICAvLyBjaGFuZ2UgdGhlIHRleHQgdmFsdWVcbiAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlQ2hpbGQubm9kZVZhbHVlICE9PSBjdXJUb05vZGVDaGlsZC5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkLm5vZGVWYWx1ZSA9IGN1clRvTm9kZUNoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgLy8gQWR2YW5jZSBib3RoIHRoZSBcInRvXCIgY2hpbGQgYW5kIHRoZSBcImZyb21cIiBjaGlsZCBzaW5jZSB3ZSBmb3VuZCBhIG1hdGNoXG4gICAgICAgICAgICAvLyBOb3RoaW5nIGVsc2UgdG8gZG8gYXMgd2UgYWxyZWFkeSByZWN1cnNpdmVseSBjYWxsZWQgbW9ycGhDaGlsZHJlbiBhYm92ZVxuICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE5vIGNvbXBhdGlibGUgbWF0Y2ggc28gcmVtb3ZlIHRoZSBvbGQgbm9kZSBmcm9tIHRoZSBET00gYW5kIGNvbnRpbnVlIHRyeWluZyB0byBmaW5kIGFcbiAgICAgICAgICAvLyBtYXRjaCBpbiB0aGUgb3JpZ2luYWwgRE9NLiBIb3dldmVyLCB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIGZyb20gbm9kZSBpcyBub3Qga2V5ZWRcbiAgICAgICAgICAvLyBzaW5jZSBpdCBpcyBwb3NzaWJsZSB0aGF0IGEga2V5ZWQgbm9kZSBtaWdodCBtYXRjaCB1cCB3aXRoIGEgbm9kZSBzb21ld2hlcmUgZWxzZSBpbiB0aGVcbiAgICAgICAgICAvLyB0YXJnZXQgdHJlZSBhbmQgd2UgZG9uJ3Qgd2FudCB0byBkaXNjYXJkIGl0IGp1c3QgeWV0IHNpbmNlIGl0IHN0aWxsIG1pZ2h0IGZpbmQgYVxuICAgICAgICAgIC8vIGhvbWUgaW4gdGhlIGZpbmFsIERPTSB0cmVlLiBBZnRlciBldmVyeXRoaW5nIGlzIGRvbmUgd2Ugd2lsbCByZW1vdmUgYW55IGtleWVkIG5vZGVzXG4gICAgICAgICAgLy8gdGhhdCBkaWRuJ3QgZmluZCBhIGhvbWVcbiAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBub2RlIGlzIGtleWVkIGl0IG1pZ2h0IGJlIG1hdGNoZWQgdXAgbGF0ZXIgc28gd2UgZGVmZXJcbiAgICAgICAgICAgIC8vIHRoZSBhY3R1YWwgcmVtb3ZhbCB0byBsYXRlclxuICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTk9URTogd2Ugc2tpcCBuZXN0ZWQga2V5ZWQgbm9kZXMgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIHRoZXJlIGlzXG4gICAgICAgICAgICAvLyAgICAgICBzdGlsbCBhIGNoYW5jZSB0aGV5IHdpbGwgYmUgbWF0Y2hlZCB1cCBsYXRlclxuICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUgLyogc2tpcCBrZXllZCBub2RlcyAqLyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgfSAvLyBFTkQ6IHdoaWxlKGN1ckZyb21Ob2RlQ2hpbGQpIHt9XG5cbiAgICAgICAgLy8gSWYgd2UgZ290IHRoaXMgZmFyIHRoZW4gd2UgZGlkIG5vdCBmaW5kIGEgY2FuZGlkYXRlIG1hdGNoIGZvclxuICAgICAgICAvLyBvdXIgXCJ0byBub2RlXCIgYW5kIHdlIGV4aGF1c3RlZCBhbGwgb2YgdGhlIGNoaWxkcmVuIFwiZnJvbVwiXG4gICAgICAgIC8vIG5vZGVzLiBUaGVyZWZvcmUsIHdlIHdpbGwganVzdCBhcHBlbmQgdGhlIGN1cnJlbnQgXCJ0b1wiIG5vZGVcbiAgICAgICAgLy8gdG8gdGhlIGVuZFxuICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5ICYmIChtYXRjaGluZ0Zyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtjdXJUb05vZGVLZXldKSAmJiBjb21wYXJlTm9kZU5hbWVzKG1hdGNoaW5nRnJvbUVsLCBjdXJUb05vZGVDaGlsZCkpIHtcbiAgICAgICAgICAvLyBNT1JQSFxuICAgICAgICAgIGlmKCFza2lwRnJvbSl7IGFkZENoaWxkKGZyb21FbCwgbWF0Y2hpbmdGcm9tRWwpOyB9XG4gICAgICAgICAgbW9ycGhFbChtYXRjaGluZ0Zyb21FbCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdCA9IG9uQmVmb3JlTm9kZUFkZGVkKGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICBpZiAob25CZWZvcmVOb2RlQWRkZWRSZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAob25CZWZvcmVOb2RlQWRkZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSBvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1clRvTm9kZUNoaWxkLmFjdHVhbGl6ZSkge1xuICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IGN1clRvTm9kZUNoaWxkLmFjdHVhbGl6ZShmcm9tRWwub3duZXJEb2N1bWVudCB8fCBkb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkQ2hpbGQoZnJvbUVsLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgIH1cblxuICAgICAgY2xlYW51cEZyb21FbChmcm9tRWwsIGN1ckZyb21Ob2RlQ2hpbGQsIGN1ckZyb21Ob2RlS2V5KTtcblxuICAgICAgdmFyIHNwZWNpYWxFbEhhbmRsZXIgPSBzcGVjaWFsRWxIYW5kbGVyc1tmcm9tRWwubm9kZU5hbWVdO1xuICAgICAgaWYgKHNwZWNpYWxFbEhhbmRsZXIpIHtcbiAgICAgICAgc3BlY2lhbEVsSGFuZGxlcihmcm9tRWwsIHRvRWwpO1xuICAgICAgfVxuICAgIH0gLy8gRU5EOiBtb3JwaENoaWxkcmVuKC4uLilcblxuICAgIHZhciBtb3JwaGVkTm9kZSA9IGZyb21Ob2RlO1xuICAgIHZhciBtb3JwaGVkTm9kZVR5cGUgPSBtb3JwaGVkTm9kZS5ub2RlVHlwZTtcbiAgICB2YXIgdG9Ob2RlVHlwZSA9IHRvTm9kZS5ub2RlVHlwZTtcblxuICAgIGlmICghY2hpbGRyZW5Pbmx5KSB7XG4gICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgYXJlIGdpdmVuIHR3byBET00gbm9kZXMgdGhhdCBhcmUgbm90XG4gICAgICAvLyBjb21wYXRpYmxlIChlLmcuIDxkaXY+IC0tPiA8c3Bhbj4gb3IgPGRpdj4gLS0+IFRFWFQpXG4gICAgICBpZiAobW9ycGhlZE5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgaWYgKHRvTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIGlmICghY29tcGFyZU5vZGVOYW1lcyhmcm9tTm9kZSwgdG9Ob2RlKSkge1xuICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGZyb21Ob2RlKTtcbiAgICAgICAgICAgIG1vcnBoZWROb2RlID0gbW92ZUNoaWxkcmVuKGZyb21Ob2RlLCBjcmVhdGVFbGVtZW50TlModG9Ob2RlLm5vZGVOYW1lLCB0b05vZGUubmFtZXNwYWNlVVJJKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEdvaW5nIGZyb20gYW4gZWxlbWVudCBub2RlIHRvIGEgdGV4dCBub2RlXG4gICAgICAgICAgbW9ycGhlZE5vZGUgPSB0b05vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobW9ycGhlZE5vZGVUeXBlID09PSBURVhUX05PREUgfHwgbW9ycGhlZE5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHsgLy8gVGV4dCBvciBjb21tZW50IG5vZGVcbiAgICAgICAgaWYgKHRvTm9kZVR5cGUgPT09IG1vcnBoZWROb2RlVHlwZSkge1xuICAgICAgICAgIGlmIChtb3JwaGVkTm9kZS5ub2RlVmFsdWUgIT09IHRvTm9kZS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgIG1vcnBoZWROb2RlLm5vZGVWYWx1ZSA9IHRvTm9kZS5ub2RlVmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG1vcnBoZWROb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRleHQgbm9kZSB0byBzb21ldGhpbmcgZWxzZVxuICAgICAgICAgIG1vcnBoZWROb2RlID0gdG9Ob2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vcnBoZWROb2RlID09PSB0b05vZGUpIHtcbiAgICAgIC8vIFRoZSBcInRvIG5vZGVcIiB3YXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgXCJmcm9tIG5vZGVcIiBzbyB3ZSBoYWQgdG9cbiAgICAgIC8vIHRvc3Mgb3V0IHRoZSBcImZyb20gbm9kZVwiIGFuZCB1c2UgdGhlIFwidG8gbm9kZVwiXG4gICAgICBvbk5vZGVEaXNjYXJkZWQoZnJvbU5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodG9Ob2RlLmlzU2FtZU5vZGUgJiYgdG9Ob2RlLmlzU2FtZU5vZGUobW9ycGhlZE5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbW9ycGhFbChtb3JwaGVkTm9kZSwgdG9Ob2RlLCBjaGlsZHJlbk9ubHkpO1xuXG4gICAgICAvLyBXZSBub3cgbmVlZCB0byBsb29wIG92ZXIgYW55IGtleWVkIG5vZGVzIHRoYXQgbWlnaHQgbmVlZCB0byBiZVxuICAgICAgLy8gcmVtb3ZlZC4gV2Ugb25seSBkbyB0aGUgcmVtb3ZhbCBpZiB3ZSBrbm93IHRoYXQgdGhlIGtleWVkIG5vZGVcbiAgICAgIC8vIG5ldmVyIGZvdW5kIGEgbWF0Y2guIFdoZW4gYSBrZXllZCBub2RlIGlzIG1hdGNoZWQgdXAgd2UgcmVtb3ZlXG4gICAgICAvLyBpdCBvdXQgb2YgZnJvbU5vZGVzTG9va3VwIGFuZCB3ZSB1c2UgZnJvbU5vZGVzTG9va3VwIHRvIGRldGVybWluZVxuICAgICAgLy8gaWYgYSBrZXllZCBub2RlIGhhcyBiZWVuIG1hdGNoZWQgdXAgb3Igbm90XG4gICAgICBpZiAoa2V5ZWRSZW1vdmFsTGlzdCkge1xuICAgICAgICBmb3IgKHZhciBpPTAsIGxlbj1rZXllZFJlbW92YWxMaXN0Lmxlbmd0aDsgaTxsZW47IGkrKykge1xuICAgICAgICAgIHZhciBlbFRvUmVtb3ZlID0gZnJvbU5vZGVzTG9va3VwW2tleWVkUmVtb3ZhbExpc3RbaV1dO1xuICAgICAgICAgIGlmIChlbFRvUmVtb3ZlKSB7XG4gICAgICAgICAgICByZW1vdmVOb2RlKGVsVG9SZW1vdmUsIGVsVG9SZW1vdmUucGFyZW50Tm9kZSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2hpbGRyZW5Pbmx5ICYmIG1vcnBoZWROb2RlICE9PSBmcm9tTm9kZSAmJiBmcm9tTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAobW9ycGhlZE5vZGUuYWN0dWFsaXplKSB7XG4gICAgICAgIG1vcnBoZWROb2RlID0gbW9ycGhlZE5vZGUuYWN0dWFsaXplKGZyb21Ob2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlIGhhZCB0byBzd2FwIG91dCB0aGUgZnJvbSBub2RlIHdpdGggYSBuZXcgbm9kZSBiZWNhdXNlIHRoZSBvbGRcbiAgICAgIC8vIG5vZGUgd2FzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIHRhcmdldCBub2RlIHRoZW4gd2UgbmVlZCB0b1xuICAgICAgLy8gcmVwbGFjZSB0aGUgb2xkIERPTSBub2RlIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZS4gVGhpcyBpcyBvbmx5XG4gICAgICAvLyBwb3NzaWJsZSBpZiB0aGUgb3JpZ2luYWwgRE9NIG5vZGUgd2FzIHBhcnQgb2YgYSBET00gdHJlZSB3aGljaFxuICAgICAgLy8gd2Uga25vdyBpcyB0aGUgY2FzZSBpZiBpdCBoYXMgYSBwYXJlbnQgbm9kZS5cbiAgICAgIGZyb21Ob2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG1vcnBoZWROb2RlLCBmcm9tTm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vcnBoZWROb2RlO1xuICB9O1xufVxuXG52YXIgbW9ycGhkb20gPSBtb3JwaGRvbUZhY3RvcnkobW9ycGhBdHRycyk7XG5cbmV4cG9ydCBkZWZhdWx0IG1vcnBoZG9tO1xuIiwgImltcG9ydCB7XG4gIFBIWF9DT01QT05FTlQsXG4gIFBIWF9ESVNBQkxFX1dJVEgsXG4gIFBIWF9GRUVEQkFDS19GT1IsXG4gIFBIWF9GRUVEQkFDS19HUk9VUCxcbiAgUEhYX1BSVU5FLFxuICBQSFhfUk9PVF9JRCxcbiAgUEhYX1NFU1NJT04sXG4gIFBIWF9TS0lQLFxuICBQSFhfTUFHSUNfSUQsXG4gIFBIWF9TVEFUSUMsXG4gIFBIWF9UUklHR0VSX0FDVElPTixcbiAgUEhYX1VQREFURSxcbiAgUEhYX1NUUkVBTSxcbiAgUEhYX1NUUkVBTV9SRUYsXG4gIFBIWF9WSUVXUE9SVF9UT1AsXG4gIFBIWF9WSUVXUE9SVF9CT1RUT00sXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGRldGVjdER1cGxpY2F0ZUlkcyxcbiAgaXNDaWRcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5pbXBvcnQgRE9NUG9zdE1vcnBoUmVzdG9yZXIgZnJvbSBcIi4vZG9tX3Bvc3RfbW9ycGhfcmVzdG9yZXJcIlxuaW1wb3J0IG1vcnBoZG9tIGZyb20gXCJtb3JwaGRvbVwiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERPTVBhdGNoIHtcbiAgc3RhdGljIHBhdGNoRWwoZnJvbUVsLCB0b0VsLCBhY3RpdmVFbGVtZW50KXtcbiAgICBtb3JwaGRvbShmcm9tRWwsIHRvRWwsIHtcbiAgICAgIGNoaWxkcmVuT25seTogZmFsc2UsXG4gICAgICBvbkJlZm9yZUVsVXBkYXRlZDogKGZyb21FbCwgdG9FbCkgPT4ge1xuICAgICAgICBpZihhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQuaXNTYW1lTm9kZShmcm9tRWwpICYmIERPTS5pc0Zvcm1JbnB1dChmcm9tRWwpKXtcbiAgICAgICAgICBET00ubWVyZ2VGb2N1c2VkSW5wdXQoZnJvbUVsLCB0b0VsKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHZpZXcsIGNvbnRhaW5lciwgaWQsIGh0bWwsIHN0cmVhbXMsIHRhcmdldENJRCl7XG4gICAgdGhpcy52aWV3ID0gdmlld1xuICAgIHRoaXMubGl2ZVNvY2tldCA9IHZpZXcubGl2ZVNvY2tldFxuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyXG4gICAgdGhpcy5pZCA9IGlkXG4gICAgdGhpcy5yb290SUQgPSB2aWV3LnJvb3QuaWRcbiAgICB0aGlzLmh0bWwgPSBodG1sXG4gICAgdGhpcy5zdHJlYW1zID0gc3RyZWFtc1xuICAgIHRoaXMuc3RyZWFtSW5zZXJ0cyA9IHt9XG4gICAgdGhpcy5zdHJlYW1Db21wb25lbnRSZXN0b3JlID0ge31cbiAgICB0aGlzLnRhcmdldENJRCA9IHRhcmdldENJRFxuICAgIHRoaXMuY2lkUGF0Y2ggPSBpc0NpZCh0aGlzLnRhcmdldENJRClcbiAgICB0aGlzLnBlbmRpbmdSZW1vdmVzID0gW11cbiAgICB0aGlzLnBoeFJlbW92ZSA9IHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKFwicmVtb3ZlXCIpXG4gICAgdGhpcy5jYWxsYmFja3MgPSB7XG4gICAgICBiZWZvcmVhZGRlZDogW10sIGJlZm9yZXVwZGF0ZWQ6IFtdLCBiZWZvcmVwaHhDaGlsZEFkZGVkOiBbXSxcbiAgICAgIGFmdGVyYWRkZWQ6IFtdLCBhZnRlcnVwZGF0ZWQ6IFtdLCBhZnRlcmRpc2NhcmRlZDogW10sIGFmdGVycGh4Q2hpbGRBZGRlZDogW10sXG4gICAgICBhZnRlcnRyYW5zaXRpb25zRGlzY2FyZGVkOiBbXVxuICAgIH1cbiAgfVxuXG4gIGJlZm9yZShraW5kLCBjYWxsYmFjayl7IHRoaXMuY2FsbGJhY2tzW2BiZWZvcmUke2tpbmR9YF0ucHVzaChjYWxsYmFjaykgfVxuICBhZnRlcihraW5kLCBjYWxsYmFjayl7IHRoaXMuY2FsbGJhY2tzW2BhZnRlciR7a2luZH1gXS5wdXNoKGNhbGxiYWNrKSB9XG5cbiAgdHJhY2tCZWZvcmUoa2luZCwgLi4uYXJncyl7XG4gICAgdGhpcy5jYWxsYmFja3NbYGJlZm9yZSR7a2luZH1gXS5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKC4uLmFyZ3MpKVxuICB9XG5cbiAgdHJhY2tBZnRlcihraW5kLCAuLi5hcmdzKXtcbiAgICB0aGlzLmNhbGxiYWNrc1tgYWZ0ZXIke2tpbmR9YF0uZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayguLi5hcmdzKSlcbiAgfVxuXG4gIG1hcmtQcnVuYWJsZUNvbnRlbnRGb3JSZW1vdmFsKCl7XG4gICAgbGV0IHBoeFVwZGF0ZSA9IHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9VUERBVEUpXG4gICAgRE9NLmFsbCh0aGlzLmNvbnRhaW5lciwgYFske3BoeFVwZGF0ZX09YXBwZW5kXSA+ICosIFske3BoeFVwZGF0ZX09cHJlcGVuZF0gPiAqYCwgZWwgPT4ge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9QUlVORSwgXCJcIilcbiAgICB9KVxuICB9XG5cbiAgcGVyZm9ybShpc0pvaW5QYXRjaCl7XG4gICAgbGV0IHt2aWV3LCBsaXZlU29ja2V0LCBjb250YWluZXIsIGh0bWx9ID0gdGhpc1xuICAgIGxldCB0YXJnZXRDb250YWluZXIgPSB0aGlzLmlzQ0lEUGF0Y2goKSA/IHRoaXMudGFyZ2V0Q0lEQ29udGFpbmVyKGh0bWwpIDogY29udGFpbmVyXG4gICAgaWYodGhpcy5pc0NJRFBhdGNoKCkgJiYgIXRhcmdldENvbnRhaW5lcil7IHJldHVybiB9XG5cbiAgICBsZXQgZm9jdXNlZCA9IGxpdmVTb2NrZXQuZ2V0QWN0aXZlRWxlbWVudCgpXG4gICAgbGV0IHtzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kfSA9IGZvY3VzZWQgJiYgRE9NLmhhc1NlbGVjdGlvblJhbmdlKGZvY3VzZWQpID8gZm9jdXNlZCA6IHt9XG4gICAgbGV0IHBoeFVwZGF0ZSA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfVVBEQVRFKVxuICAgIGxldCBwaHhGZWVkYmFja0ZvciA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfRkVFREJBQ0tfRk9SKVxuICAgIGxldCBwaHhGZWVkYmFja0dyb3VwID0gbGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9GRUVEQkFDS19HUk9VUClcbiAgICBsZXQgZGlzYWJsZVdpdGggPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX0RJU0FCTEVfV0lUSClcbiAgICBsZXQgcGh4Vmlld3BvcnRUb3AgPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX1ZJRVdQT1JUX1RPUClcbiAgICBsZXQgcGh4Vmlld3BvcnRCb3R0b20gPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX1ZJRVdQT1JUX0JPVFRPTSlcbiAgICBsZXQgcGh4VHJpZ2dlckV4dGVybmFsID0gbGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9UUklHR0VSX0FDVElPTilcbiAgICBsZXQgYWRkZWQgPSBbXVxuICAgIGxldCBmZWVkYmFja0NvbnRhaW5lcnMgPSBbXVxuICAgIGxldCB1cGRhdGVzID0gW11cbiAgICBsZXQgYXBwZW5kUHJlcGVuZFVwZGF0ZXMgPSBbXVxuXG4gICAgbGV0IGV4dGVybmFsRm9ybVRyaWdnZXJlZCA9IG51bGxcblxuICAgIGZ1bmN0aW9uIG1vcnBoKHRhcmdldENvbnRhaW5lciwgc291cmNlKXtcbiAgICAgIG1vcnBoZG9tKHRhcmdldENvbnRhaW5lciwgc291cmNlLCB7XG4gICAgICAgIGNoaWxkcmVuT25seTogdGFyZ2V0Q29udGFpbmVyLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSA9PT0gbnVsbCxcbiAgICAgICAgZ2V0Tm9kZUtleTogKG5vZGUpID0+IHtcbiAgICAgICAgICBpZihET00uaXNQaHhEZXN0cm95ZWQobm9kZSkpeyByZXR1cm4gbnVsbCB9XG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGpvaW4gcGF0Y2gsIHRoZW4gYnkgZGVmaW5pdGlvbiB0aGVyZSB3YXMgbm8gUEhYX01BR0lDX0lELlxuICAgICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IHRvIHJlZHVjZSB0aGUgYW1vdW50IG9mIGVsZW1lbnRzIG1vcnBoZG9tIGRpc2NhcmRzLlxuICAgICAgICAgIGlmKGlzSm9pblBhdGNoKXsgcmV0dXJuIG5vZGUuaWQgfVxuICAgICAgICAgIHJldHVybiBub2RlLmlkIHx8IChub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShQSFhfTUFHSUNfSUQpKVxuICAgICAgICB9LFxuICAgICAgICAvLyBza2lwIGluZGV4aW5nIGZyb20gY2hpbGRyZW4gd2hlbiBjb250YWluZXIgaXMgc3RyZWFtXG4gICAgICAgIHNraXBGcm9tQ2hpbGRyZW46IChmcm9tKSA9PiB7IHJldHVybiBmcm9tLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpID09PSBQSFhfU1RSRUFNIH0sXG4gICAgICAgIC8vIHRlbGwgbW9ycGhkb20gaG93IHRvIGFkZCBhIGNoaWxkXG4gICAgICAgIGFkZENoaWxkOiAocGFyZW50LCBjaGlsZCkgPT4ge1xuICAgICAgICAgIGxldCB7cmVmLCBzdHJlYW1BdH0gPSB0aGlzLmdldFN0cmVhbUluc2VydChjaGlsZClcbiAgICAgICAgICBpZihyZWYgPT09IHVuZGVmaW5lZCl7IHJldHVybiBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpIH1cblxuICAgICAgICAgIHRoaXMuc2V0U3RyZWFtUmVmKGNoaWxkLCByZWYpXG5cbiAgICAgICAgICAvLyBzdHJlYW1pbmdcbiAgICAgICAgICBpZihzdHJlYW1BdCA9PT0gMCl7XG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJiZWdpblwiLCBjaGlsZClcbiAgICAgICAgICB9IGVsc2UgaWYoc3RyZWFtQXQgPT09IC0xKXtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZClcbiAgICAgICAgICB9IGVsc2UgaWYoc3RyZWFtQXQgPiAwKXtcbiAgICAgICAgICAgIGxldCBzaWJsaW5nID0gQXJyYXkuZnJvbShwYXJlbnQuY2hpbGRyZW4pW3N0cmVhbUF0XVxuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgc2libGluZylcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uQmVmb3JlTm9kZUFkZGVkOiAoZWwpID0+IHtcbiAgICAgICAgICBET00ubWF5YmVBZGRQcml2YXRlSG9va3MoZWwsIHBoeFZpZXdwb3J0VG9wLCBwaHhWaWV3cG9ydEJvdHRvbSlcbiAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwiYWRkZWRcIiwgZWwpXG5cbiAgICAgICAgICBsZXQgbW9ycGhlZEVsID0gZWxcbiAgICAgICAgICAvLyB0aGlzIGlzIGEgc3RyZWFtIGl0ZW0gdGhhdCB3YXMga2VwdCBvbiByZXNldCwgcmVjdXJzaXZlbHkgbW9ycGggaXRcbiAgICAgICAgICBpZighaXNKb2luUGF0Y2ggJiYgdGhpcy5zdHJlYW1Db21wb25lbnRSZXN0b3JlW2VsLmlkXSl7XG4gICAgICAgICAgICBtb3JwaGVkRWwgPSB0aGlzLnN0cmVhbUNvbXBvbmVudFJlc3RvcmVbZWwuaWRdXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdHJlYW1Db21wb25lbnRSZXN0b3JlW2VsLmlkXVxuICAgICAgICAgICAgbW9ycGguYmluZCh0aGlzKShtb3JwaGVkRWwsIGVsKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBtb3JwaGVkRWxcbiAgICAgICAgfSxcbiAgICAgICAgb25Ob2RlQWRkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgIGlmKGVsLmdldEF0dHJpYnV0ZSl7IHRoaXMubWF5YmVSZU9yZGVyU3RyZWFtKGVsLCB0cnVlKSB9XG4gICAgICAgICAgaWYoRE9NLmlzRmVlZGJhY2tDb250YWluZXIoZWwsIHBoeEZlZWRiYWNrRm9yKSkgZmVlZGJhY2tDb250YWluZXJzLnB1c2goZWwpXG5cbiAgICAgICAgICAvLyBoYWNrIHRvIGZpeCBTYWZhcmkgaGFuZGxpbmcgb2YgaW1nIHNyY3NldCBhbmQgdmlkZW8gdGFnc1xuICAgICAgICAgIGlmKGVsIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCAmJiBlbC5zcmNzZXQpe1xuICAgICAgICAgICAgZWwuc3Jjc2V0ID0gZWwuc3Jjc2V0XG4gICAgICAgICAgfSBlbHNlIGlmKGVsIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCAmJiBlbC5hdXRvcGxheSl7XG4gICAgICAgICAgICBlbC5wbGF5KClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoRE9NLmlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlbCwgcGh4VHJpZ2dlckV4dGVybmFsKSl7XG4gICAgICAgICAgICBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBlbFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG5lc3RlZCB2aWV3IGhhbmRsaW5nXG4gICAgICAgICAgaWYoKERPTS5pc1BoeENoaWxkKGVsKSAmJiB2aWV3Lm93bnNFbGVtZW50KGVsKSkgfHwgRE9NLmlzUGh4U3RpY2t5KGVsKSAmJiB2aWV3Lm93bnNFbGVtZW50KGVsLnBhcmVudE5vZGUpKXtcbiAgICAgICAgICAgIHRoaXMudHJhY2tBZnRlcihcInBoeENoaWxkQWRkZWRcIiwgZWwpXG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZGVkLnB1c2goZWwpXG4gICAgICAgIH0sXG4gICAgICAgIG9uTm9kZURpc2NhcmRlZDogKGVsKSA9PiB0aGlzLm9uTm9kZURpc2NhcmRlZChlbCksXG4gICAgICAgIG9uQmVmb3JlTm9kZURpc2NhcmRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgaWYoZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfUFJVTkUpICE9PSBudWxsKXsgcmV0dXJuIHRydWUgfVxuICAgICAgICAgIGlmKGVsLnBhcmVudEVsZW1lbnQgIT09IG51bGwgJiYgZWwuaWQgJiZcbiAgICAgICAgICAgIERPTS5pc1BoeFVwZGF0ZShlbC5wYXJlbnRFbGVtZW50LCBwaHhVcGRhdGUsIFtQSFhfU1RSRUFNLCBcImFwcGVuZFwiLCBcInByZXBlbmRcIl0pKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZih0aGlzLm1heWJlUGVuZGluZ1JlbW92ZShlbCkpeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIGlmKHRoaXMuc2tpcENJRFNpYmxpbmcoZWwpKXsgcmV0dXJuIGZhbHNlIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIG9uRWxVcGRhdGVkOiAoZWwpID0+IHtcbiAgICAgICAgICBpZihET00uaXNOb3dUcmlnZ2VyRm9ybUV4dGVybmFsKGVsLCBwaHhUcmlnZ2VyRXh0ZXJuYWwpKXtcbiAgICAgICAgICAgIGV4dGVybmFsRm9ybVRyaWdnZXJlZCA9IGVsXG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZXMucHVzaChlbClcbiAgICAgICAgICB0aGlzLm1heWJlUmVPcmRlclN0cmVhbShlbCwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIG9uQmVmb3JlRWxVcGRhdGVkOiAoZnJvbUVsLCB0b0VsKSA9PiB7XG4gICAgICAgICAgRE9NLm1heWJlQWRkUHJpdmF0ZUhvb2tzKHRvRWwsIHBoeFZpZXdwb3J0VG9wLCBwaHhWaWV3cG9ydEJvdHRvbSlcbiAgICAgICAgICAvLyBtYXJrIGJvdGggZnJvbSBhbmQgdG8gZWxzIGFzIGZlZWRiYWNrIGNvbnRhaW5lcnMsIGFzIHdlIGRvbid0IGtub3cgeWV0IHdoaWNoIG9uZSB3aWxsIGJlIHVzZWRcbiAgICAgICAgICAvLyBhbmQgd2UgYWxzbyBuZWVkIHRvIHJlbW92ZSB0aGUgcGh4LW5vLWZlZWRiYWNrIGNsYXNzIHdoZW4gdGhlIHBoeC1mZWVkYmFjay1mb3IgYXR0cmlidXRlIGlzIHJlbW92ZWRcbiAgICAgICAgICBpZihET00uaXNGZWVkYmFja0NvbnRhaW5lcihmcm9tRWwsIHBoeEZlZWRiYWNrRm9yKSB8fCBET00uaXNGZWVkYmFja0NvbnRhaW5lcih0b0VsLCBwaHhGZWVkYmFja0Zvcikpe1xuICAgICAgICAgICAgZmVlZGJhY2tDb250YWluZXJzLnB1c2goZnJvbUVsKVxuICAgICAgICAgICAgZmVlZGJhY2tDb250YWluZXJzLnB1c2godG9FbClcbiAgICAgICAgICB9XG4gICAgICAgICAgRE9NLmNsZWFuQ2hpbGROb2Rlcyh0b0VsLCBwaHhVcGRhdGUpXG4gICAgICAgICAgaWYodGhpcy5za2lwQ0lEU2libGluZyh0b0VsKSl7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEgbGl2ZSBjb21wb25lbnQgdXNlZCBpbiBhIHN0cmVhbSwgd2UgbWF5IG5lZWQgdG8gcmVvcmRlciBpdFxuICAgICAgICAgICAgdGhpcy5tYXliZVJlT3JkZXJTdHJlYW0oZnJvbUVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKERPTS5pc1BoeFN0aWNreShmcm9tRWwpKXsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgICBpZihET00uaXNJZ25vcmVkKGZyb21FbCwgcGh4VXBkYXRlKSB8fCAoZnJvbUVsLmZvcm0gJiYgZnJvbUVsLmZvcm0uaXNTYW1lTm9kZShleHRlcm5hbEZvcm1UcmlnZ2VyZWQpKSl7XG4gICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICBET00ubWVyZ2VBdHRycyhmcm9tRWwsIHRvRWwsIHtpc0lnbm9yZWQ6IHRydWV9KVxuICAgICAgICAgICAgdXBkYXRlcy5wdXNoKGZyb21FbClcbiAgICAgICAgICAgIERPTS5hcHBseVN0aWNreU9wZXJhdGlvbnMoZnJvbUVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGZyb21FbC50eXBlID09PSBcIm51bWJlclwiICYmIChmcm9tRWwudmFsaWRpdHkgJiYgZnJvbUVsLnZhbGlkaXR5LmJhZElucHV0KSl7IHJldHVybiBmYWxzZSB9XG4gICAgICAgICAgaWYoIURPTS5zeW5jUGVuZGluZ1JlZihmcm9tRWwsIHRvRWwsIGRpc2FibGVXaXRoKSl7XG4gICAgICAgICAgICBpZihET00uaXNVcGxvYWRJbnB1dChmcm9tRWwpKXtcbiAgICAgICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgICB1cGRhdGVzLnB1c2goZnJvbUVsKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyhmcm9tRWwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBuZXN0ZWQgdmlldyBoYW5kbGluZ1xuICAgICAgICAgIGlmKERPTS5pc1BoeENoaWxkKHRvRWwpKXtcbiAgICAgICAgICAgIGxldCBwcmV2U2Vzc2lvbiA9IGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pXG4gICAgICAgICAgICBET00ubWVyZ2VBdHRycyhmcm9tRWwsIHRvRWwsIHtleGNsdWRlOiBbUEhYX1NUQVRJQ119KVxuICAgICAgICAgICAgaWYocHJldlNlc3Npb24gIT09IFwiXCIpeyBmcm9tRWwuc2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OLCBwcmV2U2Vzc2lvbikgfVxuICAgICAgICAgICAgZnJvbUVsLnNldEF0dHJpYnV0ZShQSFhfUk9PVF9JRCwgdGhpcy5yb290SUQpXG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKGZyb21FbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlucHV0IGhhbmRsaW5nXG4gICAgICAgICAgRE9NLmNvcHlQcml2YXRlcyh0b0VsLCBmcm9tRWwpXG5cbiAgICAgICAgICBsZXQgaXNGb2N1c2VkRm9ybUVsID0gZm9jdXNlZCAmJiBmcm9tRWwuaXNTYW1lTm9kZShmb2N1c2VkKSAmJiBET00uaXNGb3JtSW5wdXQoZnJvbUVsKVxuICAgICAgICAgIC8vIHNraXAgcGF0Y2hpbmcgZm9jdXNlZCBpbnB1dHMgdW5sZXNzIGZvY3VzIGlzIGEgc2VsZWN0IHRoYXQgaGFzIGNoYW5nZWQgb3B0aW9uc1xuICAgICAgICAgIGxldCBmb2N1c2VkU2VsZWN0Q2hhbmdlZCA9IGlzRm9jdXNlZEZvcm1FbCAmJiB0aGlzLmlzQ2hhbmdlZFNlbGVjdChmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgaWYoaXNGb2N1c2VkRm9ybUVsICYmIGZyb21FbC50eXBlICE9PSBcImhpZGRlblwiICYmICFmb2N1c2VkU2VsZWN0Q2hhbmdlZCl7XG4gICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICBET00ubWVyZ2VGb2N1c2VkSW5wdXQoZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgRE9NLnN5bmNBdHRyc1RvUHJvcHMoZnJvbUVsKVxuICAgICAgICAgICAgdXBkYXRlcy5wdXNoKGZyb21FbClcbiAgICAgICAgICAgIERPTS5hcHBseVN0aWNreU9wZXJhdGlvbnMoZnJvbUVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJsdXIgZm9jdXNlZCBzZWxlY3QgaWYgaXQgY2hhbmdlZCBzbyBuYXRpdmUgVUkgaXMgdXBkYXRlZCAoaWUgc2FmYXJpIHdvbid0IHVwZGF0ZSB2aXNpYmxlIG9wdGlvbnMpXG4gICAgICAgICAgICBpZihmb2N1c2VkU2VsZWN0Q2hhbmdlZCl7IGZyb21FbC5ibHVyKCkgfVxuICAgICAgICAgICAgaWYoRE9NLmlzUGh4VXBkYXRlKHRvRWwsIHBoeFVwZGF0ZSwgW1wiYXBwZW5kXCIsIFwicHJlcGVuZFwiXSkpe1xuICAgICAgICAgICAgICBhcHBlbmRQcmVwZW5kVXBkYXRlcy5wdXNoKG5ldyBET01Qb3N0TW9ycGhSZXN0b3Jlcihmcm9tRWwsIHRvRWwsIHRvRWwuZ2V0QXR0cmlidXRlKHBoeFVwZGF0ZSkpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBET00uc3luY0F0dHJzVG9Qcm9wcyh0b0VsKVxuICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyh0b0VsKVxuICAgICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy50cmFja0JlZm9yZShcImFkZGVkXCIsIGNvbnRhaW5lcilcbiAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBjb250YWluZXIsIGNvbnRhaW5lcilcblxuICAgIGxpdmVTb2NrZXQudGltZShcIm1vcnBoZG9tXCIsICgpID0+IHtcbiAgICAgIHRoaXMuc3RyZWFtcy5mb3JFYWNoKChbcmVmLCBpbnNlcnRzLCBkZWxldGVJZHMsIHJlc2V0XSkgPT4ge1xuICAgICAgICBpbnNlcnRzLmZvckVhY2goKFtrZXksIHN0cmVhbUF0LCBsaW1pdF0pID0+IHtcbiAgICAgICAgICB0aGlzLnN0cmVhbUluc2VydHNba2V5XSA9IHtyZWYsIHN0cmVhbUF0LCBsaW1pdCwgcmVzZXR9XG4gICAgICAgIH0pXG4gICAgICAgIGlmKHJlc2V0ICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAgIERPTS5hbGwoY29udGFpbmVyLCBgWyR7UEhYX1NUUkVBTV9SRUZ9PVwiJHtyZWZ9XCJdYCwgY2hpbGQgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVTdHJlYW1DaGlsZEVsZW1lbnQoY2hpbGQpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBkZWxldGVJZHMuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgICAgbGV0IGNoaWxkID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoYFtpZD1cIiR7aWR9XCJdYClcbiAgICAgICAgICBpZihjaGlsZCl7IHRoaXMucmVtb3ZlU3RyZWFtQ2hpbGRFbGVtZW50KGNoaWxkKSB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuXG4gICAgICAvLyBjbGVhciBzdHJlYW0gaXRlbXMgZnJvbSB0aGUgZGVhZCByZW5kZXIgaWYgdGhleSBhcmUgbm90IGluc2VydGVkIGFnYWluXG4gICAgICBpZihpc0pvaW5QYXRjaCl7XG4gICAgICAgIERPTS5hbGwodGhpcy5jb250YWluZXIsIGBbJHtwaHhVcGRhdGV9PSR7UEhYX1NUUkVBTX1dYCwgZWwgPT4ge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0byBvbmx5IHJlbW92ZSBlbGVtZW50cyBvd25lZCBieSB0aGUgY3VycmVudCB2aWV3XG4gICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXhfbGl2ZV92aWV3L2lzc3Vlcy8zMDQ3XG4gICAgICAgICAgdGhpcy5saXZlU29ja2V0Lm93bmVyKGVsLCAodmlldykgPT4ge1xuICAgICAgICAgICAgaWYodmlldyA9PT0gdGhpcy52aWV3KXtcbiAgICAgICAgICAgICAgQXJyYXkuZnJvbShlbC5jaGlsZHJlbikuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVTdHJlYW1DaGlsZEVsZW1lbnQoY2hpbGQpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgbW9ycGguYmluZCh0aGlzKSh0YXJnZXRDb250YWluZXIsIGh0bWwpXG4gICAgfSlcblxuICAgIGlmKGxpdmVTb2NrZXQuaXNEZWJ1Z0VuYWJsZWQoKSl7IGRldGVjdER1cGxpY2F0ZUlkcygpIH1cblxuICAgIGlmKGFwcGVuZFByZXBlbmRVcGRhdGVzLmxlbmd0aCA+IDApe1xuICAgICAgbGl2ZVNvY2tldC50aW1lKFwicG9zdC1tb3JwaCBhcHBlbmQvcHJlcGVuZCByZXN0b3JhdGlvblwiLCAoKSA9PiB7XG4gICAgICAgIGFwcGVuZFByZXBlbmRVcGRhdGVzLmZvckVhY2godXBkYXRlID0+IHVwZGF0ZS5wZXJmb3JtKCkpXG4gICAgICB9KVxuICAgIH1cblxuICAgIERPTS5tYXliZUhpZGVGZWVkYmFjayh0YXJnZXRDb250YWluZXIsIGZlZWRiYWNrQ29udGFpbmVycywgcGh4RmVlZGJhY2tGb3IsIHBoeEZlZWRiYWNrR3JvdXApXG5cbiAgICBsaXZlU29ja2V0LnNpbGVuY2VFdmVudHMoKCkgPT4gRE9NLnJlc3RvcmVGb2N1cyhmb2N1c2VkLCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSlcbiAgICBET00uZGlzcGF0Y2hFdmVudChkb2N1bWVudCwgXCJwaHg6dXBkYXRlXCIpXG4gICAgYWRkZWQuZm9yRWFjaChlbCA9PiB0aGlzLnRyYWNrQWZ0ZXIoXCJhZGRlZFwiLCBlbCkpXG4gICAgdXBkYXRlcy5mb3JFYWNoKGVsID0+IHRoaXMudHJhY2tBZnRlcihcInVwZGF0ZWRcIiwgZWwpKVxuXG4gICAgdGhpcy50cmFuc2l0aW9uUGVuZGluZ1JlbW92ZXMoKVxuXG4gICAgaWYoZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkKXtcbiAgICAgIGxpdmVTb2NrZXQudW5sb2FkKClcbiAgICAgIC8vIHVzZSBwcm90b3R5cGUncyBzdWJtaXQgaW4gY2FzZSB0aGVyZSdzIGEgZm9ybSBjb250cm9sIHdpdGggbmFtZSBvciBpZCBvZiBcInN1Ym1pdFwiXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEZvcm1FbGVtZW50L3N1Ym1pdFxuICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKGV4dGVybmFsRm9ybVRyaWdnZXJlZCkuc3VibWl0LmNhbGwoZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkKVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgb25Ob2RlRGlzY2FyZGVkKGVsKXtcbiAgICAvLyBuZXN0ZWQgdmlldyBoYW5kbGluZ1xuICAgIGlmKERPTS5pc1BoeENoaWxkKGVsKSB8fCBET00uaXNQaHhTdGlja3koZWwpKXsgdGhpcy5saXZlU29ja2V0LmRlc3Ryb3lWaWV3QnlFbChlbCkgfVxuICAgIHRoaXMudHJhY2tBZnRlcihcImRpc2NhcmRlZFwiLCBlbClcbiAgfVxuXG4gIG1heWJlUGVuZGluZ1JlbW92ZShub2RlKXtcbiAgICBpZihub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSh0aGlzLnBoeFJlbW92ZSkgIT09IG51bGwpe1xuICAgICAgdGhpcy5wZW5kaW5nUmVtb3Zlcy5wdXNoKG5vZGUpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZW1vdmVTdHJlYW1DaGlsZEVsZW1lbnQoY2hpbGQpe1xuICAgIC8vIHdlIG5lZWQgdG8gc3RvcmUgdGhlIG5vZGUgaWYgaXQgaXMgYWN0dWFsbHkgcmUtYWRkZWQgaW4gdGhlIHNhbWUgcGF0Y2hcbiAgICAvLyB3ZSBkbyBOT1Qgd2FudCB0byBleGVjdXRlIHBoeC1yZW1vdmUsIHdlIGRvIE5PVCB3YW50IHRvIGNhbGwgb25Ob2RlRGlzY2FyZGVkXG4gICAgaWYodGhpcy5zdHJlYW1JbnNlcnRzW2NoaWxkLmlkXSl7XG4gICAgICB0aGlzLnN0cmVhbUNvbXBvbmVudFJlc3RvcmVbY2hpbGQuaWRdID0gY2hpbGRcbiAgICAgIGNoaWxkLnJlbW92ZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG9ubHkgcmVtb3ZlIHRoZSBlbGVtZW50IG5vdyBpZiBpdCBoYXMgbm8gcGh4LXJlbW92ZSBiaW5kaW5nXG4gICAgICBpZighdGhpcy5tYXliZVBlbmRpbmdSZW1vdmUoY2hpbGQpKXtcbiAgICAgICAgY2hpbGQucmVtb3ZlKClcbiAgICAgICAgdGhpcy5vbk5vZGVEaXNjYXJkZWQoY2hpbGQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0U3RyZWFtSW5zZXJ0KGVsKXtcbiAgICBsZXQgaW5zZXJ0ID0gZWwuaWQgPyB0aGlzLnN0cmVhbUluc2VydHNbZWwuaWRdIDoge31cbiAgICByZXR1cm4gaW5zZXJ0IHx8IHt9XG4gIH1cblxuICBzZXRTdHJlYW1SZWYoZWwsIHJlZil7XG4gICAgRE9NLnB1dFN0aWNreShlbCwgUEhYX1NUUkVBTV9SRUYsIGVsID0+IGVsLnNldEF0dHJpYnV0ZShQSFhfU1RSRUFNX1JFRiwgcmVmKSlcbiAgfVxuXG4gIG1heWJlUmVPcmRlclN0cmVhbShlbCwgaXNOZXcpe1xuICAgIGxldCB7cmVmLCBzdHJlYW1BdCwgcmVzZXR9ID0gdGhpcy5nZXRTdHJlYW1JbnNlcnQoZWwpXG4gICAgaWYoc3RyZWFtQXQgPT09IHVuZGVmaW5lZCl7IHJldHVybiB9XG5cbiAgICAvLyB3ZSBuZWVkIHRvIHNldCB0aGUgUEhYX1NUUkVBTV9SRUYgaGVyZSBhcyB3ZWxsIGFzIGFkZENoaWxkIGlzIGludm9rZWQgb25seSBmb3IgcGFyZW50c1xuICAgIHRoaXMuc2V0U3RyZWFtUmVmKGVsLCByZWYpXG5cbiAgICBpZighcmVzZXQgJiYgIWlzTmV3KXtcbiAgICAgIC8vIHdlIG9ubHkgcmVvcmRlciBpZiB0aGUgZWxlbWVudCBpcyBuZXcgb3IgaXQncyBhIHN0cmVhbSByZXNldFxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgdGhlIGVsZW1lbnQgaGFzIGEgcGFyZW50IGVsZW1lbnQ7XG4gICAgLy8gaXQgZG9lc24ndCBpZiB3ZSBhcmUgY3VycmVudGx5IHJlY3Vyc2l2ZWx5IG1vcnBoaW5nIChyZXN0b3JpbmcgYSBzYXZlZCBzdHJlYW0gY2hpbGQpXG4gICAgLy8gYmVjYXVzZSB0aGUgZWxlbWVudCBpcyBub3QgeWV0IGFkZGVkIHRvIHRoZSByZWFsIGRvbTtcbiAgICAvLyByZW9yZGVyaW5nIGRvZXMgbm90IG1ha2Ugc2Vuc2UgaW4gdGhhdCBjYXNlIGFueXdheVxuICAgIGlmKCFlbC5wYXJlbnRFbGVtZW50KXsgcmV0dXJuIH1cblxuICAgIGlmKHN0cmVhbUF0ID09PSAwKXtcbiAgICAgIGVsLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGVsLCBlbC5wYXJlbnRFbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKVxuICAgIH0gZWxzZSBpZihzdHJlYW1BdCA+IDApe1xuICAgICAgbGV0IGNoaWxkcmVuID0gQXJyYXkuZnJvbShlbC5wYXJlbnRFbGVtZW50LmNoaWxkcmVuKVxuICAgICAgbGV0IG9sZEluZGV4ID0gY2hpbGRyZW4uaW5kZXhPZihlbClcbiAgICAgIGlmKHN0cmVhbUF0ID49IGNoaWxkcmVuLmxlbmd0aCAtIDEpe1xuICAgICAgICBlbC5wYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKGVsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHNpYmxpbmcgPSBjaGlsZHJlbltzdHJlYW1BdF1cbiAgICAgICAgaWYob2xkSW5kZXggPiBzdHJlYW1BdCl7XG4gICAgICAgICAgZWwucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoZWwsIHNpYmxpbmcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWwucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoZWwsIHNpYmxpbmcubmV4dEVsZW1lbnRTaWJsaW5nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5tYXliZUxpbWl0U3RyZWFtKGVsKVxuICB9XG5cbiAgbWF5YmVMaW1pdFN0cmVhbShlbCl7XG4gICAgbGV0IHtsaW1pdH0gPSB0aGlzLmdldFN0cmVhbUluc2VydChlbClcbiAgICBsZXQgY2hpbGRyZW4gPSBsaW1pdCAhPT0gbnVsbCAmJiBBcnJheS5mcm9tKGVsLnBhcmVudEVsZW1lbnQuY2hpbGRyZW4pXG4gICAgaWYobGltaXQgJiYgbGltaXQgPCAwICYmIGNoaWxkcmVuLmxlbmd0aCA+IGxpbWl0ICogLTEpe1xuICAgICAgY2hpbGRyZW4uc2xpY2UoMCwgY2hpbGRyZW4ubGVuZ3RoICsgbGltaXQpLmZvckVhY2goY2hpbGQgPT4gdGhpcy5yZW1vdmVTdHJlYW1DaGlsZEVsZW1lbnQoY2hpbGQpKVxuICAgIH0gZWxzZSBpZihsaW1pdCAmJiBsaW1pdCA+PSAwICYmIGNoaWxkcmVuLmxlbmd0aCA+IGxpbWl0KXtcbiAgICAgIGNoaWxkcmVuLnNsaWNlKGxpbWl0KS5mb3JFYWNoKGNoaWxkID0+IHRoaXMucmVtb3ZlU3RyZWFtQ2hpbGRFbGVtZW50KGNoaWxkKSlcbiAgICB9XG4gIH1cblxuICB0cmFuc2l0aW9uUGVuZGluZ1JlbW92ZXMoKXtcbiAgICBsZXQge3BlbmRpbmdSZW1vdmVzLCBsaXZlU29ja2V0fSA9IHRoaXNcbiAgICBpZihwZW5kaW5nUmVtb3Zlcy5sZW5ndGggPiAwKXtcbiAgICAgIGxpdmVTb2NrZXQudHJhbnNpdGlvblJlbW92ZXMocGVuZGluZ1JlbW92ZXMpXG4gICAgICBsaXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICBwZW5kaW5nUmVtb3Zlcy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICBsZXQgY2hpbGQgPSBET00uZmlyc3RQaHhDaGlsZChlbClcbiAgICAgICAgICBpZihjaGlsZCl7IGxpdmVTb2NrZXQuZGVzdHJveVZpZXdCeUVsKGNoaWxkKSB9XG4gICAgICAgICAgZWwucmVtb3ZlKClcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy50cmFja0FmdGVyKFwidHJhbnNpdGlvbnNEaXNjYXJkZWRcIiwgcGVuZGluZ1JlbW92ZXMpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlzQ2hhbmdlZFNlbGVjdChmcm9tRWwsIHRvRWwpe1xuICAgIGlmKCEoZnJvbUVsIGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpIHx8IGZyb21FbC5tdWx0aXBsZSl7IHJldHVybiBmYWxzZSB9XG4gICAgaWYoZnJvbUVsLm9wdGlvbnMubGVuZ3RoICE9PSB0b0VsLm9wdGlvbnMubGVuZ3RoKXsgcmV0dXJuIHRydWUgfVxuXG4gICAgbGV0IGZyb21TZWxlY3RlZCA9IGZyb21FbC5zZWxlY3RlZE9wdGlvbnNbMF1cbiAgICBsZXQgdG9TZWxlY3RlZCA9IHRvRWwuc2VsZWN0ZWRPcHRpb25zWzBdXG4gICAgaWYoZnJvbVNlbGVjdGVkICYmIGZyb21TZWxlY3RlZC5oYXNBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiKSl7XG4gICAgICB0b1NlbGVjdGVkLnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIGZyb21TZWxlY3RlZC5nZXRBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiKSlcbiAgICB9XG5cbiAgICAvLyBpbiBnZW5lcmFsIHdlIGhhdmUgdG8gYmUgdmVyeSBjYXJlZnVsIHdpdGggdXNpbmcgaXNFcXVhbE5vZGUgYXMgaXQgZG9lcyBub3QgYSByZWxpYWJsZVxuICAgIC8vIERPTSB0cmVlIGVxdWFsaXR5IGNoZWNrLCBidXQgZm9yIHNlbGVjdGlvbiBhdHRyaWJ1dGVzIGFuZCBvcHRpb25zIGl0IHdvcmtzIGZpbmVcbiAgICByZXR1cm4gIWZyb21FbC5pc0VxdWFsTm9kZSh0b0VsKVxuICB9XG5cbiAgaXNDSURQYXRjaCgpeyByZXR1cm4gdGhpcy5jaWRQYXRjaCB9XG5cbiAgc2tpcENJRFNpYmxpbmcoZWwpe1xuICAgIHJldHVybiBlbC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgZWwuaGFzQXR0cmlidXRlKFBIWF9TS0lQKVxuICB9XG5cbiAgdGFyZ2V0Q0lEQ29udGFpbmVyKGh0bWwpe1xuICAgIGlmKCF0aGlzLmlzQ0lEUGF0Y2goKSl7IHJldHVybiB9XG4gICAgbGV0IFtmaXJzdCwgLi4ucmVzdF0gPSBET00uZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuY29udGFpbmVyLCB0aGlzLnRhcmdldENJRClcbiAgICBpZihyZXN0Lmxlbmd0aCA9PT0gMCAmJiBET00uY2hpbGROb2RlTGVuZ3RoKGh0bWwpID09PSAxKXtcbiAgICAgIHJldHVybiBmaXJzdFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmlyc3QgJiYgZmlyc3QucGFyZW50Tm9kZVxuICAgIH1cbiAgfVxuXG4gIGluZGV4T2YocGFyZW50LCBjaGlsZCl7IHJldHVybiBBcnJheS5mcm9tKHBhcmVudC5jaGlsZHJlbikuaW5kZXhPZihjaGlsZCkgfVxufVxuIiwgImltcG9ydCB7XG4gIENPTVBPTkVOVFMsXG4gIERZTkFNSUNTLFxuICBURU1QTEFURVMsXG4gIEVWRU5UUyxcbiAgUEhYX0NPTVBPTkVOVCxcbiAgUEhYX1NLSVAsXG4gIFBIWF9NQUdJQ19JRCxcbiAgUkVQTFksXG4gIFNUQVRJQyxcbiAgVElUTEUsXG4gIFNUUkVBTSxcbiAgUk9PVCxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgaXNPYmplY3QsXG4gIGxvZ0Vycm9yLFxuICBpc0NpZCxcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5jb25zdCBWT0lEX1RBR1MgPSBuZXcgU2V0KFtcbiAgXCJhcmVhXCIsXG4gIFwiYmFzZVwiLFxuICBcImJyXCIsXG4gIFwiY29sXCIsXG4gIFwiY29tbWFuZFwiLFxuICBcImVtYmVkXCIsXG4gIFwiaHJcIixcbiAgXCJpbWdcIixcbiAgXCJpbnB1dFwiLFxuICBcImtleWdlblwiLFxuICBcImxpbmtcIixcbiAgXCJtZXRhXCIsXG4gIFwicGFyYW1cIixcbiAgXCJzb3VyY2VcIixcbiAgXCJ0cmFja1wiLFxuICBcIndiclwiXG5dKVxuY29uc3QgcXVvdGVDaGFycyA9IG5ldyBTZXQoW1wiJ1wiLCAnXCInXSlcblxuZXhwb3J0IGxldCBtb2RpZnlSb290ID0gKGh0bWwsIGF0dHJzLCBjbGVhcklubmVySFRNTCkgPT4ge1xuICBsZXQgaSA9IDBcbiAgbGV0IGluc2lkZUNvbW1lbnQgPSBmYWxzZVxuICBsZXQgYmVmb3JlVGFnLCBhZnRlclRhZywgdGFnLCB0YWdOYW1lRW5kc0F0LCBpZCwgbmV3SFRNTFxuXG4gIGxldCBsb29rYWhlYWQgPSBodG1sLm1hdGNoKC9eKFxccyooPzo8IS0tLio/LS0+XFxzKikqKTwoW15cXHNcXC8+XSspLylcbiAgaWYobG9va2FoZWFkID09PSBudWxsKSB7IHRocm93IG5ldyBFcnJvcihgbWFsZm9ybWVkIGh0bWwgJHtodG1sfWApIH1cblxuICBpID0gbG9va2FoZWFkWzBdLmxlbmd0aFxuICBiZWZvcmVUYWcgPSBsb29rYWhlYWRbMV1cbiAgdGFnID0gbG9va2FoZWFkWzJdXG4gIHRhZ05hbWVFbmRzQXQgPSBpXG5cbiAgLy8gU2NhbiB0aGUgb3BlbmluZyB0YWcgZm9yIGlkLCBpZiB0aGVyZSBpcyBhbnlcbiAgZm9yKGk7IGkgPCBodG1sLmxlbmd0aDsgaSsrKXtcbiAgICBpZihodG1sLmNoYXJBdChpKSA9PT0gXCI+XCIgKXsgYnJlYWsgfVxuICAgIGlmKGh0bWwuY2hhckF0KGkpID09PSBcIj1cIil7XG4gICAgICBsZXQgaXNJZCA9IGh0bWwuc2xpY2UoaSAtIDMsIGkpID09PSBcIiBpZFwiXG4gICAgICBpKys7XG4gICAgICBsZXQgY2hhciA9IGh0bWwuY2hhckF0KGkpXG4gICAgICBpZiAocXVvdGVDaGFycy5oYXMoY2hhcikpIHtcbiAgICAgICAgbGV0IGF0dHJTdGFydHNBdCA9IGlcbiAgICAgICAgaSsrXG4gICAgICAgIGZvcihpOyBpIDwgaHRtbC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgaWYoaHRtbC5jaGFyQXQoaSkgPT09IGNoYXIpeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSWQpIHtcbiAgICAgICAgICBpZCA9IGh0bWwuc2xpY2UoYXR0clN0YXJ0c0F0ICsgMSwgaSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IGNsb3NlQXQgPSBodG1sLmxlbmd0aCAtIDFcbiAgaW5zaWRlQ29tbWVudCA9IGZhbHNlXG4gIHdoaWxlKGNsb3NlQXQgPj0gYmVmb3JlVGFnLmxlbmd0aCArIHRhZy5sZW5ndGgpe1xuICAgIGxldCBjaGFyID0gaHRtbC5jaGFyQXQoY2xvc2VBdClcbiAgICBpZihpbnNpZGVDb21tZW50KXtcbiAgICAgIGlmKGNoYXIgPT09IFwiLVwiICYmIGh0bWwuc2xpY2UoY2xvc2VBdCAtIDMsIGNsb3NlQXQpID09PSBcIjwhLVwiKXtcbiAgICAgICAgaW5zaWRlQ29tbWVudCA9IGZhbHNlXG4gICAgICAgIGNsb3NlQXQgLT0gNFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvc2VBdCAtPSAxXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGNoYXIgPT09IFwiPlwiICYmIGh0bWwuc2xpY2UoY2xvc2VBdCAtIDIsIGNsb3NlQXQpID09PSBcIi0tXCIpe1xuICAgICAgaW5zaWRlQ29tbWVudCA9IHRydWVcbiAgICAgIGNsb3NlQXQgLT0gM1xuICAgIH0gZWxzZSBpZihjaGFyID09PSBcIj5cIil7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZUF0IC09IDFcbiAgICB9XG4gIH1cbiAgYWZ0ZXJUYWcgPSBodG1sLnNsaWNlKGNsb3NlQXQgKyAxLCBodG1sLmxlbmd0aClcblxuICBsZXQgYXR0cnNTdHIgPVxuICAgIE9iamVjdC5rZXlzKGF0dHJzKVxuICAgIC5tYXAoYXR0ciA9PiBhdHRyc1thdHRyXSA9PT0gdHJ1ZSA/IGF0dHIgOiBgJHthdHRyfT1cIiR7YXR0cnNbYXR0cl19XCJgKVxuICAgIC5qb2luKFwiIFwiKVxuXG4gIGlmKGNsZWFySW5uZXJIVE1MKXtcbiAgICAvLyBLZWVwIHRoZSBpZCBpZiBhbnlcbiAgICBsZXQgaWRBdHRyU3RyID0gaWQgPyBgIGlkPVwiJHtpZH1cImAgOiBcIlwiO1xuICAgIGlmKFZPSURfVEFHUy5oYXModGFnKSl7XG4gICAgICBuZXdIVE1MID0gYDwke3RhZ30ke2lkQXR0clN0cn0ke2F0dHJzU3RyID09PSBcIlwiID8gXCJcIiA6IFwiIFwifSR7YXR0cnNTdHJ9Lz5gXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0hUTUwgPSBgPCR7dGFnfSR7aWRBdHRyU3RyfSR7YXR0cnNTdHIgPT09IFwiXCIgPyBcIlwiIDogXCIgXCJ9JHthdHRyc1N0cn0+PC8ke3RhZ30+YFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgcmVzdCA9IGh0bWwuc2xpY2UodGFnTmFtZUVuZHNBdCwgY2xvc2VBdCArIDEpXG4gICAgbmV3SFRNTCA9IGA8JHt0YWd9JHthdHRyc1N0ciA9PT0gXCJcIiA/IFwiXCIgOiBcIiBcIn0ke2F0dHJzU3RyfSR7cmVzdH1gXG4gIH1cblxuICByZXR1cm4gW25ld0hUTUwsIGJlZm9yZVRhZywgYWZ0ZXJUYWddXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmVkIHtcbiAgc3RhdGljIGV4dHJhY3QoZGlmZil7XG4gICAgbGV0IHtbUkVQTFldOiByZXBseSwgW0VWRU5UU106IGV2ZW50cywgW1RJVExFXTogdGl0bGV9ID0gZGlmZlxuICAgIGRlbGV0ZSBkaWZmW1JFUExZXVxuICAgIGRlbGV0ZSBkaWZmW0VWRU5UU11cbiAgICBkZWxldGUgZGlmZltUSVRMRV1cbiAgICByZXR1cm4ge2RpZmYsIHRpdGxlLCByZXBseTogcmVwbHkgfHwgbnVsbCwgZXZlbnRzOiBldmVudHMgfHwgW119XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih2aWV3SWQsIHJlbmRlcmVkKXtcbiAgICB0aGlzLnZpZXdJZCA9IHZpZXdJZFxuICAgIHRoaXMucmVuZGVyZWQgPSB7fVxuICAgIHRoaXMubWFnaWNJZCA9IDBcbiAgICB0aGlzLm1lcmdlRGlmZihyZW5kZXJlZClcbiAgfVxuXG4gIHBhcmVudFZpZXdJZCgpeyByZXR1cm4gdGhpcy52aWV3SWQgfVxuXG4gIHRvU3RyaW5nKG9ubHlDaWRzKXtcbiAgICBsZXQgW3N0ciwgc3RyZWFtc10gPSB0aGlzLnJlY3Vyc2l2ZVRvU3RyaW5nKHRoaXMucmVuZGVyZWQsIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10sIG9ubHlDaWRzLCB0cnVlLCB7fSlcbiAgICByZXR1cm4gW3N0ciwgc3RyZWFtc11cbiAgfVxuXG4gIHJlY3Vyc2l2ZVRvU3RyaW5nKHJlbmRlcmVkLCBjb21wb25lbnRzID0gcmVuZGVyZWRbQ09NUE9ORU5UU10sIG9ubHlDaWRzLCBjaGFuZ2VUcmFja2luZywgcm9vdEF0dHJzKXtcbiAgICBvbmx5Q2lkcyA9IG9ubHlDaWRzID8gbmV3IFNldChvbmx5Q2lkcykgOiBudWxsXG4gICAgbGV0IG91dHB1dCA9IHtidWZmZXI6IFwiXCIsIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsIG9ubHlDaWRzOiBvbmx5Q2lkcywgc3RyZWFtczogbmV3IFNldCgpfVxuICAgIHRoaXMudG9PdXRwdXRCdWZmZXIocmVuZGVyZWQsIG51bGwsIG91dHB1dCwgY2hhbmdlVHJhY2tpbmcsIHJvb3RBdHRycylcbiAgICByZXR1cm4gW291dHB1dC5idWZmZXIsIG91dHB1dC5zdHJlYW1zXVxuICB9XG5cbiAgY29tcG9uZW50Q0lEcyhkaWZmKXsgcmV0dXJuIE9iamVjdC5rZXlzKGRpZmZbQ09NUE9ORU5UU10gfHwge30pLm1hcChpID0+IHBhcnNlSW50KGkpKSB9XG5cbiAgaXNDb21wb25lbnRPbmx5RGlmZihkaWZmKXtcbiAgICBpZighZGlmZltDT01QT05FTlRTXSl7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGRpZmYpLmxlbmd0aCA9PT0gMVxuICB9XG5cbiAgZ2V0Q29tcG9uZW50KGRpZmYsIGNpZCl7IHJldHVybiBkaWZmW0NPTVBPTkVOVFNdW2NpZF0gfVxuXG4gIHJlc2V0UmVuZGVyKGNpZCl7XG4gICAgLy8gd2UgYXJlIHJhY2luZyBhIGNvbXBvbmVudCBkZXN0cm95LCBpdCBjb3VsZCBub3QgZXhpc3QsIHNvXG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgd2UgZG9uJ3QgdHJ5IHRvIHNldCByZXNldCBvbiB1bmRlZmluZWRcbiAgICBpZih0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdW2NpZF0pe1xuICAgICAgdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXVtjaWRdLnJlc2V0ID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIG1lcmdlRGlmZihkaWZmKXtcbiAgICBsZXQgbmV3YyA9IGRpZmZbQ09NUE9ORU5UU11cbiAgICBsZXQgY2FjaGUgPSB7fVxuICAgIGRlbGV0ZSBkaWZmW0NPTVBPTkVOVFNdXG4gICAgdGhpcy5yZW5kZXJlZCA9IHRoaXMubXV0YWJsZU1lcmdlKHRoaXMucmVuZGVyZWQsIGRpZmYpXG4gICAgdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXSA9IHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10gfHwge31cblxuICAgIGlmKG5ld2Mpe1xuICAgICAgbGV0IG9sZGMgPSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdXG5cbiAgICAgIGZvcihsZXQgY2lkIGluIG5ld2Mpe1xuICAgICAgICBuZXdjW2NpZF0gPSB0aGlzLmNhY2hlZEZpbmRDb21wb25lbnQoY2lkLCBuZXdjW2NpZF0sIG9sZGMsIG5ld2MsIGNhY2hlKVxuICAgICAgfVxuXG4gICAgICBmb3IobGV0IGNpZCBpbiBuZXdjKXsgb2xkY1tjaWRdID0gbmV3Y1tjaWRdIH1cbiAgICAgIGRpZmZbQ09NUE9ORU5UU10gPSBuZXdjXG4gICAgfVxuICB9XG5cbiAgY2FjaGVkRmluZENvbXBvbmVudChjaWQsIGNkaWZmLCBvbGRjLCBuZXdjLCBjYWNoZSl7XG4gICAgaWYoY2FjaGVbY2lkXSl7XG4gICAgICByZXR1cm4gY2FjaGVbY2lkXVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmRpZmYsIHN0YXQsIHNjaWQgPSBjZGlmZltTVEFUSUNdXG5cbiAgICAgIGlmKGlzQ2lkKHNjaWQpKXtcbiAgICAgICAgbGV0IHRkaWZmXG5cbiAgICAgICAgaWYoc2NpZCA+IDApe1xuICAgICAgICAgIHRkaWZmID0gdGhpcy5jYWNoZWRGaW5kQ29tcG9uZW50KHNjaWQsIG5ld2Nbc2NpZF0sIG9sZGMsIG5ld2MsIGNhY2hlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRkaWZmID0gb2xkY1stc2NpZF1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXQgPSB0ZGlmZltTVEFUSUNdXG4gICAgICAgIG5kaWZmID0gdGhpcy5jbG9uZU1lcmdlKHRkaWZmLCBjZGlmZiwgdHJ1ZSlcbiAgICAgICAgbmRpZmZbU1RBVElDXSA9IHN0YXRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5kaWZmID0gY2RpZmZbU1RBVElDXSAhPT0gdW5kZWZpbmVkIHx8IG9sZGNbY2lkXSA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICBjZGlmZiA6IHRoaXMuY2xvbmVNZXJnZShvbGRjW2NpZF0sIGNkaWZmLCBmYWxzZSlcbiAgICAgIH1cblxuICAgICAgY2FjaGVbY2lkXSA9IG5kaWZmXG4gICAgICByZXR1cm4gbmRpZmZcbiAgICB9XG4gIH1cblxuICBtdXRhYmxlTWVyZ2UodGFyZ2V0LCBzb3VyY2Upe1xuICAgIGlmKHNvdXJjZVtTVEFUSUNdICE9PSB1bmRlZmluZWQpe1xuICAgICAgcmV0dXJuIHNvdXJjZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvTXV0YWJsZU1lcmdlKHRhcmdldCwgc291cmNlKVxuICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH1cbiAgfVxuXG4gIGRvTXV0YWJsZU1lcmdlKHRhcmdldCwgc291cmNlKXtcbiAgICBmb3IobGV0IGtleSBpbiBzb3VyY2Upe1xuICAgICAgbGV0IHZhbCA9IHNvdXJjZVtrZXldXG4gICAgICBsZXQgdGFyZ2V0VmFsID0gdGFyZ2V0W2tleV1cbiAgICAgIGxldCBpc09ialZhbCA9IGlzT2JqZWN0KHZhbClcbiAgICAgIGlmKGlzT2JqVmFsICYmIHZhbFtTVEFUSUNdID09PSB1bmRlZmluZWQgJiYgaXNPYmplY3QodGFyZ2V0VmFsKSl7XG4gICAgICAgIHRoaXMuZG9NdXRhYmxlTWVyZ2UodGFyZ2V0VmFsLCB2YWwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbFxuICAgICAgfVxuICAgIH1cbiAgICBpZih0YXJnZXRbUk9PVF0pe1xuICAgICAgdGFyZ2V0Lm5ld1JlbmRlciA9IHRydWVcbiAgICB9XG4gIH1cblxuICAvLyBNZXJnZXMgY2lkIHRyZWVzIHRvZ2V0aGVyLCBjb3B5aW5nIHN0YXRpY3MgZnJvbSBzb3VyY2UgdHJlZS5cbiAgLy9cbiAgLy8gVGhlIGBwcnVuZU1hZ2ljSWRgIGlzIHBhc3NlZCB0byBjb250cm9sIHBydW5pbmcgdGhlIG1hZ2ljSWQgb2YgdGhlXG4gIC8vIHRhcmdldC4gV2UgbXVzdCBhbHdheXMgcHJ1bmUgdGhlIG1hZ2ljSWQgd2hlbiB3ZSBhcmUgc2hhcmluZyBzdGF0aWNzXG4gIC8vIGZyb20gYW5vdGhlciBjb21wb25lbnQuIElmIG5vdCBwcnVuaW5nLCB3ZSByZXBsaWNhdGUgdGhlIGxvZ2ljIGZyb21cbiAgLy8gbXV0YWJsZU1lcmdlLCB3aGVyZSB3ZSBzZXQgbmV3UmVuZGVyIHRvIHRydWUgaWYgdGhlcmUgaXMgYSByb290XG4gIC8vIChlZmZlY3RpdmVseSBmb3JjaW5nIHRoZSBuZXcgdmVyc2lvbiB0byBiZSByZW5kZXJlZCBpbnN0ZWFkIG9mIHNraXBwZWQpXG4gIC8vXG4gIGNsb25lTWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHBydW5lTWFnaWNJZCl7XG4gICAgbGV0IG1lcmdlZCA9IHsuLi50YXJnZXQsIC4uLnNvdXJjZX1cbiAgICBmb3IobGV0IGtleSBpbiBtZXJnZWQpe1xuICAgICAgbGV0IHZhbCA9IHNvdXJjZVtrZXldXG4gICAgICBsZXQgdGFyZ2V0VmFsID0gdGFyZ2V0W2tleV1cbiAgICAgIGlmKGlzT2JqZWN0KHZhbCkgJiYgdmFsW1NUQVRJQ10gPT09IHVuZGVmaW5lZCAmJiBpc09iamVjdCh0YXJnZXRWYWwpKXtcbiAgICAgICAgbWVyZ2VkW2tleV0gPSB0aGlzLmNsb25lTWVyZ2UodGFyZ2V0VmFsLCB2YWwsIHBydW5lTWFnaWNJZClcbiAgICAgIH0gZWxzZSBpZih2YWwgPT09IHVuZGVmaW5lZCAmJiBpc09iamVjdCh0YXJnZXRWYWwpKXtcbiAgICAgICAgbWVyZ2VkW2tleV0gPSB0aGlzLmNsb25lTWVyZ2UodGFyZ2V0VmFsLCB7fSwgcHJ1bmVNYWdpY0lkKVxuICAgICAgfVxuICAgIH1cbiAgICBpZihwcnVuZU1hZ2ljSWQpe1xuICAgICAgZGVsZXRlIG1lcmdlZC5tYWdpY0lkXG4gICAgICBkZWxldGUgbWVyZ2VkLm5ld1JlbmRlclxuICAgIH0gZWxzZSBpZih0YXJnZXRbUk9PVF0pe1xuICAgICAgbWVyZ2VkLm5ld1JlbmRlciA9IHRydWVcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZFxuICB9XG5cbiAgY29tcG9uZW50VG9TdHJpbmcoY2lkKXtcbiAgICBsZXQgW3N0ciwgc3RyZWFtc10gPSB0aGlzLnJlY3Vyc2l2ZUNJRFRvU3RyaW5nKHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10sIGNpZCwgbnVsbClcbiAgICBsZXQgW3N0cmlwcGVkSFRNTCwgX2JlZm9yZSwgX2FmdGVyXSA9IG1vZGlmeVJvb3Qoc3RyLCB7fSlcbiAgICByZXR1cm4gW3N0cmlwcGVkSFRNTCwgc3RyZWFtc11cbiAgfVxuXG4gIHBydW5lQ0lEcyhjaWRzKXtcbiAgICBjaWRzLmZvckVhY2goY2lkID0+IGRlbGV0ZSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdW2NpZF0pXG4gIH1cblxuICAvLyBwcml2YXRlXG5cbiAgZ2V0KCl7IHJldHVybiB0aGlzLnJlbmRlcmVkIH1cblxuICBpc05ld0ZpbmdlcnByaW50KGRpZmYgPSB7fSl7IHJldHVybiAhIWRpZmZbU1RBVElDXSB9XG5cbiAgdGVtcGxhdGVTdGF0aWMocGFydCwgdGVtcGxhdGVzKXtcbiAgICBpZih0eXBlb2YgKHBhcnQpID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gdGVtcGxhdGVzW3BhcnRdXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJ0XG4gICAgfVxuICB9XG5cbiAgbmV4dE1hZ2ljSUQoKXtcbiAgICB0aGlzLm1hZ2ljSWQrK1xuICAgIHJldHVybiBgbSR7dGhpcy5tYWdpY0lkfS0ke3RoaXMucGFyZW50Vmlld0lkKCl9YFxuICB9XG5cbiAgLy8gQ29udmVydHMgcmVuZGVyZWQgdHJlZSB0byBvdXRwdXQgYnVmZmVyLlxuICAvL1xuICAvLyBjaGFuZ2VUcmFja2luZyBjb250cm9scyBpZiB3ZSBjYW4gYXBwbHkgdGhlIFBIWF9TS0lQIG9wdGltaXphdGlvbi5cbiAgLy8gSXQgaXMgZGlzYWJsZWQgZm9yIGNvbXByZWhlbnNpb25zIHNpbmNlIHdlIG11c3QgcmUtcmVuZGVyIHRoZSBlbnRpcmUgY29sbGVjdGlvblxuICAvLyBhbmQgbm8gaW5kaXZpZHVhbCBlbGVtZW50IGlzIHRyYWNrZWQgaW5zaWRlIHRoZSBjb21wcmVoZW5zaW9uLlxuICB0b091dHB1dEJ1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQsIGNoYW5nZVRyYWNraW5nLCByb290QXR0cnMgPSB7fSl7XG4gICAgaWYocmVuZGVyZWRbRFlOQU1JQ1NdKXsgcmV0dXJuIHRoaXMuY29tcHJlaGVuc2lvblRvQnVmZmVyKHJlbmRlcmVkLCB0ZW1wbGF0ZXMsIG91dHB1dCkgfVxuICAgIGxldCB7W1NUQVRJQ106IHN0YXRpY3N9ID0gcmVuZGVyZWRcbiAgICBzdGF0aWNzID0gdGhpcy50ZW1wbGF0ZVN0YXRpYyhzdGF0aWNzLCB0ZW1wbGF0ZXMpXG4gICAgbGV0IGlzUm9vdCA9IHJlbmRlcmVkW1JPT1RdXG4gICAgbGV0IHByZXZCdWZmZXIgPSBvdXRwdXQuYnVmZmVyXG4gICAgaWYoaXNSb290KXsgb3V0cHV0LmJ1ZmZlciA9IFwiXCIgfVxuXG4gICAgLy8gdGhpcyBjb25kaXRpb24gaXMgY2FsbGVkIHdoZW4gZmlyc3QgcmVuZGVyaW5nIGFuIG9wdGltaXphYmxlIGZ1bmN0aW9uIGNvbXBvbmVudC5cbiAgICAvLyBMQyBoYXZlIHRoZWlyIG1hZ2ljSWQgcHJldmlvdXNseSBzZXRcbiAgICBpZihjaGFuZ2VUcmFja2luZyAmJiBpc1Jvb3QgJiYgIXJlbmRlcmVkLm1hZ2ljSWQpe1xuICAgICAgcmVuZGVyZWQubmV3UmVuZGVyID0gdHJ1ZVxuICAgICAgcmVuZGVyZWQubWFnaWNJZCA9IHRoaXMubmV4dE1hZ2ljSUQoKVxuICAgIH1cblxuICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1swXVxuICAgIGZvcihsZXQgaSA9IDE7IGkgPCBzdGF0aWNzLmxlbmd0aDsgaSsrKXtcbiAgICAgIHRoaXMuZHluYW1pY1RvQnVmZmVyKHJlbmRlcmVkW2kgLSAxXSwgdGVtcGxhdGVzLCBvdXRwdXQsIGNoYW5nZVRyYWNraW5nKVxuICAgICAgb3V0cHV0LmJ1ZmZlciArPSBzdGF0aWNzW2ldXG4gICAgfVxuXG4gICAgLy8gQXBwbGllcyB0aGUgcm9vdCB0YWcgXCJza2lwXCIgb3B0aW1pemF0aW9uIGlmIHN1cHBvcnRlZCwgd2hpY2ggY2xlYXJzXG4gICAgLy8gdGhlIHJvb3QgdGFnIGF0dHJpYnV0ZXMgYW5kIGlubmVySFRNTCwgYW5kIG9ubHkgbWFpbnRhaW5zIHRoZSBtYWdpY0lkLlxuICAgIC8vIFdlIGNhbiBvbmx5IHNraXAgd2hlbiBjaGFuZ2VUcmFja2luZyBpcyBzdXBwb3J0ZWQgKG91dHNpZGUgb2YgYSBjb21wcmVoZW5zaW9uKSxcbiAgICAvLyBhbmQgd2hlbiB0aGUgcm9vdCBlbGVtZW50IGhhc24ndCBleHBlcmllbmNlZCBhbiB1bnJlbmRlcmVkIG1lcmdlIChuZXdSZW5kZXIgdHJ1ZSkuXG4gICAgaWYoaXNSb290KXtcbiAgICAgIGxldCBza2lwID0gZmFsc2VcbiAgICAgIGxldCBhdHRyc1xuICAgICAgLy8gV2hlbiBhIExDIGlzIHJlLWFkZGVkIHRvIHRoZSBwYWdlLCB3ZSBuZWVkIHRvIHJlLXJlbmRlciB0aGUgZW50aXJlIExDIHRyZWUsXG4gICAgICAvLyB0aGVyZWZvcmUgY2hhbmdlVHJhY2tpbmcgaXMgZmFsc2U7IGhvd2V2ZXIsIHdlIG5lZWQgdG8ga2VlcCBhbGwgdGhlIG1hZ2ljSWRzXG4gICAgICAvLyBmcm9tIGFueSBmdW5jdGlvbiBjb21wb25lbnQgc28gdGhlIG5leHQgdGltZSB0aGUgTEMgaXMgdXBkYXRlZCwgd2UgY2FuIGFwcGx5XG4gICAgICAvLyB0aGUgc2tpcCBvcHRpbWl6YXRpb25cbiAgICAgIGlmKGNoYW5nZVRyYWNraW5nIHx8IHJlbmRlcmVkLm1hZ2ljSWQpe1xuICAgICAgICBza2lwID0gY2hhbmdlVHJhY2tpbmcgJiYgIXJlbmRlcmVkLm5ld1JlbmRlclxuICAgICAgICBhdHRycyA9IHtbUEhYX01BR0lDX0lEXTogcmVuZGVyZWQubWFnaWNJZCwgLi4ucm9vdEF0dHJzfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cnMgPSByb290QXR0cnNcbiAgICAgIH1cbiAgICAgIGlmKHNraXApeyBhdHRyc1tQSFhfU0tJUF0gPSB0cnVlIH1cbiAgICAgIGxldCBbbmV3Um9vdCwgY29tbWVudEJlZm9yZSwgY29tbWVudEFmdGVyXSA9IG1vZGlmeVJvb3Qob3V0cHV0LmJ1ZmZlciwgYXR0cnMsIHNraXApXG4gICAgICByZW5kZXJlZC5uZXdSZW5kZXIgPSBmYWxzZVxuICAgICAgb3V0cHV0LmJ1ZmZlciA9IHByZXZCdWZmZXIgKyBjb21tZW50QmVmb3JlICsgbmV3Um9vdCArIGNvbW1lbnRBZnRlclxuICAgIH1cbiAgfVxuXG4gIGNvbXByZWhlbnNpb25Ub0J1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQpe1xuICAgIGxldCB7W0RZTkFNSUNTXTogZHluYW1pY3MsIFtTVEFUSUNdOiBzdGF0aWNzLCBbU1RSRUFNXTogc3RyZWFtfSA9IHJlbmRlcmVkXG4gICAgbGV0IFtfcmVmLCBfaW5zZXJ0cywgZGVsZXRlSWRzLCByZXNldF0gPSBzdHJlYW0gfHwgW251bGwsIHt9LCBbXSwgbnVsbF1cbiAgICBzdGF0aWNzID0gdGhpcy50ZW1wbGF0ZVN0YXRpYyhzdGF0aWNzLCB0ZW1wbGF0ZXMpXG4gICAgbGV0IGNvbXBUZW1wbGF0ZXMgPSB0ZW1wbGF0ZXMgfHwgcmVuZGVyZWRbVEVNUExBVEVTXVxuICAgIGZvcihsZXQgZCA9IDA7IGQgPCBkeW5hbWljcy5sZW5ndGg7IGQrKyl7XG4gICAgICBsZXQgZHluYW1pYyA9IGR5bmFtaWNzW2RdXG4gICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbMF1cbiAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCBzdGF0aWNzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgLy8gSW5zaWRlIGEgY29tcHJlaGVuc2lvbiwgd2UgZG9uJ3QgdHJhY2sgaG93IGR5bmFtaWNzIGNoYW5nZVxuICAgICAgICAvLyBvdmVyIHRpbWUgKGFuZCBmZWF0dXJlcyBsaWtlIHN0cmVhbXMgd291bGQgbWFrZSB0aGF0IGltcG9zc2libGVcbiAgICAgICAgLy8gdW5sZXNzIHdlIG1vdmUgdGhlIHN0cmVhbSBkaWZmaW5nIGF3YXkgZnJvbSBtb3JwaGRvbSksXG4gICAgICAgIC8vIHNvIHdlIGNhbid0IHBlcmZvcm0gcm9vdCBjaGFuZ2UgdHJhY2tpbmcuXG4gICAgICAgIGxldCBjaGFuZ2VUcmFja2luZyA9IGZhbHNlXG4gICAgICAgIHRoaXMuZHluYW1pY1RvQnVmZmVyKGR5bmFtaWNbaSAtIDFdLCBjb21wVGVtcGxhdGVzLCBvdXRwdXQsIGNoYW5nZVRyYWNraW5nKVxuICAgICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbaV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihzdHJlYW0gIT09IHVuZGVmaW5lZCAmJiAocmVuZGVyZWRbRFlOQU1JQ1NdLmxlbmd0aCA+IDAgfHwgZGVsZXRlSWRzLmxlbmd0aCA+IDAgfHwgcmVzZXQpKXtcbiAgICAgIGRlbGV0ZSByZW5kZXJlZFtTVFJFQU1dXG4gICAgICByZW5kZXJlZFtEWU5BTUlDU10gPSBbXVxuICAgICAgb3V0cHV0LnN0cmVhbXMuYWRkKHN0cmVhbSlcbiAgICB9XG4gIH1cblxuICBkeW5hbWljVG9CdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0LCBjaGFuZ2VUcmFja2luZyl7XG4gICAgaWYodHlwZW9mIChyZW5kZXJlZCkgPT09IFwibnVtYmVyXCIpe1xuICAgICAgbGV0IFtzdHIsIHN0cmVhbXNdID0gdGhpcy5yZWN1cnNpdmVDSURUb1N0cmluZyhvdXRwdXQuY29tcG9uZW50cywgcmVuZGVyZWQsIG91dHB1dC5vbmx5Q2lkcylcbiAgICAgIG91dHB1dC5idWZmZXIgKz0gc3RyXG4gICAgICBvdXRwdXQuc3RyZWFtcyA9IG5ldyBTZXQoWy4uLm91dHB1dC5zdHJlYW1zLCAuLi5zdHJlYW1zXSlcbiAgICB9IGVsc2UgaWYoaXNPYmplY3QocmVuZGVyZWQpKXtcbiAgICAgIHRoaXMudG9PdXRwdXRCdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0LCBjaGFuZ2VUcmFja2luZywge30pXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5idWZmZXIgKz0gcmVuZGVyZWRcbiAgICB9XG4gIH1cblxuICByZWN1cnNpdmVDSURUb1N0cmluZyhjb21wb25lbnRzLCBjaWQsIG9ubHlDaWRzKXtcbiAgICBsZXQgY29tcG9uZW50ID0gY29tcG9uZW50c1tjaWRdIHx8IGxvZ0Vycm9yKGBubyBjb21wb25lbnQgZm9yIENJRCAke2NpZH1gLCBjb21wb25lbnRzKVxuICAgIGxldCBhdHRycyA9IHtbUEhYX0NPTVBPTkVOVF06IGNpZH1cbiAgICBsZXQgc2tpcCA9IG9ubHlDaWRzICYmICFvbmx5Q2lkcy5oYXMoY2lkKVxuICAgIC8vIFR3byBvcHRpbWl6YXRpb24gcGF0aHMgYXBwbHkgaGVyZTpcbiAgICAvL1xuICAgIC8vICAgMS4gVGhlIG9ubHlDaWRzIG9wdGltaXphdGlvbiB3b3JrcyBieSB0aGUgc2VydmVyIGRpZmYgdGVsbGluZyB1cyBvbmx5IHNwZWNpZmljXG4gICAgLy8gICAgIGNpZCdzIGhhdmUgY2hhbmdlZC4gVGhpcyBhbGxvd3MgdXMgdG8gc2tpcCByZW5kZXJpbmcgYW55IGNvbXBvbmVudCB0aGF0IGhhc24ndCBjaGFuZ2VkLFxuICAgIC8vICAgICB3aGljaCB1bHRpbWF0ZWx5IHNldHMgUEhYX1NLSVAgcm9vdCBhdHRyaWJ1dGUgYW5kIGF2b2lkcyByZW5kZXJpbmcgdGhlIGlubmVySFRNTC5cbiAgICAvL1xuICAgIC8vICAgMi4gVGhlIHJvb3QgUEhYX1NLSVAgb3B0aW1pemF0aW9uIGdlbmVyYWxpemVzIHRvIGFsbCBIRUV4IGZ1bmN0aW9uIGNvbXBvbmVudHMsIGFuZFxuICAgIC8vICAgICB3b3JrcyBpbiB0aGUgc2FtZSBQSFhfU0tJUCBhdHRyaWJ1dGUgZmFzaGlvbiBhcyAxLCBidXQgdGhlIG5ld1JlbmRlciB0cmFja2luZyBpcyBkb25lXG4gICAgLy8gICAgIGF0IHRoZSBnZW5lcmFsIGRpZmYgbWVyZ2UgbGV2ZWwuIElmIHdlIG1lcmdlIGEgZGlmZiB3aXRoIG5ldyBkeW5hbWljcywgd2UgbmVjZXNzYXJpbHkgaGF2ZVxuICAgIC8vICAgICBleHBlcmllbmNlZCBhIGNoYW5nZSB3aGljaCBtdXN0IGJlIGEgbmV3UmVuZGVyLCBhbmQgdGh1cyB3ZSBjYW4ndCBza2lwIHRoZSByZW5kZXIuXG4gICAgLy9cbiAgICAvLyBCb3RoIG9wdGltaXphdGlvbiBmbG93cyBhcHBseSBoZXJlLiBuZXdSZW5kZXIgaXMgc2V0IGJhc2VkIG9uIHRoZSBvbmx5Q2lkcyBvcHRpbWl6YXRpb24sIGFuZFxuICAgIC8vIHdlIHRyYWNrIGEgZGV0ZXJtaW5pc3RpYyBtYWdpY0lkIGJhc2VkIG9uIHRoZSBjaWQuXG4gICAgLy9cbiAgICAvLyBjaGFuZ2VUcmFja2luZyBpcyBhYm91dCB0aGUgZW50aXJlIHRyZWVcbiAgICAvLyBuZXdSZW5kZXIgaXMgYWJvdXQgdGhlIGN1cnJlbnQgcm9vdCBpbiB0aGUgdHJlZVxuICAgIC8vXG4gICAgLy8gQnkgZGVmYXVsdCBjaGFuZ2VUcmFja2luZyBpcyBlbmFibGVkLCBidXQgd2Ugc3BlY2lhbCBjYXNlIHRoZSBmbG93IHdoZXJlIHRoZSBjbGllbnQgaXMgcHJ1bmluZ1xuICAgIC8vIGNpZHMgYW5kIHRoZSBzZXJ2ZXIgYWRkcyB0aGUgY29tcG9uZW50IGJhY2suIEluIHN1Y2ggY2FzZXMsIHdlIGV4cGxpY2l0bHkgZGlzYWJsZSBjaGFuZ2VUcmFja2luZ1xuICAgIC8vIHdpdGggcmVzZXRSZW5kZXIgZm9yIHRoaXMgY2lkLCB0aGVuIHJlLWVuYWJsZSBpdCBhZnRlciB0aGUgcmVjdXJzaXZlIGNhbGwgdG8gc2tpcCB0aGUgb3B0aW1pemF0aW9uXG4gICAgLy8gZm9yIHRoZSBlbnRpcmUgY29tcG9uZW50IHRyZWUuXG4gICAgY29tcG9uZW50Lm5ld1JlbmRlciA9ICFza2lwXG4gICAgY29tcG9uZW50Lm1hZ2ljSWQgPSBgYyR7Y2lkfS0ke3RoaXMucGFyZW50Vmlld0lkKCl9YFxuICAgIC8vIGVuYWJsZSBjaGFuZ2UgdHJhY2tpbmcgYXMgbG9uZyBhcyB0aGUgY29tcG9uZW50IGhhc24ndCBiZWVuIHJlc2V0XG4gICAgbGV0IGNoYW5nZVRyYWNraW5nID0gIWNvbXBvbmVudC5yZXNldFxuICAgIGxldCBbaHRtbCwgc3RyZWFtc10gPSB0aGlzLnJlY3Vyc2l2ZVRvU3RyaW5nKGNvbXBvbmVudCwgY29tcG9uZW50cywgb25seUNpZHMsIGNoYW5nZVRyYWNraW5nLCBhdHRycylcbiAgICAvLyBkaXNhYmxlIHJlc2V0IGFmdGVyIHdlJ3ZlIHJlbmRlcmVkXG4gICAgZGVsZXRlIGNvbXBvbmVudC5yZXNldFxuXG4gICAgcmV0dXJuIFtodG1sLCBzdHJlYW1zXVxuICB9XG59XG4iLCAibGV0IHZpZXdIb29rSUQgPSAxXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWV3SG9vayB7XG4gIHN0YXRpYyBtYWtlSUQoKXsgcmV0dXJuIHZpZXdIb29rSUQrKyB9XG4gIHN0YXRpYyBlbGVtZW50SUQoZWwpeyByZXR1cm4gZWwucGh4SG9va0lkIH1cblxuICBjb25zdHJ1Y3Rvcih2aWV3LCBlbCwgY2FsbGJhY2tzKXtcbiAgICB0aGlzLl9fdmlldyA9IHZpZXdcbiAgICB0aGlzLmxpdmVTb2NrZXQgPSB2aWV3LmxpdmVTb2NrZXRcbiAgICB0aGlzLl9fY2FsbGJhY2tzID0gY2FsbGJhY2tzXG4gICAgdGhpcy5fX2xpc3RlbmVycyA9IG5ldyBTZXQoKVxuICAgIHRoaXMuX19pc0Rpc2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgdGhpcy5lbCA9IGVsXG4gICAgdGhpcy5lbC5waHhIb29rSWQgPSB0aGlzLmNvbnN0cnVjdG9yLm1ha2VJRCgpXG4gICAgZm9yKGxldCBrZXkgaW4gdGhpcy5fX2NhbGxiYWNrcyl7IHRoaXNba2V5XSA9IHRoaXMuX19jYWxsYmFja3Nba2V5XSB9XG4gIH1cblxuICBfX21vdW50ZWQoKXsgdGhpcy5tb3VudGVkICYmIHRoaXMubW91bnRlZCgpIH1cbiAgX191cGRhdGVkKCl7IHRoaXMudXBkYXRlZCAmJiB0aGlzLnVwZGF0ZWQoKSB9XG4gIF9fYmVmb3JlVXBkYXRlKCl7IHRoaXMuYmVmb3JlVXBkYXRlICYmIHRoaXMuYmVmb3JlVXBkYXRlKCkgfVxuICBfX2Rlc3Ryb3llZCgpeyB0aGlzLmRlc3Ryb3llZCAmJiB0aGlzLmRlc3Ryb3llZCgpIH1cbiAgX19yZWNvbm5lY3RlZCgpe1xuICAgIGlmKHRoaXMuX19pc0Rpc2Nvbm5lY3RlZCl7XG4gICAgICB0aGlzLl9faXNEaXNjb25uZWN0ZWQgPSBmYWxzZVxuICAgICAgdGhpcy5yZWNvbm5lY3RlZCAmJiB0aGlzLnJlY29ubmVjdGVkKClcbiAgICB9XG4gIH1cbiAgX19kaXNjb25uZWN0ZWQoKXtcbiAgICB0aGlzLl9faXNEaXNjb25uZWN0ZWQgPSB0cnVlXG4gICAgdGhpcy5kaXNjb25uZWN0ZWQgJiYgdGhpcy5kaXNjb25uZWN0ZWQoKVxuICB9XG5cbiAgcHVzaEV2ZW50KGV2ZW50LCBwYXlsb2FkID0ge30sIG9uUmVwbHkgPSBmdW5jdGlvbiAoKXsgfSl7XG4gICAgcmV0dXJuIHRoaXMuX192aWV3LnB1c2hIb29rRXZlbnQodGhpcy5lbCwgbnVsbCwgZXZlbnQsIHBheWxvYWQsIG9uUmVwbHkpXG4gIH1cblxuICBwdXNoRXZlbnRUbyhwaHhUYXJnZXQsIGV2ZW50LCBwYXlsb2FkID0ge30sIG9uUmVwbHkgPSBmdW5jdGlvbiAoKXsgfSl7XG4gICAgcmV0dXJuIHRoaXMuX192aWV3LndpdGhpblRhcmdldHMocGh4VGFyZ2V0LCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICByZXR1cm4gdmlldy5wdXNoSG9va0V2ZW50KHRoaXMuZWwsIHRhcmdldEN0eCwgZXZlbnQsIHBheWxvYWQsIG9uUmVwbHkpXG4gICAgfSlcbiAgfVxuXG4gIGhhbmRsZUV2ZW50KGV2ZW50LCBjYWxsYmFjayl7XG4gICAgbGV0IGNhbGxiYWNrUmVmID0gKGN1c3RvbUV2ZW50LCBieXBhc3MpID0+IGJ5cGFzcyA/IGV2ZW50IDogY2FsbGJhY2soY3VzdG9tRXZlbnQuZGV0YWlsKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGBwaHg6JHtldmVudH1gLCBjYWxsYmFja1JlZilcbiAgICB0aGlzLl9fbGlzdGVuZXJzLmFkZChjYWxsYmFja1JlZilcbiAgICByZXR1cm4gY2FsbGJhY2tSZWZcbiAgfVxuXG4gIHJlbW92ZUhhbmRsZUV2ZW50KGNhbGxiYWNrUmVmKXtcbiAgICBsZXQgZXZlbnQgPSBjYWxsYmFja1JlZihudWxsLCB0cnVlKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGBwaHg6JHtldmVudH1gLCBjYWxsYmFja1JlZilcbiAgICB0aGlzLl9fbGlzdGVuZXJzLmRlbGV0ZShjYWxsYmFja1JlZilcbiAgfVxuXG4gIHVwbG9hZChuYW1lLCBmaWxlcyl7XG4gICAgcmV0dXJuIHRoaXMuX192aWV3LmRpc3BhdGNoVXBsb2FkcyhudWxsLCBuYW1lLCBmaWxlcylcbiAgfVxuXG4gIHVwbG9hZFRvKHBoeFRhcmdldCwgbmFtZSwgZmlsZXMpe1xuICAgIHJldHVybiB0aGlzLl9fdmlldy53aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgKHZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgdmlldy5kaXNwYXRjaFVwbG9hZHModGFyZ2V0Q3R4LCBuYW1lLCBmaWxlcylcbiAgICB9KVxuICB9XG5cbiAgX19jbGVhbnVwX18oKXtcbiAgICB0aGlzLl9fbGlzdGVuZXJzLmZvckVhY2goY2FsbGJhY2tSZWYgPT4gdGhpcy5yZW1vdmVIYW5kbGVFdmVudChjYWxsYmFja1JlZikpXG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBCRUZPUkVfVU5MT0FEX0xPQURFUl9USU1FT1VULFxuICBDSEVDS0FCTEVfSU5QVVRTLFxuICBDT05TRUNVVElWRV9SRUxPQURTLFxuICBQSFhfQVVUT19SRUNPVkVSLFxuICBQSFhfQ09NUE9ORU5ULFxuICBQSFhfQ09OTkVDVEVEX0NMQVNTLFxuICBQSFhfRElTQUJMRV9XSVRILFxuICBQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUsXG4gIFBIWF9ESVNBQkxFRCxcbiAgUEhYX0xPQURJTkdfQ0xBU1MsXG4gIFBIWF9FVkVOVF9DTEFTU0VTLFxuICBQSFhfRVJST1JfQ0xBU1MsXG4gIFBIWF9DTElFTlRfRVJST1JfQ0xBU1MsXG4gIFBIWF9TRVJWRVJfRVJST1JfQ0xBU1MsXG4gIFBIWF9GRUVEQkFDS19GT1IsXG4gIFBIWF9GRUVEQkFDS19HUk9VUCxcbiAgUEhYX0hBU19GT0NVU0VELFxuICBQSFhfSEFTX1NVQk1JVFRFRCxcbiAgUEhYX0hPT0ssXG4gIFBIWF9QQUdFX0xPQURJTkcsXG4gIFBIWF9QQVJFTlRfSUQsXG4gIFBIWF9QUk9HUkVTUyxcbiAgUEhYX1JFQURPTkxZLFxuICBQSFhfUkVGLFxuICBQSFhfUkVGX1NSQyxcbiAgUEhYX1JPT1RfSUQsXG4gIFBIWF9TRVNTSU9OLFxuICBQSFhfU1RBVElDLFxuICBQSFhfVFJBQ0tfU1RBVElDLFxuICBQSFhfVFJBQ0tfVVBMT0FEUyxcbiAgUEhYX1VQREFURSxcbiAgUEhYX1VQTE9BRF9SRUYsXG4gIFBIWF9WSUVXX1NFTEVDVE9SLFxuICBQSFhfTUFJTixcbiAgUEhYX01PVU5URUQsXG4gIFBVU0hfVElNRU9VVCxcbiAgUEhYX1ZJRVdQT1JUX1RPUCxcbiAgUEhYX1ZJRVdQT1JUX0JPVFRPTSxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgY2xvbmUsXG4gIGNsb3Nlc3RQaHhCaW5kaW5nLFxuICBpc0VtcHR5LFxuICBpc0VxdWFsT2JqLFxuICBsb2dFcnJvcixcbiAgbWF5YmUsXG4gIGlzQ2lkLFxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBCcm93c2VyIGZyb20gXCIuL2Jyb3dzZXJcIlxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuaW1wb3J0IERPTVBhdGNoIGZyb20gXCIuL2RvbV9wYXRjaFwiXG5pbXBvcnQgTGl2ZVVwbG9hZGVyIGZyb20gXCIuL2xpdmVfdXBsb2FkZXJcIlxuaW1wb3J0IFJlbmRlcmVkIGZyb20gXCIuL3JlbmRlcmVkXCJcbmltcG9ydCBWaWV3SG9vayBmcm9tIFwiLi92aWV3X2hvb2tcIlxuaW1wb3J0IEpTIGZyb20gXCIuL2pzXCJcblxubGV0IHNlcmlhbGl6ZUZvcm0gPSAoZm9ybSwgbWV0YWRhdGEsIG9ubHlOYW1lcyA9IFtdKSA9PiB7XG4gIGNvbnN0IHtzdWJtaXR0ZXIsIC4uLm1ldGF9ID0gbWV0YWRhdGFcblxuICAvLyBXZSBtdXN0IGluamVjdCB0aGUgc3VibWl0dGVyIGluIHRoZSBvcmRlciB0aGF0IGl0IGV4aXN0cyBpbiB0aGUgRE9NXG4gIC8vIHJlbGVhdGl2ZSB0byBvdGhlciBpbnB1dHMuIEZvciBleGFtcGxlLCBmb3IgY2hlY2tib3ggZ3JvdXBzLCB0aGUgb3JkZXIgbXVzdCBiZSBtYWludGFpbmVkLlxuICBsZXQgaW5qZWN0ZWRFbGVtZW50XG4gIGlmKHN1Ym1pdHRlciAmJiBzdWJtaXR0ZXIubmFtZSl7XG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIilcbiAgICBpbnB1dC50eXBlID0gXCJoaWRkZW5cIlxuICAgIC8vIHNldCB0aGUgZm9ybSBhdHRyaWJ1dGUgaWYgdGhlIHN1Ym1pdHRlciBoYXMgb25lO1xuICAgIC8vIHRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgZWxlbWVudCBpcyBvdXRzaWRlIHRoZSBhY3R1YWwgZm9ybSBlbGVtZW50XG4gICAgY29uc3QgZm9ybUlkID0gc3VibWl0dGVyLmdldEF0dHJpYnV0ZShcImZvcm1cIilcbiAgICBpZihmb3JtSWQpe1xuICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwiZm9ybVwiLCBmb3JtSWQpXG4gICAgfVxuICAgIGlucHV0Lm5hbWUgPSBzdWJtaXR0ZXIubmFtZVxuICAgIGlucHV0LnZhbHVlID0gc3VibWl0dGVyLnZhbHVlXG4gICAgc3VibWl0dGVyLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGlucHV0LCBzdWJtaXR0ZXIpXG4gICAgaW5qZWN0ZWRFbGVtZW50ID0gaW5wdXRcbiAgfVxuXG4gIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKGZvcm0pXG4gIGNvbnN0IHRvUmVtb3ZlID0gW11cblxuICBmb3JtRGF0YS5mb3JFYWNoKCh2YWwsIGtleSwgX2luZGV4KSA9PiB7XG4gICAgaWYodmFsIGluc3RhbmNlb2YgRmlsZSl7IHRvUmVtb3ZlLnB1c2goa2V5KSB9XG4gIH0pXG5cbiAgLy8gQ2xlYW51cCBhZnRlciBidWlsZGluZyBmaWxlRGF0YVxuICB0b1JlbW92ZS5mb3JFYWNoKGtleSA9PiBmb3JtRGF0YS5kZWxldGUoa2V5KSlcblxuICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKClcblxuICBmb3IobGV0IFtrZXksIHZhbF0gb2YgZm9ybURhdGEuZW50cmllcygpKXtcbiAgICBpZihvbmx5TmFtZXMubGVuZ3RoID09PSAwIHx8IG9ubHlOYW1lcy5pbmRleE9mKGtleSkgPj0gMCl7XG4gICAgICBwYXJhbXMuYXBwZW5kKGtleSwgdmFsKVxuICAgIH1cbiAgfVxuXG4gIC8vIHJlbW92ZSB0aGUgaW5qZWN0ZWQgZWxlbWVudCBhZ2FpblxuICAvLyAoaXQgd291bGQgYmUgcmVtb3ZlZCBieSB0aGUgbmV4dCBkb20gcGF0Y2ggYW55d2F5LCBidXQgdGhpcyBpcyBjbGVhbmVyKVxuICBpZihzdWJtaXR0ZXIgJiYgaW5qZWN0ZWRFbGVtZW50KXtcbiAgICBzdWJtaXR0ZXIucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChpbmplY3RlZEVsZW1lbnQpXG4gIH1cblxuICBmb3IobGV0IG1ldGFLZXkgaW4gbWV0YSl7IHBhcmFtcy5hcHBlbmQobWV0YUtleSwgbWV0YVttZXRhS2V5XSkgfVxuXG4gIHJldHVybiBwYXJhbXMudG9TdHJpbmcoKVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWV3IHtcbiAgY29uc3RydWN0b3IoZWwsIGxpdmVTb2NrZXQsIHBhcmVudFZpZXcsIGZsYXNoLCBsaXZlUmVmZXJlcil7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZVxuICAgIHRoaXMubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXRcbiAgICB0aGlzLmZsYXNoID0gZmxhc2hcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudFZpZXdcbiAgICB0aGlzLnJvb3QgPSBwYXJlbnRWaWV3ID8gcGFyZW50Vmlldy5yb290IDogdGhpc1xuICAgIHRoaXMuZWwgPSBlbFxuICAgIHRoaXMuaWQgPSB0aGlzLmVsLmlkXG4gICAgdGhpcy5yZWYgPSAwXG4gICAgdGhpcy5jaGlsZEpvaW5zID0gMFxuICAgIHRoaXMubG9hZGVyVGltZXIgPSBudWxsXG4gICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuICAgIHRoaXMucGVuZGluZ0Zvcm1zID0gbmV3IFNldCgpXG4gICAgdGhpcy5yZWRpcmVjdCA9IGZhbHNlXG4gICAgdGhpcy5ocmVmID0gbnVsbFxuICAgIHRoaXMuam9pbkNvdW50ID0gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5qb2luQ291bnQgLSAxIDogMFxuICAgIHRoaXMuam9pblBlbmRpbmcgPSB0cnVlXG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuICAgIHRoaXMuam9pbkNhbGxiYWNrID0gZnVuY3Rpb24ob25Eb25lKXsgb25Eb25lICYmIG9uRG9uZSgpIH1cbiAgICB0aGlzLnN0b3BDYWxsYmFjayA9IGZ1bmN0aW9uKCl7IH1cbiAgICB0aGlzLnBlbmRpbmdKb2luT3BzID0gdGhpcy5wYXJlbnQgPyBudWxsIDogW11cbiAgICB0aGlzLnZpZXdIb29rcyA9IHt9XG4gICAgdGhpcy5mb3JtU3VibWl0cyA9IFtdXG4gICAgdGhpcy5jaGlsZHJlbiA9IHRoaXMucGFyZW50ID8gbnVsbCA6IHt9XG4gICAgdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdID0ge31cbiAgICB0aGlzLmNoYW5uZWwgPSB0aGlzLmxpdmVTb2NrZXQuY2hhbm5lbChgbHY6JHt0aGlzLmlkfWAsICgpID0+IHtcbiAgICAgIGxldCB1cmwgPSB0aGlzLmhyZWYgJiYgdGhpcy5leHBhbmRVUkwodGhpcy5ocmVmKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVkaXJlY3Q6IHRoaXMucmVkaXJlY3QgPyB1cmwgOiB1bmRlZmluZWQsXG4gICAgICAgIHVybDogdGhpcy5yZWRpcmVjdCA/IHVuZGVmaW5lZCA6IHVybCB8fCB1bmRlZmluZWQsXG4gICAgICAgIHBhcmFtczogdGhpcy5jb25uZWN0UGFyYW1zKGxpdmVSZWZlcmVyKSxcbiAgICAgICAgc2Vzc2lvbjogdGhpcy5nZXRTZXNzaW9uKCksXG4gICAgICAgIHN0YXRpYzogdGhpcy5nZXRTdGF0aWMoKSxcbiAgICAgICAgZmxhc2g6IHRoaXMuZmxhc2gsXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHNldEhyZWYoaHJlZil7IHRoaXMuaHJlZiA9IGhyZWYgfVxuXG4gIHNldFJlZGlyZWN0KGhyZWYpe1xuICAgIHRoaXMucmVkaXJlY3QgPSB0cnVlXG4gICAgdGhpcy5ocmVmID0gaHJlZlxuICB9XG5cbiAgaXNNYWluKCl7IHJldHVybiB0aGlzLmVsLmhhc0F0dHJpYnV0ZShQSFhfTUFJTikgfVxuXG4gIGNvbm5lY3RQYXJhbXMobGl2ZVJlZmVyZXIpe1xuICAgIGxldCBwYXJhbXMgPSB0aGlzLmxpdmVTb2NrZXQucGFyYW1zKHRoaXMuZWwpXG4gICAgbGV0IG1hbmlmZXN0ID1cbiAgICAgIERPTS5hbGwoZG9jdW1lbnQsIGBbJHt0aGlzLmJpbmRpbmcoUEhYX1RSQUNLX1NUQVRJQyl9XWApXG4gICAgICAgIC5tYXAobm9kZSA9PiBub2RlLnNyYyB8fCBub2RlLmhyZWYpLmZpbHRlcih1cmwgPT4gdHlwZW9mICh1cmwpID09PSBcInN0cmluZ1wiKVxuXG4gICAgaWYobWFuaWZlc3QubGVuZ3RoID4gMCl7IHBhcmFtc1tcIl90cmFja19zdGF0aWNcIl0gPSBtYW5pZmVzdCB9XG4gICAgcGFyYW1zW1wiX21vdW50c1wiXSA9IHRoaXMuam9pbkNvdW50XG4gICAgcGFyYW1zW1wiX2xpdmVfcmVmZXJlclwiXSA9IGxpdmVSZWZlcmVyXG5cbiAgICByZXR1cm4gcGFyYW1zXG4gIH1cblxuICBpc0Nvbm5lY3RlZCgpeyByZXR1cm4gdGhpcy5jaGFubmVsLmNhblB1c2goKSB9XG5cbiAgZ2V0U2Vzc2lvbigpeyByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pIH1cblxuICBnZXRTdGF0aWMoKXtcbiAgICBsZXQgdmFsID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1NUQVRJQylcbiAgICByZXR1cm4gdmFsID09PSBcIlwiID8gbnVsbCA6IHZhbFxuICB9XG5cbiAgZGVzdHJveShjYWxsYmFjayA9IGZ1bmN0aW9uICgpeyB9KXtcbiAgICB0aGlzLmRlc3Ryb3lBbGxDaGlsZHJlbigpXG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gICAgZGVsZXRlIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXVxuICAgIGlmKHRoaXMucGFyZW50KXsgZGVsZXRlIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLnBhcmVudC5pZF1bdGhpcy5pZF0gfVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmxvYWRlclRpbWVyKVxuICAgIGxldCBvbkZpbmlzaGVkID0gKCkgPT4ge1xuICAgICAgY2FsbGJhY2soKVxuICAgICAgZm9yKGxldCBpZCBpbiB0aGlzLnZpZXdIb29rcyl7XG4gICAgICAgIHRoaXMuZGVzdHJveUhvb2sodGhpcy52aWV3SG9va3NbaWRdKVxuICAgICAgfVxuICAgIH1cblxuICAgIERPTS5tYXJrUGh4Q2hpbGREZXN0cm95ZWQodGhpcy5lbClcblxuICAgIHRoaXMubG9nKFwiZGVzdHJveWVkXCIsICgpID0+IFtcInRoZSBjaGlsZCBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhcmVudFwiXSlcbiAgICB0aGlzLmNoYW5uZWwubGVhdmUoKVxuICAgICAgLnJlY2VpdmUoXCJva1wiLCBvbkZpbmlzaGVkKVxuICAgICAgLnJlY2VpdmUoXCJlcnJvclwiLCBvbkZpbmlzaGVkKVxuICAgICAgLnJlY2VpdmUoXCJ0aW1lb3V0XCIsIG9uRmluaXNoZWQpXG4gIH1cblxuICBzZXRDb250YWluZXJDbGFzc2VzKC4uLmNsYXNzZXMpe1xuICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgIFBIWF9DT05ORUNURURfQ0xBU1MsXG4gICAgICBQSFhfTE9BRElOR19DTEFTUyxcbiAgICAgIFBIWF9FUlJPUl9DTEFTUyxcbiAgICAgIFBIWF9DTElFTlRfRVJST1JfQ0xBU1MsXG4gICAgICBQSFhfU0VSVkVSX0VSUk9SX0NMQVNTXG4gICAgKVxuICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzKVxuICB9XG5cbiAgc2hvd0xvYWRlcih0aW1lb3V0KXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcilcbiAgICBpZih0aW1lb3V0KXtcbiAgICAgIHRoaXMubG9hZGVyVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2hvd0xvYWRlcigpLCB0aW1lb3V0KVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IobGV0IGlkIGluIHRoaXMudmlld0hvb2tzKXsgdGhpcy52aWV3SG9va3NbaWRdLl9fZGlzY29ubmVjdGVkKCkgfVxuICAgICAgdGhpcy5zZXRDb250YWluZXJDbGFzc2VzKFBIWF9MT0FESU5HX0NMQVNTKVxuICAgIH1cbiAgfVxuXG4gIGV4ZWNBbGwoYmluZGluZyl7XG4gICAgRE9NLmFsbCh0aGlzLmVsLCBgWyR7YmluZGluZ31dYCwgZWwgPT4gdGhpcy5saXZlU29ja2V0LmV4ZWNKUyhlbCwgZWwuZ2V0QXR0cmlidXRlKGJpbmRpbmcpKSlcbiAgfVxuXG4gIGhpZGVMb2FkZXIoKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcilcbiAgICB0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoUEhYX0NPTk5FQ1RFRF9DTEFTUylcbiAgICB0aGlzLmV4ZWNBbGwodGhpcy5iaW5kaW5nKFwiY29ubmVjdGVkXCIpKVxuICB9XG5cbiAgdHJpZ2dlclJlY29ubmVjdGVkKCl7XG4gICAgZm9yKGxldCBpZCBpbiB0aGlzLnZpZXdIb29rcyl7IHRoaXMudmlld0hvb2tzW2lkXS5fX3JlY29ubmVjdGVkKCkgfVxuICB9XG5cbiAgbG9nKGtpbmQsIG1zZ0NhbGxiYWNrKXtcbiAgICB0aGlzLmxpdmVTb2NrZXQubG9nKHRoaXMsIGtpbmQsIG1zZ0NhbGxiYWNrKVxuICB9XG5cbiAgdHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUgPSBmdW5jdGlvbigpe30pe1xuICAgIHRoaXMubGl2ZVNvY2tldC50cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSlcbiAgfVxuXG4gIHdpdGhpblRhcmdldHMocGh4VGFyZ2V0LCBjYWxsYmFjayl7XG4gICAgaWYocGh4VGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgcGh4VGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCl7XG4gICAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0Lm93bmVyKHBoeFRhcmdldCwgdmlldyA9PiBjYWxsYmFjayh2aWV3LCBwaHhUYXJnZXQpKVxuICAgIH1cblxuICAgIGlmKGlzQ2lkKHBoeFRhcmdldCkpe1xuICAgICAgbGV0IHRhcmdldHMgPSBET00uZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuZWwsIHBoeFRhcmdldClcbiAgICAgIGlmKHRhcmdldHMubGVuZ3RoID09PSAwKXtcbiAgICAgICAgbG9nRXJyb3IoYG5vIGNvbXBvbmVudCBmb3VuZCBtYXRjaGluZyBwaHgtdGFyZ2V0IG9mICR7cGh4VGFyZ2V0fWApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayh0aGlzLCBwYXJzZUludChwaHhUYXJnZXQpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdGFyZ2V0cyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChwaHhUYXJnZXQpKVxuICAgICAgaWYodGFyZ2V0cy5sZW5ndGggPT09IDApeyBsb2dFcnJvcihgbm90aGluZyBmb3VuZCBtYXRjaGluZyB0aGUgcGh4LXRhcmdldCBzZWxlY3RvciBcIiR7cGh4VGFyZ2V0fVwiYCkgfVxuICAgICAgdGFyZ2V0cy5mb3JFYWNoKHRhcmdldCA9PiB0aGlzLmxpdmVTb2NrZXQub3duZXIodGFyZ2V0LCB2aWV3ID0+IGNhbGxiYWNrKHZpZXcsIHRhcmdldCkpKVxuICAgIH1cbiAgfVxuXG4gIGFwcGx5RGlmZih0eXBlLCByYXdEaWZmLCBjYWxsYmFjayl7XG4gICAgdGhpcy5sb2codHlwZSwgKCkgPT4gW1wiXCIsIGNsb25lKHJhd0RpZmYpXSlcbiAgICBsZXQge2RpZmYsIHJlcGx5LCBldmVudHMsIHRpdGxlfSA9IFJlbmRlcmVkLmV4dHJhY3QocmF3RGlmZilcbiAgICBjYWxsYmFjayh7ZGlmZiwgcmVwbHksIGV2ZW50c30pXG4gICAgaWYodGl0bGUpeyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IERPTS5wdXRUaXRsZSh0aXRsZSkpIH1cbiAgfVxuXG4gIG9uSm9pbihyZXNwKXtcbiAgICBsZXQge3JlbmRlcmVkLCBjb250YWluZXJ9ID0gcmVzcFxuICAgIGlmKGNvbnRhaW5lcil7XG4gICAgICBsZXQgW3RhZywgYXR0cnNdID0gY29udGFpbmVyXG4gICAgICB0aGlzLmVsID0gRE9NLnJlcGxhY2VSb290Q29udGFpbmVyKHRoaXMuZWwsIHRhZywgYXR0cnMpXG4gICAgfVxuICAgIHRoaXMuY2hpbGRKb2lucyA9IDBcbiAgICB0aGlzLmpvaW5QZW5kaW5nID0gdHJ1ZVxuICAgIHRoaXMuZmxhc2ggPSBudWxsXG5cbiAgICBCcm93c2VyLmRyb3BMb2NhbCh0aGlzLmxpdmVTb2NrZXQubG9jYWxTdG9yYWdlLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsIENPTlNFQ1VUSVZFX1JFTE9BRFMpXG4gICAgdGhpcy5hcHBseURpZmYoXCJtb3VudFwiLCByZW5kZXJlZCwgKHtkaWZmLCBldmVudHN9KSA9PiB7XG4gICAgICB0aGlzLnJlbmRlcmVkID0gbmV3IFJlbmRlcmVkKHRoaXMuaWQsIGRpZmYpXG4gICAgICBsZXQgW2h0bWwsIHN0cmVhbXNdID0gdGhpcy5yZW5kZXJDb250YWluZXIobnVsbCwgXCJqb2luXCIpXG4gICAgICB0aGlzLmRyb3BQZW5kaW5nUmVmcygpXG4gICAgICBsZXQgZm9ybXMgPSB0aGlzLmZvcm1zRm9yUmVjb3ZlcnkoaHRtbCkuZmlsdGVyKChbZm9ybSwgbmV3Rm9ybSwgbmV3Q2lkXSkgPT4ge1xuICAgICAgICByZXR1cm4gIXRoaXMucGVuZGluZ0Zvcm1zLmhhcyhmb3JtLmlkKVxuICAgICAgfSlcbiAgICAgIHRoaXMuam9pbkNvdW50KytcblxuICAgICAgaWYoZm9ybXMubGVuZ3RoID4gMCl7XG4gICAgICAgIGZvcm1zLmZvckVhY2goKFtmb3JtLCBuZXdGb3JtLCBuZXdDaWRdLCBpKSA9PiB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nRm9ybXMuYWRkKGZvcm0uaWQpXG4gICAgICAgICAgdGhpcy5wdXNoRm9ybVJlY292ZXJ5KGZvcm0sIG5ld0NpZCwgcmVzcCA9PiB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdGb3Jtcy5kZWxldGUoZm9ybS5pZClcbiAgICAgICAgICAgIGlmKGkgPT09IGZvcm1zLmxlbmd0aCAtIDEpe1xuICAgICAgICAgICAgICB0aGlzLm9uSm9pbkNvbXBsZXRlKHJlc3AsIGh0bWwsIHN0cmVhbXMsIGV2ZW50cylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkpvaW5Db21wbGV0ZShyZXNwLCBodG1sLCBzdHJlYW1zLCBldmVudHMpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGRyb3BQZW5kaW5nUmVmcygpe1xuICAgIERPTS5hbGwoZG9jdW1lbnQsIGBbJHtQSFhfUkVGX1NSQ309XCIke3RoaXMuaWR9XCJdWyR7UEhYX1JFRn1dYCwgZWwgPT4ge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUYpXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRl9TUkMpXG4gICAgfSlcbiAgfVxuXG4gIG9uSm9pbkNvbXBsZXRlKHtsaXZlX3BhdGNofSwgaHRtbCwgc3RyZWFtcywgZXZlbnRzKXtcbiAgICAvLyB3ZSBjYW4gY2xlYXIgcGVuZGluZyBmb3JtIHJlY292ZXJpZXMgbm93IHRoYXQgd2UndmUgam9pbmVkLlxuICAgIC8vIFRoZXkgZWl0aGVyIGFsbCByZXNvbHZlZCBvciB3ZXJlIGFiYW5kb25lZFxuICAgIHRoaXMucGVuZGluZ0Zvcm1zLmNsZWFyKClcbiAgICAvLyBJbiBvcmRlciB0byBwcm92aWRlIGEgYmV0dGVyIGV4cGVyaWVuY2UsIHdlIHdhbnQgdG8gam9pblxuICAgIC8vIGFsbCBMaXZlVmlld3MgZmlyc3QgYW5kIG9ubHkgdGhlbiBhcHBseSB0aGVpciBwYXRjaGVzLlxuICAgIGlmKHRoaXMuam9pbkNvdW50ID4gMSB8fCAodGhpcy5wYXJlbnQgJiYgIXRoaXMucGFyZW50LmlzSm9pblBlbmRpbmcoKSkpe1xuICAgICAgcmV0dXJuIHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgc3RyZWFtcywgZXZlbnRzKVxuICAgIH1cblxuICAgIC8vIE9uZSBkb3duc2lkZSBvZiB0aGlzIGFwcHJvYWNoIGlzIHRoYXQgd2UgbmVlZCB0byBmaW5kIHBoeENoaWxkcmVuXG4gICAgLy8gaW4gdGhlIGh0bWwgZnJhZ21lbnQsIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIERPTS4gVGhlIGZyYWdtZW50XG4gICAgLy8gYWxzbyBkb2VzIG5vdCBpbmNsdWRlIFBIWF9TVEFUSUMsIHNvIHdlIG5lZWQgdG8gY29weSBpdCBvdmVyIGZyb21cbiAgICAvLyB0aGUgRE9NLlxuICAgIGxldCBuZXdDaGlsZHJlbiA9IERPTS5maW5kUGh4Q2hpbGRyZW5JbkZyYWdtZW50KGh0bWwsIHRoaXMuaWQpLmZpbHRlcih0b0VsID0+IHtcbiAgICAgIGxldCBmcm9tRWwgPSB0b0VsLmlkICYmIHRoaXMuZWwucXVlcnlTZWxlY3RvcihgW2lkPVwiJHt0b0VsLmlkfVwiXWApXG4gICAgICBsZXQgcGh4U3RhdGljID0gZnJvbUVsICYmIGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1NUQVRJQylcbiAgICAgIGlmKHBoeFN0YXRpYyl7IHRvRWwuc2V0QXR0cmlidXRlKFBIWF9TVEFUSUMsIHBoeFN0YXRpYykgfVxuICAgICAgLy8gc2V0IFBIWF9ST09UX0lEIHRvIHByZXZlbnQgZXZlbnRzIGZyb20gYmVpbmcgZGlzcGF0Y2hlZCB0byB0aGUgcm9vdCB2aWV3XG4gICAgICAvLyB3aGlsZSB0aGUgY2hpbGQgam9pbiBpcyBzdGlsbCBwZW5kaW5nXG4gICAgICBpZihmcm9tRWwpeyBmcm9tRWwuc2V0QXR0cmlidXRlKFBIWF9ST09UX0lELCB0aGlzLnJvb3QuaWQpIH1cbiAgICAgIHJldHVybiB0aGlzLmpvaW5DaGlsZCh0b0VsKVxuICAgIH0pXG5cbiAgICBpZihuZXdDaGlsZHJlbi5sZW5ndGggPT09IDApe1xuICAgICAgaWYodGhpcy5wYXJlbnQpe1xuICAgICAgICB0aGlzLnJvb3QucGVuZGluZ0pvaW5PcHMucHVzaChbdGhpcywgKCkgPT4gdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBzdHJlYW1zLCBldmVudHMpXSlcbiAgICAgICAgdGhpcy5wYXJlbnQuYWNrSm9pbih0aGlzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkFsbENoaWxkSm9pbnNDb21wbGV0ZSgpXG4gICAgICAgIHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgc3RyZWFtcywgZXZlbnRzKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJvb3QucGVuZGluZ0pvaW5PcHMucHVzaChbdGhpcywgKCkgPT4gdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBzdHJlYW1zLCBldmVudHMpXSlcbiAgICB9XG4gIH1cblxuICBhdHRhY2hUcnVlRG9jRWwoKXtcbiAgICB0aGlzLmVsID0gRE9NLmJ5SWQodGhpcy5pZClcbiAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZShQSFhfUk9PVF9JRCwgdGhpcy5yb290LmlkKVxuICB9XG5cbiAgZXhlY05ld01vdW50ZWQoKXtcbiAgICBsZXQgcGh4Vmlld3BvcnRUb3AgPSB0aGlzLmJpbmRpbmcoUEhYX1ZJRVdQT1JUX1RPUClcbiAgICBsZXQgcGh4Vmlld3BvcnRCb3R0b20gPSB0aGlzLmJpbmRpbmcoUEhYX1ZJRVdQT1JUX0JPVFRPTSlcbiAgICBET00uYWxsKHRoaXMuZWwsIGBbJHtwaHhWaWV3cG9ydFRvcH1dLCBbJHtwaHhWaWV3cG9ydEJvdHRvbX1dYCwgaG9va0VsID0+IHtcbiAgICAgIERPTS5tYXliZUFkZFByaXZhdGVIb29rcyhob29rRWwsIHBoeFZpZXdwb3J0VG9wLCBwaHhWaWV3cG9ydEJvdHRvbSlcbiAgICAgIHRoaXMubWF5YmVBZGROZXdIb29rKGhvb2tFbClcbiAgICB9KVxuICAgIERPTS5hbGwodGhpcy5lbCwgYFske3RoaXMuYmluZGluZyhQSFhfSE9PSyl9XSwgW2RhdGEtcGh4LSR7UEhYX0hPT0t9XWAsIGhvb2tFbCA9PiB7XG4gICAgICB0aGlzLm1heWJlQWRkTmV3SG9vayhob29rRWwpXG4gICAgfSlcbiAgICBET00uYWxsKHRoaXMuZWwsIGBbJHt0aGlzLmJpbmRpbmcoUEhYX01PVU5URUQpfV1gLCBlbCA9PiB0aGlzLm1heWJlTW91bnRlZChlbCkpXG4gIH1cblxuICBhcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBzdHJlYW1zLCBldmVudHMpe1xuICAgIHRoaXMuYXR0YWNoVHJ1ZURvY0VsKClcbiAgICBsZXQgcGF0Y2ggPSBuZXcgRE9NUGF0Y2godGhpcywgdGhpcy5lbCwgdGhpcy5pZCwgaHRtbCwgc3RyZWFtcywgbnVsbClcbiAgICBwYXRjaC5tYXJrUHJ1bmFibGVDb250ZW50Rm9yUmVtb3ZhbCgpXG4gICAgdGhpcy5wZXJmb3JtUGF0Y2gocGF0Y2gsIGZhbHNlLCB0cnVlKVxuICAgIHRoaXMuam9pbk5ld0NoaWxkcmVuKClcbiAgICB0aGlzLmV4ZWNOZXdNb3VudGVkKClcblxuICAgIHRoaXMuam9pblBlbmRpbmcgPSBmYWxzZVxuICAgIHRoaXMubGl2ZVNvY2tldC5kaXNwYXRjaEV2ZW50cyhldmVudHMpXG4gICAgdGhpcy5hcHBseVBlbmRpbmdVcGRhdGVzKClcblxuICAgIGlmKGxpdmVfcGF0Y2gpe1xuICAgICAgbGV0IHtraW5kLCB0b30gPSBsaXZlX3BhdGNoXG4gICAgICB0aGlzLmxpdmVTb2NrZXQuaGlzdG9yeVBhdGNoKHRvLCBraW5kKVxuICAgIH1cbiAgICB0aGlzLmhpZGVMb2FkZXIoKVxuICAgIGlmKHRoaXMuam9pbkNvdW50ID4gMSl7IHRoaXMudHJpZ2dlclJlY29ubmVjdGVkKCkgfVxuICAgIHRoaXMuc3RvcENhbGxiYWNrKClcbiAgfVxuXG4gIHRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGZyb21FbCwgdG9FbCl7XG4gICAgdGhpcy5saXZlU29ja2V0LnRyaWdnZXJET00oXCJvbkJlZm9yZUVsVXBkYXRlZFwiLCBbZnJvbUVsLCB0b0VsXSlcbiAgICBsZXQgaG9vayA9IHRoaXMuZ2V0SG9vayhmcm9tRWwpXG4gICAgbGV0IGlzSWdub3JlZCA9IGhvb2sgJiYgRE9NLmlzSWdub3JlZChmcm9tRWwsIHRoaXMuYmluZGluZyhQSFhfVVBEQVRFKSlcbiAgICBpZihob29rICYmICFmcm9tRWwuaXNFcXVhbE5vZGUodG9FbCkgJiYgIShpc0lnbm9yZWQgJiYgaXNFcXVhbE9iaihmcm9tRWwuZGF0YXNldCwgdG9FbC5kYXRhc2V0KSkpe1xuICAgICAgaG9vay5fX2JlZm9yZVVwZGF0ZSgpXG4gICAgICByZXR1cm4gaG9va1xuICAgIH1cbiAgfVxuXG4gIG1heWJlTW91bnRlZChlbCl7XG4gICAgbGV0IHBoeE1vdW50ZWQgPSBlbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9NT1VOVEVEKSlcbiAgICBsZXQgaGFzQmVlbkludm9rZWQgPSBwaHhNb3VudGVkICYmIERPTS5wcml2YXRlKGVsLCBcIm1vdW50ZWRcIilcbiAgICBpZihwaHhNb3VudGVkICYmICFoYXNCZWVuSW52b2tlZCl7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQuZXhlY0pTKGVsLCBwaHhNb3VudGVkKVxuICAgICAgRE9NLnB1dFByaXZhdGUoZWwsIFwibW91bnRlZFwiLCB0cnVlKVxuICAgIH1cbiAgfVxuXG4gIG1heWJlQWRkTmV3SG9vayhlbCwgZm9yY2Upe1xuICAgIGxldCBuZXdIb29rID0gdGhpcy5hZGRIb29rKGVsKVxuICAgIGlmKG5ld0hvb2speyBuZXdIb29rLl9fbW91bnRlZCgpIH1cbiAgfVxuXG4gIHBlcmZvcm1QYXRjaChwYXRjaCwgcHJ1bmVDaWRzLCBpc0pvaW5QYXRjaCA9IGZhbHNlKXtcbiAgICBsZXQgcmVtb3ZlZEVscyA9IFtdXG4gICAgbGV0IHBoeENoaWxkcmVuQWRkZWQgPSBmYWxzZVxuICAgIGxldCB1cGRhdGVkSG9va0lkcyA9IG5ldyBTZXQoKVxuXG4gICAgcGF0Y2guYWZ0ZXIoXCJhZGRlZFwiLCBlbCA9PiB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uTm9kZUFkZGVkXCIsIFtlbF0pXG4gICAgICBsZXQgcGh4Vmlld3BvcnRUb3AgPSB0aGlzLmJpbmRpbmcoUEhYX1ZJRVdQT1JUX1RPUClcbiAgICAgIGxldCBwaHhWaWV3cG9ydEJvdHRvbSA9IHRoaXMuYmluZGluZyhQSFhfVklFV1BPUlRfQk9UVE9NKVxuICAgICAgRE9NLm1heWJlQWRkUHJpdmF0ZUhvb2tzKGVsLCBwaHhWaWV3cG9ydFRvcCwgcGh4Vmlld3BvcnRCb3R0b20pXG4gICAgICB0aGlzLm1heWJlQWRkTmV3SG9vayhlbClcbiAgICAgIGlmKGVsLmdldEF0dHJpYnV0ZSl7IHRoaXMubWF5YmVNb3VudGVkKGVsKSB9XG4gICAgfSlcblxuICAgIHBhdGNoLmFmdGVyKFwicGh4Q2hpbGRBZGRlZFwiLCBlbCA9PiB7XG4gICAgICBpZihET00uaXNQaHhTdGlja3koZWwpKXtcbiAgICAgICAgdGhpcy5saXZlU29ja2V0LmpvaW5Sb290Vmlld3MoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGh4Q2hpbGRyZW5BZGRlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcGF0Y2guYmVmb3JlKFwidXBkYXRlZFwiLCAoZnJvbUVsLCB0b0VsKSA9PiB7XG4gICAgICBsZXQgaG9vayA9IHRoaXMudHJpZ2dlckJlZm9yZVVwZGF0ZUhvb2soZnJvbUVsLCB0b0VsKVxuICAgICAgaWYoaG9vayl7IHVwZGF0ZWRIb29rSWRzLmFkZChmcm9tRWwuaWQpIH1cbiAgICB9KVxuXG4gICAgcGF0Y2guYWZ0ZXIoXCJ1cGRhdGVkXCIsIGVsID0+IHtcbiAgICAgIGlmKHVwZGF0ZWRIb29rSWRzLmhhcyhlbC5pZCkpeyB0aGlzLmdldEhvb2soZWwpLl9fdXBkYXRlZCgpIH1cbiAgICB9KVxuXG4gICAgcGF0Y2guYWZ0ZXIoXCJkaXNjYXJkZWRcIiwgKGVsKSA9PiB7XG4gICAgICBpZihlbC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpeyByZW1vdmVkRWxzLnB1c2goZWwpIH1cbiAgICB9KVxuXG4gICAgcGF0Y2guYWZ0ZXIoXCJ0cmFuc2l0aW9uc0Rpc2NhcmRlZFwiLCBlbHMgPT4gdGhpcy5hZnRlckVsZW1lbnRzUmVtb3ZlZChlbHMsIHBydW5lQ2lkcykpXG4gICAgcGF0Y2gucGVyZm9ybShpc0pvaW5QYXRjaClcbiAgICB0aGlzLmFmdGVyRWxlbWVudHNSZW1vdmVkKHJlbW92ZWRFbHMsIHBydW5lQ2lkcylcblxuICAgIHJldHVybiBwaHhDaGlsZHJlbkFkZGVkXG4gIH1cblxuICBhZnRlckVsZW1lbnRzUmVtb3ZlZChlbGVtZW50cywgcHJ1bmVDaWRzKXtcbiAgICBsZXQgZGVzdHJveWVkQ0lEcyA9IFtdXG4gICAgZWxlbWVudHMuZm9yRWFjaChwYXJlbnQgPT4ge1xuICAgICAgbGV0IGNvbXBvbmVudHMgPSBET00uYWxsKHBhcmVudCwgYFske1BIWF9DT01QT05FTlR9XWApXG4gICAgICBsZXQgaG9va3MgPSBET00uYWxsKHBhcmVudCwgYFske3RoaXMuYmluZGluZyhQSFhfSE9PSyl9XWApXG4gICAgICBjb21wb25lbnRzLmNvbmNhdChwYXJlbnQpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBsZXQgY2lkID0gdGhpcy5jb21wb25lbnRJRChlbClcbiAgICAgICAgaWYoaXNDaWQoY2lkKSAmJiBkZXN0cm95ZWRDSURzLmluZGV4T2YoY2lkKSA9PT0gLTEpeyBkZXN0cm95ZWRDSURzLnB1c2goY2lkKSB9XG4gICAgICB9KVxuICAgICAgaG9va3MuY29uY2F0KHBhcmVudCkuZm9yRWFjaChob29rRWwgPT4ge1xuICAgICAgICBsZXQgaG9vayA9IHRoaXMuZ2V0SG9vayhob29rRWwpXG4gICAgICAgIGhvb2sgJiYgdGhpcy5kZXN0cm95SG9vayhob29rKVxuICAgICAgfSlcbiAgICB9KVxuICAgIC8vIFdlIHNob3VsZCBub3QgcHJ1bmVDaWRzIG9uIGpvaW5zLiBPdGhlcndpc2UsIGluIGNhc2Ugb2ZcbiAgICAvLyByZWpvaW5zLCB3ZSBtYXkgbm90aWZ5IGNpZHMgdGhhdCBubyBsb25nZXIgYmVsb25nIHRvIHRoZVxuICAgIC8vIGN1cnJlbnQgTGl2ZVZpZXcgdG8gYmUgcmVtb3ZlZC5cbiAgICBpZihwcnVuZUNpZHMpe1xuICAgICAgdGhpcy5tYXliZVB1c2hDb21wb25lbnRzRGVzdHJveWVkKGRlc3Ryb3llZENJRHMpXG4gICAgfVxuICB9XG5cbiAgam9pbk5ld0NoaWxkcmVuKCl7XG4gICAgRE9NLmZpbmRQaHhDaGlsZHJlbih0aGlzLmVsLCB0aGlzLmlkKS5mb3JFYWNoKGVsID0+IHRoaXMuam9pbkNoaWxkKGVsKSlcbiAgfVxuXG4gIGdldENoaWxkQnlJZChpZCl7IHJldHVybiB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1baWRdIH1cblxuICBnZXREZXNjZW5kZW50QnlFbChlbCl7XG4gICAgaWYoZWwuaWQgPT09IHRoaXMuaWQpe1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bZWwuZ2V0QXR0cmlidXRlKFBIWF9QQVJFTlRfSUQpXVtlbC5pZF1cbiAgICB9XG4gIH1cblxuICBkZXN0cm95RGVzY2VuZGVudChpZCl7XG4gICAgZm9yKGxldCBwYXJlbnRJZCBpbiB0aGlzLnJvb3QuY2hpbGRyZW4pe1xuICAgICAgZm9yKGxldCBjaGlsZElkIGluIHRoaXMucm9vdC5jaGlsZHJlbltwYXJlbnRJZF0pe1xuICAgICAgICBpZihjaGlsZElkID09PSBpZCl7IHJldHVybiB0aGlzLnJvb3QuY2hpbGRyZW5bcGFyZW50SWRdW2NoaWxkSWRdLmRlc3Ryb3koKSB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgam9pbkNoaWxkKGVsKXtcbiAgICBsZXQgY2hpbGQgPSB0aGlzLmdldENoaWxkQnlJZChlbC5pZClcbiAgICBpZighY2hpbGQpe1xuICAgICAgbGV0IHZpZXcgPSBuZXcgVmlldyhlbCwgdGhpcy5saXZlU29ja2V0LCB0aGlzKVxuICAgICAgdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdW3ZpZXcuaWRdID0gdmlld1xuICAgICAgdmlldy5qb2luKClcbiAgICAgIHRoaXMuY2hpbGRKb2lucysrXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGlzSm9pblBlbmRpbmcoKXsgcmV0dXJuIHRoaXMuam9pblBlbmRpbmcgfVxuXG4gIGFja0pvaW4oX2NoaWxkKXtcbiAgICB0aGlzLmNoaWxkSm9pbnMtLVxuXG4gICAgaWYodGhpcy5jaGlsZEpvaW5zID09PSAwKXtcbiAgICAgIGlmKHRoaXMucGFyZW50KXtcbiAgICAgICAgdGhpcy5wYXJlbnQuYWNrSm9pbih0aGlzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkFsbENoaWxkSm9pbnNDb21wbGV0ZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKXtcbiAgICB0aGlzLmpvaW5DYWxsYmFjaygoKSA9PiB7XG4gICAgICB0aGlzLnBlbmRpbmdKb2luT3BzLmZvckVhY2goKFt2aWV3LCBvcF0pID0+IHtcbiAgICAgICAgaWYoIXZpZXcuaXNEZXN0cm95ZWQoKSl7IG9wKCkgfVxuICAgICAgfSlcbiAgICAgIHRoaXMucGVuZGluZ0pvaW5PcHMgPSBbXVxuICAgIH0pXG4gIH1cblxuICB1cGRhdGUoZGlmZiwgZXZlbnRzKXtcbiAgICBpZih0aGlzLmlzSm9pblBlbmRpbmcoKSB8fCAodGhpcy5saXZlU29ja2V0Lmhhc1BlbmRpbmdMaW5rKCkgJiYgdGhpcy5yb290LmlzTWFpbigpKSl7XG4gICAgICByZXR1cm4gdGhpcy5wZW5kaW5nRGlmZnMucHVzaCh7ZGlmZiwgZXZlbnRzfSlcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVkLm1lcmdlRGlmZihkaWZmKVxuICAgIGxldCBwaHhDaGlsZHJlbkFkZGVkID0gZmFsc2VcblxuICAgIC8vIFdoZW4gdGhlIGRpZmYgb25seSBjb250YWlucyBjb21wb25lbnQgZGlmZnMsIHRoZW4gd2FsayBjb21wb25lbnRzXG4gICAgLy8gYW5kIHBhdGNoIG9ubHkgdGhlIHBhcmVudCBjb21wb25lbnQgY29udGFpbmVycyBmb3VuZCBpbiB0aGUgZGlmZi5cbiAgICAvLyBPdGhlcndpc2UsIHBhdGNoIGVudGlyZSBMViBjb250YWluZXIuXG4gICAgaWYodGhpcy5yZW5kZXJlZC5pc0NvbXBvbmVudE9ubHlEaWZmKGRpZmYpKXtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC50aW1lKFwiY29tcG9uZW50IHBhdGNoIGNvbXBsZXRlXCIsICgpID0+IHtcbiAgICAgICAgbGV0IHBhcmVudENpZHMgPSBET00uZmluZEV4aXN0aW5nUGFyZW50Q0lEcyh0aGlzLmVsLCB0aGlzLnJlbmRlcmVkLmNvbXBvbmVudENJRHMoZGlmZikpXG4gICAgICAgIHBhcmVudENpZHMuZm9yRWFjaChwYXJlbnRDSUQgPT4ge1xuICAgICAgICAgIGlmKHRoaXMuY29tcG9uZW50UGF0Y2godGhpcy5yZW5kZXJlZC5nZXRDb21wb25lbnQoZGlmZiwgcGFyZW50Q0lEKSwgcGFyZW50Q0lEKSl7IHBoeENoaWxkcmVuQWRkZWQgPSB0cnVlIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmKCFpc0VtcHR5KGRpZmYpKXtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC50aW1lKFwiZnVsbCBwYXRjaCBjb21wbGV0ZVwiLCAoKSA9PiB7XG4gICAgICAgIGxldCBbaHRtbCwgc3RyZWFtc10gPSB0aGlzLnJlbmRlckNvbnRhaW5lcihkaWZmLCBcInVwZGF0ZVwiKVxuICAgICAgICBsZXQgcGF0Y2ggPSBuZXcgRE9NUGF0Y2godGhpcywgdGhpcy5lbCwgdGhpcy5pZCwgaHRtbCwgc3RyZWFtcywgbnVsbClcbiAgICAgICAgcGh4Q2hpbGRyZW5BZGRlZCA9IHRoaXMucGVyZm9ybVBhdGNoKHBhdGNoLCB0cnVlKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmxpdmVTb2NrZXQuZGlzcGF0Y2hFdmVudHMoZXZlbnRzKVxuICAgIGlmKHBoeENoaWxkcmVuQWRkZWQpeyB0aGlzLmpvaW5OZXdDaGlsZHJlbigpIH1cbiAgfVxuXG4gIHJlbmRlckNvbnRhaW5lcihkaWZmLCBraW5kKXtcbiAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0LnRpbWUoYHRvU3RyaW5nIGRpZmYgKCR7a2luZH0pYCwgKCkgPT4ge1xuICAgICAgbGV0IHRhZyA9IHRoaXMuZWwudGFnTmFtZVxuICAgICAgLy8gRG9uJ3Qgc2tpcCBhbnkgY29tcG9uZW50IGluIHRoZSBkaWZmIG5vciBhbnkgbWFya2VkIGFzIHBydW5lZFxuICAgICAgLy8gKGFzIHRoZXkgbWF5IGhhdmUgYmVlbiBhZGRlZCBiYWNrKVxuICAgICAgbGV0IGNpZHMgPSBkaWZmID8gdGhpcy5yZW5kZXJlZC5jb21wb25lbnRDSURzKGRpZmYpIDogbnVsbFxuICAgICAgbGV0IFtodG1sLCBzdHJlYW1zXSA9IHRoaXMucmVuZGVyZWQudG9TdHJpbmcoY2lkcylcbiAgICAgIHJldHVybiBbYDwke3RhZ30+JHtodG1sfTwvJHt0YWd9PmAsIHN0cmVhbXNdXG4gICAgfSlcbiAgfVxuXG4gIGNvbXBvbmVudFBhdGNoKGRpZmYsIGNpZCl7XG4gICAgaWYoaXNFbXB0eShkaWZmKSkgcmV0dXJuIGZhbHNlXG4gICAgbGV0IFtodG1sLCBzdHJlYW1zXSA9IHRoaXMucmVuZGVyZWQuY29tcG9uZW50VG9TdHJpbmcoY2lkKVxuICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBzdHJlYW1zLCBjaWQpXG4gICAgbGV0IGNoaWxkcmVuQWRkZWQgPSB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgdHJ1ZSlcbiAgICByZXR1cm4gY2hpbGRyZW5BZGRlZFxuICB9XG5cbiAgZ2V0SG9vayhlbCl7IHJldHVybiB0aGlzLnZpZXdIb29rc1tWaWV3SG9vay5lbGVtZW50SUQoZWwpXSB9XG5cbiAgYWRkSG9vayhlbCl7XG4gICAgaWYoVmlld0hvb2suZWxlbWVudElEKGVsKSB8fCAhZWwuZ2V0QXR0cmlidXRlKXsgcmV0dXJuIH1cbiAgICBsZXQgaG9va05hbWUgPSBlbC5nZXRBdHRyaWJ1dGUoYGRhdGEtcGh4LSR7UEhYX0hPT0t9YCkgfHwgZWwuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfSE9PSykpXG4gICAgaWYoaG9va05hbWUgJiYgIXRoaXMub3duc0VsZW1lbnQoZWwpKXsgcmV0dXJuIH1cbiAgICBsZXQgY2FsbGJhY2tzID0gdGhpcy5saXZlU29ja2V0LmdldEhvb2tDYWxsYmFja3MoaG9va05hbWUpXG5cbiAgICBpZihjYWxsYmFja3Mpe1xuICAgICAgaWYoIWVsLmlkKXsgbG9nRXJyb3IoYG5vIERPTSBJRCBmb3IgaG9vayBcIiR7aG9va05hbWV9XCIuIEhvb2tzIHJlcXVpcmUgYSB1bmlxdWUgSUQgb24gZWFjaCBlbGVtZW50LmAsIGVsKSB9XG4gICAgICBsZXQgaG9vayA9IG5ldyBWaWV3SG9vayh0aGlzLCBlbCwgY2FsbGJhY2tzKVxuICAgICAgdGhpcy52aWV3SG9va3NbVmlld0hvb2suZWxlbWVudElEKGhvb2suZWwpXSA9IGhvb2tcbiAgICAgIHJldHVybiBob29rXG4gICAgfSBlbHNlIGlmKGhvb2tOYW1lICE9PSBudWxsKXtcbiAgICAgIGxvZ0Vycm9yKGB1bmtub3duIGhvb2sgZm91bmQgZm9yIFwiJHtob29rTmFtZX1cImAsIGVsKVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3lIb29rKGhvb2spe1xuICAgIGhvb2suX19kZXN0cm95ZWQoKVxuICAgIGhvb2suX19jbGVhbnVwX18oKVxuICAgIGRlbGV0ZSB0aGlzLnZpZXdIb29rc1tWaWV3SG9vay5lbGVtZW50SUQoaG9vay5lbCldXG4gIH1cblxuICBhcHBseVBlbmRpbmdVcGRhdGVzKCl7XG4gICAgdGhpcy5wZW5kaW5nRGlmZnMuZm9yRWFjaCgoe2RpZmYsIGV2ZW50c30pID0+IHRoaXMudXBkYXRlKGRpZmYsIGV2ZW50cykpXG4gICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuICAgIHRoaXMuZWFjaENoaWxkKGNoaWxkID0+IGNoaWxkLmFwcGx5UGVuZGluZ1VwZGF0ZXMoKSlcbiAgfVxuXG4gIGVhY2hDaGlsZChjYWxsYmFjayl7XG4gICAgbGV0IGNoaWxkcmVuID0gdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdIHx8IHt9XG4gICAgZm9yKGxldCBpZCBpbiBjaGlsZHJlbil7IGNhbGxiYWNrKHRoaXMuZ2V0Q2hpbGRCeUlkKGlkKSkgfVxuICB9XG5cbiAgb25DaGFubmVsKGV2ZW50LCBjYil7XG4gICAgdGhpcy5saXZlU29ja2V0Lm9uQ2hhbm5lbCh0aGlzLmNoYW5uZWwsIGV2ZW50LCByZXNwID0+IHtcbiAgICAgIGlmKHRoaXMuaXNKb2luUGVuZGluZygpKXtcbiAgICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IGNiKHJlc3ApXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IGNiKHJlc3ApKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBiaW5kQ2hhbm5lbCgpe1xuICAgIC8vIFRoZSBkaWZmIGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoZSByZWd1bGFyIHVwZGF0ZSBvcGVyYXRpb25zLlxuICAgIC8vIEFsbCBvdGhlciBvcGVyYXRpb25zIGFyZSBxdWV1ZWQgdG8gYmUgYXBwbGllZCBvbmx5IGFmdGVyIGpvaW4uXG4gICAgdGhpcy5saXZlU29ja2V0Lm9uQ2hhbm5lbCh0aGlzLmNoYW5uZWwsIFwiZGlmZlwiLCAocmF3RGlmZikgPT4ge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICB0aGlzLmFwcGx5RGlmZihcInVwZGF0ZVwiLCByYXdEaWZmLCAoe2RpZmYsIGV2ZW50c30pID0+IHRoaXMudXBkYXRlKGRpZmYsIGV2ZW50cykpXG4gICAgICB9KVxuICAgIH0pXG4gICAgdGhpcy5vbkNoYW5uZWwoXCJyZWRpcmVjdFwiLCAoe3RvLCBmbGFzaH0pID0+IHRoaXMub25SZWRpcmVjdCh7dG8sIGZsYXNofSkpXG4gICAgdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3BhdGNoXCIsIChyZWRpcikgPT4gdGhpcy5vbkxpdmVQYXRjaChyZWRpcikpXG4gICAgdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3JlZGlyZWN0XCIsIChyZWRpcikgPT4gdGhpcy5vbkxpdmVSZWRpcmVjdChyZWRpcikpXG4gICAgdGhpcy5jaGFubmVsLm9uRXJyb3IocmVhc29uID0+IHRoaXMub25FcnJvcihyZWFzb24pKVxuICAgIHRoaXMuY2hhbm5lbC5vbkNsb3NlKHJlYXNvbiA9PiB0aGlzLm9uQ2xvc2UocmVhc29uKSlcbiAgfVxuXG4gIGRlc3Ryb3lBbGxDaGlsZHJlbigpeyB0aGlzLmVhY2hDaGlsZChjaGlsZCA9PiBjaGlsZC5kZXN0cm95KCkpIH1cblxuICBvbkxpdmVSZWRpcmVjdChyZWRpcil7XG4gICAgbGV0IHt0bywga2luZCwgZmxhc2h9ID0gcmVkaXJcbiAgICBsZXQgdXJsID0gdGhpcy5leHBhbmRVUkwodG8pXG4gICAgdGhpcy5saXZlU29ja2V0Lmhpc3RvcnlSZWRpcmVjdCh1cmwsIGtpbmQsIGZsYXNoKVxuICB9XG5cbiAgb25MaXZlUGF0Y2gocmVkaXIpe1xuICAgIGxldCB7dG8sIGtpbmR9ID0gcmVkaXJcbiAgICB0aGlzLmhyZWYgPSB0aGlzLmV4cGFuZFVSTCh0bylcbiAgICB0aGlzLmxpdmVTb2NrZXQuaGlzdG9yeVBhdGNoKHRvLCBraW5kKVxuICB9XG5cbiAgZXhwYW5kVVJMKHRvKXtcbiAgICByZXR1cm4gdG8uc3RhcnRzV2l0aChcIi9cIikgPyBgJHt3aW5kb3cubG9jYXRpb24ucHJvdG9jb2x9Ly8ke3dpbmRvdy5sb2NhdGlvbi5ob3N0fSR7dG99YCA6IHRvXG4gIH1cblxuICBvblJlZGlyZWN0KHt0bywgZmxhc2h9KXsgdGhpcy5saXZlU29ja2V0LnJlZGlyZWN0KHRvLCBmbGFzaCkgfVxuXG4gIGlzRGVzdHJveWVkKCl7IHJldHVybiB0aGlzLmRlc3Ryb3llZCB9XG5cbiAgam9pbkRlYWQoKXsgdGhpcy5pc0RlYWQgPSB0cnVlIH1cblxuICBqb2luKGNhbGxiYWNrKXtcbiAgICB0aGlzLnNob3dMb2FkZXIodGhpcy5saXZlU29ja2V0LmxvYWRlclRpbWVvdXQpXG4gICAgdGhpcy5iaW5kQ2hhbm5lbCgpXG4gICAgaWYodGhpcy5pc01haW4oKSl7XG4gICAgICB0aGlzLnN0b3BDYWxsYmFjayA9IHRoaXMubGl2ZVNvY2tldC53aXRoUGFnZUxvYWRpbmcoe3RvOiB0aGlzLmhyZWYsIGtpbmQ6IFwiaW5pdGlhbFwifSlcbiAgICB9XG4gICAgdGhpcy5qb2luQ2FsbGJhY2sgPSAob25Eb25lKSA9PiB7XG4gICAgICBvbkRvbmUgPSBvbkRvbmUgfHwgZnVuY3Rpb24oKXt9XG4gICAgICBjYWxsYmFjayA/IGNhbGxiYWNrKHRoaXMuam9pbkNvdW50LCBvbkRvbmUpIDogb25Eb25lKClcbiAgICB9XG4gICAgdGhpcy5saXZlU29ja2V0LndyYXBQdXNoKHRoaXMsIHt0aW1lb3V0OiBmYWxzZX0sICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNoYW5uZWwuam9pbigpXG4gICAgICAgIC5yZWNlaXZlKFwib2tcIiwgZGF0YSA9PiB7XG4gICAgICAgICAgaWYoIXRoaXMuaXNEZXN0cm95ZWQoKSl7XG4gICAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB0aGlzLm9uSm9pbihkYXRhKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgcmVzcCA9PiAhdGhpcy5pc0Rlc3Ryb3llZCgpICYmIHRoaXMub25Kb2luRXJyb3IocmVzcCkpXG4gICAgICAgIC5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiAhdGhpcy5pc0Rlc3Ryb3llZCgpICYmIHRoaXMub25Kb2luRXJyb3Ioe3JlYXNvbjogXCJ0aW1lb3V0XCJ9KSlcbiAgICB9KVxuICB9XG5cbiAgb25Kb2luRXJyb3IocmVzcCl7XG4gICAgaWYocmVzcC5yZWFzb24gPT09IFwicmVsb2FkXCIpe1xuICAgICAgdGhpcy5sb2coXCJlcnJvclwiLCAoKSA9PiBbYGZhaWxlZCBtb3VudCB3aXRoICR7cmVzcC5zdGF0dXN9LiBGYWxsaW5nIGJhY2sgdG8gcGFnZSByZXF1ZXN0YCwgcmVzcF0pXG4gICAgICBpZih0aGlzLmlzTWFpbigpKXsgdGhpcy5vblJlZGlyZWN0KHt0bzogdGhpcy5ocmVmfSkgfVxuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIGlmKHJlc3AucmVhc29uID09PSBcInVuYXV0aG9yaXplZFwiIHx8IHJlc3AucmVhc29uID09PSBcInN0YWxlXCIpe1xuICAgICAgdGhpcy5sb2coXCJlcnJvclwiLCAoKSA9PiBbXCJ1bmF1dGhvcml6ZWQgbGl2ZV9yZWRpcmVjdC4gRmFsbGluZyBiYWNrIHRvIHBhZ2UgcmVxdWVzdFwiLCByZXNwXSlcbiAgICAgIGlmKHRoaXMuaXNNYWluKCkpeyB0aGlzLm9uUmVkaXJlY3Qoe3RvOiB0aGlzLmhyZWZ9KSB9XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYocmVzcC5yZWRpcmVjdCB8fCByZXNwLmxpdmVfcmVkaXJlY3Qpe1xuICAgICAgdGhpcy5qb2luUGVuZGluZyA9IGZhbHNlXG4gICAgICB0aGlzLmNoYW5uZWwubGVhdmUoKVxuICAgIH1cbiAgICBpZihyZXNwLnJlZGlyZWN0KXsgcmV0dXJuIHRoaXMub25SZWRpcmVjdChyZXNwLnJlZGlyZWN0KSB9XG4gICAgaWYocmVzcC5saXZlX3JlZGlyZWN0KXsgcmV0dXJuIHRoaXMub25MaXZlUmVkaXJlY3QocmVzcC5saXZlX3JlZGlyZWN0KSB9XG4gICAgdGhpcy5kaXNwbGF5RXJyb3IoW1BIWF9MT0FESU5HX0NMQVNTLCBQSFhfRVJST1JfQ0xBU1MsIFBIWF9TRVJWRVJfRVJST1JfQ0xBU1NdKVxuICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgKCkgPT4gW1widW5hYmxlIHRvIGpvaW5cIiwgcmVzcF0pXG4gICAgaWYodGhpcy5saXZlU29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLmxpdmVTb2NrZXQucmVsb2FkV2l0aEppdHRlcih0aGlzKSB9XG4gIH1cblxuICBvbkNsb3NlKHJlYXNvbil7XG4gICAgaWYodGhpcy5pc0Rlc3Ryb3llZCgpKXsgcmV0dXJuIH1cbiAgICBpZih0aGlzLmxpdmVTb2NrZXQuaGFzUGVuZGluZ0xpbmsoKSAmJiByZWFzb24gIT09IFwibGVhdmVcIil7XG4gICAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0LnJlbG9hZFdpdGhKaXR0ZXIodGhpcylcbiAgICB9XG4gICAgdGhpcy5kZXN0cm95QWxsQ2hpbGRyZW4oKVxuICAgIHRoaXMubGl2ZVNvY2tldC5kcm9wQWN0aXZlRWxlbWVudCh0aGlzKVxuICAgIC8vIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIGJlIG51bGwgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTFcbiAgICBpZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KXsgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCkgfVxuICAgIGlmKHRoaXMubGl2ZVNvY2tldC5pc1VubG9hZGVkKCkpe1xuICAgICAgdGhpcy5zaG93TG9hZGVyKEJFRk9SRV9VTkxPQURfTE9BREVSX1RJTUVPVVQpXG4gICAgfVxuICB9XG5cbiAgb25FcnJvcihyZWFzb24pe1xuICAgIHRoaXMub25DbG9zZShyZWFzb24pXG4gICAgaWYodGhpcy5saXZlU29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLmxvZyhcImVycm9yXCIsICgpID0+IFtcInZpZXcgY3Jhc2hlZFwiLCByZWFzb25dKSB9XG4gICAgaWYoIXRoaXMubGl2ZVNvY2tldC5pc1VubG9hZGVkKCkpe1xuICAgICAgaWYodGhpcy5saXZlU29ja2V0LmlzQ29ubmVjdGVkKCkpe1xuICAgICAgICB0aGlzLmRpc3BsYXlFcnJvcihbUEhYX0xPQURJTkdfQ0xBU1MsIFBIWF9FUlJPUl9DTEFTUywgUEhYX1NFUlZFUl9FUlJPUl9DTEFTU10pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpc3BsYXlFcnJvcihbUEhYX0xPQURJTkdfQ0xBU1MsIFBIWF9FUlJPUl9DTEFTUywgUEhYX0NMSUVOVF9FUlJPUl9DTEFTU10pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGlzcGxheUVycm9yKGNsYXNzZXMpe1xuICAgIGlmKHRoaXMuaXNNYWluKCkpeyBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLCB7ZGV0YWlsOiB7dG86IHRoaXMuaHJlZiwga2luZDogXCJlcnJvclwifX0pIH1cbiAgICB0aGlzLnNob3dMb2FkZXIoKVxuICAgIHRoaXMuc2V0Q29udGFpbmVyQ2xhc3NlcyguLi5jbGFzc2VzKVxuICAgIHRoaXMuZXhlY0FsbCh0aGlzLmJpbmRpbmcoXCJkaXNjb25uZWN0ZWRcIikpXG4gIH1cblxuICBwdXNoV2l0aFJlcGx5KHJlZkdlbmVyYXRvciwgZXZlbnQsIHBheWxvYWQsIG9uUmVwbHkgPSBmdW5jdGlvbiAoKXsgfSl7XG4gICAgaWYoIXRoaXMuaXNDb25uZWN0ZWQoKSl7IHJldHVybiB9XG5cbiAgICBsZXQgW3JlZiwgW2VsXSwgb3B0c10gPSByZWZHZW5lcmF0b3IgPyByZWZHZW5lcmF0b3IoKSA6IFtudWxsLCBbXSwge31dXG4gICAgbGV0IG9uTG9hZGluZ0RvbmUgPSBmdW5jdGlvbigpeyB9XG4gICAgaWYob3B0cy5wYWdlX2xvYWRpbmcgfHwgKGVsICYmIChlbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9QQUdFX0xPQURJTkcpKSAhPT0gbnVsbCkpKXtcbiAgICAgIG9uTG9hZGluZ0RvbmUgPSB0aGlzLmxpdmVTb2NrZXQud2l0aFBhZ2VMb2FkaW5nKHtraW5kOiBcImVsZW1lbnRcIiwgdGFyZ2V0OiBlbH0pXG4gICAgfVxuXG4gICAgaWYodHlwZW9mIChwYXlsb2FkLmNpZCkgIT09IFwibnVtYmVyXCIpeyBkZWxldGUgcGF5bG9hZC5jaWQgfVxuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmxpdmVTb2NrZXQud3JhcFB1c2godGhpcywge3RpbWVvdXQ6IHRydWV9LCAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWwucHVzaChldmVudCwgcGF5bG9hZCwgUFVTSF9USU1FT1VUKS5yZWNlaXZlKFwib2tcIiwgcmVzcCA9PiB7XG4gICAgICAgICAgbGV0IGZpbmlzaCA9IChob29rUmVwbHkpID0+IHtcbiAgICAgICAgICAgIGlmKHJlc3AucmVkaXJlY3QpeyB0aGlzLm9uUmVkaXJlY3QocmVzcC5yZWRpcmVjdCkgfVxuICAgICAgICAgICAgaWYocmVzcC5saXZlX3BhdGNoKXsgdGhpcy5vbkxpdmVQYXRjaChyZXNwLmxpdmVfcGF0Y2gpIH1cbiAgICAgICAgICAgIGlmKHJlc3AubGl2ZV9yZWRpcmVjdCl7IHRoaXMub25MaXZlUmVkaXJlY3QocmVzcC5saXZlX3JlZGlyZWN0KSB9XG4gICAgICAgICAgICBvbkxvYWRpbmdEb25lKClcbiAgICAgICAgICAgIG9uUmVwbHkocmVzcCwgaG9va1JlcGx5KVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXNwLmRpZmYpe1xuICAgICAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmFwcGx5RGlmZihcInVwZGF0ZVwiLCByZXNwLmRpZmYsICh7ZGlmZiwgcmVwbHksIGV2ZW50c30pID0+IHtcbiAgICAgICAgICAgICAgICBpZihyZWYgIT09IG51bGwpeyB0aGlzLnVuZG9SZWZzKHJlZikgfVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKGRpZmYsIGV2ZW50cylcbiAgICAgICAgICAgICAgICBmaW5pc2gocmVwbHkpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZihyZWYgIT09IG51bGwpeyB0aGlzLnVuZG9SZWZzKHJlZikgfVxuICAgICAgICAgICAgZmluaXNoKG51bGwpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICApXG4gIH1cblxuICB1bmRvUmVmcyhyZWYpe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gfSAvLyBleGl0IGlmIGV4dGVybmFsIGZvcm0gdHJpZ2dlcmVkXG5cbiAgICBET00uYWxsKGRvY3VtZW50LCBgWyR7UEhYX1JFRl9TUkN9PVwiJHt0aGlzLmlkfVwiXVske1BIWF9SRUZ9PVwiJHtyZWZ9XCJdYCwgZWwgPT4ge1xuICAgICAgbGV0IGRpc2FibGVkVmFsID0gZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFRClcbiAgICAgIGxldCByZWFkT25seVZhbCA9IGVsLmdldEF0dHJpYnV0ZShQSFhfUkVBRE9OTFkpXG4gICAgICAvLyByZW1vdmUgcmVmc1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUYpXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRl9TUkMpXG4gICAgICAvLyByZXN0b3JlIGlucHV0c1xuICAgICAgaWYocmVhZE9ubHlWYWwgIT09IG51bGwpe1xuICAgICAgICBlbC5yZWFkT25seSA9IHJlYWRPbmx5VmFsID09PSBcInRydWVcIiA/IHRydWUgOiBmYWxzZVxuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFQURPTkxZKVxuICAgICAgfVxuICAgICAgaWYoZGlzYWJsZWRWYWwgIT09IG51bGwpe1xuICAgICAgICBlbC5kaXNhYmxlZCA9IGRpc2FibGVkVmFsID09PSBcInRydWVcIiA/IHRydWUgOiBmYWxzZVxuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX0RJU0FCTEVEKVxuICAgICAgfVxuICAgICAgLy8gcmVtb3ZlIGNsYXNzZXNcbiAgICAgIFBIWF9FVkVOVF9DTEFTU0VTLmZvckVhY2goY2xhc3NOYW1lID0+IERPTS5yZW1vdmVDbGFzcyhlbCwgY2xhc3NOYW1lKSlcbiAgICAgIC8vIHJlc3RvcmUgZGlzYWJsZXNcbiAgICAgIGxldCBkaXNhYmxlUmVzdG9yZSA9IGVsLmdldEF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUpXG4gICAgICBpZihkaXNhYmxlUmVzdG9yZSAhPT0gbnVsbCl7XG4gICAgICAgIGVsLmlubmVyVGV4dCA9IGRpc2FibGVSZXN0b3JlXG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUpXG4gICAgICB9XG4gICAgICBsZXQgdG9FbCA9IERPTS5wcml2YXRlKGVsLCBQSFhfUkVGKVxuICAgICAgaWYodG9FbCl7XG4gICAgICAgIGxldCBob29rID0gdGhpcy50cmlnZ2VyQmVmb3JlVXBkYXRlSG9vayhlbCwgdG9FbClcbiAgICAgICAgRE9NUGF0Y2gucGF0Y2hFbChlbCwgdG9FbCwgdGhpcy5saXZlU29ja2V0LmdldEFjdGl2ZUVsZW1lbnQoKSlcbiAgICAgICAgaWYoaG9vayl7IGhvb2suX191cGRhdGVkKCkgfVxuICAgICAgICBET00uZGVsZXRlUHJpdmF0ZShlbCwgUEhYX1JFRilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcHV0UmVmKGVsZW1lbnRzLCBldmVudCwgb3B0cyA9IHt9KXtcbiAgICBsZXQgbmV3UmVmID0gdGhpcy5yZWYrK1xuICAgIGxldCBkaXNhYmxlV2l0aCA9IHRoaXMuYmluZGluZyhQSFhfRElTQUJMRV9XSVRIKVxuICAgIGlmKG9wdHMubG9hZGluZyl7IGVsZW1lbnRzID0gZWxlbWVudHMuY29uY2F0KERPTS5hbGwoZG9jdW1lbnQsIG9wdHMubG9hZGluZykpfVxuXG4gICAgZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGBwaHgtJHtldmVudH0tbG9hZGluZ2ApXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRiwgbmV3UmVmKVxuICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9SRUZfU1JDLCB0aGlzLmVsLmlkKVxuICAgICAgbGV0IGRpc2FibGVUZXh0ID0gZWwuZ2V0QXR0cmlidXRlKGRpc2FibGVXaXRoKVxuICAgICAgaWYoZGlzYWJsZVRleHQgIT09IG51bGwpe1xuICAgICAgICBpZighZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSkpe1xuICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUsIGVsLmlubmVyVGV4dClcbiAgICAgICAgfVxuICAgICAgICBpZihkaXNhYmxlVGV4dCAhPT0gXCJcIil7IGVsLmlubmVyVGV4dCA9IGRpc2FibGVUZXh0IH1cbiAgICAgICAgLy8gUEhYX0RJU0FCTEVEIGNvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIHNldCBpbiBkaXNhYmxlRm9ybVxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBlbC5nZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVEKSB8fCBlbC5kaXNhYmxlZClcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIilcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBbbmV3UmVmLCBlbGVtZW50cywgb3B0c11cbiAgfVxuXG4gIGNvbXBvbmVudElEKGVsKXtcbiAgICBsZXQgY2lkID0gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKVxuICAgIHJldHVybiBjaWQgPyBwYXJzZUludChjaWQpIDogbnVsbFxuICB9XG5cbiAgdGFyZ2V0Q29tcG9uZW50SUQodGFyZ2V0LCB0YXJnZXRDdHgsIG9wdHMgPSB7fSl7XG4gICAgaWYoaXNDaWQodGFyZ2V0Q3R4KSl7IHJldHVybiB0YXJnZXRDdHggfVxuXG4gICAgbGV0IGNpZE9yU2VsZWN0b3IgPSBvcHRzLnRhcmdldCB8fCB0YXJnZXQuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcInRhcmdldFwiKSlcbiAgICBpZihpc0NpZChjaWRPclNlbGVjdG9yKSl7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoY2lkT3JTZWxlY3RvcilcbiAgICB9IGVsc2UgaWYodGFyZ2V0Q3R4ICYmIChjaWRPclNlbGVjdG9yICE9PSBudWxsIHx8IG9wdHMudGFyZ2V0KSl7XG4gICAgICByZXR1cm4gdGhpcy5jbG9zZXN0Q29tcG9uZW50SUQodGFyZ2V0Q3R4KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGNsb3Nlc3RDb21wb25lbnRJRCh0YXJnZXRDdHgpe1xuICAgIGlmKGlzQ2lkKHRhcmdldEN0eCkpe1xuICAgICAgcmV0dXJuIHRhcmdldEN0eFxuICAgIH0gZWxzZSBpZih0YXJnZXRDdHgpe1xuICAgICAgcmV0dXJuIG1heWJlKHRhcmdldEN0eC5jbG9zZXN0KGBbJHtQSFhfQ09NUE9ORU5UfV1gKSwgZWwgPT4gdGhpcy5vd25zRWxlbWVudChlbCkgJiYgdGhpcy5jb21wb25lbnRJRChlbCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgcHVzaEhvb2tFdmVudChlbCwgdGFyZ2V0Q3R4LCBldmVudCwgcGF5bG9hZCwgb25SZXBseSl7XG4gICAgaWYoIXRoaXMuaXNDb25uZWN0ZWQoKSl7XG4gICAgICB0aGlzLmxvZyhcImhvb2tcIiwgKCkgPT4gW1widW5hYmxlIHRvIHB1c2ggaG9vayBldmVudC4gTGl2ZVZpZXcgbm90IGNvbm5lY3RlZFwiLCBldmVudCwgcGF5bG9hZF0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgbGV0IFtyZWYsIGVscywgb3B0c10gPSB0aGlzLnB1dFJlZihbZWxdLCBcImhvb2tcIilcbiAgICB0aGlzLnB1c2hXaXRoUmVwbHkoKCkgPT4gW3JlZiwgZWxzLCBvcHRzXSwgXCJldmVudFwiLCB7XG4gICAgICB0eXBlOiBcImhvb2tcIixcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIHZhbHVlOiBwYXlsb2FkLFxuICAgICAgY2lkOiB0aGlzLmNsb3Nlc3RDb21wb25lbnRJRCh0YXJnZXRDdHgpXG4gICAgfSwgKHJlc3AsIHJlcGx5KSA9PiBvblJlcGx5KHJlcGx5LCByZWYpKVxuXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgZXh0cmFjdE1ldGEoZWwsIG1ldGEsIHZhbHVlKXtcbiAgICBsZXQgcHJlZml4ID0gdGhpcy5iaW5kaW5nKFwidmFsdWUtXCIpXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGVsLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspe1xuICAgICAgaWYoIW1ldGEpeyBtZXRhID0ge30gfVxuICAgICAgbGV0IG5hbWUgPSBlbC5hdHRyaWJ1dGVzW2ldLm5hbWVcbiAgICAgIGlmKG5hbWUuc3RhcnRzV2l0aChwcmVmaXgpKXsgbWV0YVtuYW1lLnJlcGxhY2UocHJlZml4LCBcIlwiKV0gPSBlbC5nZXRBdHRyaWJ1dGUobmFtZSkgfVxuICAgIH1cbiAgICBpZihlbC52YWx1ZSAhPT0gdW5kZWZpbmVkICYmICEoZWwgaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQpKXtcbiAgICAgIGlmKCFtZXRhKXsgbWV0YSA9IHt9IH1cbiAgICAgIG1ldGEudmFsdWUgPSBlbC52YWx1ZVxuXG4gICAgICBpZihlbC50YWdOYW1lID09PSBcIklOUFVUXCIgJiYgQ0hFQ0tBQkxFX0lOUFVUUy5pbmRleE9mKGVsLnR5cGUpID49IDAgJiYgIWVsLmNoZWNrZWQpe1xuICAgICAgICBkZWxldGUgbWV0YS52YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZih2YWx1ZSl7XG4gICAgICBpZighbWV0YSl7IG1ldGEgPSB7fSB9XG4gICAgICBmb3IobGV0IGtleSBpbiB2YWx1ZSl7IG1ldGFba2V5XSA9IHZhbHVlW2tleV0gfVxuICAgIH1cbiAgICByZXR1cm4gbWV0YVxuICB9XG5cblxuICBwdXNoRXZlbnQodHlwZSwgZWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIG1ldGEsIG9wdHMgPSB7fSwgb25SZXBseSl7XG4gICAgdGhpcy5wdXNoV2l0aFJlcGx5KCgpID0+IHRoaXMucHV0UmVmKFtlbF0sIHR5cGUsIG9wdHMpLCBcImV2ZW50XCIsIHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICB2YWx1ZTogdGhpcy5leHRyYWN0TWV0YShlbCwgbWV0YSwgb3B0cy52YWx1ZSksXG4gICAgICBjaWQ6IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoZWwsIHRhcmdldEN0eCwgb3B0cylcbiAgICB9LCAocmVzcCwgcmVwbHkpID0+IG9uUmVwbHkgJiYgb25SZXBseShyZXBseSkpXG4gIH1cblxuICBwdXNoRmlsZVByb2dyZXNzKGZpbGVFbCwgZW50cnlSZWYsIHByb2dyZXNzLCBvblJlcGx5ID0gZnVuY3Rpb24gKCl7IH0pe1xuICAgIHRoaXMubGl2ZVNvY2tldC53aXRoaW5Pd25lcnMoZmlsZUVsLmZvcm0sICh2aWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgIHZpZXcucHVzaFdpdGhSZXBseShudWxsLCBcInByb2dyZXNzXCIsIHtcbiAgICAgICAgZXZlbnQ6IGZpbGVFbC5nZXRBdHRyaWJ1dGUodmlldy5iaW5kaW5nKFBIWF9QUk9HUkVTUykpLFxuICAgICAgICByZWY6IGZpbGVFbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpLFxuICAgICAgICBlbnRyeV9yZWY6IGVudHJ5UmVmLFxuICAgICAgICBwcm9ncmVzczogcHJvZ3Jlc3MsXG4gICAgICAgIGNpZDogdmlldy50YXJnZXRDb21wb25lbnRJRChmaWxlRWwuZm9ybSwgdGFyZ2V0Q3R4KVxuICAgICAgfSwgb25SZXBseSlcbiAgICB9KVxuICB9XG5cbiAgcHVzaElucHV0KGlucHV0RWwsIHRhcmdldEN0eCwgZm9yY2VDaWQsIHBoeEV2ZW50LCBvcHRzLCBjYWxsYmFjayl7XG4gICAgbGV0IHVwbG9hZHNcbiAgICBsZXQgY2lkID0gaXNDaWQoZm9yY2VDaWQpID8gZm9yY2VDaWQgOiB0aGlzLnRhcmdldENvbXBvbmVudElEKGlucHV0RWwuZm9ybSwgdGFyZ2V0Q3R4LCBvcHRzKVxuICAgIGxldCByZWZHZW5lcmF0b3IgPSAoKSA9PiB0aGlzLnB1dFJlZihbaW5wdXRFbCwgaW5wdXRFbC5mb3JtXSwgXCJjaGFuZ2VcIiwgb3B0cylcbiAgICBsZXQgZm9ybURhdGFcbiAgICBsZXQgbWV0YSAgPSB0aGlzLmV4dHJhY3RNZXRhKGlucHV0RWwuZm9ybSlcbiAgICBpZihpbnB1dEVsIGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnQpeyBtZXRhLnN1Ym1pdHRlciA9IGlucHV0RWwgfVxuICAgIGlmKGlucHV0RWwuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcImNoYW5nZVwiKSkpe1xuICAgICAgZm9ybURhdGEgPSBzZXJpYWxpemVGb3JtKGlucHV0RWwuZm9ybSwge190YXJnZXQ6IG9wdHMuX3RhcmdldCwgLi4ubWV0YX0sIFtpbnB1dEVsLm5hbWVdKVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtRGF0YSA9IHNlcmlhbGl6ZUZvcm0oaW5wdXRFbC5mb3JtLCB7X3RhcmdldDogb3B0cy5fdGFyZ2V0LCAuLi5tZXRhfSlcbiAgICB9XG4gICAgaWYoRE9NLmlzVXBsb2FkSW5wdXQoaW5wdXRFbCkgJiYgaW5wdXRFbC5maWxlcyAmJiBpbnB1dEVsLmZpbGVzLmxlbmd0aCA+IDApe1xuICAgICAgTGl2ZVVwbG9hZGVyLnRyYWNrRmlsZXMoaW5wdXRFbCwgQXJyYXkuZnJvbShpbnB1dEVsLmZpbGVzKSlcbiAgICB9XG4gICAgdXBsb2FkcyA9IExpdmVVcGxvYWRlci5zZXJpYWxpemVVcGxvYWRzKGlucHV0RWwpXG5cbiAgICBsZXQgZXZlbnQgPSB7XG4gICAgICB0eXBlOiBcImZvcm1cIixcbiAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgIHVwbG9hZHM6IHVwbG9hZHMsXG4gICAgICBjaWQ6IGNpZFxuICAgIH1cbiAgICB0aGlzLnB1c2hXaXRoUmVwbHkocmVmR2VuZXJhdG9yLCBcImV2ZW50XCIsIGV2ZW50LCByZXNwID0+IHtcbiAgICAgIERPTS5zaG93RXJyb3IoaW5wdXRFbCwgdGhpcy5saXZlU29ja2V0LmJpbmRpbmcoUEhYX0ZFRURCQUNLX0ZPUiksIHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9GRUVEQkFDS19HUk9VUCkpXG4gICAgICBpZihET00uaXNVcGxvYWRJbnB1dChpbnB1dEVsKSAmJiBET00uaXNBdXRvVXBsb2FkKGlucHV0RWwpKXtcbiAgICAgICAgaWYoTGl2ZVVwbG9hZGVyLmZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoaW5wdXRFbCkubGVuZ3RoID4gMCl7XG4gICAgICAgICAgbGV0IFtyZWYsIF9lbHNdID0gcmVmR2VuZXJhdG9yKClcbiAgICAgICAgICB0aGlzLnVwbG9hZEZpbGVzKGlucHV0RWwuZm9ybSwgdGFyZ2V0Q3R4LCByZWYsIGNpZCwgKF91cGxvYWRzKSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXNwKVxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQXdhaXRpbmdTdWJtaXQoaW5wdXRFbC5mb3JtKVxuICAgICAgICAgICAgdGhpcy51bmRvUmVmcyhyZWYpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzcClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgdHJpZ2dlckF3YWl0aW5nU3VibWl0KGZvcm1FbCl7XG4gICAgbGV0IGF3YWl0aW5nU3VibWl0ID0gdGhpcy5nZXRTY2hlZHVsZWRTdWJtaXQoZm9ybUVsKVxuICAgIGlmKGF3YWl0aW5nU3VibWl0KXtcbiAgICAgIGxldCBbX2VsLCBfcmVmLCBfb3B0cywgY2FsbGJhY2tdID0gYXdhaXRpbmdTdWJtaXRcbiAgICAgIHRoaXMuY2FuY2VsU3VibWl0KGZvcm1FbClcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH1cblxuICBnZXRTY2hlZHVsZWRTdWJtaXQoZm9ybUVsKXtcbiAgICByZXR1cm4gdGhpcy5mb3JtU3VibWl0cy5maW5kKChbZWwsIF9yZWYsIF9vcHRzLCBfY2FsbGJhY2tdKSA9PiBlbC5pc1NhbWVOb2RlKGZvcm1FbCkpXG4gIH1cblxuICBzY2hlZHVsZVN1Ym1pdChmb3JtRWwsIHJlZiwgb3B0cywgY2FsbGJhY2spe1xuICAgIGlmKHRoaXMuZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbCkpeyByZXR1cm4gdHJ1ZSB9XG4gICAgdGhpcy5mb3JtU3VibWl0cy5wdXNoKFtmb3JtRWwsIHJlZiwgb3B0cywgY2FsbGJhY2tdKVxuICB9XG5cbiAgY2FuY2VsU3VibWl0KGZvcm1FbCl7XG4gICAgdGhpcy5mb3JtU3VibWl0cyA9IHRoaXMuZm9ybVN1Ym1pdHMuZmlsdGVyKChbZWwsIHJlZiwgX2NhbGxiYWNrXSkgPT4ge1xuICAgICAgaWYoZWwuaXNTYW1lTm9kZShmb3JtRWwpKXtcbiAgICAgICAgdGhpcy51bmRvUmVmcyhyZWYpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZGlzYWJsZUZvcm0oZm9ybUVsLCBvcHRzID0ge30pe1xuICAgIGxldCBmaWx0ZXJJZ25vcmVkID0gZWwgPT4ge1xuICAgICAgbGV0IHVzZXJJZ25vcmVkID0gY2xvc2VzdFBoeEJpbmRpbmcoZWwsIGAke3RoaXMuYmluZGluZyhQSFhfVVBEQVRFKX09aWdub3JlYCwgZWwuZm9ybSlcbiAgICAgIHJldHVybiAhKHVzZXJJZ25vcmVkIHx8IGNsb3Nlc3RQaHhCaW5kaW5nKGVsLCBcImRhdGEtcGh4LXVwZGF0ZT1pZ25vcmVcIiwgZWwuZm9ybSkpXG4gICAgfVxuICAgIGxldCBmaWx0ZXJEaXNhYmxlcyA9IGVsID0+IHtcbiAgICAgIHJldHVybiBlbC5oYXNBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9ESVNBQkxFX1dJVEgpKVxuICAgIH1cbiAgICBsZXQgZmlsdGVyQnV0dG9uID0gZWwgPT4gZWwudGFnTmFtZSA9PSBcIkJVVFRPTlwiXG5cbiAgICBsZXQgZmlsdGVySW5wdXQgPSBlbCA9PiBbXCJJTlBVVFwiLCBcIlRFWFRBUkVBXCIsIFwiU0VMRUNUXCJdLmluY2x1ZGVzKGVsLnRhZ05hbWUpXG5cbiAgICBsZXQgZm9ybUVsZW1lbnRzID0gQXJyYXkuZnJvbShmb3JtRWwuZWxlbWVudHMpXG4gICAgbGV0IGRpc2FibGVzID0gZm9ybUVsZW1lbnRzLmZpbHRlcihmaWx0ZXJEaXNhYmxlcylcbiAgICBsZXQgYnV0dG9ucyA9IGZvcm1FbGVtZW50cy5maWx0ZXIoZmlsdGVyQnV0dG9uKS5maWx0ZXIoZmlsdGVySWdub3JlZClcbiAgICBsZXQgaW5wdXRzID0gZm9ybUVsZW1lbnRzLmZpbHRlcihmaWx0ZXJJbnB1dCkuZmlsdGVyKGZpbHRlcklnbm9yZWQpXG5cbiAgICBidXR0b25zLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBidXR0b24uZGlzYWJsZWQpXG4gICAgICBidXR0b24uZGlzYWJsZWQgPSB0cnVlXG4gICAgfSlcbiAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX1JFQURPTkxZLCBpbnB1dC5yZWFkT25seSlcbiAgICAgIGlucHV0LnJlYWRPbmx5ID0gdHJ1ZVxuICAgICAgaWYoaW5wdXQuZmlsZXMpe1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBpbnB1dC5kaXNhYmxlZClcbiAgICAgICAgaW5wdXQuZGlzYWJsZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSlcbiAgICBmb3JtRWwuc2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfUEFHRV9MT0FESU5HKSwgXCJcIilcbiAgICByZXR1cm4gdGhpcy5wdXRSZWYoW2Zvcm1FbF0uY29uY2F0KGRpc2FibGVzKS5jb25jYXQoYnV0dG9ucykuY29uY2F0KGlucHV0cyksIFwic3VibWl0XCIsIG9wdHMpXG4gIH1cblxuICBwdXNoRm9ybVN1Ym1pdChmb3JtRWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIHN1Ym1pdHRlciwgb3B0cywgb25SZXBseSl7XG4gICAgbGV0IHJlZkdlbmVyYXRvciA9ICgpID0+IHRoaXMuZGlzYWJsZUZvcm0oZm9ybUVsLCBvcHRzKVxuICAgIGxldCBjaWQgPSB0aGlzLnRhcmdldENvbXBvbmVudElEKGZvcm1FbCwgdGFyZ2V0Q3R4KVxuICAgIGlmKExpdmVVcGxvYWRlci5oYXNVcGxvYWRzSW5Qcm9ncmVzcyhmb3JtRWwpKXtcbiAgICAgIGxldCBbcmVmLCBfZWxzXSA9IHJlZkdlbmVyYXRvcigpXG4gICAgICBsZXQgcHVzaCA9ICgpID0+IHRoaXMucHVzaEZvcm1TdWJtaXQoZm9ybUVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBzdWJtaXR0ZXIsIG9wdHMsIG9uUmVwbHkpXG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZVN1Ym1pdChmb3JtRWwsIHJlZiwgb3B0cywgcHVzaClcbiAgICB9IGVsc2UgaWYoTGl2ZVVwbG9hZGVyLmlucHV0c0F3YWl0aW5nUHJlZmxpZ2h0KGZvcm1FbCkubGVuZ3RoID4gMCl7XG4gICAgICBsZXQgW3JlZiwgZWxzXSA9IHJlZkdlbmVyYXRvcigpXG4gICAgICBsZXQgcHJveHlSZWZHZW4gPSAoKSA9PiBbcmVmLCBlbHMsIG9wdHNdXG4gICAgICB0aGlzLnVwbG9hZEZpbGVzKGZvcm1FbCwgdGFyZ2V0Q3R4LCByZWYsIGNpZCwgKHVwbG9hZHMpID0+IHtcbiAgICAgICAgLy8gaWYgd2Ugc3RpbGwgaGF2aW5nIHBlbmRpbmcgcHJlZmxpZ2h0cyBpdCBtZWFucyB3ZSBoYXZlIGludmFsaWQgZW50cmllc1xuICAgICAgICAvLyBhbmQgdGhlIHBoeC1zdWJtaXQgY2Fubm90IGJlIGNvbXBsZXRlZFxuICAgICAgICBpZihMaXZlVXBsb2FkZXIuaW5wdXRzQXdhaXRpbmdQcmVmbGlnaHQoZm9ybUVsKS5sZW5ndGggPiAwKXtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bmRvUmVmcyhyZWYpXG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGEgPSB0aGlzLmV4dHJhY3RNZXRhKGZvcm1FbClcbiAgICAgICAgbGV0IGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShmb3JtRWwsIHtzdWJtaXR0ZXIsIC4uLm1ldGF9KVxuICAgICAgICB0aGlzLnB1c2hXaXRoUmVwbHkocHJveHlSZWZHZW4sIFwiZXZlbnRcIiwge1xuICAgICAgICAgIHR5cGU6IFwiZm9ybVwiLFxuICAgICAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgICAgICB2YWx1ZTogZm9ybURhdGEsXG4gICAgICAgICAgY2lkOiBjaWRcbiAgICAgICAgfSwgb25SZXBseSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmKCEoZm9ybUVsLmhhc0F0dHJpYnV0ZShQSFhfUkVGKSAmJiBmb3JtRWwuY2xhc3NMaXN0LmNvbnRhaW5zKFwicGh4LXN1Ym1pdC1sb2FkaW5nXCIpKSl7XG4gICAgICBsZXQgbWV0YSA9IHRoaXMuZXh0cmFjdE1ldGEoZm9ybUVsKVxuICAgICAgbGV0IGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShmb3JtRWwsIHtzdWJtaXR0ZXIsIC4uLm1ldGF9KVxuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KHJlZkdlbmVyYXRvciwgXCJldmVudFwiLCB7XG4gICAgICAgIHR5cGU6IFwiZm9ybVwiLFxuICAgICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgICAgY2lkOiBjaWRcbiAgICAgIH0sIG9uUmVwbHkpXG4gICAgfVxuICB9XG5cbiAgdXBsb2FkRmlsZXMoZm9ybUVsLCB0YXJnZXRDdHgsIHJlZiwgY2lkLCBvbkNvbXBsZXRlKXtcbiAgICBsZXQgam9pbkNvdW50QXRVcGxvYWQgPSB0aGlzLmpvaW5Db3VudFxuICAgIGxldCBpbnB1dEVscyA9IExpdmVVcGxvYWRlci5hY3RpdmVGaWxlSW5wdXRzKGZvcm1FbClcbiAgICBsZXQgbnVtRmlsZUlucHV0c0luUHJvZ3Jlc3MgPSBpbnB1dEVscy5sZW5ndGhcblxuICAgIC8vIGdldCBlYWNoIGZpbGUgaW5wdXRcbiAgICBpbnB1dEVscy5mb3JFYWNoKGlucHV0RWwgPT4ge1xuICAgICAgbGV0IHVwbG9hZGVyID0gbmV3IExpdmVVcGxvYWRlcihpbnB1dEVsLCB0aGlzLCAoKSA9PiB7XG4gICAgICAgIG51bUZpbGVJbnB1dHNJblByb2dyZXNzLS1cbiAgICAgICAgaWYobnVtRmlsZUlucHV0c0luUHJvZ3Jlc3MgPT09IDApeyBvbkNvbXBsZXRlKCkgfVxuICAgICAgfSk7XG5cbiAgICAgIGxldCBlbnRyaWVzID0gdXBsb2FkZXIuZW50cmllcygpLm1hcChlbnRyeSA9PiBlbnRyeS50b1ByZWZsaWdodFBheWxvYWQoKSlcblxuICAgICAgaWYoZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbnVtRmlsZUlucHV0c0luUHJvZ3Jlc3MtLVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgbGV0IHBheWxvYWQgPSB7XG4gICAgICAgIHJlZjogaW5wdXRFbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpLFxuICAgICAgICBlbnRyaWVzOiBlbnRyaWVzLFxuICAgICAgICBjaWQ6IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoaW5wdXRFbC5mb3JtLCB0YXJnZXRDdHgpXG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nKFwidXBsb2FkXCIsICgpID0+IFtcInNlbmRpbmcgcHJlZmxpZ2h0IHJlcXVlc3RcIiwgcGF5bG9hZF0pXG5cbiAgICAgIHRoaXMucHVzaFdpdGhSZXBseShudWxsLCBcImFsbG93X3VwbG9hZFwiLCBwYXlsb2FkLCByZXNwID0+IHtcbiAgICAgICAgdGhpcy5sb2coXCJ1cGxvYWRcIiwgKCkgPT4gW1wiZ290IHByZWZsaWdodCByZXNwb25zZVwiLCByZXNwXSlcbiAgICAgICAgLy8gdGhlIHByZWZsaWdodCB3aWxsIHJlamVjdCBlbnRyaWVzIGJleW9uZCB0aGUgbWF4IGVudHJpZXNcbiAgICAgICAgLy8gc28gd2UgZXJyb3IgYW5kIGNhbmNlbCBlbnRyaWVzIG9uIHRoZSBjbGllbnQgdGhhdCBhcmUgbWlzc2luZyBmcm9tIHRoZSByZXNwb25zZVxuICAgICAgICB1cGxvYWRlci5lbnRyaWVzKCkuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgICAgaWYocmVzcC5lbnRyaWVzICYmICFyZXNwLmVudHJpZXNbZW50cnkucmVmXSl7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUZhaWxlZEVudHJ5UHJlZmxpZ2h0KGVudHJ5LnJlZiwgXCJmYWlsZWQgcHJlZmxpZ2h0XCIsIHVwbG9hZGVyKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLy8gZm9yIGF1dG8gdXBsb2Fkcywgd2UgbWF5IGhhdmUgYW4gZW1wdHkgZW50cmllcyByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgICAgLy8gZm9yIGZvcm0gc3VibWl0cyB0aGF0IGNvbnRhaW4gaW52YWxpZCBlbnRyaWVzXG4gICAgICAgIGlmKHJlc3AuZXJyb3IgfHwgT2JqZWN0LmtleXMocmVzcC5lbnRyaWVzKS5sZW5ndGggPT09IDApe1xuICAgICAgICAgIHRoaXMudW5kb1JlZnMocmVmKVxuICAgICAgICAgIGxldCBlcnJvcnMgPSByZXNwLmVycm9yIHx8IFtdXG4gICAgICAgICAgZXJyb3JzLm1hcCgoW2VudHJ5X3JlZiwgcmVhc29uXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVGYWlsZWRFbnRyeVByZWZsaWdodChlbnRyeV9yZWYsIHJlYXNvbiwgdXBsb2FkZXIpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgb25FcnJvciA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLm9uRXJyb3IoKCkgPT4ge1xuICAgICAgICAgICAgICBpZih0aGlzLmpvaW5Db3VudCA9PT0gam9pbkNvdW50QXRVcGxvYWQpeyBjYWxsYmFjaygpIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICAgIHVwbG9hZGVyLmluaXRBZGFwdGVyVXBsb2FkKHJlc3AsIG9uRXJyb3IsIHRoaXMubGl2ZVNvY2tldClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgaGFuZGxlRmFpbGVkRW50cnlQcmVmbGlnaHQodXBsb2FkUmVmLCByZWFzb24sIHVwbG9hZGVyKXtcbiAgICBpZih1cGxvYWRlci5pc0F1dG9VcGxvYWQoKSl7XG4gICAgICAvLyB1cGxvYWRSZWYgbWF5IGJlIHRvcCBsZXZlbCB1cGxvYWQgY29uZmlnIHJlZiBvciBlbnRyeSByZWZcbiAgICAgIGxldCBlbnRyeSA9IHVwbG9hZGVyLmVudHJpZXMoKS5maW5kKGVudHJ5ID0+IGVudHJ5LnJlZiA9PT0gdXBsb2FkUmVmLnRvU3RyaW5nKCkpXG4gICAgICBpZihlbnRyeSl7IGVudHJ5LmNhbmNlbCgpIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXBsb2FkZXIuZW50cmllcygpLm1hcChlbnRyeSA9PiBlbnRyeS5jYW5jZWwoKSlcbiAgICB9XG4gICAgdGhpcy5sb2coXCJ1cGxvYWRcIiwgKCkgPT4gW2BlcnJvciBmb3IgZW50cnkgJHt1cGxvYWRSZWZ9YCwgcmVhc29uXSlcbiAgfVxuXG4gIGRpc3BhdGNoVXBsb2Fkcyh0YXJnZXRDdHgsIG5hbWUsIGZpbGVzT3JCbG9icyl7XG4gICAgbGV0IHRhcmdldEVsZW1lbnQgPSB0aGlzLnRhcmdldEN0eEVsZW1lbnQodGFyZ2V0Q3R4KSB8fCB0aGlzLmVsXG4gICAgbGV0IGlucHV0cyA9IERPTS5maW5kVXBsb2FkSW5wdXRzKHRhcmdldEVsZW1lbnQpLmZpbHRlcihlbCA9PiBlbC5uYW1lID09PSBuYW1lKVxuICAgIGlmKGlucHV0cy5sZW5ndGggPT09IDApeyBsb2dFcnJvcihgbm8gbGl2ZSBmaWxlIGlucHV0cyBmb3VuZCBtYXRjaGluZyB0aGUgbmFtZSBcIiR7bmFtZX1cImApIH1cbiAgICBlbHNlIGlmKGlucHV0cy5sZW5ndGggPiAxKXsgbG9nRXJyb3IoYGR1cGxpY2F0ZSBsaXZlIGZpbGUgaW5wdXRzIGZvdW5kIG1hdGNoaW5nIHRoZSBuYW1lIFwiJHtuYW1lfVwiYCkgfVxuICAgIGVsc2UgeyBET00uZGlzcGF0Y2hFdmVudChpbnB1dHNbMF0sIFBIWF9UUkFDS19VUExPQURTLCB7ZGV0YWlsOiB7ZmlsZXM6IGZpbGVzT3JCbG9ic319KSB9XG4gIH1cblxuICB0YXJnZXRDdHhFbGVtZW50KHRhcmdldEN0eCkge1xuICAgIGlmKGlzQ2lkKHRhcmdldEN0eCkpe1xuICAgICAgbGV0IFt0YXJnZXRdID0gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmVsLCB0YXJnZXRDdHgpXG4gICAgICByZXR1cm4gdGFyZ2V0XG4gICAgfSBlbHNlIGlmKHRhcmdldEN0eCkge1xuICAgICAgcmV0dXJuIHRhcmdldEN0eFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHB1c2hGb3JtUmVjb3ZlcnkoZm9ybSwgbmV3Q2lkLCBjYWxsYmFjayl7XG4gICAgdGhpcy5saXZlU29ja2V0LndpdGhpbk93bmVycyhmb3JtLCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICBsZXQgcGh4Q2hhbmdlID0gdGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpXG4gICAgICBsZXQgaW5wdXRzID0gQXJyYXkuZnJvbShmb3JtLmVsZW1lbnRzKS5maWx0ZXIoZWwgPT4gRE9NLmlzRm9ybUlucHV0KGVsKSAmJiBlbC5uYW1lICYmICFlbC5oYXNBdHRyaWJ1dGUocGh4Q2hhbmdlKSlcbiAgICAgIGlmKGlucHV0cy5sZW5ndGggPT09IDApeyByZXR1cm4gfVxuXG4gICAgICAvLyB3ZSBtdXN0IGNsZWFyIHRyYWNrZWQgdXBsb2FkcyBiZWZvcmUgcmVjb3ZlcnkgYXMgdGhleSBubyBsb25nZXIgaGF2ZSB2YWxpZCByZWZzXG4gICAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBpbnB1dC5oYXNBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpICYmIExpdmVVcGxvYWRlci5jbGVhckZpbGVzKGlucHV0KSlcbiAgICAgIGxldCBpbnB1dCA9IGlucHV0cy5maW5kKGVsID0+IGVsLnR5cGUgIT09IFwiaGlkZGVuXCIpIHx8IGlucHV0c1swXVxuXG4gICAgICBsZXQgcGh4RXZlbnQgPSBmb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0FVVE9fUkVDT1ZFUikpIHx8IGZvcm0uZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcImNoYW5nZVwiKSlcbiAgICAgIEpTLmV4ZWMoXCJjaGFuZ2VcIiwgcGh4RXZlbnQsIHZpZXcsIGlucHV0LCBbXCJwdXNoXCIsIHtfdGFyZ2V0OiBpbnB1dC5uYW1lLCBuZXdDaWQ6IG5ld0NpZCwgY2FsbGJhY2s6IGNhbGxiYWNrfV0pXG4gICAgfSlcbiAgfVxuXG4gIHB1c2hMaW5rUGF0Y2goaHJlZiwgdGFyZ2V0RWwsIGNhbGxiYWNrKXtcbiAgICBsZXQgbGlua1JlZiA9IHRoaXMubGl2ZVNvY2tldC5zZXRQZW5kaW5nTGluayhocmVmKVxuICAgIGxldCByZWZHZW4gPSB0YXJnZXRFbCA/ICgpID0+IHRoaXMucHV0UmVmKFt0YXJnZXRFbF0sIFwiY2xpY2tcIikgOiBudWxsXG4gICAgbGV0IGZhbGxiYWNrID0gKCkgPT4gdGhpcy5saXZlU29ja2V0LnJlZGlyZWN0KHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgIGxldCB1cmwgPSBocmVmLnN0YXJ0c1dpdGgoXCIvXCIpID8gYCR7bG9jYXRpb24ucHJvdG9jb2x9Ly8ke2xvY2F0aW9uLmhvc3R9JHtocmVmfWAgOiBocmVmXG5cbiAgICBsZXQgcHVzaCA9IHRoaXMucHVzaFdpdGhSZXBseShyZWZHZW4sIFwibGl2ZV9wYXRjaFwiLCB7dXJsfSwgcmVzcCA9PiB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGlmKHJlc3AubGlua19yZWRpcmVjdCl7XG4gICAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcGxhY2VNYWluKGhyZWYsIG51bGwsIGNhbGxiYWNrLCBsaW5rUmVmKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKHRoaXMubGl2ZVNvY2tldC5jb21taXRQZW5kaW5nTGluayhsaW5rUmVmKSl7XG4gICAgICAgICAgICB0aGlzLmhyZWYgPSBocmVmXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYXBwbHlQZW5kaW5nVXBkYXRlcygpXG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobGlua1JlZilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaWYocHVzaCl7XG4gICAgICBwdXNoLnJlY2VpdmUoXCJ0aW1lb3V0XCIsIGZhbGxiYWNrKVxuICAgIH0gZWxzZSB7XG4gICAgICBmYWxsYmFjaygpXG4gICAgfVxuICB9XG5cbiAgZm9ybXNGb3JSZWNvdmVyeShodG1sKXtcbiAgICBpZih0aGlzLmpvaW5Db3VudCA9PT0gMCl7IHJldHVybiBbXSB9XG5cbiAgICBsZXQgcGh4Q2hhbmdlID0gdGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpXG4gICAgbGV0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpXG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbFxuXG4gICAgcmV0dXJuIChcbiAgICAgIERPTS5hbGwodGhpcy5lbCwgYGZvcm1bJHtwaHhDaGFuZ2V9XWApXG4gICAgICAgIC5maWx0ZXIoZm9ybSA9PiBmb3JtLmlkICYmIHRoaXMub3duc0VsZW1lbnQoZm9ybSkpXG4gICAgICAgIC5maWx0ZXIoZm9ybSA9PiBmb3JtLmVsZW1lbnRzLmxlbmd0aCA+IDApXG4gICAgICAgIC5maWx0ZXIoZm9ybSA9PiBmb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0FVVE9fUkVDT1ZFUikpICE9PSBcImlnbm9yZVwiKVxuICAgICAgICAubWFwKGZvcm0gPT4ge1xuICAgICAgICAgIC8vIGF0dHJpYnV0ZSBnaXZlbiB2aWEgSlMgbW9kdWxlIG5lZWRzIHRvIGJlIGVzY2FwZWQgYXMgaXQgY29udGFpbnMgdGhlIHN5bWJvbHMgW11cIixcbiAgICAgICAgICAvLyB3aGljaCByZXN1bHQgaW4gYW4gaW52YWxpZCBjc3Mgc2VsZWN0b3Igb3RoZXJ3aXNlLlxuICAgICAgICAgIGNvbnN0IHBoeENoYW5nZVZhbHVlID0gQ1NTLmVzY2FwZShmb3JtLmdldEF0dHJpYnV0ZShwaHhDaGFuZ2UpKVxuICAgICAgICAgIGxldCBuZXdGb3JtID0gdGVtcGxhdGUuY29udGVudC5xdWVyeVNlbGVjdG9yKGBmb3JtW2lkPVwiJHtmb3JtLmlkfVwiXVske3BoeENoYW5nZX09XCIke3BoeENoYW5nZVZhbHVlfVwiXWApXG4gICAgICAgICAgaWYobmV3Rm9ybSl7XG4gICAgICAgICAgICByZXR1cm4gW2Zvcm0sIG5ld0Zvcm0sIHRoaXMudGFyZ2V0Q29tcG9uZW50SUQobmV3Rm9ybSldXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbZm9ybSwgZm9ybSwgdGhpcy50YXJnZXRDb21wb25lbnRJRChmb3JtKV1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoKFtmb3JtLCBuZXdGb3JtLCBuZXdDaWRdKSA9PiBuZXdGb3JtKVxuICAgIClcbiAgfVxuXG4gIG1heWJlUHVzaENvbXBvbmVudHNEZXN0cm95ZWQoZGVzdHJveWVkQ0lEcyl7XG4gICAgbGV0IHdpbGxEZXN0cm95Q0lEcyA9IGRlc3Ryb3llZENJRHMuZmlsdGVyKGNpZCA9PiB7XG4gICAgICByZXR1cm4gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmVsLCBjaWQpLmxlbmd0aCA9PT0gMFxuICAgIH0pXG5cbiAgICBpZih3aWxsRGVzdHJveUNJRHMubGVuZ3RoID4gMCl7XG4gICAgICAvLyB3ZSBtdXN0IHJlc2V0IHRoZSByZW5kZXIgY2hhbmdlIHRyYWNraW5nIGZvciBjaWRzIHRoYXRcbiAgICAgIC8vIGNvdWxkIGJlIGFkZGVkIGJhY2sgZnJvbSB0aGUgc2VydmVyIHNvIHdlIGRvbid0IHNraXAgdGhlbVxuICAgICAgd2lsbERlc3Ryb3lDSURzLmZvckVhY2goY2lkID0+IHRoaXMucmVuZGVyZWQucmVzZXRSZW5kZXIoY2lkKSlcblxuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KG51bGwsIFwiY2lkc193aWxsX2Rlc3Ryb3lcIiwge2NpZHM6IHdpbGxEZXN0cm95Q0lEc30sICgpID0+IHtcbiAgICAgICAgLy8gU2VlIGlmIGFueSBvZiB0aGUgY2lkcyB3ZSB3YW50ZWQgdG8gZGVzdHJveSB3ZXJlIGFkZGVkIGJhY2ssXG4gICAgICAgIC8vIGlmIHRoZXkgd2VyZSBhZGRlZCBiYWNrLCB3ZSBkb24ndCBhY3R1YWxseSBkZXN0cm95IHRoZW0uXG4gICAgICAgIGxldCBjb21wbGV0ZWx5RGVzdHJveUNJRHMgPSB3aWxsRGVzdHJveUNJRHMuZmlsdGVyKGNpZCA9PiB7XG4gICAgICAgICAgcmV0dXJuIERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5lbCwgY2lkKS5sZW5ndGggPT09IDBcbiAgICAgICAgfSlcblxuICAgICAgICBpZihjb21wbGV0ZWx5RGVzdHJveUNJRHMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KG51bGwsIFwiY2lkc19kZXN0cm95ZWRcIiwge2NpZHM6IGNvbXBsZXRlbHlEZXN0cm95Q0lEc30sIChyZXNwKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVkLnBydW5lQ0lEcyhyZXNwLmNpZHMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBvd25zRWxlbWVudChlbCl7XG4gICAgbGV0IHBhcmVudFZpZXdFbCA9IGVsLmNsb3Nlc3QoUEhYX1ZJRVdfU0VMRUNUT1IpXG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShQSFhfUEFSRU5UX0lEKSA9PT0gdGhpcy5pZCB8fFxuICAgICAgKHBhcmVudFZpZXdFbCAmJiBwYXJlbnRWaWV3RWwuaWQgPT09IHRoaXMuaWQpIHx8XG4gICAgICAoIXBhcmVudFZpZXdFbCAmJiB0aGlzLmlzRGVhZClcbiAgfVxuXG4gIHN1Ym1pdEZvcm0oZm9ybSwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgc3VibWl0dGVyLCBvcHRzID0ge30pe1xuICAgIERPTS5wdXRQcml2YXRlKGZvcm0sIFBIWF9IQVNfU1VCTUlUVEVELCB0cnVlKVxuICAgIGNvbnN0IHBoeEZlZWRiYWNrRm9yID0gdGhpcy5saXZlU29ja2V0LmJpbmRpbmcoUEhYX0ZFRURCQUNLX0ZPUilcbiAgICBjb25zdCBwaHhGZWVkYmFja0dyb3VwID0gdGhpcy5saXZlU29ja2V0LmJpbmRpbmcoUEhYX0ZFRURCQUNLX0dST1VQKVxuICAgIGNvbnN0IGlucHV0cyA9IEFycmF5LmZyb20oZm9ybS5lbGVtZW50cylcbiAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBET00ucHV0UHJpdmF0ZShpbnB1dCwgUEhYX0hBU19TVUJNSVRURUQsIHRydWUpKVxuICAgIHRoaXMubGl2ZVNvY2tldC5ibHVyQWN0aXZlRWxlbWVudCh0aGlzKVxuICAgIHRoaXMucHVzaEZvcm1TdWJtaXQoZm9ybSwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgc3VibWl0dGVyLCBvcHRzLCAoKSA9PiB7XG4gICAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBET00uc2hvd0Vycm9yKGlucHV0LCBwaHhGZWVkYmFja0ZvciwgcGh4RmVlZGJhY2tHcm91cCkpXG4gICAgICB0aGlzLmxpdmVTb2NrZXQucmVzdG9yZVByZXZpb3VzbHlBY3RpdmVGb2N1cygpXG4gICAgfSlcbiAgfVxuXG4gIGJpbmRpbmcoa2luZCl7IHJldHVybiB0aGlzLmxpdmVTb2NrZXQuYmluZGluZyhraW5kKSB9XG59XG4iLCAiLyoqIEluaXRpYWxpemVzIHRoZSBMaXZlU29ja2V0XG4gKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRQb2ludCAtIFRoZSBzdHJpbmcgV2ViU29ja2V0IGVuZHBvaW50LCBpZSwgYFwid3NzOi8vZXhhbXBsZS5jb20vbGl2ZVwiYCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXCIvbGl2ZVwiYCAoaW5oZXJpdGVkIGhvc3QgJiBwcm90b2NvbClcbiAqIEBwYXJhbSB7UGhvZW5peC5Tb2NrZXR9IHNvY2tldCAtIHRoZSByZXF1aXJlZCBQaG9lbml4IFNvY2tldCBjbGFzcyBpbXBvcnRlZCBmcm9tIFwicGhvZW5peFwiLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgaW1wb3J0IHtTb2NrZXR9IGZyb20gXCJwaG9lbml4XCJcbiAqICAgICBpbXBvcnQge0xpdmVTb2NrZXR9IGZyb20gXCJwaG9lbml4X2xpdmVfdmlld1wiXG4gKiAgICAgbGV0IGxpdmVTb2NrZXQgPSBuZXcgTGl2ZVNvY2tldChcIi9saXZlXCIsIFNvY2tldCwgey4uLn0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24uIE91dHNpZGUgb2Yga2V5cyBsaXN0ZWQgYmVsb3csIGFsbFxuICogY29uZmlndXJhdGlvbiBpcyBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlIFBob2VuaXggU29ja2V0IGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLmRlZmF1bHRzXSAtIFRoZSBvcHRpb25hbCBkZWZhdWx0cyB0byB1c2UgZm9yIHZhcmlvdXMgYmluZGluZ3MsXG4gKiBzdWNoIGFzIGBwaHgtZGVib3VuY2VgLiBTdXBwb3J0cyB0aGUgZm9sbG93aW5nIGtleXM6XG4gKlxuICogICAtIGRlYm91bmNlIC0gdGhlIG1pbGxpc2Vjb25kIHBoeC1kZWJvdW5jZSB0aW1lLiBEZWZhdWx0cyAzMDBcbiAqICAgLSB0aHJvdHRsZSAtIHRoZSBtaWxsaXNlY29uZCBwaHgtdGhyb3R0bGUgdGltZS4gRGVmYXVsdHMgMzAwXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMucGFyYW1zXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3IgcGFzc2luZyBjb25uZWN0IHBhcmFtcy5cbiAqIFRoZSBmdW5jdGlvbiByZWNlaXZlcyB0aGUgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBMaXZlVmlldy4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIChlbCkgPT4ge3ZpZXc6IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtbXktdmlldy1uYW1lXCIsIHRva2VuOiB3aW5kb3cubXlUb2tlbn1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmluZGluZ1ByZWZpeF0gLSBUaGUgb3B0aW9uYWwgcHJlZml4IHRvIHVzZSBmb3IgYWxsIHBoeCBET00gYW5ub3RhdGlvbnMuXG4gKiBEZWZhdWx0cyB0byBcInBoeC1cIi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5ob29rc10gLSBUaGUgb3B0aW9uYWwgb2JqZWN0IGZvciByZWZlcmVuY2luZyBMaXZlVmlldyBob29rIGNhbGxiYWNrcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy51cGxvYWRlcnNdIC0gVGhlIG9wdGlvbmFsIG9iamVjdCBmb3IgcmVmZXJlbmNpbmcgTGl2ZVZpZXcgdXBsb2FkZXIgY2FsbGJhY2tzLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5sb2FkZXJUaW1lb3V0XSAtIFRoZSBvcHRpb25hbCBkZWxheSBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgYXBwbHlcbiAqIGxvYWRpbmcgc3RhdGVzLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5tYXhSZWxvYWRzXSAtIFRoZSBtYXhpbXVtIHJlbG9hZHMgYmVmb3JlIGVudGVyaW5nIGZhaWxzYWZlIG1vZGUuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRzLnJlbG9hZEppdHRlck1pbl0gLSBUaGUgbWluaW11bSB0aW1lIGJldHdlZW4gbm9ybWFsIHJlbG9hZCBhdHRlbXB0cy5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdHMucmVsb2FkSml0dGVyTWF4XSAtIFRoZSBtYXhpbXVtIHRpbWUgYmV0d2VlbiBub3JtYWwgcmVsb2FkIGF0dGVtcHRzLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5mYWlsc2FmZUppdHRlcl0gLSBUaGUgdGltZSBiZXR3ZWVuIHJlbG9hZCBhdHRlbXB0cyBpbiBmYWlsc2FmZSBtb2RlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMudmlld0xvZ2dlcl0gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdG8gbG9nIGRlYnVnIGluZm9ybWF0aW9uLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgKHZpZXcsIGtpbmQsIG1zZywgb2JqKSA9PiBjb25zb2xlLmxvZyhgJHt2aWV3LmlkfSAke2tpbmR9OiAke21zZ30gLSBgLCBvYmopXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLm1ldGFkYXRhXSAtIFRoZSBvcHRpb25hbCBvYmplY3QgbWFwcGluZyBldmVudCBuYW1lcyB0byBmdW5jdGlvbnMgZm9yXG4gKiBwb3B1bGF0aW5nIGV2ZW50IG1ldGFkYXRhLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgbWV0YWRhdGE6IHtcbiAqICAgICAgIGNsaWNrOiAoZSwgZWwpID0+IHtcbiAqICAgICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXG4gKiAgICAgICAgICAgbWV0YUtleTogZS5tZXRhS2V5LFxuICogICAgICAgICAgIGRldGFpbDogZS5kZXRhaWwgfHwgMSxcbiAqICAgICAgICAgfVxuICogICAgICAgfSxcbiAqICAgICAgIGtleWRvd246IChlLCBlbCkgPT4ge1xuICogICAgICAgICByZXR1cm4ge1xuICogICAgICAgICAgIGtleTogZS5rZXksXG4gKiAgICAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxuICogICAgICAgICAgIG1ldGFLZXk6IGUubWV0YUtleSxcbiAqICAgICAgICAgICBzaGlmdEtleTogZS5zaGlmdEtleVxuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLnNlc3Npb25TdG9yYWdlXSAtIEFuIG9wdGlvbmFsIFN0b3JhZ2UgY29tcGF0aWJsZSBvYmplY3RcbiAqIFVzZWZ1bCB3aGVuIExpdmVWaWV3IHdvbid0IGhhdmUgYWNjZXNzIHRvIGBzZXNzaW9uU3RvcmFnZWAuICBGb3IgZXhhbXBsZSwgVGhpcyBjb3VsZFxuICogaGFwcGVuIGlmIGEgc2l0ZSBsb2FkcyBhIGNyb3NzLWRvbWFpbiBMaXZlVmlldyBpbiBhbiBpZnJhbWUuICBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICAgICBjbGFzcyBJbk1lbW9yeVN0b3JhZ2Uge1xuICogICAgICAgY29uc3RydWN0b3IoKSB7IHRoaXMuc3RvcmFnZSA9IHt9IH1cbiAqICAgICAgIGdldEl0ZW0oa2V5TmFtZSkgeyByZXR1cm4gdGhpcy5zdG9yYWdlW2tleU5hbWVdIHx8IG51bGwgfVxuICogICAgICAgcmVtb3ZlSXRlbShrZXlOYW1lKSB7IGRlbGV0ZSB0aGlzLnN0b3JhZ2Vba2V5TmFtZV0gfVxuICogICAgICAgc2V0SXRlbShrZXlOYW1lLCBrZXlWYWx1ZSkgeyB0aGlzLnN0b3JhZ2Vba2V5TmFtZV0gPSBrZXlWYWx1ZSB9XG4gKiAgICAgfVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5sb2NhbFN0b3JhZ2VdIC0gQW4gb3B0aW9uYWwgU3RvcmFnZSBjb21wYXRpYmxlIG9iamVjdFxuICogVXNlZnVsIGZvciB3aGVuIExpdmVWaWV3IHdvbid0IGhhdmUgYWNjZXNzIHRvIGBsb2NhbFN0b3JhZ2VgLlxuICogU2VlIGBvcHRzLnNlc3Npb25TdG9yYWdlYCBmb3IgZXhhbXBsZXMuXG4qL1xuXG5pbXBvcnQge1xuICBCSU5ESU5HX1BSRUZJWCxcbiAgQ09OU0VDVVRJVkVfUkVMT0FEUyxcbiAgREVGQVVMVFMsXG4gIEZBSUxTQUZFX0pJVFRFUixcbiAgTE9BREVSX1RJTUVPVVQsXG4gIE1BWF9SRUxPQURTLFxuICBQSFhfREVCT1VOQ0UsXG4gIFBIWF9EUk9QX1RBUkdFVCxcbiAgUEhYX0hBU19GT0NVU0VELFxuICBQSFhfS0VZLFxuICBQSFhfTElOS19TVEFURSxcbiAgUEhYX0xJVkVfTElOSyxcbiAgUEhYX0xWX0RFQlVHLFxuICBQSFhfTFZfTEFURU5DWV9TSU0sXG4gIFBIWF9MVl9QUk9GSUxFLFxuICBQSFhfTUFJTixcbiAgUEhYX1BBUkVOVF9JRCxcbiAgUEhYX1ZJRVdfU0VMRUNUT1IsXG4gIFBIWF9ST09UX0lELFxuICBQSFhfVEhST1RUTEUsXG4gIFBIWF9UUkFDS19VUExPQURTLFxuICBQSFhfU0VTU0lPTixcbiAgUEhYX0ZFRURCQUNLX0ZPUixcbiAgUEhYX0ZFRURCQUNLX0dST1VQLFxuICBSRUxPQURfSklUVEVSX01JTixcbiAgUkVMT0FEX0pJVFRFUl9NQVgsXG4gIFBIWF9SRUYsXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGNsb25lLFxuICBjbG9zZXN0UGh4QmluZGluZyxcbiAgY2xvc3VyZSxcbiAgZGVidWcsXG4gIG1heWJlXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IEJyb3dzZXIgZnJvbSBcIi4vYnJvd3NlclwiXG5pbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5pbXBvcnQgSG9va3MgZnJvbSBcIi4vaG9va3NcIlxuaW1wb3J0IExpdmVVcGxvYWRlciBmcm9tIFwiLi9saXZlX3VwbG9hZGVyXCJcbmltcG9ydCBWaWV3IGZyb20gXCIuL3ZpZXdcIlxuaW1wb3J0IEpTIGZyb20gXCIuL2pzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGl2ZVNvY2tldCB7XG4gIGNvbnN0cnVjdG9yKHVybCwgcGh4U29ja2V0LCBvcHRzID0ge30pe1xuICAgIHRoaXMudW5sb2FkZWQgPSBmYWxzZVxuICAgIGlmKCFwaHhTb2NrZXQgfHwgcGh4U29ja2V0LmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiT2JqZWN0XCIpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgIGEgcGhvZW5peCBTb2NrZXQgbXVzdCBiZSBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBMaXZlU29ja2V0IGNvbnN0cnVjdG9yLiBGb3IgZXhhbXBsZTpcblxuICAgICAgICAgIGltcG9ydCB7U29ja2V0fSBmcm9tIFwicGhvZW5peFwiXG4gICAgICAgICAgaW1wb3J0IHtMaXZlU29ja2V0fSBmcm9tIFwicGhvZW5peF9saXZlX3ZpZXdcIlxuICAgICAgICAgIGxldCBsaXZlU29ja2V0ID0gbmV3IExpdmVTb2NrZXQoXCIvbGl2ZVwiLCBTb2NrZXQsIHsuLi59KVxuICAgICAgYClcbiAgICB9XG4gICAgdGhpcy5zb2NrZXQgPSBuZXcgcGh4U29ja2V0KHVybCwgb3B0cylcbiAgICB0aGlzLmJpbmRpbmdQcmVmaXggPSBvcHRzLmJpbmRpbmdQcmVmaXggfHwgQklORElOR19QUkVGSVhcbiAgICB0aGlzLm9wdHMgPSBvcHRzXG4gICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKG9wdHMucGFyYW1zIHx8IHt9KVxuICAgIHRoaXMudmlld0xvZ2dlciA9IG9wdHMudmlld0xvZ2dlclxuICAgIHRoaXMubWV0YWRhdGFDYWxsYmFja3MgPSBvcHRzLm1ldGFkYXRhIHx8IHt9XG4gICAgdGhpcy5kZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oY2xvbmUoREVGQVVMVFMpLCBvcHRzLmRlZmF1bHRzIHx8IHt9KVxuICAgIHRoaXMuYWN0aXZlRWxlbWVudCA9IG51bGxcbiAgICB0aGlzLnByZXZBY3RpdmUgPSBudWxsXG4gICAgdGhpcy5zaWxlbmNlZCA9IGZhbHNlXG4gICAgdGhpcy5tYWluID0gbnVsbFxuICAgIHRoaXMub3V0Z29pbmdNYWluRWwgPSBudWxsXG4gICAgdGhpcy5jbGlja1N0YXJ0ZWRBdFRhcmdldCA9IG51bGxcbiAgICB0aGlzLmxpbmtSZWYgPSAxXG4gICAgdGhpcy5yb290cyA9IHt9XG4gICAgdGhpcy5ocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWZcbiAgICB0aGlzLnBlbmRpbmdMaW5rID0gbnVsbFxuICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gY2xvbmUod2luZG93LmxvY2F0aW9uKVxuICAgIHRoaXMuaG9va3MgPSBvcHRzLmhvb2tzIHx8IHt9XG4gICAgdGhpcy51cGxvYWRlcnMgPSBvcHRzLnVwbG9hZGVycyB8fCB7fVxuICAgIHRoaXMubG9hZGVyVGltZW91dCA9IG9wdHMubG9hZGVyVGltZW91dCB8fCBMT0FERVJfVElNRU9VVFxuICAgIHRoaXMucmVsb2FkV2l0aEppdHRlclRpbWVyID0gbnVsbFxuICAgIHRoaXMubWF4UmVsb2FkcyA9IG9wdHMubWF4UmVsb2FkcyB8fCBNQVhfUkVMT0FEU1xuICAgIHRoaXMucmVsb2FkSml0dGVyTWluID0gb3B0cy5yZWxvYWRKaXR0ZXJNaW4gfHwgUkVMT0FEX0pJVFRFUl9NSU5cbiAgICB0aGlzLnJlbG9hZEppdHRlck1heCA9IG9wdHMucmVsb2FkSml0dGVyTWF4IHx8IFJFTE9BRF9KSVRURVJfTUFYXG4gICAgdGhpcy5mYWlsc2FmZUppdHRlciA9IG9wdHMuZmFpbHNhZmVKaXR0ZXIgfHwgRkFJTFNBRkVfSklUVEVSXG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UgPSBvcHRzLmxvY2FsU3RvcmFnZSB8fCB3aW5kb3cubG9jYWxTdG9yYWdlXG4gICAgdGhpcy5zZXNzaW9uU3RvcmFnZSA9IG9wdHMuc2Vzc2lvblN0b3JhZ2UgfHwgd2luZG93LnNlc3Npb25TdG9yYWdlXG4gICAgdGhpcy5ib3VuZFRvcExldmVsRXZlbnRzID0gZmFsc2VcbiAgICB0aGlzLmRvbUNhbGxiYWNrcyA9IE9iamVjdC5hc3NpZ24oe29uTm9kZUFkZGVkOiBjbG9zdXJlKCksIG9uQmVmb3JlRWxVcGRhdGVkOiBjbG9zdXJlKCl9LCBvcHRzLmRvbSB8fCB7fSlcbiAgICB0aGlzLnRyYW5zaXRpb25zID0gbmV3IFRyYW5zaXRpb25TZXQoKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX2UgPT4ge1xuICAgICAgdGhpcy51bmxvYWRlZCA9IHRydWVcbiAgICB9KVxuICAgIHRoaXMuc29ja2V0Lm9uT3BlbigoKSA9PiB7XG4gICAgICBpZih0aGlzLmlzVW5sb2FkZWQoKSl7XG4gICAgICAgIC8vIHJlbG9hZCBwYWdlIGlmIGJlaW5nIHJlc3RvcmVkIGZyb20gYmFjay9mb3J3YXJkIGNhY2hlIGFuZCBicm93c2VyIGRvZXMgbm90IGVtaXQgXCJwYWdlc2hvd1wiXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyBwdWJsaWNcblxuICBpc1Byb2ZpbGVFbmFibGVkKCl7IHJldHVybiB0aGlzLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUEhYX0xWX1BST0ZJTEUpID09PSBcInRydWVcIiB9XG5cbiAgaXNEZWJ1Z0VuYWJsZWQoKXsgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfREVCVUcpID09PSBcInRydWVcIiB9XG5cbiAgaXNEZWJ1Z0Rpc2FibGVkKCl7IHJldHVybiB0aGlzLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUEhYX0xWX0RFQlVHKSA9PT0gXCJmYWxzZVwiIH1cblxuICBlbmFibGVEZWJ1ZygpeyB0aGlzLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUEhYX0xWX0RFQlVHLCBcInRydWVcIikgfVxuXG4gIGVuYWJsZVByb2ZpbGluZygpeyB0aGlzLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUEhYX0xWX1BST0ZJTEUsIFwidHJ1ZVwiKSB9XG5cbiAgZGlzYWJsZURlYnVnKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfREVCVUcsIFwiZmFsc2VcIikgfVxuXG4gIGRpc2FibGVQcm9maWxpbmcoKXsgdGhpcy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFBIWF9MVl9QUk9GSUxFKSB9XG5cbiAgZW5hYmxlTGF0ZW5jeVNpbSh1cHBlckJvdW5kTXMpe1xuICAgIHRoaXMuZW5hYmxlRGVidWcoKVxuICAgIGNvbnNvbGUubG9nKFwibGF0ZW5jeSBzaW11bGF0b3IgZW5hYmxlZCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoaXMgYnJvd3NlciBzZXNzaW9uLiBDYWxsIGRpc2FibGVMYXRlbmN5U2ltKCkgdG8gZGlzYWJsZVwiKVxuICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfTEFURU5DWV9TSU0sIHVwcGVyQm91bmRNcylcbiAgfVxuXG4gIGRpc2FibGVMYXRlbmN5U2ltKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShQSFhfTFZfTEFURU5DWV9TSU0pIH1cblxuICBnZXRMYXRlbmN5U2ltKCl7XG4gICAgbGV0IHN0ciA9IHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfTEFURU5DWV9TSU0pXG4gICAgcmV0dXJuIHN0ciA/IHBhcnNlSW50KHN0cikgOiBudWxsXG4gIH1cblxuICBnZXRTb2NrZXQoKXsgcmV0dXJuIHRoaXMuc29ja2V0IH1cblxuICBjb25uZWN0KCl7XG4gICAgLy8gZW5hYmxlIGRlYnVnIGJ5IGRlZmF1bHQgaWYgb24gbG9jYWxob3N0IGFuZCBub3QgZXhwbGljaXRseSBkaXNhYmxlZFxuICAgIGlmKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA9PT0gXCJsb2NhbGhvc3RcIiAmJiAhdGhpcy5pc0RlYnVnRGlzYWJsZWQoKSl7IHRoaXMuZW5hYmxlRGVidWcoKSB9XG4gICAgbGV0IGRvQ29ubmVjdCA9ICgpID0+IHtcbiAgICAgIGlmKHRoaXMuam9pblJvb3RWaWV3cygpKXtcbiAgICAgICAgdGhpcy5iaW5kVG9wTGV2ZWxFdmVudHMoKVxuICAgICAgICB0aGlzLnNvY2tldC5jb25uZWN0KClcbiAgICAgIH0gZWxzZSBpZih0aGlzLm1haW4pe1xuICAgICAgICB0aGlzLnNvY2tldC5jb25uZWN0KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmluZFRvcExldmVsRXZlbnRzKHtkZWFkOiB0cnVlfSlcbiAgICAgIH1cbiAgICAgIHRoaXMuam9pbkRlYWRWaWV3KClcbiAgICB9XG4gICAgaWYoW1wiY29tcGxldGVcIiwgXCJsb2FkZWRcIiwgXCJpbnRlcmFjdGl2ZVwiXS5pbmRleE9mKGRvY3VtZW50LnJlYWR5U3RhdGUpID49IDApe1xuICAgICAgZG9Db25uZWN0KClcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4gZG9Db25uZWN0KCkpXG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdChjYWxsYmFjayl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVsb2FkV2l0aEppdHRlclRpbWVyKVxuICAgIHRoaXMuc29ja2V0LmRpc2Nvbm5lY3QoY2FsbGJhY2spXG4gIH1cblxuICByZXBsYWNlVHJhbnNwb3J0KHRyYW5zcG9ydCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVsb2FkV2l0aEppdHRlclRpbWVyKVxuICAgIHRoaXMuc29ja2V0LnJlcGxhY2VUcmFuc3BvcnQodHJhbnNwb3J0KVxuICAgIHRoaXMuY29ubmVjdCgpXG4gIH1cblxuICBleGVjSlMoZWwsIGVuY29kZWRKUywgZXZlbnRUeXBlID0gbnVsbCl7XG4gICAgdGhpcy5vd25lcihlbCwgdmlldyA9PiBKUy5leGVjKGV2ZW50VHlwZSwgZW5jb2RlZEpTLCB2aWV3LCBlbCkpXG4gIH1cblxuICAvLyBwcml2YXRlXG5cbiAgZXhlY0pTSG9va1B1c2goZWwsIHBoeEV2ZW50LCBkYXRhLCBjYWxsYmFjayl7XG4gICAgdGhpcy53aXRoaW5Pd25lcnMoZWwsIHZpZXcgPT4ge1xuICAgICAgSlMuZXhlYyhcImhvb2tcIiwgcGh4RXZlbnQsIHZpZXcsIGVsLCBbXCJwdXNoXCIsIHtkYXRhLCBjYWxsYmFja31dKVxuICAgIH0pXG4gIH1cblxuICB1bmxvYWQoKXtcbiAgICBpZih0aGlzLnVubG9hZGVkKXsgcmV0dXJuIH1cbiAgICBpZih0aGlzLm1haW4gJiYgdGhpcy5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5sb2codGhpcy5tYWluLCBcInNvY2tldFwiLCAoKSA9PiBbXCJkaXNjb25uZWN0IGZvciBwYWdlIG5hdlwiXSkgfVxuICAgIHRoaXMudW5sb2FkZWQgPSB0cnVlXG4gICAgdGhpcy5kZXN0cm95QWxsVmlld3MoKVxuICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gIH1cblxuICB0cmlnZ2VyRE9NKGtpbmQsIGFyZ3MpeyB0aGlzLmRvbUNhbGxiYWNrc1traW5kXSguLi5hcmdzKSB9XG5cbiAgdGltZShuYW1lLCBmdW5jKXtcbiAgICBpZighdGhpcy5pc1Byb2ZpbGVFbmFibGVkKCkgfHwgIWNvbnNvbGUudGltZSl7IHJldHVybiBmdW5jKCkgfVxuICAgIGNvbnNvbGUudGltZShuYW1lKVxuICAgIGxldCByZXN1bHQgPSBmdW5jKClcbiAgICBjb25zb2xlLnRpbWVFbmQobmFtZSlcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBsb2codmlldywga2luZCwgbXNnQ2FsbGJhY2spe1xuICAgIGlmKHRoaXMudmlld0xvZ2dlcil7XG4gICAgICBsZXQgW21zZywgb2JqXSA9IG1zZ0NhbGxiYWNrKClcbiAgICAgIHRoaXMudmlld0xvZ2dlcih2aWV3LCBraW5kLCBtc2csIG9iailcbiAgICB9IGVsc2UgaWYodGhpcy5pc0RlYnVnRW5hYmxlZCgpKXtcbiAgICAgIGxldCBbbXNnLCBvYmpdID0gbXNnQ2FsbGJhY2soKVxuICAgICAgZGVidWcodmlldywga2luZCwgbXNnLCBvYmopXG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdERPTVVwZGF0ZShjYWxsYmFjayl7XG4gICAgdGhpcy50cmFuc2l0aW9ucy5hZnRlcihjYWxsYmFjaylcbiAgfVxuXG4gIHRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lID0gZnVuY3Rpb24oKXt9KXtcbiAgICB0aGlzLnRyYW5zaXRpb25zLmFkZFRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lKVxuICB9XG5cbiAgb25DaGFubmVsKGNoYW5uZWwsIGV2ZW50LCBjYil7XG4gICAgY2hhbm5lbC5vbihldmVudCwgZGF0YSA9PiB7XG4gICAgICBsZXQgbGF0ZW5jeSA9IHRoaXMuZ2V0TGF0ZW5jeVNpbSgpXG4gICAgICBpZighbGF0ZW5jeSl7XG4gICAgICAgIGNiKGRhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGNiKGRhdGEpLCBsYXRlbmN5KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICB3cmFwUHVzaCh2aWV3LCBvcHRzLCBwdXNoKXtcbiAgICBsZXQgbGF0ZW5jeSA9IHRoaXMuZ2V0TGF0ZW5jeVNpbSgpXG4gICAgbGV0IG9sZEpvaW5Db3VudCA9IHZpZXcuam9pbkNvdW50XG4gICAgaWYoIWxhdGVuY3kpe1xuICAgICAgaWYodGhpcy5pc0Nvbm5lY3RlZCgpICYmIG9wdHMudGltZW91dCl7XG4gICAgICAgIHJldHVybiBwdXNoKCkucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4ge1xuICAgICAgICAgIGlmKHZpZXcuam9pbkNvdW50ID09PSBvbGRKb2luQ291bnQgJiYgIXZpZXcuaXNEZXN0cm95ZWQoKSl7XG4gICAgICAgICAgICB0aGlzLnJlbG9hZFdpdGhKaXR0ZXIodmlldywgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmxvZyh2aWV3LCBcInRpbWVvdXRcIiwgKCkgPT4gW1wicmVjZWl2ZWQgdGltZW91dCB3aGlsZSBjb21tdW5pY2F0aW5nIHdpdGggc2VydmVyLiBGYWxsaW5nIGJhY2sgdG8gaGFyZCByZWZyZXNoIGZvciByZWNvdmVyeVwiXSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHB1c2goKVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBmYWtlUHVzaCA9IHtcbiAgICAgIHJlY2VpdmVzOiBbXSxcbiAgICAgIHJlY2VpdmUoa2luZCwgY2IpeyB0aGlzLnJlY2VpdmVzLnB1c2goW2tpbmQsIGNiXSkgfVxuICAgIH1cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmKHZpZXcuaXNEZXN0cm95ZWQoKSl7IHJldHVybiB9XG4gICAgICBmYWtlUHVzaC5yZWNlaXZlcy5yZWR1Y2UoKGFjYywgW2tpbmQsIGNiXSkgPT4gYWNjLnJlY2VpdmUoa2luZCwgY2IpLCBwdXNoKCkpXG4gICAgfSwgbGF0ZW5jeSlcbiAgICByZXR1cm4gZmFrZVB1c2hcbiAgfVxuXG4gIHJlbG9hZFdpdGhKaXR0ZXIodmlldywgbG9nKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZWxvYWRXaXRoSml0dGVyVGltZXIpXG4gICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICBsZXQgbWluTXMgPSB0aGlzLnJlbG9hZEppdHRlck1pblxuICAgIGxldCBtYXhNcyA9IHRoaXMucmVsb2FkSml0dGVyTWF4XG4gICAgbGV0IGFmdGVyTXMgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4TXMgLSBtaW5NcyArIDEpKSArIG1pbk1zXG4gICAgbGV0IHRyaWVzID0gQnJvd3Nlci51cGRhdGVMb2NhbCh0aGlzLmxvY2FsU3RvcmFnZSwgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLCBDT05TRUNVVElWRV9SRUxPQURTLCAwLCBjb3VudCA9PiBjb3VudCArIDEpXG4gICAgaWYodHJpZXMgPiB0aGlzLm1heFJlbG9hZHMpe1xuICAgICAgYWZ0ZXJNcyA9IHRoaXMuZmFpbHNhZmVKaXR0ZXJcbiAgICB9XG4gICAgdGhpcy5yZWxvYWRXaXRoSml0dGVyVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIGlmIHZpZXcgaGFzIHJlY292ZXJlZCwgc3VjaCBhcyB0cmFuc3BvcnQgcmVwbGFjZWQsIHRoZW4gY2FuY2VsXG4gICAgICBpZih2aWV3LmlzRGVzdHJveWVkKCkgfHwgdmlldy5pc0Nvbm5lY3RlZCgpKXsgcmV0dXJuIH1cbiAgICAgIHZpZXcuZGVzdHJveSgpXG4gICAgICBsb2cgPyBsb2coKSA6IHRoaXMubG9nKHZpZXcsIFwiam9pblwiLCAoKSA9PiBbYGVuY291bnRlcmVkICR7dHJpZXN9IGNvbnNlY3V0aXZlIHJlbG9hZHNgXSlcbiAgICAgIGlmKHRyaWVzID4gdGhpcy5tYXhSZWxvYWRzKXtcbiAgICAgICAgdGhpcy5sb2codmlldywgXCJqb2luXCIsICgpID0+IFtgZXhjZWVkZWQgJHt0aGlzLm1heFJlbG9hZHN9IGNvbnNlY3V0aXZlIHJlbG9hZHMuIEVudGVyaW5nIGZhaWxzYWZlIG1vZGVgXSlcbiAgICAgIH1cbiAgICAgIGlmKHRoaXMuaGFzUGVuZGluZ0xpbmsoKSl7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IHRoaXMucGVuZGluZ0xpbmtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgfVxuICAgIH0sIGFmdGVyTXMpXG4gIH1cblxuICBnZXRIb29rQ2FsbGJhY2tzKG5hbWUpe1xuICAgIHJldHVybiBuYW1lICYmIG5hbWUuc3RhcnRzV2l0aChcIlBob2VuaXguXCIpID8gSG9va3NbbmFtZS5zcGxpdChcIi5cIilbMV1dIDogdGhpcy5ob29rc1tuYW1lXVxuICB9XG5cbiAgaXNVbmxvYWRlZCgpeyByZXR1cm4gdGhpcy51bmxvYWRlZCB9XG5cbiAgaXNDb25uZWN0ZWQoKXsgcmV0dXJuIHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkgfVxuXG4gIGdldEJpbmRpbmdQcmVmaXgoKXsgcmV0dXJuIHRoaXMuYmluZGluZ1ByZWZpeCB9XG5cbiAgYmluZGluZyhraW5kKXsgcmV0dXJuIGAke3RoaXMuZ2V0QmluZGluZ1ByZWZpeCgpfSR7a2luZH1gIH1cblxuICBjaGFubmVsKHRvcGljLCBwYXJhbXMpeyByZXR1cm4gdGhpcy5zb2NrZXQuY2hhbm5lbCh0b3BpYywgcGFyYW1zKSB9XG5cbiAgam9pbkRlYWRWaWV3KCl7XG4gICAgbGV0IGJvZHkgPSBkb2N1bWVudC5ib2R5XG4gICAgaWYoYm9keSAmJiAhdGhpcy5pc1BoeFZpZXcoYm9keSkgJiYgIXRoaXMuaXNQaHhWaWV3KGRvY3VtZW50LmZpcnN0RWxlbWVudENoaWxkKSl7XG4gICAgICBsZXQgdmlldyA9IHRoaXMubmV3Um9vdFZpZXcoYm9keSlcbiAgICAgIHZpZXcuc2V0SHJlZih0aGlzLmdldEhyZWYoKSlcbiAgICAgIHZpZXcuam9pbkRlYWQoKVxuICAgICAgaWYoIXRoaXMubWFpbil7IHRoaXMubWFpbiA9IHZpZXcgfVxuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB2aWV3LmV4ZWNOZXdNb3VudGVkKCkpXG4gICAgfVxuICB9XG5cbiAgam9pblJvb3RWaWV3cygpe1xuICAgIGxldCByb290c0ZvdW5kID0gZmFsc2VcbiAgICBET00uYWxsKGRvY3VtZW50LCBgJHtQSFhfVklFV19TRUxFQ1RPUn06bm90KFske1BIWF9QQVJFTlRfSUR9XSlgLCByb290RWwgPT4ge1xuICAgICAgaWYoIXRoaXMuZ2V0Um9vdEJ5SWQocm9vdEVsLmlkKSl7XG4gICAgICAgIGxldCB2aWV3ID0gdGhpcy5uZXdSb290Vmlldyhyb290RWwpXG4gICAgICAgIHZpZXcuc2V0SHJlZih0aGlzLmdldEhyZWYoKSlcbiAgICAgICAgdmlldy5qb2luKClcbiAgICAgICAgaWYocm9vdEVsLmhhc0F0dHJpYnV0ZShQSFhfTUFJTikpeyB0aGlzLm1haW4gPSB2aWV3IH1cbiAgICAgIH1cbiAgICAgIHJvb3RzRm91bmQgPSB0cnVlXG4gICAgfSlcbiAgICByZXR1cm4gcm9vdHNGb3VuZFxuICB9XG5cbiAgcmVkaXJlY3QodG8sIGZsYXNoKXtcbiAgICB0aGlzLnVubG9hZCgpXG4gICAgQnJvd3Nlci5yZWRpcmVjdCh0bywgZmxhc2gpXG4gIH1cblxuICByZXBsYWNlTWFpbihocmVmLCBmbGFzaCwgY2FsbGJhY2sgPSBudWxsLCBsaW5rUmVmID0gdGhpcy5zZXRQZW5kaW5nTGluayhocmVmKSl7XG4gICAgbGV0IGxpdmVSZWZlcmVyID0gdGhpcy5jdXJyZW50TG9jYXRpb24uaHJlZlxuICAgIHRoaXMub3V0Z29pbmdNYWluRWwgPSB0aGlzLm91dGdvaW5nTWFpbkVsIHx8IHRoaXMubWFpbi5lbFxuICAgIGxldCBuZXdNYWluRWwgPSBET00uY2xvbmVOb2RlKHRoaXMub3V0Z29pbmdNYWluRWwsIFwiXCIpXG4gICAgdGhpcy5tYWluLnNob3dMb2FkZXIodGhpcy5sb2FkZXJUaW1lb3V0KVxuICAgIHRoaXMubWFpbi5kZXN0cm95KClcblxuICAgIHRoaXMubWFpbiA9IHRoaXMubmV3Um9vdFZpZXcobmV3TWFpbkVsLCBmbGFzaCwgbGl2ZVJlZmVyZXIpXG4gICAgdGhpcy5tYWluLnNldFJlZGlyZWN0KGhyZWYpXG4gICAgdGhpcy50cmFuc2l0aW9uUmVtb3ZlcyhudWxsLCB0cnVlKVxuICAgIHRoaXMubWFpbi5qb2luKChqb2luQ291bnQsIG9uRG9uZSkgPT4ge1xuICAgICAgaWYoam9pbkNvdW50ID09PSAxICYmIHRoaXMuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpe1xuICAgICAgICB0aGlzLnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgIERPTS5maW5kUGh4U3RpY2t5KGRvY3VtZW50KS5mb3JFYWNoKGVsID0+IG5ld01haW5FbC5hcHBlbmRDaGlsZChlbCkpXG4gICAgICAgICAgdGhpcy5vdXRnb2luZ01haW5FbC5yZXBsYWNlV2l0aChuZXdNYWluRWwpXG4gICAgICAgICAgdGhpcy5vdXRnb2luZ01haW5FbCA9IG51bGxcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhsaW5rUmVmKVxuICAgICAgICAgIG9uRG9uZSgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHRyYW5zaXRpb25SZW1vdmVzKGVsZW1lbnRzLCBza2lwU3RpY2t5KXtcbiAgICBsZXQgcmVtb3ZlQXR0ciA9IHRoaXMuYmluZGluZyhcInJlbW92ZVwiKVxuICAgIGVsZW1lbnRzID0gZWxlbWVudHMgfHwgRE9NLmFsbChkb2N1bWVudCwgYFske3JlbW92ZUF0dHJ9XWApXG5cbiAgICBpZihza2lwU3RpY2t5KXtcbiAgICAgIGNvbnN0IHN0aWNraWVzID0gRE9NLmZpbmRQaHhTdGlja3koZG9jdW1lbnQpIHx8IFtdXG4gICAgICBlbGVtZW50cyA9IGVsZW1lbnRzLmZpbHRlcihlbCA9PiAhRE9NLmlzQ2hpbGRPZkFueShlbCwgc3RpY2tpZXMpKVxuICAgIH1cbiAgICBlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgIHRoaXMuZXhlY0pTKGVsLCBlbC5nZXRBdHRyaWJ1dGUocmVtb3ZlQXR0ciksIFwicmVtb3ZlXCIpXG4gICAgfSlcbiAgfVxuXG4gIGlzUGh4VmlldyhlbCl7IHJldHVybiBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OKSAhPT0gbnVsbCB9XG5cbiAgbmV3Um9vdFZpZXcoZWwsIGZsYXNoLCBsaXZlUmVmZXJlcil7XG4gICAgbGV0IHZpZXcgPSBuZXcgVmlldyhlbCwgdGhpcywgbnVsbCwgZmxhc2gsIGxpdmVSZWZlcmVyKVxuICAgIHRoaXMucm9vdHNbdmlldy5pZF0gPSB2aWV3XG4gICAgcmV0dXJuIHZpZXdcbiAgfVxuXG4gIG93bmVyKGNoaWxkRWwsIGNhbGxiYWNrKXtcbiAgICBsZXQgdmlldyA9IG1heWJlKGNoaWxkRWwuY2xvc2VzdChQSFhfVklFV19TRUxFQ1RPUiksIGVsID0+IHRoaXMuZ2V0Vmlld0J5RWwoZWwpKSB8fCB0aGlzLm1haW5cbiAgICBpZih2aWV3KXsgY2FsbGJhY2sodmlldykgfVxuICB9XG5cbiAgd2l0aGluT3duZXJzKGNoaWxkRWwsIGNhbGxiYWNrKXtcbiAgICB0aGlzLm93bmVyKGNoaWxkRWwsIHZpZXcgPT4gY2FsbGJhY2sodmlldywgY2hpbGRFbCkpXG4gIH1cblxuICBnZXRWaWV3QnlFbChlbCl7XG4gICAgbGV0IHJvb3RJZCA9IGVsLmdldEF0dHJpYnV0ZShQSFhfUk9PVF9JRClcbiAgICByZXR1cm4gbWF5YmUodGhpcy5nZXRSb290QnlJZChyb290SWQpLCByb290ID0+IHJvb3QuZ2V0RGVzY2VuZGVudEJ5RWwoZWwpKVxuICB9XG5cbiAgZ2V0Um9vdEJ5SWQoaWQpeyByZXR1cm4gdGhpcy5yb290c1tpZF0gfVxuXG4gIGRlc3Ryb3lBbGxWaWV3cygpe1xuICAgIGZvcihsZXQgaWQgaW4gdGhpcy5yb290cyl7XG4gICAgICB0aGlzLnJvb3RzW2lkXS5kZXN0cm95KClcbiAgICAgIGRlbGV0ZSB0aGlzLnJvb3RzW2lkXVxuICAgIH1cbiAgICB0aGlzLm1haW4gPSBudWxsXG4gIH1cblxuICBkZXN0cm95Vmlld0J5RWwoZWwpe1xuICAgIGxldCByb290ID0gdGhpcy5nZXRSb290QnlJZChlbC5nZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQpKVxuICAgIGlmKHJvb3QgJiYgcm9vdC5pZCA9PT0gZWwuaWQpe1xuICAgICAgcm9vdC5kZXN0cm95KClcbiAgICAgIGRlbGV0ZSB0aGlzLnJvb3RzW3Jvb3QuaWRdXG4gICAgfSBlbHNlIGlmKHJvb3Qpe1xuICAgICAgcm9vdC5kZXN0cm95RGVzY2VuZGVudChlbC5pZClcbiAgICB9XG4gIH1cblxuICBzZXRBY3RpdmVFbGVtZW50KHRhcmdldCl7XG4gICAgaWYodGhpcy5hY3RpdmVFbGVtZW50ID09PSB0YXJnZXQpeyByZXR1cm4gfVxuICAgIHRoaXMuYWN0aXZlRWxlbWVudCA9IHRhcmdldFxuICAgIGxldCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICBpZih0YXJnZXQgPT09IHRoaXMuYWN0aXZlRWxlbWVudCl7IHRoaXMuYWN0aXZlRWxlbWVudCA9IG51bGwgfVxuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMpXG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMpXG4gICAgfVxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBjYW5jZWwpXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBjYW5jZWwpXG4gIH1cblxuICBnZXRBY3RpdmVFbGVtZW50KCl7XG4gICAgaWYoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSl7XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gYmUgbnVsbCBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMVxuICAgICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keVxuICAgIH1cbiAgfVxuXG4gIGRyb3BBY3RpdmVFbGVtZW50KHZpZXcpe1xuICAgIGlmKHRoaXMucHJldkFjdGl2ZSAmJiB2aWV3Lm93bnNFbGVtZW50KHRoaXMucHJldkFjdGl2ZSkpe1xuICAgICAgdGhpcy5wcmV2QWN0aXZlID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHJlc3RvcmVQcmV2aW91c2x5QWN0aXZlRm9jdXMoKXtcbiAgICBpZih0aGlzLnByZXZBY3RpdmUgJiYgdGhpcy5wcmV2QWN0aXZlICE9PSBkb2N1bWVudC5ib2R5KXtcbiAgICAgIHRoaXMucHJldkFjdGl2ZS5mb2N1cygpXG4gICAgfVxuICB9XG5cbiAgYmx1ckFjdGl2ZUVsZW1lbnQoKXtcbiAgICB0aGlzLnByZXZBY3RpdmUgPSB0aGlzLmdldEFjdGl2ZUVsZW1lbnQoKVxuICAgIGlmKHRoaXMucHJldkFjdGl2ZSAhPT0gZG9jdW1lbnQuYm9keSl7IHRoaXMucHJldkFjdGl2ZS5ibHVyKCkgfVxuICB9XG5cbiAgYmluZFRvcExldmVsRXZlbnRzKHtkZWFkfSA9IHt9KXtcbiAgICBpZih0aGlzLmJvdW5kVG9wTGV2ZWxFdmVudHMpeyByZXR1cm4gfVxuXG4gICAgdGhpcy5ib3VuZFRvcExldmVsRXZlbnRzID0gdHJ1ZVxuICAgIC8vIGVudGVyIGZhaWxzYWZlIHJlbG9hZCBpZiBzZXJ2ZXIgaGFzIGdvbmUgYXdheSBpbnRlbnRpb25hbGx5LCBzdWNoIGFzIFwiZGlzY29ubmVjdFwiIGJyb2FkY2FzdFxuICAgIHRoaXMuc29ja2V0Lm9uQ2xvc2UoZXZlbnQgPT4ge1xuICAgICAgLy8gZmFpbHNhZmUgcmVsb2FkIGlmIG5vcm1hbCBjbG9zdXJlIGFuZCB3ZSBzdGlsbCBoYXZlIGEgbWFpbiBMVlxuICAgICAgaWYoZXZlbnQgJiYgZXZlbnQuY29kZSA9PT0gMTAwMCAmJiB0aGlzLm1haW4peyByZXR1cm4gdGhpcy5yZWxvYWRXaXRoSml0dGVyKHRoaXMubWFpbikgfVxuICAgIH0pXG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCl7IH0pIC8vIGVuc3VyZSBhbGwgY2xpY2sgZXZlbnRzIGJ1YmJsZSBmb3IgbW9iaWxlIFNhZmFyaVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZXNob3dcIiwgZSA9PiB7XG4gICAgICBpZihlLnBlcnNpc3RlZCl7IC8vIHJlbG9hZCBwYWdlIGlmIGJlaW5nIHJlc3RvcmVkIGZyb20gYmFjay9mb3J3YXJkIGNhY2hlXG4gICAgICAgIHRoaXMuZ2V0U29ja2V0KCkuZGlzY29ubmVjdCgpXG4gICAgICAgIHRoaXMud2l0aFBhZ2VMb2FkaW5nKHt0bzogd2luZG93LmxvY2F0aW9uLmhyZWYsIGtpbmQ6IFwicmVkaXJlY3RcIn0pXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgfVxuICAgIH0sIHRydWUpXG4gICAgaWYoIWRlYWQpeyB0aGlzLmJpbmROYXYoKSB9XG4gICAgdGhpcy5iaW5kQ2xpY2tzKClcbiAgICBpZighZGVhZCl7IHRoaXMuYmluZEZvcm1zKCkgfVxuICAgIHRoaXMuYmluZCh7a2V5dXA6IFwia2V5dXBcIiwga2V5ZG93bjogXCJrZXlkb3duXCJ9LCAoZSwgdHlwZSwgdmlldywgdGFyZ2V0RWwsIHBoeEV2ZW50LCBwaHhUYXJnZXQpID0+IHtcbiAgICAgIGxldCBtYXRjaEtleSA9IHRhcmdldEVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0tFWSkpXG4gICAgICBsZXQgcHJlc3NlZEtleSA9IGUua2V5ICYmIGUua2V5LnRvTG93ZXJDYXNlKCkgLy8gY2hyb21lIGNsaWNrZWQgYXV0b2NvbXBsZXRlcyBzZW5kIGEga2V5ZG93biB3aXRob3V0IGtleVxuICAgICAgaWYobWF0Y2hLZXkgJiYgbWF0Y2hLZXkudG9Mb3dlckNhc2UoKSAhPT0gcHJlc3NlZEtleSl7IHJldHVybiB9XG5cbiAgICAgIGxldCBkYXRhID0ge2tleTogZS5rZXksIC4uLnRoaXMuZXZlbnRNZXRhKHR5cGUsIGUsIHRhcmdldEVsKX1cbiAgICAgIEpTLmV4ZWModHlwZSwgcGh4RXZlbnQsIHZpZXcsIHRhcmdldEVsLCBbXCJwdXNoXCIsIHtkYXRhfV0pXG4gICAgfSlcbiAgICB0aGlzLmJpbmQoe2JsdXI6IFwiZm9jdXNvdXRcIiwgZm9jdXM6IFwiZm9jdXNpblwifSwgKGUsIHR5cGUsIHZpZXcsIHRhcmdldEVsLCBwaHhFdmVudCwgcGh4VGFyZ2V0KSA9PiB7XG4gICAgICBpZighcGh4VGFyZ2V0KXtcbiAgICAgICAgbGV0IGRhdGEgPSB7a2V5OiBlLmtleSwgLi4udGhpcy5ldmVudE1ldGEodHlwZSwgZSwgdGFyZ2V0RWwpfVxuICAgICAgICBKUy5leGVjKHR5cGUsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXRFbCwgW1wicHVzaFwiLCB7ZGF0YX1dKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5iaW5kKHtibHVyOiBcImJsdXJcIiwgZm9jdXM6IFwiZm9jdXNcIn0sIChlLCB0eXBlLCB2aWV3LCB0YXJnZXRFbCwgcGh4RXZlbnQsIHBoeFRhcmdldCkgPT4ge1xuICAgICAgLy8gYmx1ciBhbmQgZm9jdXMgYXJlIHRyaWdnZXJlZCBvbiBkb2N1bWVudCBhbmQgd2luZG93LiBEaXNjYXJkIG9uZSB0byBhdm9pZCBkdXBzXG4gICAgICBpZihwaHhUYXJnZXQgPT09IFwid2luZG93XCIpe1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZXZlbnRNZXRhKHR5cGUsIGUsIHRhcmdldEVsKVxuICAgICAgICBKUy5leGVjKHR5cGUsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXRFbCwgW1wicHVzaFwiLCB7ZGF0YX1dKVxuICAgICAgfVxuICAgIH0pXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCBlID0+IGUucHJldmVudERlZmF1bHQoKSlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgZSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIGxldCBkcm9wVGFyZ2V0SWQgPSBtYXliZShjbG9zZXN0UGh4QmluZGluZyhlLnRhcmdldCwgdGhpcy5iaW5kaW5nKFBIWF9EUk9QX1RBUkdFVCkpLCB0cnVlVGFyZ2V0ID0+IHtcbiAgICAgICAgcmV0dXJuIHRydWVUYXJnZXQuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfRFJPUF9UQVJHRVQpKVxuICAgICAgfSlcbiAgICAgIGxldCBkcm9wVGFyZ2V0ID0gZHJvcFRhcmdldElkICYmIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRyb3BUYXJnZXRJZClcbiAgICAgIGxldCBmaWxlcyA9IEFycmF5LmZyb20oZS5kYXRhVHJhbnNmZXIuZmlsZXMgfHwgW10pXG4gICAgICBpZighZHJvcFRhcmdldCB8fCBkcm9wVGFyZ2V0LmRpc2FibGVkIHx8IGZpbGVzLmxlbmd0aCA9PT0gMCB8fCAhKGRyb3BUYXJnZXQuZmlsZXMgaW5zdGFuY2VvZiBGaWxlTGlzdCkpeyByZXR1cm4gfVxuXG4gICAgICBMaXZlVXBsb2FkZXIudHJhY2tGaWxlcyhkcm9wVGFyZ2V0LCBmaWxlcywgZS5kYXRhVHJhbnNmZXIpXG4gICAgICBkcm9wVGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiaW5wdXRcIiwge2J1YmJsZXM6IHRydWV9KSlcbiAgICB9KVxuICAgIHRoaXMub24oUEhYX1RSQUNLX1VQTE9BRFMsIGUgPT4ge1xuICAgICAgbGV0IHVwbG9hZFRhcmdldCA9IGUudGFyZ2V0XG4gICAgICBpZighRE9NLmlzVXBsb2FkSW5wdXQodXBsb2FkVGFyZ2V0KSl7IHJldHVybiB9XG4gICAgICBsZXQgZmlsZXMgPSBBcnJheS5mcm9tKGUuZGV0YWlsLmZpbGVzIHx8IFtdKS5maWx0ZXIoZiA9PiBmIGluc3RhbmNlb2YgRmlsZSB8fCBmIGluc3RhbmNlb2YgQmxvYilcbiAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKHVwbG9hZFRhcmdldCwgZmlsZXMpXG4gICAgICB1cGxvYWRUYXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiLCB7YnViYmxlczogdHJ1ZX0pKVxuICAgIH0pXG4gIH1cblxuICBldmVudE1ldGEoZXZlbnROYW1lLCBlLCB0YXJnZXRFbCl7XG4gICAgbGV0IGNhbGxiYWNrID0gdGhpcy5tZXRhZGF0YUNhbGxiYWNrc1tldmVudE5hbWVdXG4gICAgcmV0dXJuIGNhbGxiYWNrID8gY2FsbGJhY2soZSwgdGFyZ2V0RWwpIDoge31cbiAgfVxuXG4gIHNldFBlbmRpbmdMaW5rKGhyZWYpe1xuICAgIHRoaXMubGlua1JlZisrXG4gICAgdGhpcy5wZW5kaW5nTGluayA9IGhyZWZcbiAgICByZXR1cm4gdGhpcy5saW5rUmVmXG4gIH1cblxuICBjb21taXRQZW5kaW5nTGluayhsaW5rUmVmKXtcbiAgICBpZih0aGlzLmxpbmtSZWYgIT09IGxpbmtSZWYpe1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaHJlZiA9IHRoaXMucGVuZGluZ0xpbmtcbiAgICAgIHRoaXMucGVuZGluZ0xpbmsgPSBudWxsXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGdldEhyZWYoKXsgcmV0dXJuIHRoaXMuaHJlZiB9XG5cbiAgaGFzUGVuZGluZ0xpbmsoKXsgcmV0dXJuICEhdGhpcy5wZW5kaW5nTGluayB9XG5cbiAgYmluZChldmVudHMsIGNhbGxiYWNrKXtcbiAgICBmb3IobGV0IGV2ZW50IGluIGV2ZW50cyl7XG4gICAgICBsZXQgYnJvd3NlckV2ZW50TmFtZSA9IGV2ZW50c1tldmVudF1cblxuICAgICAgdGhpcy5vbihicm93c2VyRXZlbnROYW1lLCBlID0+IHtcbiAgICAgICAgbGV0IGJpbmRpbmcgPSB0aGlzLmJpbmRpbmcoZXZlbnQpXG4gICAgICAgIGxldCB3aW5kb3dCaW5kaW5nID0gdGhpcy5iaW5kaW5nKGB3aW5kb3ctJHtldmVudH1gKVxuICAgICAgICBsZXQgdGFyZ2V0UGh4RXZlbnQgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUgJiYgZS50YXJnZXQuZ2V0QXR0cmlidXRlKGJpbmRpbmcpXG4gICAgICAgIGlmKHRhcmdldFBoeEV2ZW50KXtcbiAgICAgICAgICB0aGlzLmRlYm91bmNlKGUudGFyZ2V0LCBlLCBicm93c2VyRXZlbnROYW1lLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndpdGhpbk93bmVycyhlLnRhcmdldCwgdmlldyA9PiB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGUsIGV2ZW50LCB2aWV3LCBlLnRhcmdldCwgdGFyZ2V0UGh4RXZlbnQsIG51bGwpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRE9NLmFsbChkb2N1bWVudCwgYFske3dpbmRvd0JpbmRpbmd9XWAsIGVsID0+IHtcbiAgICAgICAgICAgIGxldCBwaHhFdmVudCA9IGVsLmdldEF0dHJpYnV0ZSh3aW5kb3dCaW5kaW5nKVxuICAgICAgICAgICAgdGhpcy5kZWJvdW5jZShlbCwgZSwgYnJvd3NlckV2ZW50TmFtZSwgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLndpdGhpbk93bmVycyhlbCwgdmlldyA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSwgZXZlbnQsIHZpZXcsIGVsLCBwaHhFdmVudCwgXCJ3aW5kb3dcIilcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBiaW5kQ2xpY2tzKCl7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZSA9PiB0aGlzLmNsaWNrU3RhcnRlZEF0VGFyZ2V0ID0gZS50YXJnZXQpXG4gICAgdGhpcy5iaW5kQ2xpY2soXCJjbGlja1wiLCBcImNsaWNrXCIsIGZhbHNlKVxuICAgIHRoaXMuYmluZENsaWNrKFwibW91c2Vkb3duXCIsIFwiY2FwdHVyZS1jbGlja1wiLCB0cnVlKVxuICB9XG5cbiAgYmluZENsaWNrKGV2ZW50TmFtZSwgYmluZGluZ05hbWUsIGNhcHR1cmUpe1xuICAgIGxldCBjbGljayA9IHRoaXMuYmluZGluZyhiaW5kaW5nTmFtZSlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGUgPT4ge1xuICAgICAgbGV0IHRhcmdldCA9IG51bGxcbiAgICAgIGlmKGNhcHR1cmUpe1xuICAgICAgICB0YXJnZXQgPSBlLnRhcmdldC5tYXRjaGVzKGBbJHtjbGlja31dYCkgPyBlLnRhcmdldCA6IGUudGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoYFske2NsaWNrfV1gKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYSBzeW50aGV0aWMgY2xpY2sgZXZlbnQgKGRldGFpbCAwKSB3aWxsIG5vdCBoYXZlIGNhdXNlZCBhIG1vdXNlZG93biBldmVudCxcbiAgICAgICAgLy8gdGhlcmVmb3JlIHRoZSBjbGlja1N0YXJ0ZWRBdFRhcmdldCBpcyBzdGFsZVxuICAgICAgICBpZihlLmRldGFpbCA9PT0gMCkgdGhpcy5jbGlja1N0YXJ0ZWRBdFRhcmdldCA9IGUudGFyZ2V0XG4gICAgICAgIGxldCBjbGlja1N0YXJ0ZWRBdFRhcmdldCA9IHRoaXMuY2xpY2tTdGFydGVkQXRUYXJnZXQgfHwgZS50YXJnZXRcbiAgICAgICAgdGFyZ2V0ID0gY2xvc2VzdFBoeEJpbmRpbmcoY2xpY2tTdGFydGVkQXRUYXJnZXQsIGNsaWNrKVxuICAgICAgICB0aGlzLmRpc3BhdGNoQ2xpY2tBd2F5KGUsIGNsaWNrU3RhcnRlZEF0VGFyZ2V0KVxuICAgICAgICB0aGlzLmNsaWNrU3RhcnRlZEF0VGFyZ2V0ID0gbnVsbFxuICAgICAgfVxuICAgICAgbGV0IHBoeEV2ZW50ID0gdGFyZ2V0ICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoY2xpY2spXG4gICAgICBpZighcGh4RXZlbnQpe1xuICAgICAgICBpZighY2FwdHVyZSAmJiBET00uaXNOZXdQYWdlQ2xpY2soZSwgd2luZG93LmxvY2F0aW9uKSl7IHRoaXMudW5sb2FkKCkgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYodGFyZ2V0LmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiKXsgZS5wcmV2ZW50RGVmYXVsdCgpIH1cblxuICAgICAgLy8gbm9vcCBpZiB3ZSBhcmUgaW4gdGhlIG1pZGRsZSBvZiBhd2FpdGluZyBhbiBhY2sgZm9yIHRoaXMgZWwgYWxyZWFkeVxuICAgICAgaWYodGFyZ2V0Lmhhc0F0dHJpYnV0ZShQSFhfUkVGKSl7IHJldHVybiB9XG5cbiAgICAgIHRoaXMuZGVib3VuY2UodGFyZ2V0LCBlLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy53aXRoaW5Pd25lcnModGFyZ2V0LCB2aWV3ID0+IHtcbiAgICAgICAgICBKUy5leGVjKFwiY2xpY2tcIiwgcGh4RXZlbnQsIHZpZXcsIHRhcmdldCwgW1wicHVzaFwiLCB7ZGF0YTogdGhpcy5ldmVudE1ldGEoXCJjbGlja1wiLCBlLCB0YXJnZXQpfV0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0sIGNhcHR1cmUpXG4gIH1cblxuICBkaXNwYXRjaENsaWNrQXdheShlLCBjbGlja1N0YXJ0ZWRBdCl7XG4gICAgbGV0IHBoeENsaWNrQXdheSA9IHRoaXMuYmluZGluZyhcImNsaWNrLWF3YXlcIilcbiAgICBET00uYWxsKGRvY3VtZW50LCBgWyR7cGh4Q2xpY2tBd2F5fV1gLCBlbCA9PiB7XG4gICAgICBpZighKGVsLmlzU2FtZU5vZGUoY2xpY2tTdGFydGVkQXQpIHx8IGVsLmNvbnRhaW5zKGNsaWNrU3RhcnRlZEF0KSkpe1xuICAgICAgICB0aGlzLndpdGhpbk93bmVycyhlbCwgdmlldyA9PiB7XG4gICAgICAgICAgbGV0IHBoeEV2ZW50ID0gZWwuZ2V0QXR0cmlidXRlKHBoeENsaWNrQXdheSlcbiAgICAgICAgICBpZihKUy5pc1Zpc2libGUoZWwpICYmIEpTLmlzSW5WaWV3cG9ydChlbCkpe1xuICAgICAgICAgICAgSlMuZXhlYyhcImNsaWNrXCIsIHBoeEV2ZW50LCB2aWV3LCBlbCwgW1wicHVzaFwiLCB7ZGF0YTogdGhpcy5ldmVudE1ldGEoXCJjbGlja1wiLCBlLCBlLnRhcmdldCl9XSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGJpbmROYXYoKXtcbiAgICBpZighQnJvd3Nlci5jYW5QdXNoU3RhdGUoKSl7IHJldHVybiB9XG4gICAgaWYoaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbil7IGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiIH1cbiAgICBsZXQgc2Nyb2xsVGltZXIgPSBudWxsXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgX2UgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHNjcm9sbFRpbWVyKVxuICAgICAgc2Nyb2xsVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgQnJvd3Nlci51cGRhdGVDdXJyZW50U3RhdGUoc3RhdGUgPT4gT2JqZWN0LmFzc2lnbihzdGF0ZSwge3Njcm9sbDogd2luZG93LnNjcm9sbFl9KSlcbiAgICAgIH0sIDEwMClcbiAgICB9KVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgZXZlbnQgPT4ge1xuICAgICAgaWYoIXRoaXMucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pKXsgcmV0dXJuIH1cbiAgICAgIGxldCB7dHlwZSwgaWQsIHJvb3QsIHNjcm9sbH0gPSBldmVudC5zdGF0ZSB8fCB7fVxuICAgICAgbGV0IGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxuXG4gICAgICBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIFwicGh4Om5hdmlnYXRlXCIsIHtkZXRhaWw6IHtocmVmLCBwYXRjaDogdHlwZSA9PT0gXCJwYXRjaFwiLCBwb3A6IHRydWV9fSlcbiAgICAgIHRoaXMucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGlmKHRoaXMubWFpbi5pc0Nvbm5lY3RlZCgpICYmICh0eXBlID09PSBcInBhdGNoXCIgJiYgaWQgPT09IHRoaXMubWFpbi5pZCkpe1xuICAgICAgICAgIHRoaXMubWFpbi5wdXNoTGlua1BhdGNoKGhyZWYsIG51bGwsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWF5YmVTY3JvbGwoc2Nyb2xsKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZXBsYWNlTWFpbihocmVmLCBudWxsLCAoKSA9PiB7XG4gICAgICAgICAgICBpZihyb290KXsgdGhpcy5yZXBsYWNlUm9vdEhpc3RvcnkoKSB9XG4gICAgICAgICAgICB0aGlzLm1heWJlU2Nyb2xsKHNjcm9sbClcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sIGZhbHNlKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZSA9PiB7XG4gICAgICBsZXQgdGFyZ2V0ID0gY2xvc2VzdFBoeEJpbmRpbmcoZS50YXJnZXQsIFBIWF9MSVZFX0xJTkspXG4gICAgICBsZXQgdHlwZSA9IHRhcmdldCAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFBIWF9MSVZFX0xJTkspXG4gICAgICBpZighdHlwZSB8fCAhdGhpcy5pc0Nvbm5lY3RlZCgpIHx8ICF0aGlzLm1haW4gfHwgRE9NLndhbnRzTmV3VGFiKGUpKXsgcmV0dXJuIH1cblxuICAgICAgLy8gV2hlbiB3cmFwcGluZyBhbiBTVkcgZWxlbWVudCBpbiBhbiBhbmNob3IgdGFnLCB0aGUgaHJlZiBjYW4gYmUgYW4gU1ZHQW5pbWF0ZWRTdHJpbmdcbiAgICAgIGxldCBocmVmID0gdGFyZ2V0LmhyZWYgaW5zdGFuY2VvZiBTVkdBbmltYXRlZFN0cmluZyA/IHRhcmdldC5ocmVmLmJhc2VWYWwgOiB0YXJnZXQuaHJlZlxuXG4gICAgICBsZXQgbGlua1N0YXRlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShQSFhfTElOS19TVEFURSlcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSAvLyBkbyBub3QgYnViYmxlIGNsaWNrIHRvIHJlZ3VsYXIgcGh4LWNsaWNrIGJpbmRpbmdzXG4gICAgICBpZih0aGlzLnBlbmRpbmdMaW5rID09PSBocmVmKXsgcmV0dXJuIH1cblxuICAgICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgaWYodHlwZSA9PT0gXCJwYXRjaFwiKXtcbiAgICAgICAgICB0aGlzLnB1c2hIaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCB0YXJnZXQpXG4gICAgICAgIH0gZWxzZSBpZih0eXBlID09PSBcInJlZGlyZWN0XCIpe1xuICAgICAgICAgIHRoaXMuaGlzdG9yeVJlZGlyZWN0KGhyZWYsIGxpbmtTdGF0ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7UEhYX0xJVkVfTElOS30gdG8gYmUgXCJwYXRjaFwiIG9yIFwicmVkaXJlY3RcIiwgZ290OiAke3R5cGV9YClcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGh4Q2xpY2sgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcImNsaWNrXCIpKVxuICAgICAgICBpZihwaHhDbGljayl7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHRoaXMuZXhlY0pTKHRhcmdldCwgcGh4Q2xpY2ssIFwiY2xpY2tcIikpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSwgZmFsc2UpXG4gIH1cblxuICBtYXliZVNjcm9sbChzY3JvbGwpe1xuICAgIGlmKHR5cGVvZihzY3JvbGwpID09PSBcIm51bWJlclwiKXtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBzY3JvbGwpXG4gICAgICB9KSAvLyB0aGUgYm9keSBuZWVkcyB0byByZW5kZXIgYmVmb3JlIHdlIHNjcm9sbC5cbiAgICB9XG4gIH1cblxuICBkaXNwYXRjaEV2ZW50KGV2ZW50LCBwYXlsb2FkID0ge30pe1xuICAgIERPTS5kaXNwYXRjaEV2ZW50KHdpbmRvdywgYHBoeDoke2V2ZW50fWAsIHtkZXRhaWw6IHBheWxvYWR9KVxuICB9XG5cbiAgZGlzcGF0Y2hFdmVudHMoZXZlbnRzKXtcbiAgICBldmVudHMuZm9yRWFjaCgoW2V2ZW50LCBwYXlsb2FkXSkgPT4gdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50LCBwYXlsb2FkKSlcbiAgfVxuXG4gIHdpdGhQYWdlTG9hZGluZyhpbmZvLCBjYWxsYmFjayl7XG4gICAgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpwYWdlLWxvYWRpbmctc3RhcnRcIiwge2RldGFpbDogaW5mb30pXG4gICAgbGV0IGRvbmUgPSAoKSA9PiBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIFwicGh4OnBhZ2UtbG9hZGluZy1zdG9wXCIsIHtkZXRhaWw6IGluZm99KVxuICAgIHJldHVybiBjYWxsYmFjayA/IGNhbGxiYWNrKGRvbmUpIDogZG9uZVxuICB9XG5cbiAgcHVzaEhpc3RvcnlQYXRjaChocmVmLCBsaW5rU3RhdGUsIHRhcmdldEVsKXtcbiAgICBpZighdGhpcy5pc0Nvbm5lY3RlZCgpIHx8ICF0aGlzLm1haW4uaXNNYWluKCkpeyByZXR1cm4gQnJvd3Nlci5yZWRpcmVjdChocmVmKSB9XG5cbiAgICB0aGlzLndpdGhQYWdlTG9hZGluZyh7dG86IGhyZWYsIGtpbmQ6IFwicGF0Y2hcIn0sIGRvbmUgPT4ge1xuICAgICAgdGhpcy5tYWluLnB1c2hMaW5rUGF0Y2goaHJlZiwgdGFyZ2V0RWwsIGxpbmtSZWYgPT4ge1xuICAgICAgICB0aGlzLmhpc3RvcnlQYXRjaChocmVmLCBsaW5rU3RhdGUsIGxpbmtSZWYpXG4gICAgICAgIGRvbmUoKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgaGlzdG9yeVBhdGNoKGhyZWYsIGxpbmtTdGF0ZSwgbGlua1JlZiA9IHRoaXMuc2V0UGVuZGluZ0xpbmsoaHJlZikpe1xuICAgIGlmKCF0aGlzLmNvbW1pdFBlbmRpbmdMaW5rKGxpbmtSZWYpKXsgcmV0dXJuIH1cblxuICAgIEJyb3dzZXIucHVzaFN0YXRlKGxpbmtTdGF0ZSwge3R5cGU6IFwicGF0Y2hcIiwgaWQ6IHRoaXMubWFpbi5pZH0sIGhyZWYpXG4gICAgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpuYXZpZ2F0ZVwiLCB7ZGV0YWlsOiB7cGF0Y2g6IHRydWUsIGhyZWYsIHBvcDogZmFsc2V9fSlcbiAgICB0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKVxuICB9XG5cbiAgaGlzdG9yeVJlZGlyZWN0KGhyZWYsIGxpbmtTdGF0ZSwgZmxhc2gpe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkgfHwgIXRoaXMubWFpbi5pc01haW4oKSl7IHJldHVybiBCcm93c2VyLnJlZGlyZWN0KGhyZWYsIGZsYXNoKSB9XG5cbiAgICAvLyBjb252ZXJ0IHRvIGZ1bGwgaHJlZiBpZiBvbmx5IHBhdGggcHJlZml4XG4gICAgaWYoL15cXC8kfF5cXC9bXlxcL10rLiokLy50ZXN0KGhyZWYpKXtcbiAgICAgIGxldCB7cHJvdG9jb2wsIGhvc3R9ID0gd2luZG93LmxvY2F0aW9uXG4gICAgICBocmVmID0gYCR7cHJvdG9jb2x9Ly8ke2hvc3R9JHtocmVmfWBcbiAgICB9XG4gICAgbGV0IHNjcm9sbCA9IHdpbmRvdy5zY3JvbGxZXG4gICAgdGhpcy53aXRoUGFnZUxvYWRpbmcoe3RvOiBocmVmLCBraW5kOiBcInJlZGlyZWN0XCJ9LCBkb25lID0+IHtcbiAgICAgIHRoaXMucmVwbGFjZU1haW4oaHJlZiwgZmxhc2gsIChsaW5rUmVmKSA9PiB7XG4gICAgICAgIGlmKGxpbmtSZWYgPT09IHRoaXMubGlua1JlZil7XG4gICAgICAgICAgQnJvd3Nlci5wdXNoU3RhdGUobGlua1N0YXRlLCB7dHlwZTogXCJyZWRpcmVjdFwiLCBpZDogdGhpcy5tYWluLmlkLCBzY3JvbGw6IHNjcm9sbH0sIGhyZWYpXG4gICAgICAgICAgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpuYXZpZ2F0ZVwiLCB7ZGV0YWlsOiB7aHJlZiwgcGF0Y2g6IGZhbHNlLCBwb3A6IGZhbHNlfX0pXG4gICAgICAgICAgdGhpcy5yZWdpc3Rlck5ld0xvY2F0aW9uKHdpbmRvdy5sb2NhdGlvbilcbiAgICAgICAgfVxuICAgICAgICBkb25lKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHJlcGxhY2VSb290SGlzdG9yeSgpe1xuICAgIEJyb3dzZXIucHVzaFN0YXRlKFwicmVwbGFjZVwiLCB7cm9vdDogdHJ1ZSwgdHlwZTogXCJwYXRjaFwiLCBpZDogdGhpcy5tYWluLmlkfSlcbiAgfVxuXG4gIHJlZ2lzdGVyTmV3TG9jYXRpb24obmV3TG9jYXRpb24pe1xuICAgIGxldCB7cGF0aG5hbWUsIHNlYXJjaH0gPSB0aGlzLmN1cnJlbnRMb2NhdGlvblxuICAgIGlmKHBhdGhuYW1lICsgc2VhcmNoID09PSBuZXdMb2NhdGlvbi5wYXRobmFtZSArIG5ld0xvY2F0aW9uLnNlYXJjaCl7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBjbG9uZShuZXdMb2NhdGlvbilcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgYmluZEZvcm1zKCl7XG4gICAgbGV0IGl0ZXJhdGlvbnMgPSAwXG4gICAgbGV0IGV4dGVybmFsRm9ybVN1Ym1pdHRlZCA9IGZhbHNlXG5cbiAgICAvLyBkaXNhYmxlIGZvcm1zIG9uIHN1Ym1pdCB0aGF0IHRyYWNrIHBoeC1jaGFuZ2UgYnV0IHBlcmZvcm0gZXh0ZXJuYWwgc3VibWl0XG4gICAgdGhpcy5vbihcInN1Ym1pdFwiLCBlID0+IHtcbiAgICAgIGxldCBwaHhTdWJtaXQgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwic3VibWl0XCIpKVxuICAgICAgbGV0IHBoeENoYW5nZSA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIikpXG4gICAgICBpZighZXh0ZXJuYWxGb3JtU3VibWl0dGVkICYmIHBoeENoYW5nZSAmJiAhcGh4U3VibWl0KXtcbiAgICAgICAgZXh0ZXJuYWxGb3JtU3VibWl0dGVkID0gdHJ1ZVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZS50YXJnZXQsIHZpZXcgPT4ge1xuICAgICAgICAgIHZpZXcuZGlzYWJsZUZvcm0oZS50YXJnZXQpXG4gICAgICAgICAgLy8gc2FmYXJpIG5lZWRzIG5leHQgdGlja1xuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgaWYoRE9NLmlzVW5sb2FkYWJsZUZvcm1TdWJtaXQoZSkpeyB0aGlzLnVubG9hZCgpIH1cbiAgICAgICAgICAgIGUudGFyZ2V0LnN1Ym1pdCgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LCB0cnVlKVxuXG4gICAgdGhpcy5vbihcInN1Ym1pdFwiLCBlID0+IHtcbiAgICAgIGxldCBwaHhFdmVudCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJzdWJtaXRcIikpXG4gICAgICBpZighcGh4RXZlbnQpe1xuICAgICAgICBpZihET00uaXNVbmxvYWRhYmxlRm9ybVN1Ym1pdChlKSl7IHRoaXMudW5sb2FkKCkgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgZS50YXJnZXQuZGlzYWJsZWQgPSB0cnVlXG4gICAgICB0aGlzLndpdGhpbk93bmVycyhlLnRhcmdldCwgdmlldyA9PiB7XG4gICAgICAgIEpTLmV4ZWMoXCJzdWJtaXRcIiwgcGh4RXZlbnQsIHZpZXcsIGUudGFyZ2V0LCBbXCJwdXNoXCIsIHtzdWJtaXR0ZXI6IGUuc3VibWl0dGVyfV0pXG4gICAgICB9KVxuICAgIH0sIGZhbHNlKVxuXG4gICAgZm9yKGxldCB0eXBlIG9mIFtcImNoYW5nZVwiLCBcImlucHV0XCJdKXtcbiAgICAgIHRoaXMub24odHlwZSwgZSA9PiB7XG4gICAgICAgIGxldCBwaHhDaGFuZ2UgPSB0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIilcbiAgICAgICAgbGV0IGlucHV0ID0gZS50YXJnZXRcbiAgICAgICAgbGV0IGlucHV0RXZlbnQgPSBpbnB1dC5nZXRBdHRyaWJ1dGUocGh4Q2hhbmdlKVxuICAgICAgICBsZXQgZm9ybUV2ZW50ID0gaW5wdXQuZm9ybSAmJiBpbnB1dC5mb3JtLmdldEF0dHJpYnV0ZShwaHhDaGFuZ2UpXG4gICAgICAgIGxldCBwaHhFdmVudCA9IGlucHV0RXZlbnQgfHwgZm9ybUV2ZW50XG4gICAgICAgIGlmKCFwaHhFdmVudCl7IHJldHVybiB9XG4gICAgICAgIGlmKGlucHV0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgaW5wdXQudmFsaWRpdHkgJiYgaW5wdXQudmFsaWRpdHkuYmFkSW5wdXQpeyByZXR1cm4gfVxuXG4gICAgICAgIGxldCBkaXNwYXRjaGVyID0gaW5wdXRFdmVudCA/IGlucHV0IDogaW5wdXQuZm9ybVxuICAgICAgICBsZXQgY3VycmVudEl0ZXJhdGlvbnMgPSBpdGVyYXRpb25zXG4gICAgICAgIGl0ZXJhdGlvbnMrK1xuICAgICAgICBsZXQge2F0OiBhdCwgdHlwZTogbGFzdFR5cGV9ID0gRE9NLnByaXZhdGUoaW5wdXQsIFwicHJldi1pdGVyYXRpb25cIikgfHwge31cbiAgICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIGFsd2F5cyBmaXJlIGF0IGxlYXN0IG9uZSBcImlucHV0XCIgZXZlbnQgYmVmb3JlIGV2ZXJ5IFwiY2hhbmdlXCJcbiAgICAgICAgLy8gSWdub3JlIFwiY2hhbmdlXCIgZXZlbnRzLCB1bmxlc3MgdGhlcmUgd2FzIG5vIHByaW9yIFwiaW5wdXRcIiBldmVudC5cbiAgICAgICAgLy8gVGhpcyBjb3VsZCBoYXBwZW4gaWYgdXNlciBjb2RlIHRyaWdnZXJzIGEgXCJjaGFuZ2VcIiBldmVudCwgb3IgaWYgdGhlIGJyb3dzZXIgaXMgbm9uLWNvbmZvcm1pbmcuXG4gICAgICAgIGlmKGF0ID09PSBjdXJyZW50SXRlcmF0aW9ucyAtIDEgJiYgdHlwZSA9PT0gXCJjaGFuZ2VcIiAmJiBsYXN0VHlwZSA9PT0gXCJpbnB1dFwiKXsgcmV0dXJuIH1cblxuICAgICAgICBET00ucHV0UHJpdmF0ZShpbnB1dCwgXCJwcmV2LWl0ZXJhdGlvblwiLCB7YXQ6IGN1cnJlbnRJdGVyYXRpb25zLCB0eXBlOiB0eXBlfSlcblxuICAgICAgICB0aGlzLmRlYm91bmNlKGlucHV0LCBlLCB0eXBlLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZGlzcGF0Y2hlciwgdmlldyA9PiB7XG4gICAgICAgICAgICBET00ucHV0UHJpdmF0ZShpbnB1dCwgUEhYX0hBU19GT0NVU0VELCB0cnVlKVxuICAgICAgICAgICAgaWYoIURPTS5pc1RleHR1YWxJbnB1dChpbnB1dCkpe1xuICAgICAgICAgICAgICB0aGlzLnNldEFjdGl2ZUVsZW1lbnQoaW5wdXQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBKUy5leGVjKFwiY2hhbmdlXCIsIHBoeEV2ZW50LCB2aWV3LCBpbnB1dCwgW1wicHVzaFwiLCB7X3RhcmdldDogZS50YXJnZXQubmFtZSwgZGlzcGF0Y2hlcjogZGlzcGF0Y2hlcn1dKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9LCBmYWxzZSlcbiAgICB9XG4gICAgdGhpcy5vbihcInJlc2V0XCIsIChlKSA9PiB7XG4gICAgICBsZXQgZm9ybSA9IGUudGFyZ2V0XG4gICAgICBET00ucmVzZXRGb3JtKGZvcm0sIHRoaXMuYmluZGluZyhQSFhfRkVFREJBQ0tfRk9SKSwgdGhpcy5iaW5kaW5nKFBIWF9GRUVEQkFDS19HUk9VUCkpXG4gICAgICBsZXQgaW5wdXQgPSBBcnJheS5mcm9tKGZvcm0uZWxlbWVudHMpLmZpbmQoZWwgPT4gZWwudHlwZSA9PT0gXCJyZXNldFwiKVxuICAgICAgaWYoaW5wdXQpe1xuICAgICAgICAvLyB3YWl0IHVudGlsIG5leHQgdGljayB0byBnZXQgdXBkYXRlZCBpbnB1dCB2YWx1ZVxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIsIHtidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiBmYWxzZX0pKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBkZWJvdW5jZShlbCwgZXZlbnQsIGV2ZW50VHlwZSwgY2FsbGJhY2spe1xuICAgIGlmKGV2ZW50VHlwZSA9PT0gXCJibHVyXCIgfHwgZXZlbnRUeXBlID09PSBcImZvY3Vzb3V0XCIpeyByZXR1cm4gY2FsbGJhY2soKSB9XG5cbiAgICBsZXQgcGh4RGVib3VuY2UgPSB0aGlzLmJpbmRpbmcoUEhYX0RFQk9VTkNFKVxuICAgIGxldCBwaHhUaHJvdHRsZSA9IHRoaXMuYmluZGluZyhQSFhfVEhST1RUTEUpXG4gICAgbGV0IGRlZmF1bHREZWJvdW5jZSA9IHRoaXMuZGVmYXVsdHMuZGVib3VuY2UudG9TdHJpbmcoKVxuICAgIGxldCBkZWZhdWx0VGhyb3R0bGUgPSB0aGlzLmRlZmF1bHRzLnRocm90dGxlLnRvU3RyaW5nKClcblxuICAgIHRoaXMud2l0aGluT3duZXJzKGVsLCB2aWV3ID0+IHtcbiAgICAgIGxldCBhc3luY0ZpbHRlciA9ICgpID0+ICF2aWV3LmlzRGVzdHJveWVkKCkgJiYgZG9jdW1lbnQuYm9keS5jb250YWlucyhlbClcbiAgICAgIERPTS5kZWJvdW5jZShlbCwgZXZlbnQsIHBoeERlYm91bmNlLCBkZWZhdWx0RGVib3VuY2UsIHBoeFRocm90dGxlLCBkZWZhdWx0VGhyb3R0bGUsIGFzeW5jRmlsdGVyLCAoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHNpbGVuY2VFdmVudHMoY2FsbGJhY2spe1xuICAgIHRoaXMuc2lsZW5jZWQgPSB0cnVlXG4gICAgY2FsbGJhY2soKVxuICAgIHRoaXMuc2lsZW5jZWQgPSBmYWxzZVxuICB9XG5cbiAgb24oZXZlbnQsIGNhbGxiYWNrKXtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZSA9PiB7XG4gICAgICBpZighdGhpcy5zaWxlbmNlZCl7IGNhbGxiYWNrKGUpIH1cbiAgICB9KVxuICB9XG59XG5cbmNsYXNzIFRyYW5zaXRpb25TZXQge1xuICBjb25zdHJ1Y3Rvcigpe1xuICAgIHRoaXMudHJhbnNpdGlvbnMgPSBuZXcgU2V0KClcbiAgICB0aGlzLnBlbmRpbmdPcHMgPSBbXVxuICB9XG5cbiAgcmVzZXQoKXtcbiAgICB0aGlzLnRyYW5zaXRpb25zLmZvckVhY2godGltZXIgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKVxuICAgICAgdGhpcy50cmFuc2l0aW9ucy5kZWxldGUodGltZXIpXG4gICAgfSlcbiAgICB0aGlzLmZsdXNoUGVuZGluZ09wcygpXG4gIH1cblxuICBhZnRlcihjYWxsYmFjayl7XG4gICAgaWYodGhpcy5zaXplKCkgPT09IDApe1xuICAgICAgY2FsbGJhY2soKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2hQZW5kaW5nT3AoY2FsbGJhY2spXG4gICAgfVxuICB9XG5cbiAgYWRkVHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpe1xuICAgIG9uU3RhcnQoKVxuICAgIGxldCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc2l0aW9ucy5kZWxldGUodGltZXIpXG4gICAgICBvbkRvbmUoKVxuICAgICAgdGhpcy5mbHVzaFBlbmRpbmdPcHMoKVxuICAgIH0sIHRpbWUpXG4gICAgdGhpcy50cmFuc2l0aW9ucy5hZGQodGltZXIpXG4gIH1cblxuICBwdXNoUGVuZGluZ09wKG9wKXsgdGhpcy5wZW5kaW5nT3BzLnB1c2gob3ApIH1cblxuICBzaXplKCl7IHJldHVybiB0aGlzLnRyYW5zaXRpb25zLnNpemUgfVxuXG4gIGZsdXNoUGVuZGluZ09wcygpe1xuICAgIGlmKHRoaXMuc2l6ZSgpID4gMCl7IHJldHVybiB9XG4gICAgbGV0IG9wID0gdGhpcy5wZW5kaW5nT3BzLnNoaWZ0KClcbiAgICBpZihvcCl7XG4gICAgICBvcCgpXG4gICAgICB0aGlzLmZsdXNoUGVuZGluZ09wcygpXG4gICAgfVxuICB9XG59XG4iLCAiLy8gSWYgeW91IHdhbnQgdG8gdXNlIFBob2VuaXggY2hhbm5lbHMsIHJ1biBgbWl4IGhlbHAgcGh4Lmdlbi5jaGFubmVsYFxuLy8gdG8gZ2V0IHN0YXJ0ZWQgYW5kIHRoZW4gdW5jb21tZW50IHRoZSBsaW5lIGJlbG93LlxuLy8gaW1wb3J0IFwiLi91c2VyX3NvY2tldC5qc1wiXG5cbi8vIFlvdSBjYW4gaW5jbHVkZSBkZXBlbmRlbmNpZXMgaW4gdHdvIHdheXMuXG4vL1xuLy8gVGhlIHNpbXBsZXN0IG9wdGlvbiBpcyB0byBwdXQgdGhlbSBpbiBhc3NldHMvdmVuZG9yIGFuZFxuLy8gaW1wb3J0IHRoZW0gdXNpbmcgcmVsYXRpdmUgcGF0aHM6XG4vL1xuLy8gICAgIGltcG9ydCBcIi4uL3ZlbmRvci9zb21lLXBhY2thZ2UuanNcIlxuLy9cbi8vIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gYG5wbSBpbnN0YWxsIHNvbWUtcGFja2FnZSAtLXByZWZpeCBhc3NldHNgIGFuZCBpbXBvcnRcbi8vIHRoZW0gdXNpbmcgYSBwYXRoIHN0YXJ0aW5nIHdpdGggdGhlIHBhY2thZ2UgbmFtZTpcbi8vXG4vLyAgICAgaW1wb3J0IFwic29tZS1wYWNrYWdlXCJcbi8vXG5cbi8vIEluY2x1ZGUgcGhvZW5peF9odG1sIHRvIGhhbmRsZSBtZXRob2Q9UFVUL0RFTEVURSBpbiBmb3JtcyBhbmQgYnV0dG9ucy5cbmltcG9ydCBcInBob2VuaXhfaHRtbFwiXG4vLyBFc3RhYmxpc2ggUGhvZW5peCBTb2NrZXQgYW5kIExpdmVWaWV3IGNvbmZpZ3VyYXRpb24uXG5pbXBvcnQge1NvY2tldH0gZnJvbSBcInBob2VuaXhcIlxuaW1wb3J0IHtMaXZlU29ja2V0fSBmcm9tIFwicGhvZW5peF9saXZlX3ZpZXdcIlxuaW1wb3J0IHRvcGJhciBmcm9tIFwiLi4vdmVuZG9yL3RvcGJhclwiXG5pbXBvcnQgQ2hhcnQgZnJvbSAnY2hhcnQuanMvYXV0byc7XG5cbmxldCBob29rcyA9IHt9XG5ob29rcy5DaGFydEpTID0gIHtcbiAgcGVyc29uKCkgeyByZXR1cm4gdGhpcy5lbC5kYXRhc2V0LnBlcnNvbiB9LFxuICBtb3VudGVkKCkge1xuICAgIHRyZW5kcy5lbWJlZC5yZW5kZXJFeHBsb3JlV2lkZ2V0VG8oZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJteS1jaGFydFwiKSwgXCJUSU1FU0VSSUVTXCIsIHtcbiAgICAgIFwiY29tcGFyaXNvbkl0ZW1cIjogW3tcImtleXdvcmRcIjogdGhpcy5wZXJzb24oKSwgXCJnZW9cIjogXCJFU1wiLCBcInRpbWVcIjogXCIyMDA0LTAxLTAxIDIwMjQtMDItMDRcIn1dLFxuICAgICAgXCJjYXRlZ29yeVwiOiAwLFxuICAgICAgXCJwcm9wZXJ0eVwiOiBcIlwiXG4gICAgfSwge1xuICAgICAgXCJleHBsb3JlUXVlcnlcIjogYGRhdGU9YWxsJmdlbz1FUyZxPSR7dGhpcy5wZXJzb24oKX0maGw9ZXNgLFxuICAgICAgXCJndWVzdFBhdGhcIjogXCJodHRwczovL3RyZW5kcy5nb29nbGUuY29tOjQ0My90cmVuZHMvZW1iZWQvXCJcbiAgICB9KTtcbiAgfVxufSBcblxuaG9va3MuR2FsbGVyeSA9IHtcbiAgbmV4dEltYWdlKGdhbGxlcnlJZCkge1xuICAgIGNvbnN0IGdhbGxlcnlFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7Z2FsbGVyeUlkfWApO1xuICAgIGNvbnN0IGltYWdlcyA9IEpTT04ucGFyc2UoZ2FsbGVyeUVsZW1lbnQuZGF0YXNldC5pbWFnZXMpO1xuICAgIGNvbnN0IGltZ0VsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAjJHtnYWxsZXJ5SWR9LWltYWdlYCk7XG4gICAgY29uc3QgY3VycmVudFNyYyA9IGltZ0VsZW1lbnQuc3JjO1xuICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGltYWdlcy5pbmRleE9mKGN1cnJlbnRTcmMpO1xuICAgIGNvbnN0IG5leHRJbmRleCA9IChjdXJyZW50SW5kZXggKyAxKSAlIGltYWdlcy5sZW5ndGg7XG4gICAgaW1nRWxlbWVudC5zcmMgPSBpbWFnZXNbbmV4dEluZGV4XTtcbiAgfSxcbiAgcHJldkltYWdlKGdhbGxlcnlJZCkge1xuICAgIGNvbnN0IGdhbGxlcnlFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7Z2FsbGVyeUlkfWApO1xuICAgIGNvbnN0IGltYWdlcyA9IEpTT04ucGFyc2UoZ2FsbGVyeUVsZW1lbnQuZGF0YXNldC5pbWFnZXMpO1xuICAgIGNvbnN0IGltZ0VsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAjJHtnYWxsZXJ5SWR9LWltYWdlYCk7XG4gICAgY29uc3QgY3VycmVudFNyYyA9IGltZ0VsZW1lbnQuc3JjO1xuICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGltYWdlcy5pbmRleE9mKGN1cnJlbnRTcmMpO1xuICAgIGNvbnN0IHByZXZJbmRleCA9IChjdXJyZW50SW5kZXggLSAxICsgaW1hZ2VzLmxlbmd0aCkgJSBpbWFnZXMubGVuZ3RoO1xuICAgIGltZ0VsZW1lbnQuc3JjID0gaW1hZ2VzW3ByZXZJbmRleF07XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJidXR0b24tcHJldlwiKS5vbmNsaWNrID0gKCkgPT4gdGhpcy5wcmV2SW1hZ2UodGhpcy5lbC5pZCk7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJidXR0b24tbmV4dFwiKS5vbmNsaWNrID0gKCkgPT4gdGhpcy5uZXh0SW1hZ2UodGhpcy5lbC5pZCk7XG4gIH1cbn1cblxubGV0IGNzcmZUb2tlbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJtZXRhW25hbWU9J2NzcmYtdG9rZW4nXVwiKS5nZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIpXG5sZXQgbGl2ZVNvY2tldCA9IG5ldyBMaXZlU29ja2V0KFwiL2xpdmVcIiwgU29ja2V0LCB7XG4gIGxvbmdQb2xsRmFsbGJhY2tNczogMjUwMCxcbiAgaG9va3M6IGhvb2tzLFxuICBwYXJhbXM6IHtfY3NyZl90b2tlbjogY3NyZlRva2VufVxufSlcblxuLy8gU2hvdyBwcm9ncmVzcyBiYXIgb24gbGl2ZSBuYXZpZ2F0aW9uIGFuZCBmb3JtIHN1Ym1pdHNcbnRvcGJhci5jb25maWcoe2JhckNvbG9yczogezA6IFwiIzI5ZFwifSwgc2hhZG93Q29sb3I6IFwicmdiYSgwLCAwLCAwLCAuMylcIn0pXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBoeDpwYWdlLWxvYWRpbmctc3RhcnRcIiwgX2luZm8gPT4gdG9wYmFyLnNob3coMzAwKSlcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGh4OnBhZ2UtbG9hZGluZy1zdG9wXCIsIF9pbmZvID0+IHRvcGJhci5oaWRlKCkpXG5cbi8vIGNvbm5lY3QgaWYgdGhlcmUgYXJlIGFueSBMaXZlVmlld3Mgb24gdGhlIHBhZ2VcbmxpdmVTb2NrZXQuY29ubmVjdCgpXG5cbi8vIGV4cG9zZSBsaXZlU29ja2V0IG9uIHdpbmRvdyBmb3Igd2ViIGNvbnNvbGUgZGVidWcgbG9ncyBhbmQgbGF0ZW5jeSBzaW11bGF0aW9uOlxuLy8gPj4gbGl2ZVNvY2tldC5lbmFibGVEZWJ1ZygpXG4vLyA+PiBsaXZlU29ja2V0LmVuYWJsZUxhdGVuY3lTaW0oMTAwMCkgIC8vIGVuYWJsZWQgZm9yIGR1cmF0aW9uIG9mIGJyb3dzZXIgc2Vzc2lvblxuLy8gPj4gbGl2ZVNvY2tldC5kaXNhYmxlTGF0ZW5jeVNpbSgpXG53aW5kb3cubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXRcblxuIiwgIi8qIVxuICogQGt1cmtsZS9jb2xvciB2MC4zLjJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9rdXJrbGUvY29sb3IjcmVhZG1lXG4gKiAoYykgMjAyMyBKdWtrYSBLdXJrZWxhXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gcm91bmQodikge1xuICByZXR1cm4gdiArIDAuNSB8IDA7XG59XG5jb25zdCBsaW0gPSAodiwgbCwgaCkgPT4gTWF0aC5tYXgoTWF0aC5taW4odiwgaCksIGwpO1xuZnVuY3Rpb24gcDJiKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMi41NSksIDAsIDI1NSk7XG59XG5mdW5jdGlvbiBiMnAodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgLyAyLjU1KSwgMCwgMTAwKTtcbn1cbmZ1bmN0aW9uIG4yYih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDI1NSksIDAsIDI1NSk7XG59XG5mdW5jdGlvbiBiMm4odikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgLyAyLjU1KSAvIDEwMCwgMCwgMSk7XG59XG5mdW5jdGlvbiBuMnAodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgKiAxMDApLCAwLCAxMDApO1xufVxuXG5jb25zdCBtYXAkMSA9IHswOiAwLCAxOiAxLCAyOiAyLCAzOiAzLCA0OiA0LCA1OiA1LCA2OiA2LCA3OiA3LCA4OiA4LCA5OiA5LCBBOiAxMCwgQjogMTEsIEM6IDEyLCBEOiAxMywgRTogMTQsIEY6IDE1LCBhOiAxMCwgYjogMTEsIGM6IDEyLCBkOiAxMywgZTogMTQsIGY6IDE1fTtcbmNvbnN0IGhleCA9IFsuLi4nMDEyMzQ1Njc4OUFCQ0RFRiddO1xuY29uc3QgaDEgPSBiID0+IGhleFtiICYgMHhGXTtcbmNvbnN0IGgyID0gYiA9PiBoZXhbKGIgJiAweEYwKSA+PiA0XSArIGhleFtiICYgMHhGXTtcbmNvbnN0IGVxID0gYiA9PiAoKGIgJiAweEYwKSA+PiA0KSA9PT0gKGIgJiAweEYpO1xuY29uc3QgaXNTaG9ydCA9IHYgPT4gZXEodi5yKSAmJiBlcSh2LmcpICYmIGVxKHYuYikgJiYgZXEodi5hKTtcbmZ1bmN0aW9uIGhleFBhcnNlKHN0cikge1xuICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0clswXSA9PT0gJyMnKSB7XG4gICAgaWYgKGxlbiA9PT0gNCB8fCBsZW4gPT09IDUpIHtcbiAgICAgIHJldCA9IHtcbiAgICAgICAgcjogMjU1ICYgbWFwJDFbc3RyWzFdXSAqIDE3LFxuICAgICAgICBnOiAyNTUgJiBtYXAkMVtzdHJbMl1dICogMTcsXG4gICAgICAgIGI6IDI1NSAmIG1hcCQxW3N0clszXV0gKiAxNyxcbiAgICAgICAgYTogbGVuID09PSA1ID8gbWFwJDFbc3RyWzRdXSAqIDE3IDogMjU1XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAobGVuID09PSA3IHx8IGxlbiA9PT0gOSkge1xuICAgICAgcmV0ID0ge1xuICAgICAgICByOiBtYXAkMVtzdHJbMV1dIDw8IDQgfCBtYXAkMVtzdHJbMl1dLFxuICAgICAgICBnOiBtYXAkMVtzdHJbM11dIDw8IDQgfCBtYXAkMVtzdHJbNF1dLFxuICAgICAgICBiOiBtYXAkMVtzdHJbNV1dIDw8IDQgfCBtYXAkMVtzdHJbNl1dLFxuICAgICAgICBhOiBsZW4gPT09IDkgPyAobWFwJDFbc3RyWzddXSA8PCA0IHwgbWFwJDFbc3RyWzhdXSkgOiAyNTVcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5jb25zdCBhbHBoYSA9IChhLCBmKSA9PiBhIDwgMjU1ID8gZihhKSA6ICcnO1xuZnVuY3Rpb24gaGV4U3RyaW5nKHYpIHtcbiAgdmFyIGYgPSBpc1Nob3J0KHYpID8gaDEgOiBoMjtcbiAgcmV0dXJuIHZcbiAgICA/ICcjJyArIGYodi5yKSArIGYodi5nKSArIGYodi5iKSArIGFscGhhKHYuYSwgZilcbiAgICA6IHVuZGVmaW5lZDtcbn1cblxuY29uc3QgSFVFX1JFID0gL14oaHNsYT98aHdifGhzdilcXChcXHMqKFstKy5lXFxkXSspKD86ZGVnKT9bXFxzLF0rKFstKy5lXFxkXSspJVtcXHMsXSsoWy0rLmVcXGRdKyklKD86W1xccyxdKyhbLSsuZVxcZF0rKSglKT8pP1xccypcXCkkLztcbmZ1bmN0aW9uIGhzbDJyZ2JuKGgsIHMsIGwpIHtcbiAgY29uc3QgYSA9IHMgKiBNYXRoLm1pbihsLCAxIC0gbCk7XG4gIGNvbnN0IGYgPSAobiwgayA9IChuICsgaCAvIDMwKSAlIDEyKSA9PiBsIC0gYSAqIE1hdGgubWF4KE1hdGgubWluKGsgLSAzLCA5IC0gaywgMSksIC0xKTtcbiAgcmV0dXJuIFtmKDApLCBmKDgpLCBmKDQpXTtcbn1cbmZ1bmN0aW9uIGhzdjJyZ2JuKGgsIHMsIHYpIHtcbiAgY29uc3QgZiA9IChuLCBrID0gKG4gKyBoIC8gNjApICUgNikgPT4gdiAtIHYgKiBzICogTWF0aC5tYXgoTWF0aC5taW4oaywgNCAtIGssIDEpLCAwKTtcbiAgcmV0dXJuIFtmKDUpLCBmKDMpLCBmKDEpXTtcbn1cbmZ1bmN0aW9uIGh3YjJyZ2JuKGgsIHcsIGIpIHtcbiAgY29uc3QgcmdiID0gaHNsMnJnYm4oaCwgMSwgMC41KTtcbiAgbGV0IGk7XG4gIGlmICh3ICsgYiA+IDEpIHtcbiAgICBpID0gMSAvICh3ICsgYik7XG4gICAgdyAqPSBpO1xuICAgIGIgKj0gaTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgcmdiW2ldICo9IDEgLSB3IC0gYjtcbiAgICByZ2JbaV0gKz0gdztcbiAgfVxuICByZXR1cm4gcmdiO1xufVxuZnVuY3Rpb24gaHVlVmFsdWUociwgZywgYiwgZCwgbWF4KSB7XG4gIGlmIChyID09PSBtYXgpIHtcbiAgICByZXR1cm4gKChnIC0gYikgLyBkKSArIChnIDwgYiA/IDYgOiAwKTtcbiAgfVxuICBpZiAoZyA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIChiIC0gcikgLyBkICsgMjtcbiAgfVxuICByZXR1cm4gKHIgLSBnKSAvIGQgKyA0O1xufVxuZnVuY3Rpb24gcmdiMmhzbCh2KSB7XG4gIGNvbnN0IHJhbmdlID0gMjU1O1xuICBjb25zdCByID0gdi5yIC8gcmFuZ2U7XG4gIGNvbnN0IGcgPSB2LmcgLyByYW5nZTtcbiAgY29uc3QgYiA9IHYuYiAvIHJhbmdlO1xuICBjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgY29uc3QgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gIGNvbnN0IGwgPSAobWF4ICsgbWluKSAvIDI7XG4gIGxldCBoLCBzLCBkO1xuICBpZiAobWF4ICE9PSBtaW4pIHtcbiAgICBkID0gbWF4IC0gbWluO1xuICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICBoID0gaHVlVmFsdWUociwgZywgYiwgZCwgbWF4KTtcbiAgICBoID0gaCAqIDYwICsgMC41O1xuICB9XG4gIHJldHVybiBbaCB8IDAsIHMgfHwgMCwgbF07XG59XG5mdW5jdGlvbiBjYWxsbihmLCBhLCBiLCBjKSB7XG4gIHJldHVybiAoXG4gICAgQXJyYXkuaXNBcnJheShhKVxuICAgICAgPyBmKGFbMF0sIGFbMV0sIGFbMl0pXG4gICAgICA6IGYoYSwgYiwgYylcbiAgKS5tYXAobjJiKTtcbn1cbmZ1bmN0aW9uIGhzbDJyZ2IoaCwgcywgbCkge1xuICByZXR1cm4gY2FsbG4oaHNsMnJnYm4sIGgsIHMsIGwpO1xufVxuZnVuY3Rpb24gaHdiMnJnYihoLCB3LCBiKSB7XG4gIHJldHVybiBjYWxsbihod2IycmdibiwgaCwgdywgYik7XG59XG5mdW5jdGlvbiBoc3YycmdiKGgsIHMsIHYpIHtcbiAgcmV0dXJuIGNhbGxuKGhzdjJyZ2JuLCBoLCBzLCB2KTtcbn1cbmZ1bmN0aW9uIGh1ZShoKSB7XG4gIHJldHVybiAoaCAlIDM2MCArIDM2MCkgJSAzNjA7XG59XG5mdW5jdGlvbiBodWVQYXJzZShzdHIpIHtcbiAgY29uc3QgbSA9IEhVRV9SRS5leGVjKHN0cik7XG4gIGxldCBhID0gMjU1O1xuICBsZXQgdjtcbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtWzVdICE9PSB2KSB7XG4gICAgYSA9IG1bNl0gPyBwMmIoK21bNV0pIDogbjJiKCttWzVdKTtcbiAgfVxuICBjb25zdCBoID0gaHVlKCttWzJdKTtcbiAgY29uc3QgcDEgPSArbVszXSAvIDEwMDtcbiAgY29uc3QgcDIgPSArbVs0XSAvIDEwMDtcbiAgaWYgKG1bMV0gPT09ICdod2InKSB7XG4gICAgdiA9IGh3YjJyZ2IoaCwgcDEsIHAyKTtcbiAgfSBlbHNlIGlmIChtWzFdID09PSAnaHN2Jykge1xuICAgIHYgPSBoc3YycmdiKGgsIHAxLCBwMik7XG4gIH0gZWxzZSB7XG4gICAgdiA9IGhzbDJyZ2IoaCwgcDEsIHAyKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHI6IHZbMF0sXG4gICAgZzogdlsxXSxcbiAgICBiOiB2WzJdLFxuICAgIGE6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHJvdGF0ZSh2LCBkZWcpIHtcbiAgdmFyIGggPSByZ2IyaHNsKHYpO1xuICBoWzBdID0gaHVlKGhbMF0gKyBkZWcpO1xuICBoID0gaHNsMnJnYihoKTtcbiAgdi5yID0gaFswXTtcbiAgdi5nID0gaFsxXTtcbiAgdi5iID0gaFsyXTtcbn1cbmZ1bmN0aW9uIGhzbFN0cmluZyh2KSB7XG4gIGlmICghdikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBhID0gcmdiMmhzbCh2KTtcbiAgY29uc3QgaCA9IGFbMF07XG4gIGNvbnN0IHMgPSBuMnAoYVsxXSk7XG4gIGNvbnN0IGwgPSBuMnAoYVsyXSk7XG4gIHJldHVybiB2LmEgPCAyNTVcbiAgICA/IGBoc2xhKCR7aH0sICR7c30lLCAke2x9JSwgJHtiMm4odi5hKX0pYFxuICAgIDogYGhzbCgke2h9LCAke3N9JSwgJHtsfSUpYDtcbn1cblxuY29uc3QgbWFwID0ge1xuICB4OiAnZGFyaycsXG4gIFo6ICdsaWdodCcsXG4gIFk6ICdyZScsXG4gIFg6ICdibHUnLFxuICBXOiAnZ3InLFxuICBWOiAnbWVkaXVtJyxcbiAgVTogJ3NsYXRlJyxcbiAgQTogJ2VlJyxcbiAgVDogJ29sJyxcbiAgUzogJ29yJyxcbiAgQjogJ3JhJyxcbiAgQzogJ2xhdGVnJyxcbiAgRDogJ2lnaHRzJyxcbiAgUjogJ2luJyxcbiAgUTogJ3R1cnF1b2lzJyxcbiAgRTogJ2hpJyxcbiAgUDogJ3JvJyxcbiAgTzogJ2FsJyxcbiAgTjogJ2xlJyxcbiAgTTogJ2RlJyxcbiAgTDogJ3llbGxvJyxcbiAgRjogJ2VuJyxcbiAgSzogJ2NoJyxcbiAgRzogJ2Fya3MnLFxuICBIOiAnZWEnLFxuICBJOiAnaWdodGcnLFxuICBKOiAnd2gnXG59O1xuY29uc3QgbmFtZXMkMSA9IHtcbiAgT2ljZVhlOiAnZjBmOGZmJyxcbiAgYW50aXF1ZXdFdGU6ICdmYWViZDcnLFxuICBhcXVhOiAnZmZmZicsXG4gIGFxdWFtYXJSZTogJzdmZmZkNCcsXG4gIGF6dVk6ICdmMGZmZmYnLFxuICBiZWlnZTogJ2Y1ZjVkYycsXG4gIGJpc3F1ZTogJ2ZmZTRjNCcsXG4gIGJsYWNrOiAnMCcsXG4gIGJsYW5LZWRPbW9uZDogJ2ZmZWJjZCcsXG4gIFhlOiAnZmYnLFxuICBYZXZpVGV0OiAnOGEyYmUyJyxcbiAgYlB3bjogJ2E1MmEyYScsXG4gIGJ1cmx5d29vZDogJ2RlYjg4NycsXG4gIGNhTXRYZTogJzVmOWVhMCcsXG4gIEthcnRZdXNlOiAnN2ZmZjAwJyxcbiAgS29jVGF0ZTogJ2QyNjkxZScsXG4gIGNTTzogJ2ZmN2Y1MCcsXG4gIGNTbmZsb3dlclhlOiAnNjQ5NWVkJyxcbiAgY1Nuc2lsazogJ2ZmZjhkYycsXG4gIGNyaW1zb246ICdkYzE0M2MnLFxuICBjeWFuOiAnZmZmZicsXG4gIHhYZTogJzhiJyxcbiAgeGN5YW46ICc4YjhiJyxcbiAgeGdUTW5QZDogJ2I4ODYwYicsXG4gIHhXYXk6ICdhOWE5YTknLFxuICB4Z1lGOiAnNjQwMCcsXG4gIHhnWXk6ICdhOWE5YTknLFxuICB4a2hha2k6ICdiZGI3NmInLFxuICB4bWFnRnRhOiAnOGIwMDhiJyxcbiAgeFRpdmVnWUY6ICc1NTZiMmYnLFxuICB4U2FuZ2U6ICdmZjhjMDAnLFxuICB4U2NFZDogJzk5MzJjYycsXG4gIHhZZDogJzhiMDAwMCcsXG4gIHhzT21vbjogJ2U5OTY3YScsXG4gIHhzSGdZRjogJzhmYmM4ZicsXG4gIHhVWGU6ICc0ODNkOGInLFxuICB4VVdheTogJzJmNGY0ZicsXG4gIHhVZ1l5OiAnMmY0ZjRmJyxcbiAgeFFlOiAnY2VkMScsXG4gIHh2aVRldDogJzk0MDBkMycsXG4gIGRBcHBSazogJ2ZmMTQ5MycsXG4gIGRBcHNreVhlOiAnYmZmZicsXG4gIGRpbVdheTogJzY5Njk2OScsXG4gIGRpbWdZeTogJzY5Njk2OScsXG4gIGRvZGdlclhlOiAnMWU5MGZmJyxcbiAgZmlZYnJpY2s6ICdiMjIyMjInLFxuICBmbFNPd0V0ZTogJ2ZmZmFmMCcsXG4gIGZvWXN0V0FuOiAnMjI4YjIyJyxcbiAgZnVLc2lhOiAnZmYwMGZmJyxcbiAgZ2FSc2JTbzogJ2RjZGNkYycsXG4gIGdob3N0d0V0ZTogJ2Y4ZjhmZicsXG4gIGdUZDogJ2ZmZDcwMCcsXG4gIGdUTW5QZDogJ2RhYTUyMCcsXG4gIFdheTogJzgwODA4MCcsXG4gIGdZRjogJzgwMDAnLFxuICBnWUZMdzogJ2FkZmYyZicsXG4gIGdZeTogJzgwODA4MCcsXG4gIGhvbmV5TXc6ICdmMGZmZjAnLFxuICBob3RwUms6ICdmZjY5YjQnLFxuICBSZGlhbllkOiAnY2Q1YzVjJyxcbiAgUmRpZ286ICc0YjAwODInLFxuICBpdlN5OiAnZmZmZmYwJyxcbiAga2hha2k6ICdmMGU2OGMnLFxuICBsYXZGTXI6ICdlNmU2ZmEnLFxuICBsYXZGTXJYc2g6ICdmZmYwZjUnLFxuICBsYXduZ1lGOiAnN2NmYzAwJyxcbiAgTm1vbmNFZmZvbjogJ2ZmZmFjZCcsXG4gIFpYZTogJ2FkZDhlNicsXG4gIFpjU086ICdmMDgwODAnLFxuICBaY3lhbjogJ2UwZmZmZicsXG4gIFpnVE1uUGRMdzogJ2ZhZmFkMicsXG4gIFpXYXk6ICdkM2QzZDMnLFxuICBaZ1lGOiAnOTBlZTkwJyxcbiAgWmdZeTogJ2QzZDNkMycsXG4gIFpwUms6ICdmZmI2YzEnLFxuICBac09tb246ICdmZmEwN2EnLFxuICBac0hnWUY6ICcyMGIyYWEnLFxuICBac2t5WGU6ICc4N2NlZmEnLFxuICBaVVdheTogJzc3ODg5OScsXG4gIFpVZ1l5OiAnNzc4ODk5JyxcbiAgWnN0QWxYZTogJ2IwYzRkZScsXG4gIFpMdzogJ2ZmZmZlMCcsXG4gIGxpbWU6ICdmZjAwJyxcbiAgbGltZWdZRjogJzMyY2QzMicsXG4gIGxSRjogJ2ZhZjBlNicsXG4gIG1hZ0Z0YTogJ2ZmMDBmZicsXG4gIG1hUG9uOiAnODAwMDAwJyxcbiAgVmFxdWFtYXJSZTogJzY2Y2RhYScsXG4gIFZYZTogJ2NkJyxcbiAgVlNjRWQ6ICdiYTU1ZDMnLFxuICBWcHVycE46ICc5MzcwZGInLFxuICBWc0hnWUY6ICczY2IzNzEnLFxuICBWVVhlOiAnN2I2OGVlJyxcbiAgVnNwclJnZ1lGOiAnZmE5YScsXG4gIFZRZTogJzQ4ZDFjYycsXG4gIFZ2aVRldFlkOiAnYzcxNTg1JyxcbiAgbWlkbmlnaHRYZTogJzE5MTk3MCcsXG4gIG1SdGNZYW06ICdmNWZmZmEnLFxuICBtaXN0eVBzZTogJ2ZmZTRlMScsXG4gIG1vY2Nhc1I6ICdmZmU0YjUnLFxuICBuYXZham93RXRlOiAnZmZkZWFkJyxcbiAgbmF2eTogJzgwJyxcbiAgVGRsYWNlOiAnZmRmNWU2JyxcbiAgVGl2ZTogJzgwODAwMCcsXG4gIFRpdmVkQmI6ICc2YjhlMjMnLFxuICBTYW5nZTogJ2ZmYTUwMCcsXG4gIFNhbmdlWWQ6ICdmZjQ1MDAnLFxuICBTY0VkOiAnZGE3MGQ2JyxcbiAgcE9lZ1RNblBkOiAnZWVlOGFhJyxcbiAgcE9lZ1lGOiAnOThmYjk4JyxcbiAgcE9lUWU6ICdhZmVlZWUnLFxuICBwT2V2aVRldFlkOiAnZGI3MDkzJyxcbiAgcGFwYXlhd0VwOiAnZmZlZmQ1JyxcbiAgcEhLcHVmZjogJ2ZmZGFiOScsXG4gIHBlcnU6ICdjZDg1M2YnLFxuICBwUms6ICdmZmMwY2InLFxuICBwbHVtOiAnZGRhMGRkJyxcbiAgcG93TXJYZTogJ2IwZTBlNicsXG4gIHB1cnBOOiAnODAwMDgwJyxcbiAgWWJlY2NhcHVycE46ICc2NjMzOTknLFxuICBZZDogJ2ZmMDAwMCcsXG4gIFBzeWJyb3duOiAnYmM4ZjhmJyxcbiAgUHlPWGU6ICc0MTY5ZTEnLFxuICBzYWRkTmJQd246ICc4YjQ1MTMnLFxuICBzT21vbjogJ2ZhODA3MicsXG4gIHNhbmR5YlB3bjogJ2Y0YTQ2MCcsXG4gIHNIZ1lGOiAnMmU4YjU3JyxcbiAgc0hzaGVsbDogJ2ZmZjVlZScsXG4gIHNpRm5hOiAnYTA1MjJkJyxcbiAgc2lsdmVyOiAnYzBjMGMwJyxcbiAgc2t5WGU6ICc4N2NlZWInLFxuICBVWGU6ICc2YTVhY2QnLFxuICBVV2F5OiAnNzA4MDkwJyxcbiAgVWdZeTogJzcwODA5MCcsXG4gIHNub3c6ICdmZmZhZmEnLFxuICBzcHJSZ2dZRjogJ2ZmN2YnLFxuICBzdEFsWGU6ICc0NjgyYjQnLFxuICB0YW46ICdkMmI0OGMnLFxuICB0ZU86ICc4MDgwJyxcbiAgdEVzdE46ICdkOGJmZDgnLFxuICB0b21hdG86ICdmZjYzNDcnLFxuICBRZTogJzQwZTBkMCcsXG4gIHZpVGV0OiAnZWU4MmVlJyxcbiAgSkh0OiAnZjVkZWIzJyxcbiAgd0V0ZTogJ2ZmZmZmZicsXG4gIHdFdGVzbW9rZTogJ2Y1ZjVmNScsXG4gIEx3OiAnZmZmZjAwJyxcbiAgTHdnWUY6ICc5YWNkMzInXG59O1xuZnVuY3Rpb24gdW5wYWNrKCkge1xuICBjb25zdCB1bnBhY2tlZCA9IHt9O1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobmFtZXMkMSk7XG4gIGNvbnN0IHRrZXlzID0gT2JqZWN0LmtleXMobWFwKTtcbiAgbGV0IGksIGosIGssIG9rLCBuaztcbiAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBvayA9IG5rID0ga2V5c1tpXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgdGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGsgPSB0a2V5c1tqXTtcbiAgICAgIG5rID0gbmsucmVwbGFjZShrLCBtYXBba10pO1xuICAgIH1cbiAgICBrID0gcGFyc2VJbnQobmFtZXMkMVtva10sIDE2KTtcbiAgICB1bnBhY2tlZFtua10gPSBbayA+PiAxNiAmIDB4RkYsIGsgPj4gOCAmIDB4RkYsIGsgJiAweEZGXTtcbiAgfVxuICByZXR1cm4gdW5wYWNrZWQ7XG59XG5cbmxldCBuYW1lcztcbmZ1bmN0aW9uIG5hbWVQYXJzZShzdHIpIHtcbiAgaWYgKCFuYW1lcykge1xuICAgIG5hbWVzID0gdW5wYWNrKCk7XG4gICAgbmFtZXMudHJhbnNwYXJlbnQgPSBbMCwgMCwgMCwgMF07XG4gIH1cbiAgY29uc3QgYSA9IG5hbWVzW3N0ci50b0xvd2VyQ2FzZSgpXTtcbiAgcmV0dXJuIGEgJiYge1xuICAgIHI6IGFbMF0sXG4gICAgZzogYVsxXSxcbiAgICBiOiBhWzJdLFxuICAgIGE6IGEubGVuZ3RoID09PSA0ID8gYVszXSA6IDI1NVxuICB9O1xufVxuXG5jb25zdCBSR0JfUkUgPSAvXnJnYmE/XFwoXFxzKihbLSsuXFxkXSspKCUpP1tcXHMsXSsoWy0rLmVcXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT8oPzpbXFxzLC9dKyhbLSsuZVxcZF0rKSglKT8pP1xccypcXCkkLztcbmZ1bmN0aW9uIHJnYlBhcnNlKHN0cikge1xuICBjb25zdCBtID0gUkdCX1JFLmV4ZWMoc3RyKTtcbiAgbGV0IGEgPSAyNTU7XG4gIGxldCByLCBnLCBiO1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1bN10gIT09IHIpIHtcbiAgICBjb25zdCB2ID0gK21bN107XG4gICAgYSA9IG1bOF0gPyBwMmIodikgOiBsaW0odiAqIDI1NSwgMCwgMjU1KTtcbiAgfVxuICByID0gK21bMV07XG4gIGcgPSArbVszXTtcbiAgYiA9ICttWzVdO1xuICByID0gMjU1ICYgKG1bMl0gPyBwMmIocikgOiBsaW0ociwgMCwgMjU1KSk7XG4gIGcgPSAyNTUgJiAobVs0XSA/IHAyYihnKSA6IGxpbShnLCAwLCAyNTUpKTtcbiAgYiA9IDI1NSAmIChtWzZdID8gcDJiKGIpIDogbGltKGIsIDAsIDI1NSkpO1xuICByZXR1cm4ge1xuICAgIHI6IHIsXG4gICAgZzogZyxcbiAgICBiOiBiLFxuICAgIGE6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHJnYlN0cmluZyh2KSB7XG4gIHJldHVybiB2ICYmIChcbiAgICB2LmEgPCAyNTVcbiAgICAgID8gYHJnYmEoJHt2LnJ9LCAke3YuZ30sICR7di5ifSwgJHtiMm4odi5hKX0pYFxuICAgICAgOiBgcmdiKCR7di5yfSwgJHt2Lmd9LCAke3YuYn0pYFxuICApO1xufVxuXG5jb25zdCB0byA9IHYgPT4gdiA8PSAwLjAwMzEzMDggPyB2ICogMTIuOTIgOiBNYXRoLnBvdyh2LCAxLjAgLyAyLjQpICogMS4wNTUgLSAwLjA1NTtcbmNvbnN0IGZyb20gPSB2ID0+IHYgPD0gMC4wNDA0NSA/IHYgLyAxMi45MiA6IE1hdGgucG93KCh2ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShyZ2IxLCByZ2IyLCB0KSB7XG4gIGNvbnN0IHIgPSBmcm9tKGIybihyZ2IxLnIpKTtcbiAgY29uc3QgZyA9IGZyb20oYjJuKHJnYjEuZykpO1xuICBjb25zdCBiID0gZnJvbShiMm4ocmdiMS5iKSk7XG4gIHJldHVybiB7XG4gICAgcjogbjJiKHRvKHIgKyB0ICogKGZyb20oYjJuKHJnYjIucikpIC0gcikpKSxcbiAgICBnOiBuMmIodG8oZyArIHQgKiAoZnJvbShiMm4ocmdiMi5nKSkgLSBnKSkpLFxuICAgIGI6IG4yYih0byhiICsgdCAqIChmcm9tKGIybihyZ2IyLmIpKSAtIGIpKSksXG4gICAgYTogcmdiMS5hICsgdCAqIChyZ2IyLmEgLSByZ2IxLmEpXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vZEhTTCh2LCBpLCByYXRpbykge1xuICBpZiAodikge1xuICAgIGxldCB0bXAgPSByZ2IyaHNsKHYpO1xuICAgIHRtcFtpXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRtcFtpXSArIHRtcFtpXSAqIHJhdGlvLCBpID09PSAwID8gMzYwIDogMSkpO1xuICAgIHRtcCA9IGhzbDJyZ2IodG1wKTtcbiAgICB2LnIgPSB0bXBbMF07XG4gICAgdi5nID0gdG1wWzFdO1xuICAgIHYuYiA9IHRtcFsyXTtcbiAgfVxufVxuZnVuY3Rpb24gY2xvbmUodiwgcHJvdG8pIHtcbiAgcmV0dXJuIHYgPyBPYmplY3QuYXNzaWduKHByb3RvIHx8IHt9LCB2KSA6IHY7XG59XG5mdW5jdGlvbiBmcm9tT2JqZWN0KGlucHV0KSB7XG4gIHZhciB2ID0ge3I6IDAsIGc6IDAsIGI6IDAsIGE6IDI1NX07XG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIGlmIChpbnB1dC5sZW5ndGggPj0gMykge1xuICAgICAgdiA9IHtyOiBpbnB1dFswXSwgZzogaW5wdXRbMV0sIGI6IGlucHV0WzJdLCBhOiAyNTV9O1xuICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IDMpIHtcbiAgICAgICAgdi5hID0gbjJiKGlucHV0WzNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdiA9IGNsb25lKGlucHV0LCB7cjogMCwgZzogMCwgYjogMCwgYTogMX0pO1xuICAgIHYuYSA9IG4yYih2LmEpO1xuICB9XG4gIHJldHVybiB2O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25QYXJzZShzdHIpIHtcbiAgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICdyJykge1xuICAgIHJldHVybiByZ2JQYXJzZShzdHIpO1xuICB9XG4gIHJldHVybiBodWVQYXJzZShzdHIpO1xufVxuY2xhc3MgQ29sb3Ige1xuICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIENvbG9yKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgaW5wdXQ7XG4gICAgbGV0IHY7XG4gICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2ID0gZnJvbU9iamVjdChpbnB1dCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgdiA9IGhleFBhcnNlKGlucHV0KSB8fCBuYW1lUGFyc2UoaW5wdXQpIHx8IGZ1bmN0aW9uUGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB0aGlzLl9yZ2IgPSB2O1xuICAgIHRoaXMuX3ZhbGlkID0gISF2O1xuICB9XG4gIGdldCB2YWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQ7XG4gIH1cbiAgZ2V0IHJnYigpIHtcbiAgICB2YXIgdiA9IGNsb25lKHRoaXMuX3JnYik7XG4gICAgaWYgKHYpIHtcbiAgICAgIHYuYSA9IGIybih2LmEpO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfVxuICBzZXQgcmdiKG9iaikge1xuICAgIHRoaXMuX3JnYiA9IGZyb21PYmplY3Qob2JqKTtcbiAgfVxuICByZ2JTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gcmdiU3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaGV4U3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IGhleFN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIGhzbFN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyBoc2xTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBtaXgoY29sb3IsIHdlaWdodCkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgY29uc3QgYzEgPSB0aGlzLnJnYjtcbiAgICAgIGNvbnN0IGMyID0gY29sb3IucmdiO1xuICAgICAgbGV0IHcyO1xuICAgICAgY29uc3QgcCA9IHdlaWdodCA9PT0gdzIgPyAwLjUgOiB3ZWlnaHQ7XG4gICAgICBjb25zdCB3ID0gMiAqIHAgLSAxO1xuICAgICAgY29uc3QgYSA9IGMxLmEgLSBjMi5hO1xuICAgICAgY29uc3QgdzEgPSAoKHcgKiBhID09PSAtMSA/IHcgOiAodyArIGEpIC8gKDEgKyB3ICogYSkpICsgMSkgLyAyLjA7XG4gICAgICB3MiA9IDEgLSB3MTtcbiAgICAgIGMxLnIgPSAweEZGICYgdzEgKiBjMS5yICsgdzIgKiBjMi5yICsgMC41O1xuICAgICAgYzEuZyA9IDB4RkYgJiB3MSAqIGMxLmcgKyB3MiAqIGMyLmcgKyAwLjU7XG4gICAgICBjMS5iID0gMHhGRiAmIHcxICogYzEuYiArIHcyICogYzIuYiArIDAuNTtcbiAgICAgIGMxLmEgPSBwICogYzEuYSArICgxIC0gcCkgKiBjMi5hO1xuICAgICAgdGhpcy5yZ2IgPSBjMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW50ZXJwb2xhdGUoY29sb3IsIHQpIHtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIHRoaXMuX3JnYiA9IGludGVycG9sYXRlKHRoaXMuX3JnYiwgY29sb3IuX3JnYiwgdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yZ2IpO1xuICB9XG4gIGFscGhhKGEpIHtcbiAgICB0aGlzLl9yZ2IuYSA9IG4yYihhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhcmVyKHJhdGlvKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIHJnYi5hICo9IDEgLSByYXRpbztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBncmV5c2NhbGUoKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIGNvbnN0IHZhbCA9IHJvdW5kKHJnYi5yICogMC4zICsgcmdiLmcgKiAwLjU5ICsgcmdiLmIgKiAwLjExKTtcbiAgICByZ2IuciA9IHJnYi5nID0gcmdiLmIgPSB2YWw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb3BhcXVlcihyYXRpbykge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcbiAgICByZ2IuYSAqPSAxICsgcmF0aW87XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbmVnYXRlKCkge1xuICAgIGNvbnN0IHYgPSB0aGlzLl9yZ2I7XG4gICAgdi5yID0gMjU1IC0gdi5yO1xuICAgIHYuZyA9IDI1NSAtIHYuZztcbiAgICB2LmIgPSAyNTUgLSB2LmI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbGlnaHRlbihyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDIsIHJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkYXJrZW4ocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAyLCAtcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNhdHVyYXRlKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMSwgcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRlc2F0dXJhdGUocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAxLCAtcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvdGF0ZShkZWcpIHtcbiAgICByb3RhdGUodGhpcy5fcmdiLCBkZWcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4X2VzbShpbnB1dCkge1xuICByZXR1cm4gbmV3IENvbG9yKGlucHV0KTtcbn1cblxuZXhwb3J0IHsgQ29sb3IsIGIybiwgYjJwLCBpbmRleF9lc20gYXMgZGVmYXVsdCwgaGV4UGFyc2UsIGhleFN0cmluZywgaHNsMnJnYiwgaHNsU3RyaW5nLCBoc3YycmdiLCBodWVQYXJzZSwgaHdiMnJnYiwgbGltLCBuMmIsIG4ycCwgbmFtZVBhcnNlLCBwMmIsIHJnYjJoc2wsIHJnYlBhcnNlLCByZ2JTdHJpbmcsIHJvdGF0ZSwgcm91bmQgfTtcbiIsICIvKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVyc1xuICovXG5cbmltcG9ydCB0eXBlIHtBbnlPYmplY3R9IGZyb20gJy4uL3R5cGVzL2Jhc2ljLmpzJztcbmltcG9ydCB0eXBlIHtBY3RpdmVEYXRhUG9pbnQsIENoYXJ0RXZlbnR9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcblxuLyoqXG4gKiBBbiBlbXB0eSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSwgZm9yIG9wdGlvbmFsIGNhbGxiYWNrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHtcbiAgLyogbm9vcCAqL1xufVxuXG4vKipcbiAqIFJldHVybnMgYSB1bmlxdWUgaWQsIHNlcXVlbnRpYWxseSBnZW5lcmF0ZWQgZnJvbSBhIGdsb2JhbCB2YXJpYWJsZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHVpZCA9ICgoKSA9PiB7XG4gIGxldCBpZCA9IDA7XG4gIHJldHVybiAoKSA9PiBpZCsrO1xufSkoKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBuZWl0aGVyIG51bGwgbm9yIHVuZGVmaW5lZCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbE9yVW5kZWYodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBudWxsIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgKGluY2x1ZGluZyB0eXBlZCBhcnJheXMpLCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheTxUID0gdW5rbm93bj4odmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBUW10ge1xuICBpZiAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodHlwZS5zbGljZSgwLCA3KSA9PT0gJ1tvYmplY3QnICYmIHR5cGUuc2xpY2UoLTYpID09PSAnQXJyYXldJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QgKGV4Y2x1ZGluZyBudWxsKSwgZWxzZSByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgQW55T2JqZWN0IHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSByZXR1cm5zIGZhbHNlXG4gKiBAcGFyYW0gdmFsdWUgIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyRmluaXRlKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgbnVtYmVyIHtcbiAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBpc0Zpbml0ZSgrdmFsdWUpO1xufVxuZXhwb3J0IHtcbiAgaXNOdW1iZXJGaW5pdGUgYXMgaXNGaW5pdGUsXG59O1xuXG4vKipcbiAqIFJldHVybnMgYHZhbHVlYCBpZiBmaW5pdGUsIGVsc2UgcmV0dXJucyBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgZGVmaW5lZC5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGB2YWx1ZWAgaXMgbm90IGZpbml0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbml0ZU9yRGVmYXVsdCh2YWx1ZTogdW5rbm93biwgZGVmYXVsdFZhbHVlOiBudW1iZXIpIHtcbiAgcmV0dXJuIGlzTnVtYmVyRmluaXRlKHZhbHVlKSA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYHZhbHVlYCBpZiBkZWZpbmVkLCBlbHNlIHJldHVybnMgYGRlZmF1bHRWYWx1ZWAuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGRlZmluZWQuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBgdmFsdWVgIGlzIHVuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlT3JEZWZhdWx0PFQ+KHZhbHVlOiBUIHwgdW5kZWZpbmVkLCBkZWZhdWx0VmFsdWU6IFQpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbn1cblxuZXhwb3J0IGNvbnN0IHRvUGVyY2VudGFnZSA9ICh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nLCBkaW1lbnNpb246IG51bWJlcikgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnJScpID9cbiAgICBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMFxuICAgIDogK3ZhbHVlIC8gZGltZW5zaW9uO1xuXG5leHBvcnQgY29uc3QgdG9EaW1lbnNpb24gPSAodmFsdWU6IG51bWJlciB8IHN0cmluZywgZGltZW5zaW9uOiBudW1iZXIpID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoJyUnKSA/XG4gICAgcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBkaW1lbnNpb25cbiAgICA6ICt2YWx1ZTtcblxuLyoqXG4gKiBDYWxscyBgZm5gIHdpdGggdGhlIGdpdmVuIGBhcmdzYCBpbiB0aGUgc2NvcGUgZGVmaW5lZCBieSBgdGhpc0FyZ2AgYW5kIHJldHVybnMgdGhlXG4gKiB2YWx1ZSByZXR1cm5lZCBieSBgZm5gLiBJZiBgZm5gIGlzIG5vdCBhIGZ1bmN0aW9uLCB0aGlzIG1ldGhvZCByZXR1cm5zIHVuZGVmaW5lZC5cbiAqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHdpdGggd2hpY2ggYGZuYCBzaG91bGQgYmUgY2FsbGVkLlxuICogQHBhcmFtIFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxsYmFjazxUIGV4dGVuZHMgKHRoaXM6IFRBLCAuLi5yZXN0QXJnczogdW5rbm93bltdKSA9PiBSLCBUQSwgUj4oXG4gIGZuOiBUIHwgdW5kZWZpbmVkLFxuICBhcmdzOiB1bmtub3duW10sXG4gIHRoaXNBcmc/OiBUQVxuKTogUiB8IHVuZGVmaW5lZCB7XG4gIGlmIChmbiAmJiB0eXBlb2YgZm4uY2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vdGUoU0IpIGZvciBwZXJmb3JtYW5jZSBzYWtlLCB0aGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4gbG9vcGFibGUgdHlwZVxuICogaXMgdW5rbm93biBvciBpbiBub25lIGludGVuc2l2ZSBjb2RlIChub3QgY2FsbGVkIG9mdGVuIGFuZCBzbWFsbCBsb29wYWJsZSkuIEVsc2VcbiAqIGl0J3MgcHJlZmVyYWJsZSB0byB1c2UgYSByZWd1bGFyIGZvcigpIGxvb3AgYW5kIHNhdmUgZXh0cmEgZnVuY3Rpb24gY2FsbHMuXG4gKiBAcGFyYW0gbG9vcGFibGUgLSBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGJlIGl0ZXJhdGVkLlxuICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaXRlbS5cbiAqIEBwYXJhbSBbdGhpc0FyZ10gLSBUaGUgdmFsdWUgb2YgYHRoaXNgIHByb3ZpZGVkIGZvciB0aGUgY2FsbCB0byBgZm5gLlxuICogQHBhcmFtIFtyZXZlcnNlXSAtIElmIHRydWUsIGl0ZXJhdGVzIGJhY2t3YXJkIG9uIHRoZSBsb29wYWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2g8VCwgVEE+KFxuICBsb29wYWJsZTogUmVjb3JkPHN0cmluZywgVD4sXG4gIGZuOiAodGhpczogVEEsIHY6IFQsIGk6IHN0cmluZykgPT4gdm9pZCxcbiAgdGhpc0FyZz86IFRBLFxuICByZXZlcnNlPzogYm9vbGVhblxuKTogdm9pZDtcbmV4cG9ydCBmdW5jdGlvbiBlYWNoPFQsIFRBPihcbiAgbG9vcGFibGU6IFRbXSxcbiAgZm46ICh0aGlzOiBUQSwgdjogVCwgaTogbnVtYmVyKSA9PiB2b2lkLFxuICB0aGlzQXJnPzogVEEsXG4gIHJldmVyc2U/OiBib29sZWFuXG4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2g8VCwgVEE+KFxuICBsb29wYWJsZTogVFtdIHwgUmVjb3JkPHN0cmluZywgVD4sXG4gIGZuOiAodGhpczogVEEsIHY6IFQsIGk6IGFueSkgPT4gdm9pZCxcbiAgdGhpc0FyZz86IFRBLFxuICByZXZlcnNlPzogYm9vbGVhblxuKSB7XG4gIGxldCBpOiBudW1iZXIsIGxlbjogbnVtYmVyLCBrZXlzOiBzdHJpbmdbXTtcbiAgaWYgKGlzQXJyYXkobG9vcGFibGUpKSB7XG4gICAgbGVuID0gbG9vcGFibGUubGVuZ3RoO1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChsb29wYWJsZSkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXMobG9vcGFibGUpO1xuICAgIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtrZXlzW2ldXSwga2V5c1tpXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBgYTBgIGFuZCBgYTFgIGFycmF5cyBoYXZlIHRoZSBzYW1lIGNvbnRlbnQsIGVsc2UgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSBhMCAtIFRoZSBhcnJheSB0byBjb21wYXJlXG4gKiBAcGFyYW0gYTEgLSBUaGUgYXJyYXkgdG8gY29tcGFyZVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9lbGVtZW50c0VxdWFsKGEwOiBBY3RpdmVEYXRhUG9pbnRbXSwgYTE6IEFjdGl2ZURhdGFQb2ludFtdKSB7XG4gIGxldCBpOiBudW1iZXIsIGlsZW46IG51bWJlciwgdjA6IEFjdGl2ZURhdGFQb2ludCwgdjE6IEFjdGl2ZURhdGFQb2ludDtcblxuICBpZiAoIWEwIHx8ICFhMSB8fCBhMC5sZW5ndGggIT09IGExLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBhMC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2MCA9IGEwW2ldO1xuICAgIHYxID0gYTFbaV07XG5cbiAgICBpZiAodjAuZGF0YXNldEluZGV4ICE9PSB2MS5kYXRhc2V0SW5kZXggfHwgdjAuaW5kZXggIT09IHYxLmluZGV4KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGRlZXAgY29weSBvZiBgc291cmNlYCB3aXRob3V0IGtlZXBpbmcgcmVmZXJlbmNlcyBvbiBvYmplY3RzIGFuZCBhcnJheXMuXG4gKiBAcGFyYW0gc291cmNlIC0gVGhlIHZhbHVlIHRvIGNsb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmU8VD4oc291cmNlOiBUKTogVCB7XG4gIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcbiAgICByZXR1cm4gc291cmNlLm1hcChjbG9uZSkgYXMgdW5rbm93biBhcyBUO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIGNvbnN0IGtsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQgayA9IDA7XG5cbiAgICBmb3IgKDsgayA8IGtsZW47ICsraykge1xuICAgICAgdGFyZ2V0W2tleXNba11dID0gY2xvbmUoc291cmNlW2tleXNba11dKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgcmV0dXJuIHNvdXJjZTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXk6IHN0cmluZykge1xuICByZXR1cm4gWydfX3Byb3RvX18nLCAncHJvdG90eXBlJywgJ2NvbnN0cnVjdG9yJ10uaW5kZXhPZihrZXkpID09PSAtMTtcbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBtZXJnZXIgd2hlbiBDaGFydC5oZWxwZXJzLm1lcmdlIGlzIGNhbGxlZCB3aXRob3V0IG1lcmdlciBvcHRpb24uXG4gKiBOb3RlKFNCKTogYWxzbyB1c2VkIGJ5IG1lcmdlQ29uZmlnIGFuZCBtZXJnZVNjYWxlQ29uZmlnIGFzIGZhbGxiYWNrLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9tZXJnZXIoa2V5OiBzdHJpbmcsIHRhcmdldDogQW55T2JqZWN0LCBzb3VyY2U6IEFueU9iamVjdCwgb3B0aW9uczogQW55T2JqZWN0KSB7XG4gIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdHZhbCA9IHRhcmdldFtrZXldO1xuICBjb25zdCBzdmFsID0gc291cmNlW2tleV07XG5cbiAgaWYgKGlzT2JqZWN0KHR2YWwpICYmIGlzT2JqZWN0KHN2YWwpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgIG1lcmdlKHR2YWwsIHN2YWwsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldFtrZXldID0gY2xvbmUoc3ZhbCk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZXJnZU9wdGlvbnMge1xuICBtZXJnZXI/OiAoa2V5OiBzdHJpbmcsIHRhcmdldDogQW55T2JqZWN0LCBzb3VyY2U6IEFueU9iamVjdCwgb3B0aW9ucz86IEFueU9iamVjdCkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBkZWVwIGNvcGllcyBgc291cmNlYCBwcm9wZXJ0aWVzIGludG8gYHRhcmdldGAgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuICogSU1QT1JUQU5UOiBgdGFyZ2V0YCBpcyBub3QgY2xvbmVkIGFuZCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCBgc291cmNlYCBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGluIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSBtZXJnZWQgaW50by5cbiAqIEBwYXJhbSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gLSBNZXJnaW5nIG9wdGlvbnM6XG4gKiBAcGFyYW0gW29wdGlvbnMubWVyZ2VyXSAtIFRoZSBtZXJnZSBtZXRob2QgKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG4gKiBAcmV0dXJucyBUaGUgYHRhcmdldGAgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VD4odGFyZ2V0OiBULCBzb3VyY2U6IFtdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxULCBTMT4odGFyZ2V0OiBULCBzb3VyY2U6IFMxLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IFQgJiBTMTtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxULCBTMSwgUzI+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IFQgJiBTMSAmIFMyO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxLCBTMiwgUzM+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyLCBTM10sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUICYgUzEgJiBTMiAmIFMzO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxLCBTMiwgUzMsIFM0PihcbiAgdGFyZ2V0OiBULFxuICBzb3VyY2U6IFtTMSwgUzIsIFMzLCBTNF0sXG4gIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnNcbik6IFQgJiBTMSAmIFMyICYgUzMgJiBTNDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxUPih0YXJnZXQ6IFQsIHNvdXJjZTogQW55T2JqZWN0W10sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBBbnlPYmplY3Q7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VD4odGFyZ2V0OiBULCBzb3VyY2U6IEFueU9iamVjdFtdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogQW55T2JqZWN0IHtcbiAgY29uc3Qgc291cmNlcyA9IGlzQXJyYXkoc291cmNlKSA/IHNvdXJjZSA6IFtzb3VyY2VdO1xuICBjb25zdCBpbGVuID0gc291cmNlcy5sZW5ndGg7XG5cbiAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldCBhcyBBbnlPYmplY3Q7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgbWVyZ2VyID0gb3B0aW9ucy5tZXJnZXIgfHwgX21lcmdlcjtcbiAgbGV0IGN1cnJlbnQ6IEFueU9iamVjdDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIGN1cnJlbnQgPSBzb3VyY2VzW2ldO1xuICAgIGlmICghaXNPYmplY3QoY3VycmVudCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjdXJyZW50KTtcbiAgICBmb3IgKGxldCBrID0gMCwga2xlbiA9IGtleXMubGVuZ3RoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICBtZXJnZXIoa2V5c1trXSwgdGFyZ2V0LCBjdXJyZW50LCBvcHRpb25zIGFzIEFueU9iamVjdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBkZWVwIGNvcGllcyBgc291cmNlYCBwcm9wZXJ0aWVzIGludG8gYHRhcmdldGAgKm9ubHkqIGlmIG5vdCBkZWZpbmVkIGluIHRhcmdldC5cbiAqIElNUE9SVEFOVDogYHRhcmdldGAgaXMgbm90IGNsb25lZCBhbmQgd2lsbCBiZSB1cGRhdGVkIHdpdGggYHNvdXJjZWAgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXG4gKiBAcGFyYW0gc291cmNlIC0gT2JqZWN0KHMpIHRvIG1lcmdlIGludG8gYHRhcmdldGAuXG4gKiBAcmV0dXJucyBUaGUgYHRhcmdldGAgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxUPih0YXJnZXQ6IFQsIHNvdXJjZTogW10pOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzE+KHRhcmdldDogVCwgc291cmNlOiBTMSk6IFQgJiBTMTtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQsIFMxPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxXSk6IFQgJiBTMTtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQsIFMxLCBTMj4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzJdKTogVCAmIFMxICYgUzI7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxULCBTMSwgUzIsIFMzPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxLCBTMiwgUzNdKTogVCAmIFMxICYgUzIgJiBTMztcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQsIFMxLCBTMiwgUzMsIFM0Pih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxLCBTMiwgUzMsIFM0XSk6IFQgJiBTMSAmIFMyICYgUzMgJiBTNDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQ+KHRhcmdldDogVCwgc291cmNlOiBBbnlPYmplY3RbXSk6IEFueU9iamVjdDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQ+KHRhcmdldDogVCwgc291cmNlOiBBbnlPYmplY3RbXSk6IEFueU9iamVjdCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgcmV0dXJuIG1lcmdlPFQ+KHRhcmdldCwgc291cmNlLCB7bWVyZ2VyOiBfbWVyZ2VySWZ9KTtcbn1cblxuLyoqXG4gKiBNZXJnZXMgc291cmNlW2tleV0gaW4gdGFyZ2V0W2tleV0gb25seSBpZiB0YXJnZXRba2V5XSBpcyB1bmRlZmluZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX21lcmdlcklmKGtleTogc3RyaW5nLCB0YXJnZXQ6IEFueU9iamVjdCwgc291cmNlOiBBbnlPYmplY3QpIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB0dmFsID0gdGFyZ2V0W2tleV07XG4gIGNvbnN0IHN2YWwgPSBzb3VyY2Vba2V5XTtcblxuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICBtZXJnZUlmKHR2YWwsIHN2YWwpO1xuICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzdmFsKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGVwcmVjYXRlZChzY29wZTogc3RyaW5nLCB2YWx1ZTogdW5rbm93biwgcHJldmlvdXM6IHN0cmluZywgY3VycmVudDogc3RyaW5nKSB7XG4gIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKHNjb3BlICsgJzogXCInICsgcHJldmlvdXMgK1xuICAgICAgJ1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCInICsgY3VycmVudCArICdcIiBpbnN0ZWFkJyk7XG4gIH1cbn1cblxuLy8gcmVzb2x2ZU9iamVjdEtleSByZXNvbHZlciBjYWNoZVxuY29uc3Qga2V5UmVzb2x2ZXJzID0ge1xuICAvLyBDaGFydC5oZWxwZXJzLmNvcmUgcmVzb2x2ZU9iamVjdEtleSBzaG91bGQgcmVzb2x2ZSBlbXB0eSBrZXkgdG8gcm9vdCBvYmplY3RcbiAgJyc6IHYgPT4gdixcbiAgLy8gZGVmYXVsdCByZXNvbHZlcnNcbiAgeDogbyA9PiBvLngsXG4gIHk6IG8gPT4gby55XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc3BsaXRLZXkoa2V5OiBzdHJpbmcpIHtcbiAgY29uc3QgcGFydHMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgY29uc3Qga2V5czogc3RyaW5nW10gPSBbXTtcbiAgbGV0IHRtcCA9ICcnO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICB0bXAgKz0gcGFydDtcbiAgICBpZiAodG1wLmVuZHNXaXRoKCdcXFxcJykpIHtcbiAgICAgIHRtcCA9IHRtcC5zbGljZSgwLCAtMSkgKyAnLic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMucHVzaCh0bXApO1xuICAgICAgdG1wID0gJyc7XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfZ2V0S2V5UmVzb2x2ZXIoa2V5OiBzdHJpbmcpIHtcbiAgY29uc3Qga2V5cyA9IF9zcGxpdEtleShrZXkpO1xuICByZXR1cm4gb2JqID0+IHtcbiAgICBmb3IgKGNvbnN0IGsgb2Yga2V5cykge1xuICAgICAgaWYgKGsgPT09ICcnKSB7XG4gICAgICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5OlxuICAgICAgICAvLyBDaGFydC5oZWxwZXJzLmNvcmUgcmVzb2x2ZU9iamVjdEtleSBzaG91bGQgYnJlYWsgYXQgZW1wdHkga2V5XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgb2JqID0gb2JqICYmIG9ialtrXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVPYmplY3RLZXkob2JqOiBBbnlPYmplY3QsIGtleTogc3RyaW5nKTogYW55IHtcbiAgY29uc3QgcmVzb2x2ZXIgPSBrZXlSZXNvbHZlcnNba2V5XSB8fCAoa2V5UmVzb2x2ZXJzW2tleV0gPSBfZ2V0S2V5UmVzb2x2ZXIoa2V5KSk7XG4gIHJldHVybiByZXNvbHZlcihvYmopO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY2FwaXRhbGl6ZShzdHI6IHN0cmluZykge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxuXG5cbmV4cG9ydCBjb25zdCBkZWZpbmVkID0gKHZhbHVlOiB1bmtub3duKSA9PiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuXG5leHBvcnQgY29uc3QgaXNGdW5jdGlvbiA9ICh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55ID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcblxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMxMTI4ODU1L2NvbXBhcmluZy1lY21hNi1zZXRzLWZvci1lcXVhbGl0eSMzMTEyOTM4NFxuZXhwb3J0IGNvbnN0IHNldHNFcXVhbCA9IDxUPihhOiBTZXQ8VD4sIGI6IFNldDxUPikgPT4ge1xuICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgYSkge1xuICAgIGlmICghYi5oYXMoaXRlbSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGUgLSBUaGUgZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfaXNDbGlja0V2ZW50KGU6IENoYXJ0RXZlbnQpIHtcbiAgcmV0dXJuIGUudHlwZSA9PT0gJ21vdXNldXAnIHx8IGUudHlwZSA9PT0gJ2NsaWNrJyB8fCBlLnR5cGUgPT09ICdjb250ZXh0bWVudSc7XG59XG4iLCAiaW1wb3J0IHR5cGUge1BvaW50fSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuaW1wb3J0IHtpc0Zpbml0ZSBhcyBpc0Zpbml0ZU51bWJlcn0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIEBhbGlhcyBDaGFydC5oZWxwZXJzLm1hdGhcbiAqIEBuYW1lc3BhY2VcbiAqL1xuXG5leHBvcnQgY29uc3QgUEkgPSBNYXRoLlBJO1xuZXhwb3J0IGNvbnN0IFRBVSA9IDIgKiBQSTtcbmV4cG9ydCBjb25zdCBQSVRBVSA9IFRBVSArIFBJO1xuZXhwb3J0IGNvbnN0IElORklOSVRZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuZXhwb3J0IGNvbnN0IFJBRF9QRVJfREVHID0gUEkgLyAxODA7XG5leHBvcnQgY29uc3QgSEFMRl9QSSA9IFBJIC8gMjtcbmV4cG9ydCBjb25zdCBRVUFSVEVSX1BJID0gUEkgLyA0O1xuZXhwb3J0IGNvbnN0IFRXT19USElSRFNfUEkgPSBQSSAqIDIgLyAzO1xuXG5leHBvcnQgY29uc3QgbG9nMTAgPSBNYXRoLmxvZzEwO1xuZXhwb3J0IGNvbnN0IHNpZ24gPSBNYXRoLnNpZ247XG5cbmV4cG9ydCBmdW5jdGlvbiBhbG1vc3RFcXVhbHMoeDogbnVtYmVyLCB5OiBudW1iZXIsIGVwc2lsb246IG51bWJlcikge1xuICByZXR1cm4gTWF0aC5hYnMoeCAtIHkpIDwgZXBzaWxvbjtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgbmljZSBudW1iZXIgYWxnb3JpdGhtIHVzZWQgaW4gZGV0ZXJtaW5pbmcgd2hlcmUgYXhpcyBsYWJlbHMgd2lsbCBnb1xuICovXG5leHBvcnQgZnVuY3Rpb24gbmljZU51bShyYW5nZTogbnVtYmVyKSB7XG4gIGNvbnN0IHJvdW5kZWRSYW5nZSA9IE1hdGgucm91bmQocmFuZ2UpO1xuICByYW5nZSA9IGFsbW9zdEVxdWFscyhyYW5nZSwgcm91bmRlZFJhbmdlLCByYW5nZSAvIDEwMDApID8gcm91bmRlZFJhbmdlIDogcmFuZ2U7XG4gIGNvbnN0IG5pY2VSYW5nZSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHJhbmdlKSkpO1xuICBjb25zdCBmcmFjdGlvbiA9IHJhbmdlIC8gbmljZVJhbmdlO1xuICBjb25zdCBuaWNlRnJhY3Rpb24gPSBmcmFjdGlvbiA8PSAxID8gMSA6IGZyYWN0aW9uIDw9IDIgPyAyIDogZnJhY3Rpb24gPD0gNSA/IDUgOiAxMDtcbiAgcmV0dXJuIG5pY2VGcmFjdGlvbiAqIG5pY2VSYW5nZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGZhY3RvcnMgc29ydGVkIGZyb20gMSB0byBzcXJ0KHZhbHVlKVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9mYWN0b3JpemUodmFsdWU6IG51bWJlcikge1xuICBjb25zdCByZXN1bHQ6IG51bWJlcltdID0gW107XG4gIGNvbnN0IHNxcnQgPSBNYXRoLnNxcnQodmFsdWUpO1xuICBsZXQgaTogbnVtYmVyO1xuXG4gIGZvciAoaSA9IDE7IGkgPCBzcXJ0OyBpKyspIHtcbiAgICBpZiAodmFsdWUgJSBpID09PSAwKSB7XG4gICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlIC8gaSk7XG4gICAgfVxuICB9XG4gIGlmIChzcXJ0ID09PSAoc3FydCB8IDApKSB7IC8vIGlmIHZhbHVlIGlzIGEgc3F1YXJlIG51bWJlclxuICAgIHJlc3VsdC5wdXNoKHNxcnQpO1xuICB9XG5cbiAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IGEgLSBiKS5wb3AoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKG46IHVua25vd24pOiBuIGlzIG51bWJlciB7XG4gIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuIGFzIHN0cmluZykpICYmIGlzRmluaXRlKG4gYXMgbnVtYmVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFsbW9zdFdob2xlKHg6IG51bWJlciwgZXBzaWxvbjogbnVtYmVyKSB7XG4gIGNvbnN0IHJvdW5kZWQgPSBNYXRoLnJvdW5kKHgpO1xuICByZXR1cm4gKChyb3VuZGVkIC0gZXBzaWxvbikgPD0geCkgJiYgKChyb3VuZGVkICsgZXBzaWxvbikgPj0geCk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zZXRNaW5BbmRNYXhCeUtleShcbiAgYXJyYXk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5bXSxcbiAgdGFyZ2V0OiB7IG1pbjogbnVtYmVyLCBtYXg6IG51bWJlciB9LFxuICBwcm9wZXJ0eTogc3RyaW5nXG4pIHtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCB2YWx1ZTogbnVtYmVyO1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICB2YWx1ZSA9IGFycmF5W2ldW3Byb3BlcnR5XTtcbiAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgdGFyZ2V0Lm1pbiA9IE1hdGgubWluKHRhcmdldC5taW4sIHZhbHVlKTtcbiAgICAgIHRhcmdldC5tYXggPSBNYXRoLm1heCh0YXJnZXQubWF4LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1JhZGlhbnMoZGVncmVlczogbnVtYmVyKSB7XG4gIHJldHVybiBkZWdyZWVzICogKFBJIC8gMTgwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvRGVncmVlcyhyYWRpYW5zOiBudW1iZXIpIHtcbiAgcmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gUEkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICogaS5lLiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCwgb2YgdGhlIHZhbHVlIG9mIHRoaXMgTnVtYmVyLlxuICogQHBhcmFtIHggLSBBIG51bWJlci5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2RlY2ltYWxQbGFjZXMoeDogbnVtYmVyKSB7XG4gIGlmICghaXNGaW5pdGVOdW1iZXIoeCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGUgPSAxO1xuICBsZXQgcCA9IDA7XG4gIHdoaWxlIChNYXRoLnJvdW5kKHggKiBlKSAvIGUgIT09IHgpIHtcbiAgICBlICo9IDEwO1xuICAgIHArKztcbiAgfVxuICByZXR1cm4gcDtcbn1cblxuLy8gR2V0cyB0aGUgYW5nbGUgZnJvbSB2ZXJ0aWNhbCB1cHJpZ2h0IHRvIHRoZSBwb2ludCBhYm91dCBhIGNlbnRyZS5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbmdsZUZyb21Qb2ludChcbiAgY2VudHJlUG9pbnQ6IFBvaW50LFxuICBhbmdsZVBvaW50OiBQb2ludFxuKSB7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbVhDZW50ZXIgPSBhbmdsZVBvaW50LnggLSBjZW50cmVQb2ludC54O1xuICBjb25zdCBkaXN0YW5jZUZyb21ZQ2VudGVyID0gYW5nbGVQb2ludC55IC0gY2VudHJlUG9pbnQueTtcbiAgY29uc3QgcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyID0gTWF0aC5zcXJ0KGRpc3RhbmNlRnJvbVhDZW50ZXIgKiBkaXN0YW5jZUZyb21YQ2VudGVyICsgZGlzdGFuY2VGcm9tWUNlbnRlciAqIGRpc3RhbmNlRnJvbVlDZW50ZXIpO1xuXG4gIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoZGlzdGFuY2VGcm9tWUNlbnRlciwgZGlzdGFuY2VGcm9tWENlbnRlcik7XG5cbiAgaWYgKGFuZ2xlIDwgKC0wLjUgKiBQSSkpIHtcbiAgICBhbmdsZSArPSBUQVU7IC8vIG1ha2Ugc3VyZSB0aGUgcmV0dXJuZWQgYW5nbGUgaXMgaW4gdGhlIHJhbmdlIG9mICgtUEkvMiwgM1BJLzJdXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFuZ2xlLFxuICAgIGRpc3RhbmNlOiByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXJcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlQmV0d2VlblBvaW50cyhwdDE6IFBvaW50LCBwdDI6IFBvaW50KSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocHQyLnggLSBwdDEueCwgMikgKyBNYXRoLnBvdyhwdDIueSAtIHB0MS55LCAyKSk7XG59XG5cbi8qKlxuICogU2hvcnRlc3QgZGlzdGFuY2UgYmV0d2VlbiBhbmdsZXMsIGluIGVpdGhlciBkaXJlY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FuZ2xlRGlmZihhOiBudW1iZXIsIGI6IG51bWJlcikge1xuICByZXR1cm4gKGEgLSBiICsgUElUQVUpICUgVEFVIC0gUEk7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFuZ2xlIHRvIGJlIGJldHdlZW4gMCBhbmQgMipQSVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9ub3JtYWxpemVBbmdsZShhOiBudW1iZXIpIHtcbiAgcmV0dXJuIChhICUgVEFVICsgVEFVKSAlIFRBVTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FuZ2xlQmV0d2VlbihhbmdsZTogbnVtYmVyLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgc2FtZUFuZ2xlSXNGdWxsQ2lyY2xlPzogYm9vbGVhbikge1xuICBjb25zdCBhID0gX25vcm1hbGl6ZUFuZ2xlKGFuZ2xlKTtcbiAgY29uc3QgcyA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gIGNvbnN0IGUgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcbiAgY29uc3QgYW5nbGVUb1N0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHMgLSBhKTtcbiAgY29uc3QgYW5nbGVUb0VuZCA9IF9ub3JtYWxpemVBbmdsZShlIC0gYSk7XG4gIGNvbnN0IHN0YXJ0VG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gcyk7XG4gIGNvbnN0IGVuZFRvQW5nbGUgPSBfbm9ybWFsaXplQW5nbGUoYSAtIGUpO1xuICByZXR1cm4gYSA9PT0gcyB8fCBhID09PSBlIHx8IChzYW1lQW5nbGVJc0Z1bGxDaXJjbGUgJiYgcyA9PT0gZSlcbiAgICB8fCAoYW5nbGVUb1N0YXJ0ID4gYW5nbGVUb0VuZCAmJiBzdGFydFRvQW5nbGUgPCBlbmRUb0FuZ2xlKTtcbn1cblxuLyoqXG4gKiBMaW1pdCBgdmFsdWVgIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBtaW5cbiAqIEBwYXJhbSBtYXhcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbGltaXRWYWx1ZSh2YWx1ZTogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWx1ZSkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pbnQxNlJhbmdlKHZhbHVlOiBudW1iZXIpIHtcbiAgcmV0dXJuIF9saW1pdFZhbHVlKHZhbHVlLCAtMzI3NjgsIDMyNzY3KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBzdGFydFxuICogQHBhcmFtIGVuZFxuICogQHBhcmFtIFtlcHNpbG9uXVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc0JldHdlZW4odmFsdWU6IG51bWJlciwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIGVwc2lsb24gPSAxZS02KSB7XG4gIHJldHVybiB2YWx1ZSA+PSBNYXRoLm1pbihzdGFydCwgZW5kKSAtIGVwc2lsb24gJiYgdmFsdWUgPD0gTWF0aC5tYXgoc3RhcnQsIGVuZCkgKyBlcHNpbG9uO1xufVxuIiwgImltcG9ydCB7X2NhcGl0YWxpemV9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBCaW5hcnkgc2VhcmNoXG4gKiBAcGFyYW0gdGFibGUgLSB0aGUgdGFibGUgc2VhcmNoLiBtdXN0IGJlIHNvcnRlZCFcbiAqIEBwYXJhbSB2YWx1ZSAtIHZhbHVlIHRvIGZpbmRcbiAqIEBwYXJhbSBjbXBcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbG9va3VwKFxuICB0YWJsZTogbnVtYmVyW10sXG4gIHZhbHVlOiBudW1iZXIsXG4gIGNtcD86ICh2YWx1ZTogbnVtYmVyKSA9PiBib29sZWFuXG4pOiB7bG86IG51bWJlciwgaGk6IG51bWJlcn07XG5leHBvcnQgZnVuY3Rpb24gX2xvb2t1cDxUPihcbiAgdGFibGU6IFRbXSxcbiAgdmFsdWU6IG51bWJlcixcbiAgY21wOiAodmFsdWU6IG51bWJlcikgPT4gYm9vbGVhblxuKToge2xvOiBudW1iZXIsIGhpOiBudW1iZXJ9O1xuZXhwb3J0IGZ1bmN0aW9uIF9sb29rdXAoXG4gIHRhYmxlOiB1bmtub3duW10sXG4gIHZhbHVlOiBudW1iZXIsXG4gIGNtcD86ICh2YWx1ZTogbnVtYmVyKSA9PiBib29sZWFuXG4pIHtcbiAgY21wID0gY21wIHx8ICgoaW5kZXgpID0+IHRhYmxlW2luZGV4XSA8IHZhbHVlKTtcbiAgbGV0IGhpID0gdGFibGUubGVuZ3RoIC0gMTtcbiAgbGV0IGxvID0gMDtcbiAgbGV0IG1pZDogbnVtYmVyO1xuXG4gIHdoaWxlIChoaSAtIGxvID4gMSkge1xuICAgIG1pZCA9IChsbyArIGhpKSA+PiAxO1xuICAgIGlmIChjbXAobWlkKSkge1xuICAgICAgbG8gPSBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpID0gbWlkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7bG8sIGhpfTtcbn1cblxuLyoqXG4gKiBCaW5hcnkgc2VhcmNoXG4gKiBAcGFyYW0gdGFibGUgLSB0aGUgdGFibGUgc2VhcmNoLiBtdXN0IGJlIHNvcnRlZCFcbiAqIEBwYXJhbSBrZXkgLSBwcm9wZXJ0eSBuYW1lIGZvciB0aGUgdmFsdWUgaW4gZWFjaCBlbnRyeVxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gZmluZFxuICogQHBhcmFtIGxhc3QgLSBsb29rdXAgbGFzdCBpbmRleFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF9sb29rdXBCeUtleSA9IChcbiAgdGFibGU6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5bXSxcbiAga2V5OiBzdHJpbmcsXG4gIHZhbHVlOiBudW1iZXIsXG4gIGxhc3Q/OiBib29sZWFuXG4pID0+XG4gIF9sb29rdXAodGFibGUsIHZhbHVlLCBsYXN0XG4gICAgPyBpbmRleCA9PiB7XG4gICAgICBjb25zdCB0aSA9IHRhYmxlW2luZGV4XVtrZXldO1xuICAgICAgcmV0dXJuIHRpIDwgdmFsdWUgfHwgdGkgPT09IHZhbHVlICYmIHRhYmxlW2luZGV4ICsgMV1ba2V5XSA9PT0gdmFsdWU7XG4gICAgfVxuICAgIDogaW5kZXggPT4gdGFibGVbaW5kZXhdW2tleV0gPCB2YWx1ZSk7XG5cbi8qKlxuICogUmV2ZXJzZSBiaW5hcnkgc2VhcmNoXG4gKiBAcGFyYW0gdGFibGUgLSB0aGUgdGFibGUgc2VhcmNoLiBtdXN0IGJlIHNvcnRlZCFcbiAqIEBwYXJhbSBrZXkgLSBwcm9wZXJ0eSBuYW1lIGZvciB0aGUgdmFsdWUgaW4gZWFjaCBlbnRyeVxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gZmluZFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF9ybG9va3VwQnlLZXkgPSAoXG4gIHRhYmxlOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+W10sXG4gIGtleTogc3RyaW5nLFxuICB2YWx1ZTogbnVtYmVyXG4pID0+XG4gIF9sb29rdXAodGFibGUsIHZhbHVlLCBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA+PSB2YWx1ZSk7XG5cbi8qKlxuICogUmV0dXJuIHN1YnNldCBvZiBgdmFsdWVzYCBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YCBpbmNsdXNpdmUuXG4gKiBWYWx1ZXMgYXJlIGFzc3VtZWQgdG8gYmUgaW4gc29ydGVkIG9yZGVyLlxuICogQHBhcmFtIHZhbHVlcyAtIHNvcnRlZCBhcnJheSBvZiB2YWx1ZXNcbiAqIEBwYXJhbSBtaW4gLSBtaW4gdmFsdWVcbiAqIEBwYXJhbSBtYXggLSBtYXggdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9maWx0ZXJCZXR3ZWVuKHZhbHVlczogbnVtYmVyW10sIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gdmFsdWVzLmxlbmd0aDtcblxuICB3aGlsZSAoc3RhcnQgPCBlbmQgJiYgdmFsdWVzW3N0YXJ0XSA8IG1pbikge1xuICAgIHN0YXJ0Kys7XG4gIH1cbiAgd2hpbGUgKGVuZCA+IHN0YXJ0ICYmIHZhbHVlc1tlbmQgLSAxXSA+IG1heCkge1xuICAgIGVuZC0tO1xuICB9XG5cbiAgcmV0dXJuIHN0YXJ0ID4gMCB8fCBlbmQgPCB2YWx1ZXMubGVuZ3RoXG4gICAgPyB2YWx1ZXMuc2xpY2Uoc3RhcnQsIGVuZClcbiAgICA6IHZhbHVlcztcbn1cblxuY29uc3QgYXJyYXlFdmVudHMgPSBbJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsICd1bnNoaWZ0J10gYXMgY29uc3Q7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXJyYXlMaXN0ZW5lcjxUPiB7XG4gIF9vbkRhdGFQdXNoPyguLi5pdGVtOiBUW10pOiB2b2lkO1xuICBfb25EYXRhUG9wPygpOiB2b2lkO1xuICBfb25EYXRhU2hpZnQ/KCk6IHZvaWQ7XG4gIF9vbkRhdGFTcGxpY2U/KGluZGV4OiBudW1iZXIsIGRlbGV0ZUNvdW50OiBudW1iZXIsIC4uLml0ZW1zOiBUW10pOiB2b2lkO1xuICBfb25EYXRhVW5zaGlmdD8oLi4uaXRlbTogVFtdKTogdm9pZDtcbn1cblxuLyoqXG4gKiBIb29rcyB0aGUgYXJyYXkgbWV0aG9kcyB0aGF0IGFkZCBvciByZW1vdmUgdmFsdWVzICgncHVzaCcsIHBvcCcsICdzaGlmdCcsICdzcGxpY2UnLFxuICogJ3Vuc2hpZnQnKSBhbmQgbm90aWZ5IHRoZSBsaXN0ZW5lciBBRlRFUiB0aGUgYXJyYXkgaGFzIGJlZW4gYWx0ZXJlZC4gTGlzdGVuZXJzIGFyZVxuICogY2FsbGVkIG9uIHRoZSAnX29uRGF0YSonIGNhbGxiYWNrcyAoZS5nLiBfb25EYXRhUHVzaCwgZXRjLikgd2l0aCBzYW1lIGFyZ3VtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzPFQ+KGFycmF5OiBUW10sIGxpc3RlbmVyOiBBcnJheUxpc3RlbmVyPFQ+KTogdm9pZDtcbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgaWYgKGFycmF5Ll9jaGFydGpzKSB7XG4gICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwgJ19jaGFydGpzJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZToge1xuICAgICAgbGlzdGVuZXJzOiBbbGlzdGVuZXJdXG4gICAgfVxuICB9KTtcblxuICBhcnJheUV2ZW50cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCBtZXRob2QgPSAnX29uRGF0YScgKyBfY2FwaXRhbGl6ZShrZXkpO1xuICAgIGNvbnN0IGJhc2UgPSBhcnJheVtrZXldO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWUoLi4uYXJncykge1xuICAgICAgICBjb25zdCByZXMgPSBiYXNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgICAgIGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5mb3JFYWNoKChvYmplY3QpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdFttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvYmplY3RbbWV0aG9kXSguLi5hcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgZ2l2ZW4gYXJyYXkgZXZlbnQgbGlzdGVuZXIgYW5kIGNsZWFudXAgZXh0cmEgYXR0YWNoZWQgcHJvcGVydGllcyAoc3VjaCBhc1xuICogdGhlIF9jaGFydGpzIHN0dWIgYW5kIG92ZXJyaWRkZW4gbWV0aG9kcykgaWYgYXJyYXkgZG9lc24ndCBoYXZlIGFueSBtb3JlIGxpc3RlbmVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubGlzdGVuQXJyYXlFdmVudHM8VD4oYXJyYXk6IFRbXSwgbGlzdGVuZXI6IEFycmF5TGlzdGVuZXI8VD4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIHVubGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG4gIGNvbnN0IHN0dWIgPSBhcnJheS5fY2hhcnRqcztcbiAgaWYgKCFzdHViKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbGlzdGVuZXJzID0gc3R1Yi5saXN0ZW5lcnM7XG4gIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cblxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBhcnJheUV2ZW50cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBkZWxldGUgYXJyYXlba2V5XTtcbiAgfSk7XG5cbiAgZGVsZXRlIGFycmF5Ll9jaGFydGpzO1xufVxuXG4vKipcbiAqIEBwYXJhbSBpdGVtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gX2FycmF5VW5pcXVlPFQ+KGl0ZW1zOiBUW10pIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxUPihpdGVtcyk7XG5cbiAgaWYgKHNldC5zaXplID09PSBpdGVtcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICByZXR1cm4gQXJyYXkuZnJvbShzZXQpO1xufVxuIiwgImltcG9ydCB0eXBlIHtDaGFydE1ldGEsIFBvaW50RWxlbWVudH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG5pbXBvcnQge19saW1pdFZhbHVlfSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19sb29rdXBCeUtleX0gZnJvbSAnLi9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZm9udFN0cmluZyhwaXhlbFNpemU6IG51bWJlciwgZm9udFN0eWxlOiBzdHJpbmcsIGZvbnRGYW1pbHk6IHN0cmluZykge1xuICByZXR1cm4gZm9udFN0eWxlICsgJyAnICsgcGl4ZWxTaXplICsgJ3B4ICcgKyBmb250RmFtaWx5O1xufVxuXG4vKipcbiogUmVxdWVzdCBhbmltYXRpb24gcG9seWZpbGxcbiovXG5leHBvcnQgY29uc3QgcmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xufSgpKTtcblxuLyoqXG4gKiBUaHJvdHRsZXMgY2FsbGluZyBgZm5gIG9uY2UgcGVyIGFuaW1hdGlvbiBmcmFtZVxuICogTGF0ZXN0IGFyZ3VtZW50cyBhcmUgdXNlZCBvbiB0aGUgYWN0dWFsIGNhbGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlZDxUQXJncyBleHRlbmRzIEFycmF5PGFueT4+KFxuICBmbjogKC4uLmFyZ3M6IFRBcmdzKSA9PiB2b2lkLFxuICB0aGlzQXJnOiBhbnksXG4pIHtcbiAgbGV0IGFyZ3NUb1VzZSA9IFtdIGFzIFRBcmdzO1xuICBsZXQgdGlja2luZyA9IGZhbHNlO1xuXG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzOiBUQXJncykge1xuICAgIC8vIFNhdmUgdGhlIGFyZ3MgZm9yIHVzZSBsYXRlclxuICAgIGFyZ3NUb1VzZSA9IGFyZ3M7XG4gICAgaWYgKCF0aWNraW5nKSB7XG4gICAgICB0aWNraW5nID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csICgpID0+IHtcbiAgICAgICAgdGlja2luZyA9IGZhbHNlO1xuICAgICAgICBmbi5hcHBseSh0aGlzQXJnLCBhcmdzVG9Vc2UpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIERlYm91bmNlcyBjYWxsaW5nIGBmbmAgZm9yIGBkZWxheWAgbXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlPFRBcmdzIGV4dGVuZHMgQXJyYXk8YW55Pj4oZm46ICguLi5hcmdzOiBUQXJncykgPT4gdm9pZCwgZGVsYXk6IG51bWJlcikge1xuICBsZXQgdGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3M6IFRBcmdzKSB7XG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmbiwgZGVsYXksIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbGF5O1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzICdzdGFydCcgdG8gJ2xlZnQnLCAnZW5kJyB0byAncmlnaHQnIGFuZCBvdGhlcnMgdG8gJ2NlbnRlcidcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBfdG9MZWZ0UmlnaHRDZW50ZXIgPSAoYWxpZ246ICdzdGFydCcgfCAnZW5kJyB8ICdjZW50ZXInKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/ICdsZWZ0JyA6IGFsaWduID09PSAnZW5kJyA/ICdyaWdodCcgOiAnY2VudGVyJztcblxuLyoqXG4gKiBSZXR1cm5zIGBzdGFydGAsIGBlbmRgIG9yIGAoc3RhcnQgKyBlbmQpIC8gMmAgZGVwZW5kaW5nIG9uIGBhbGlnbmAuIERlZmF1bHRzIHRvIGBjZW50ZXJgXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX2FsaWduU3RhcnRFbmQgPSAoYWxpZ246ICdzdGFydCcgfCAnZW5kJyB8ICdjZW50ZXInLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcikgPT4gYWxpZ24gPT09ICdzdGFydCcgPyBzdGFydCA6IGFsaWduID09PSAnZW5kJyA/IGVuZCA6IChzdGFydCArIGVuZCkgLyAyO1xuXG4vKipcbiAqIFJldHVybnMgYGxlZnRgLCBgcmlnaHRgIG9yIGAobGVmdCArIHJpZ2h0KSAvIDJgIGRlcGVuZGluZyBvbiBgYWxpZ25gLiBEZWZhdWx0cyB0byBgbGVmdGBcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBfdGV4dFggPSAoYWxpZ246ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJywgbGVmdDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBydGw6IGJvb2xlYW4pID0+IHtcbiAgY29uc3QgY2hlY2sgPSBydGwgPyAnbGVmdCcgOiAncmlnaHQnO1xuICByZXR1cm4gYWxpZ24gPT09IGNoZWNrID8gcmlnaHQgOiBhbGlnbiA9PT0gJ2NlbnRlcicgPyAobGVmdCArIHJpZ2h0KSAvIDIgOiBsZWZ0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gc3RhcnQgYW5kIGNvdW50IG9mIHZpc2libGUgcG9pbnRzLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGE6IENoYXJ0TWV0YTwnbGluZScgfCAnc2NhdHRlcic+LCBwb2ludHM6IFBvaW50RWxlbWVudFtdLCBhbmltYXRpb25zRGlzYWJsZWQ6IGJvb2xlYW4pIHtcbiAgY29uc3QgcG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGNvdW50ID0gcG9pbnRDb3VudDtcblxuICBpZiAobWV0YS5fc29ydGVkKSB7XG4gICAgY29uc3Qge2lTY2FsZSwgX3BhcnNlZH0gPSBtZXRhO1xuICAgIGNvbnN0IGF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcblxuICAgIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgICBzdGFydCA9IF9saW1pdFZhbHVlKE1hdGgubWluKFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gdHlwZSBfcGFyc2VkXG4gICAgICAgIF9sb29rdXBCeUtleShfcGFyc2VkLCBheGlzLCBtaW4pLmxvLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gZml4IHR5cGVzIG9uIF9sb29rdXBCeUtleVxuICAgICAgICBhbmltYXRpb25zRGlzYWJsZWQgPyBwb2ludENvdW50IDogX2xvb2t1cEJ5S2V5KHBvaW50cywgYXhpcywgaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUobWluKSkubG8pLFxuICAgICAgMCwgcG9pbnRDb3VudCAtIDEpO1xuICAgIH1cbiAgICBpZiAobWF4RGVmaW5lZCkge1xuICAgICAgY291bnQgPSBfbGltaXRWYWx1ZShNYXRoLm1heChcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBOZWVkIHRvIHR5cGUgX3BhcnNlZFxuICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgaVNjYWxlLmF4aXMsIG1heCwgdHJ1ZSkuaGkgKyAxLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gZml4IHR5cGVzIG9uIF9sb29rdXBCeUtleVxuICAgICAgICBhbmltYXRpb25zRGlzYWJsZWQgPyAwIDogX2xvb2t1cEJ5S2V5KHBvaW50cywgYXhpcywgaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUobWF4KSwgdHJ1ZSkuaGkgKyAxKSxcbiAgICAgIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IHBvaW50Q291bnQgLSBzdGFydDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge3N0YXJ0LCBjb3VudH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBzY2FsZSByYW5nZXMgaGF2ZSBjaGFuZ2VkLlxuICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGEuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpIHtcbiAgY29uc3Qge3hTY2FsZSwgeVNjYWxlLCBfc2NhbGVSYW5nZXN9ID0gbWV0YTtcbiAgY29uc3QgbmV3UmFuZ2VzID0ge1xuICAgIHhtaW46IHhTY2FsZS5taW4sXG4gICAgeG1heDogeFNjYWxlLm1heCxcbiAgICB5bWluOiB5U2NhbGUubWluLFxuICAgIHltYXg6IHlTY2FsZS5tYXhcbiAgfTtcbiAgaWYgKCFfc2NhbGVSYW5nZXMpIHtcbiAgICBtZXRhLl9zY2FsZVJhbmdlcyA9IG5ld1JhbmdlcztcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBjaGFuZ2VkID0gX3NjYWxlUmFuZ2VzLnhtaW4gIT09IHhTY2FsZS5taW5cblx0XHR8fCBfc2NhbGVSYW5nZXMueG1heCAhPT0geFNjYWxlLm1heFxuXHRcdHx8IF9zY2FsZVJhbmdlcy55bWluICE9PSB5U2NhbGUubWluXG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnltYXggIT09IHlTY2FsZS5tYXg7XG5cbiAgT2JqZWN0LmFzc2lnbihfc2NhbGVSYW5nZXMsIG5ld1Jhbmdlcyk7XG4gIHJldHVybiBjaGFuZ2VkO1xufVxuIiwgImltcG9ydCB7UEksIFRBVSwgSEFMRl9QSX0gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuXG5jb25zdCBhdEVkZ2UgPSAodDogbnVtYmVyKSA9PiB0ID09PSAwIHx8IHQgPT09IDE7XG5jb25zdCBlbGFzdGljSW4gPSAodDogbnVtYmVyLCBzOiBudW1iZXIsIHA6IG51bWJlcikgPT4gLShNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiBUQVUgLyBwKSk7XG5jb25zdCBlbGFzdGljT3V0ID0gKHQ6IG51bWJlciwgczogbnVtYmVyLCBwOiBudW1iZXIpID0+IE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApICsgMTtcblxuLyoqXG4gKiBFYXNpbmcgZnVuY3Rpb25zIGFkYXB0ZWQgZnJvbSBSb2JlcnQgUGVubmVyJ3MgZWFzaW5nIGVxdWF0aW9ucy5cbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5lYXNpbmcuZWZmZWN0c1xuICogQHNlZSBodHRwOi8vd3d3LnJvYmVydHBlbm5lci5jb20vZWFzaW5nL1xuICovXG5jb25zdCBlZmZlY3RzID0ge1xuICBsaW5lYXI6ICh0OiBudW1iZXIpID0+IHQsXG5cbiAgZWFzZUluUXVhZDogKHQ6IG51bWJlcikgPT4gdCAqIHQsXG5cbiAgZWFzZU91dFF1YWQ6ICh0OiBudW1iZXIpID0+IC10ICogKHQgLSAyKSxcblxuICBlYXNlSW5PdXRRdWFkOiAodDogbnVtYmVyKSA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdFxuICAgIDogLTAuNSAqICgoLS10KSAqICh0IC0gMikgLSAxKSxcblxuICBlYXNlSW5DdWJpYzogKHQ6IG51bWJlcikgPT4gdCAqIHQgKiB0LFxuXG4gIGVhc2VPdXRDdWJpYzogKHQ6IG51bWJlcikgPT4gKHQgLT0gMSkgKiB0ICogdCArIDEsXG5cbiAgZWFzZUluT3V0Q3ViaWM6ICh0OiBudW1iZXIpID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0ICogdFxuICAgIDogMC41ICogKCh0IC09IDIpICogdCAqIHQgKyAyKSxcblxuICBlYXNlSW5RdWFydDogKHQ6IG51bWJlcikgPT4gdCAqIHQgKiB0ICogdCxcblxuICBlYXNlT3V0UXVhcnQ6ICh0OiBudW1iZXIpID0+IC0oKHQgLT0gMSkgKiB0ICogdCAqIHQgLSAxKSxcblxuICBlYXNlSW5PdXRRdWFydDogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0ICogdFxuICAgIDogLTAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAtIDIpLFxuXG4gIGVhc2VJblF1aW50OiAodDogbnVtYmVyKSA9PiB0ICogdCAqIHQgKiB0ICogdCxcblxuICBlYXNlT3V0UXVpbnQ6ICh0OiBudW1iZXIpID0+ICh0IC09IDEpICogdCAqIHQgKiB0ICogdCArIDEsXG5cbiAgZWFzZUluT3V0UXVpbnQ6ICh0OiBudW1iZXIpID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0XG4gICAgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMiksXG5cbiAgZWFzZUluU2luZTogKHQ6IG51bWJlcikgPT4gLU1hdGguY29zKHQgKiBIQUxGX1BJKSArIDEsXG5cbiAgZWFzZU91dFNpbmU6ICh0OiBudW1iZXIpID0+IE1hdGguc2luKHQgKiBIQUxGX1BJKSxcblxuICBlYXNlSW5PdXRTaW5lOiAodDogbnVtYmVyKSA9PiAtMC41ICogKE1hdGguY29zKFBJICogdCkgLSAxKSxcblxuICBlYXNlSW5FeHBvOiAodDogbnVtYmVyKSA9PiAodCA9PT0gMCkgPyAwIDogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKSxcblxuICBlYXNlT3V0RXhwbzogKHQ6IG51bWJlcikgPT4gKHQgPT09IDEpID8gMSA6IC1NYXRoLnBvdygyLCAtMTAgKiB0KSArIDEsXG5cbiAgZWFzZUluT3V0RXhwbzogKHQ6IG51bWJlcikgPT4gYXRFZGdlKHQpID8gdCA6IHQgPCAwLjVcbiAgICA/IDAuNSAqIE1hdGgucG93KDIsIDEwICogKHQgKiAyIC0gMSkpXG4gICAgOiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqICh0ICogMiAtIDEpKSArIDIpLFxuXG4gIGVhc2VJbkNpcmM6ICh0OiBudW1iZXIpID0+ICh0ID49IDEpID8gdCA6IC0oTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKSxcblxuICBlYXNlT3V0Q2lyYzogKHQ6IG51bWJlcikgPT4gTWF0aC5zcXJ0KDEgLSAodCAtPSAxKSAqIHQpLFxuXG4gIGVhc2VJbk91dENpcmM6ICh0OiBudW1iZXIpID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKVxuICAgIDogMC41ICogKE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpLFxuXG4gIGVhc2VJbkVsYXN0aWM6ICh0OiBudW1iZXIpID0+IGF0RWRnZSh0KSA/IHQgOiBlbGFzdGljSW4odCwgMC4wNzUsIDAuMyksXG5cbiAgZWFzZU91dEVsYXN0aWM6ICh0OiBudW1iZXIpID0+IGF0RWRnZSh0KSA/IHQgOiBlbGFzdGljT3V0KHQsIDAuMDc1LCAwLjMpLFxuXG4gIGVhc2VJbk91dEVsYXN0aWModDogbnVtYmVyKSB7XG4gICAgY29uc3QgcyA9IDAuMTEyNTtcbiAgICBjb25zdCBwID0gMC40NTtcbiAgICByZXR1cm4gYXRFZGdlKHQpID8gdCA6XG4gICAgICB0IDwgMC41XG4gICAgICAgID8gMC41ICogZWxhc3RpY0luKHQgKiAyLCBzLCBwKVxuICAgICAgICA6IDAuNSArIDAuNSAqIGVsYXN0aWNPdXQodCAqIDIgLSAxLCBzLCBwKTtcbiAgfSxcblxuICBlYXNlSW5CYWNrKHQ6IG51bWJlcikge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuICB9LFxuXG4gIGVhc2VPdXRCYWNrKHQ6IG51bWJlcikge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiAodCAtPSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG4gIH0sXG5cbiAgZWFzZUluT3V0QmFjayh0OiBudW1iZXIpIHtcbiAgICBsZXQgcyA9IDEuNzAxNTg7XG4gICAgaWYgKCh0IC89IDAuNSkgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogKHQgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCAtIHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0ICsgcykgKyAyKTtcbiAgfSxcblxuICBlYXNlSW5Cb3VuY2U6ICh0OiBudW1iZXIpID0+IDEgLSBlZmZlY3RzLmVhc2VPdXRCb3VuY2UoMSAtIHQpLFxuXG4gIGVhc2VPdXRCb3VuY2UodDogbnVtYmVyKSB7XG4gICAgY29uc3QgbSA9IDcuNTYyNTtcbiAgICBjb25zdCBkID0gMi43NTtcbiAgICBpZiAodCA8ICgxIC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogdCAqIHQ7XG4gICAgfVxuICAgIGlmICh0IDwgKDIgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiAodCAtPSAoMS41IC8gZCkpICogdCArIDAuNzU7XG4gICAgfVxuICAgIGlmICh0IDwgKDIuNSAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgyLjI1IC8gZCkpICogdCArIDAuOTM3NTtcbiAgICB9XG4gICAgcmV0dXJuIG0gKiAodCAtPSAoMi42MjUgLyBkKSkgKiB0ICsgMC45ODQzNzU7XG4gIH0sXG5cbiAgZWFzZUluT3V0Qm91bmNlOiAodDogbnVtYmVyKSA9PiAodCA8IDAuNSlcbiAgICA/IGVmZmVjdHMuZWFzZUluQm91bmNlKHQgKiAyKSAqIDAuNVxuICAgIDogZWZmZWN0cy5lYXNlT3V0Qm91bmNlKHQgKiAyIC0gMSkgKiAwLjUgKyAwLjUsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgdHlwZSBFYXNpbmdGdW5jdGlvbiA9IGtleW9mIHR5cGVvZiBlZmZlY3RzXG5cbmV4cG9ydCBkZWZhdWx0IGVmZmVjdHM7XG4iLCAiaW1wb3J0IHtDb2xvcn0gZnJvbSAnQGt1cmtsZS9jb2xvcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgQ2FudmFzUGF0dGVybiB8IENhbnZhc0dyYWRpZW50IHtcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCB0eXBlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ1tvYmplY3QgQ2FudmFzUGF0dGVybl0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IENhbnZhc0dyYWRpZW50XSc7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb2xvcih2YWx1ZTogQ2FudmFzR3JhZGllbnQpOiBDYW52YXNHcmFkaWVudDtcbmV4cG9ydCBmdW5jdGlvbiBjb2xvcih2YWx1ZTogQ2FudmFzUGF0dGVybik6IENhbnZhc1BhdHRlcm47XG5leHBvcnQgZnVuY3Rpb24gY29sb3IoXG4gIHZhbHVlOlxuICB8IHN0cmluZ1xuICB8IHsgcjogbnVtYmVyOyBnOiBudW1iZXI7IGI6IG51bWJlcjsgYTogbnVtYmVyIH1cbiAgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl1cbiAgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXVxuKTogQ29sb3I7XG5leHBvcnQgZnVuY3Rpb24gY29sb3IodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpID8gdmFsdWUgOiBuZXcgQ29sb3IodmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SG92ZXJDb2xvcih2YWx1ZTogQ2FudmFzR3JhZGllbnQpOiBDYW52YXNHcmFkaWVudDtcbmV4cG9ydCBmdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlOiBDYW52YXNQYXR0ZXJuKTogQ2FudmFzUGF0dGVybjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gZ2V0SG92ZXJDb2xvcih2YWx1ZSkge1xuICByZXR1cm4gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSlcbiAgICA/IHZhbHVlXG4gICAgOiBuZXcgQ29sb3IodmFsdWUpLnNhdHVyYXRlKDAuNSkuZGFya2VuKDAuMSkuaGV4U3RyaW5nKCk7XG59XG4iLCAiY29uc3QgbnVtYmVycyA9IFsneCcsICd5JywgJ2JvcmRlcldpZHRoJywgJ3JhZGl1cycsICd0ZW5zaW9uJ107XG5jb25zdCBjb2xvcnMgPSBbJ2NvbG9yJywgJ2JvcmRlckNvbG9yJywgJ2JhY2tncm91bmRDb2xvciddO1xuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlBbmltYXRpb25zRGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgZGVmYXVsdHMuc2V0KCdhbmltYXRpb24nLCB7XG4gICAgZGVsYXk6IHVuZGVmaW5lZCxcbiAgICBkdXJhdGlvbjogMTAwMCxcbiAgICBlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxuICAgIGZuOiB1bmRlZmluZWQsXG4gICAgZnJvbTogdW5kZWZpbmVkLFxuICAgIGxvb3A6IHVuZGVmaW5lZCxcbiAgICB0bzogdW5kZWZpbmVkLFxuICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuZGVzY3JpYmUoJ2FuaW1hdGlvbicsIHtcbiAgICBfZmFsbGJhY2s6IGZhbHNlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ29uUHJvZ3Jlc3MnICYmIG5hbWUgIT09ICdvbkNvbXBsZXRlJyAmJiBuYW1lICE9PSAnZm4nLFxuICB9KTtcblxuICBkZWZhdWx0cy5zZXQoJ2FuaW1hdGlvbnMnLCB7XG4gICAgY29sb3JzOiB7XG4gICAgICB0eXBlOiAnY29sb3InLFxuICAgICAgcHJvcGVydGllczogY29sb3JzXG4gICAgfSxcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IG51bWJlcnNcbiAgICB9LFxuICB9KTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9ucycsIHtcbiAgICBfZmFsbGJhY2s6ICdhbmltYXRpb24nLFxuICB9KTtcblxuICBkZWZhdWx0cy5zZXQoJ3RyYW5zaXRpb25zJywge1xuICAgIGFjdGl2ZToge1xuICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIGR1cmF0aW9uOiA0MDBcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlc2l6ZToge1xuICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICB9XG4gICAgfSxcbiAgICBzaG93OiB7XG4gICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgIGNvbG9yczoge1xuICAgICAgICAgIGZyb206ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaWJsZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkdXJhdGlvbjogMCAvLyBzaG93IGltbWVkaWF0ZWx5XG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfSxcbiAgICBoaWRlOiB7XG4gICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgIGNvbG9yczoge1xuICAgICAgICAgIHRvOiAndHJhbnNwYXJlbnQnXG4gICAgICAgIH0sXG4gICAgICAgIHZpc2libGU6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgICBmbjogdiA9PiB2IHwgMCAvLyBmb3Iga2VlcGluZyB0aGUgZGF0YXNldCB2aXNpYmxlIGFsbCB0aGUgd2F5IHRocm91Z2ggdGhlIGFuaW1hdGlvblxuICAgICAgICB9LFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGFwcGx5TGF5b3V0c0RlZmF1bHRzKGRlZmF1bHRzKSB7XG4gIGRlZmF1bHRzLnNldCgnbGF5b3V0Jywge1xuICAgIGF1dG9QYWRkaW5nOiB0cnVlLFxuICAgIHBhZGRpbmc6IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMFxuICAgIH1cbiAgfSk7XG59XG4iLCAiXG5jb25zdCBpbnRsQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgSW50bC5OdW1iZXJGb3JtYXQ+KCk7XG5cbmZ1bmN0aW9uIGdldE51bWJlckZvcm1hdChsb2NhbGU6IHN0cmluZywgb3B0aW9ucz86IEludGwuTnVtYmVyRm9ybWF0T3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgY2FjaGVLZXkgPSBsb2NhbGUgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgbGV0IGZvcm1hdHRlciA9IGludGxDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWZvcm1hdHRlcikge1xuICAgIGZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpO1xuICAgIGludGxDYWNoZS5zZXQoY2FjaGVLZXksIGZvcm1hdHRlcik7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdHRlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW06IG51bWJlciwgbG9jYWxlOiBzdHJpbmcsIG9wdGlvbnM/OiBJbnRsLk51bWJlckZvcm1hdE9wdGlvbnMpIHtcbiAgcmV0dXJuIGdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdChudW0pO1xufVxuIiwgImltcG9ydCB7aXNBcnJheX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtmb3JtYXROdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRsLmpzJztcbmltcG9ydCB7bG9nMTB9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcblxuLyoqXG4gKiBOYW1lc3BhY2UgdG8gaG9sZCBmb3JtYXR0ZXJzIGZvciBkaWZmZXJlbnQgdHlwZXMgb2YgdGlja3NcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuVGlja3MuZm9ybWF0dGVyc1xuICovXG5jb25zdCBmb3JtYXR0ZXJzID0ge1xuICAvKipcbiAgICogRm9ybWF0dGVyIGZvciB2YWx1ZSBsYWJlbHNcbiAgICogQG1ldGhvZCBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzLnZhbHVlc1xuICAgKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIGRpc3BsYXlcbiAgICogQHJldHVybiB7c3RyaW5nfHN0cmluZ1tdfSB0aGUgbGFiZWwgdG8gZGlzcGxheVxuICAgKi9cbiAgdmFsdWVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gLyoqIEB0eXBlIHtzdHJpbmdbXX0gKi8gKHZhbHVlKSA6ICcnICsgdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcm1hdHRlciBmb3IgbnVtZXJpYyB0aWNrc1xuICAgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICAgKiBAcGFyYW0gdGlja1ZhbHVlIHtudW1iZXJ9IHRoZSB2YWx1ZSB0byBiZSBmb3JtYXR0ZWRcbiAgICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IHRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlciBpbiB0aGUgdGlja3MgYXJyYXlcbiAgICogQHBhcmFtIHRpY2tzIHtvYmplY3RbXX0gdGhlIGxpc3Qgb2YgdGlja3MgYmVpbmcgY29udmVydGVkXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyXG4gICAqL1xuICBudW1lcmljKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG4gICAgaWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcwJzsgLy8gbmV2ZXIgc2hvdyBkZWNpbWFsIHBsYWNlcyBmb3IgMFxuICAgIH1cblxuICAgIGNvbnN0IGxvY2FsZSA9IHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGU7XG4gICAgbGV0IG5vdGF0aW9uO1xuICAgIGxldCBkZWx0YSA9IHRpY2tWYWx1ZTsgLy8gVGhpcyBpcyB1c2VkIHdoZW4gdGhlcmUgYXJlIGxlc3MgdGhhbiAyIHRpY2tzIGFzIHRoZSB0aWNrIGludGVydmFsLlxuXG4gICAgaWYgKHRpY2tzLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIGFsbCB0aWNrcyBhcmUgc21hbGwgb3IgdGhlcmUgaHVnZSBudW1iZXJzOyB1c2Ugc2NpZW50aWZpYyBub3RhdGlvblxuICAgICAgY29uc3QgbWF4VGljayA9IE1hdGgubWF4KE1hdGguYWJzKHRpY2tzWzBdLnZhbHVlKSwgTWF0aC5hYnModGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUpKTtcbiAgICAgIGlmIChtYXhUaWNrIDwgMWUtNCB8fCBtYXhUaWNrID4gMWUrMTUpIHtcbiAgICAgICAgbm90YXRpb24gPSAnc2NpZW50aWZpYyc7XG4gICAgICB9XG5cbiAgICAgIGRlbHRhID0gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcyk7XG4gICAgfVxuXG4gICAgY29uc3QgbG9nRGVsdGEgPSBsb2cxMChNYXRoLmFicyhkZWx0YSkpO1xuXG4gICAgLy8gV2hlbiBkYXRhc2V0cyBoYXZlIHZhbHVlcyBhcHByb2FjaGluZyBOdW1iZXIuTUFYX1ZBTFVFLCB0aGUgdGljayBjYWxjdWxhdGlvbnMgbWlnaHQgcmVzdWx0IGluXG4gICAgLy8gaW5maW5pdHkgYW5kIGV2ZW50dWFsbHkgTmFOLiBQYXNzaW5nIE5hTiBmb3IgbWluaW11bUZyYWN0aW9uRGlnaXRzIG9yIG1heGltdW1GcmFjdGlvbkRpZ2l0c1xuICAgIC8vIHdpbGwgbWFrZSB0aGUgbnVtYmVyIGZvcm1hdHRlciB0aHJvdy4gU28gaW5zdGVhZCB3ZSBjaGVjayBmb3IgaXNOYU4gYW5kIHVzZSBhIGZhbGxiYWNrIHZhbHVlLlxuICAgIC8vXG4gICAgLy8gdG9GaXhlZCBoYXMgYSBtYXggb2YgMjAgZGVjaW1hbCBwbGFjZXNcbiAgICBjb25zdCBudW1EZWNpbWFsID0gaXNOYU4obG9nRGVsdGEpID8gMSA6IE1hdGgubWF4KE1hdGgubWluKC0xICogTWF0aC5mbG9vcihsb2dEZWx0YSksIDIwKSwgMCk7XG5cbiAgICBjb25zdCBvcHRpb25zID0ge25vdGF0aW9uLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IG51bURlY2ltYWwsIG1heGltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbH07XG4gICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcblxuICAgIHJldHVybiBmb3JtYXROdW1iZXIodGlja1ZhbHVlLCBsb2NhbGUsIG9wdGlvbnMpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEZvcm1hdHRlciBmb3IgbG9nYXJpdGhtaWMgdGlja3NcbiAgICogQG1ldGhvZCBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljXG4gICAqIEBwYXJhbSB0aWNrVmFsdWUge251bWJlcn0gdGhlIHZhbHVlIHRvIGJlIGZvcm1hdHRlZFxuICAgKiBAcGFyYW0gaW5kZXgge251bWJlcn0gdGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyIGluIHRoZSB0aWNrcyBhcnJheVxuICAgKiBAcGFyYW0gdGlja3Mge29iamVjdFtdfSB0aGUgbGlzdCBvZiB0aWNrcyBiZWluZyBjb252ZXJ0ZWRcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXJcbiAgICovXG4gIGxvZ2FyaXRobWljKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG4gICAgaWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcwJztcbiAgICB9XG4gICAgY29uc3QgcmVtYWluID0gdGlja3NbaW5kZXhdLnNpZ25pZmljYW5kIHx8ICh0aWNrVmFsdWUgLyAoTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAodGlja1ZhbHVlKSkpKSk7XG4gICAgaWYgKFsxLCAyLCAzLCA1LCAxMCwgMTVdLmluY2x1ZGVzKHJlbWFpbikgfHwgaW5kZXggPiAwLjggKiB0aWNrcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLm51bWVyaWMuY2FsbCh0aGlzLCB0aWNrVmFsdWUsIGluZGV4LCB0aWNrcyk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG59O1xuXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlbHRhKHRpY2tWYWx1ZSwgdGlja3MpIHtcbiAgLy8gRmlndXJlIG91dCBob3cgbWFueSBkaWdpdHMgdG8gc2hvd1xuICAvLyBUaGUgc3BhY2UgYmV0d2VlbiB0aGUgZmlyc3QgdHdvIHRpY2tzIG1pZ2h0IGJlIHNtYWxsZXIgdGhhbiBub3JtYWwgc3BhY2luZ1xuICBsZXQgZGVsdGEgPSB0aWNrcy5sZW5ndGggPiAzID8gdGlja3NbMl0udmFsdWUgLSB0aWNrc1sxXS52YWx1ZSA6IHRpY2tzWzFdLnZhbHVlIC0gdGlja3NbMF0udmFsdWU7XG5cbiAgLy8gSWYgd2UgaGF2ZSBhIG51bWJlciBsaWtlIDIuNSBhcyB0aGUgZGVsdGEsIGZpZ3VyZSBvdXQgaG93IG1hbnkgZGVjaW1hbCBwbGFjZXMgd2UgbmVlZFxuICBpZiAoTWF0aC5hYnMoZGVsdGEpID49IDEgJiYgdGlja1ZhbHVlICE9PSBNYXRoLmZsb29yKHRpY2tWYWx1ZSkpIHtcbiAgICAvLyBub3QgYW4gaW50ZWdlclxuICAgIGRlbHRhID0gdGlja1ZhbHVlIC0gTWF0aC5mbG9vcih0aWNrVmFsdWUpO1xuICB9XG4gIHJldHVybiBkZWx0YTtcbn1cblxuLyoqXG4gKiBOYW1lc3BhY2UgdG8gaG9sZCBzdGF0aWMgdGljayBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICogQG5hbWVzcGFjZSBDaGFydC5UaWNrc1xuICovXG5leHBvcnQgZGVmYXVsdCB7Zm9ybWF0dGVyc307XG4iLCAiaW1wb3J0IFRpY2tzIGZyb20gJy4vY29yZS50aWNrcy5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVNjYWxlRGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgZGVmYXVsdHMuc2V0KCdzY2FsZScsIHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIG9mZnNldDogZmFsc2UsXG4gICAgcmV2ZXJzZTogZmFsc2UsXG4gICAgYmVnaW5BdFplcm86IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogU2NhbGUgYm91bmRhcnkgc3RyYXRlZ3kgKGJ5cGFzc2VkIGJ5IG1pbi9tYXggdGltZSBvcHRpb25zKVxuICAgICAqIC0gYGRhdGFgOiBtYWtlIHN1cmUgZGF0YSBhcmUgZnVsbHkgdmlzaWJsZSwgdGlja3Mgb3V0c2lkZSBhcmUgcmVtb3ZlZFxuICAgICAqIC0gYHRpY2tzYDogbWFrZSBzdXJlIHRpY2tzIGFyZSBmdWxseSB2aXNpYmxlLCBkYXRhIG91dHNpZGUgYXJlIHRydW5jYXRlZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTU2XG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICovXG4gICAgYm91bmRzOiAndGlja3MnLFxuXG4gICAgY2xpcDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEFkZGl0aW9uIGdyYWNlIGFkZGVkIHRvIG1heCBhbmQgcmVkdWNlZCBmcm9tIG1pbiBkYXRhIHZhbHVlLlxuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqL1xuICAgIGdyYWNlOiAwLFxuXG4gICAgLy8gZ3JpZCBsaW5lIHNldHRpbmdzXG4gICAgZ3JpZDoge1xuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgIGRyYXdPbkNoYXJ0QXJlYTogdHJ1ZSxcbiAgICAgIGRyYXdUaWNrczogdHJ1ZSxcbiAgICAgIHRpY2tMZW5ndGg6IDgsXG4gICAgICB0aWNrV2lkdGg6IChfY3R4LCBvcHRpb25zKSA9PiBvcHRpb25zLmxpbmVXaWR0aCxcbiAgICAgIHRpY2tDb2xvcjogKF9jdHgsIG9wdGlvbnMpID0+IG9wdGlvbnMuY29sb3IsXG4gICAgICBvZmZzZXQ6IGZhbHNlLFxuICAgIH0sXG5cbiAgICBib3JkZXI6IHtcbiAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICBkYXNoOiBbXSxcbiAgICAgIGRhc2hPZmZzZXQ6IDAuMCxcbiAgICAgIHdpZHRoOiAxXG4gICAgfSxcblxuICAgIC8vIHNjYWxlIHRpdGxlXG4gICAgdGl0bGU6IHtcbiAgICAgIC8vIGRpc3BsYXkgcHJvcGVydHlcbiAgICAgIGRpc3BsYXk6IGZhbHNlLFxuXG4gICAgICAvLyBhY3R1YWwgbGFiZWxcbiAgICAgIHRleHQ6ICcnLFxuXG4gICAgICAvLyB0b3AvYm90dG9tIHBhZGRpbmdcbiAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgdG9wOiA0LFxuICAgICAgICBib3R0b206IDRcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gbGFiZWwgc2V0dGluZ3NcbiAgICB0aWNrczoge1xuICAgICAgbWluUm90YXRpb246IDAsXG4gICAgICBtYXhSb3RhdGlvbjogNTAsXG4gICAgICBtaXJyb3I6IGZhbHNlLFxuICAgICAgdGV4dFN0cm9rZVdpZHRoOiAwLFxuICAgICAgdGV4dFN0cm9rZUNvbG9yOiAnJyxcbiAgICAgIHBhZGRpbmc6IDMsXG4gICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgYXV0b1NraXA6IHRydWUsXG4gICAgICBhdXRvU2tpcFBhZGRpbmc6IDMsXG4gICAgICBsYWJlbE9mZnNldDogMCxcbiAgICAgIC8vIFdlIHBhc3MgdGhyb3VnaCBhcnJheXMgdG8gYmUgcmVuZGVyZWQgYXMgbXVsdGlsaW5lIGxhYmVscywgd2UgY29udmVydCBPdGhlcnMgdG8gc3RyaW5ncyBoZXJlLlxuICAgICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMudmFsdWVzLFxuICAgICAgbWlub3I6IHt9LFxuICAgICAgbWFqb3I6IHt9LFxuICAgICAgYWxpZ246ICdjZW50ZXInLFxuICAgICAgY3Jvc3NBbGlnbjogJ25lYXInLFxuXG4gICAgICBzaG93TGFiZWxCYWNrZHJvcDogZmFsc2UsXG4gICAgICBiYWNrZHJvcENvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KScsXG4gICAgICBiYWNrZHJvcFBhZGRpbmc6IDIsXG4gICAgfVxuICB9KTtcblxuICBkZWZhdWx0cy5yb3V0ZSgnc2NhbGUudGlja3MnLCAnY29sb3InLCAnJywgJ2NvbG9yJyk7XG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS5ncmlkJywgJ2NvbG9yJywgJycsICdib3JkZXJDb2xvcicpO1xuICBkZWZhdWx0cy5yb3V0ZSgnc2NhbGUuYm9yZGVyJywgJ2NvbG9yJywgJycsICdib3JkZXJDb2xvcicpO1xuICBkZWZhdWx0cy5yb3V0ZSgnc2NhbGUudGl0bGUnLCAnY29sb3InLCAnJywgJ2NvbG9yJyk7XG5cbiAgZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlJywge1xuICAgIF9mYWxsYmFjazogZmFsc2UsXG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdiZWZvcmUnKSAmJiAhbmFtZS5zdGFydHNXaXRoKCdhZnRlcicpICYmIG5hbWUgIT09ICdjYWxsYmFjaycgJiYgbmFtZSAhPT0gJ3BhcnNlcicsXG4gICAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdib3JkZXJEYXNoJyAmJiBuYW1lICE9PSAndGlja0JvcmRlckRhc2gnICYmIG5hbWUgIT09ICdkYXNoJyxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlcycsIHtcbiAgICBfZmFsbGJhY2s6ICdzY2FsZScsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZS50aWNrcycsIHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdiYWNrZHJvcFBhZGRpbmcnICYmIG5hbWUgIT09ICdjYWxsYmFjaycsXG4gICAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdiYWNrZHJvcFBhZGRpbmcnLFxuICB9KTtcbn1cbiIsICJpbXBvcnQge2dldEhvdmVyQ29sb3J9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xvci5qcyc7XG5pbXBvcnQge2lzT2JqZWN0LCBtZXJnZSwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7YXBwbHlBbmltYXRpb25zRGVmYXVsdHN9IGZyb20gJy4vY29yZS5hbmltYXRpb25zLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7YXBwbHlMYXlvdXRzRGVmYXVsdHN9IGZyb20gJy4vY29yZS5sYXlvdXRzLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7YXBwbHlTY2FsZURlZmF1bHRzfSBmcm9tICcuL2NvcmUuc2NhbGUuZGVmYXVsdHMuanMnO1xuXG5leHBvcnQgY29uc3Qgb3ZlcnJpZGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmV4cG9ydCBjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2NvcGUobm9kZSwga2V5KSB7XG4gIGlmICgha2V5KSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgY29uc3Qga2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICBmb3IgKGxldCBpID0gMCwgbiA9IGtleXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgY29uc3QgayA9IGtleXNbaV07XG4gICAgbm9kZSA9IG5vZGVba10gfHwgKG5vZGVba10gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gc2V0KHJvb3QsIHNjb3BlLCB2YWx1ZXMpIHtcbiAgaWYgKHR5cGVvZiBzY29wZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbWVyZ2UoZ2V0U2NvcGUocm9vdCwgc2NvcGUpLCB2YWx1ZXMpO1xuICB9XG4gIHJldHVybiBtZXJnZShnZXRTY29wZShyb290LCAnJyksIHNjb3BlKTtcbn1cblxuLyoqXG4gKiBQbGVhc2UgdXNlIHRoZSBtb2R1bGUncyBkZWZhdWx0IGV4cG9ydCB3aGljaCBwcm92aWRlcyBhIHNpbmdsZXRvbiBpbnN0YW5jZVxuICogTm90ZTogY2xhc3MgaXMgZXhwb3J0ZWQgZm9yIHR5cGVkb2NcbiAqL1xuZXhwb3J0IGNsYXNzIERlZmF1bHRzIHtcbiAgY29uc3RydWN0b3IoX2Rlc2NyaXB0b3JzLCBfYXBwbGllcnMpIHtcbiAgICB0aGlzLmFuaW1hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuICAgIHRoaXMuYm9yZGVyQ29sb3IgPSAncmdiYSgwLDAsMCwwLjEpJztcbiAgICB0aGlzLmNvbG9yID0gJyM2NjYnO1xuICAgIHRoaXMuZGF0YXNldHMgPSB7fTtcbiAgICB0aGlzLmRldmljZVBpeGVsUmF0aW8gPSAoY29udGV4dCkgPT4gY29udGV4dC5jaGFydC5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgdGhpcy5lbGVtZW50cyA9IHt9O1xuICAgIHRoaXMuZXZlbnRzID0gW1xuICAgICAgJ21vdXNlbW92ZScsXG4gICAgICAnbW91c2VvdXQnLFxuICAgICAgJ2NsaWNrJyxcbiAgICAgICd0b3VjaHN0YXJ0JyxcbiAgICAgICd0b3VjaG1vdmUnXG4gICAgXTtcbiAgICB0aGlzLmZvbnQgPSB7XG4gICAgICBmYW1pbHk6IFwiJ0hlbHZldGljYSBOZXVlJywgJ0hlbHZldGljYScsICdBcmlhbCcsIHNhbnMtc2VyaWZcIixcbiAgICAgIHNpemU6IDEyLFxuICAgICAgc3R5bGU6ICdub3JtYWwnLFxuICAgICAgbGluZUhlaWdodDogMS4yLFxuICAgICAgd2VpZ2h0OiBudWxsXG4gICAgfTtcbiAgICB0aGlzLmhvdmVyID0ge307XG4gICAgdGhpcy5ob3ZlckJhY2tncm91bmRDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgIHRoaXMuaG92ZXJCb3JkZXJDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcik7XG4gICAgdGhpcy5ob3ZlckNvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmNvbG9yKTtcbiAgICB0aGlzLmluZGV4QXhpcyA9ICd4JztcbiAgICB0aGlzLmludGVyYWN0aW9uID0ge1xuICAgICAgbW9kZTogJ25lYXJlc3QnLFxuICAgICAgaW50ZXJzZWN0OiB0cnVlLFxuICAgICAgaW5jbHVkZUludmlzaWJsZTogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMubWFpbnRhaW5Bc3BlY3RSYXRpbyA9IHRydWU7XG4gICAgdGhpcy5vbkhvdmVyID0gbnVsbDtcbiAgICB0aGlzLm9uQ2xpY2sgPSBudWxsO1xuICAgIHRoaXMucGFyc2luZyA9IHRydWU7XG4gICAgdGhpcy5wbHVnaW5zID0ge307XG4gICAgdGhpcy5yZXNwb25zaXZlID0gdHJ1ZTtcbiAgICB0aGlzLnNjYWxlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2NhbGVzID0ge307XG4gICAgdGhpcy5zaG93TGluZSA9IHRydWU7XG4gICAgdGhpcy5kcmF3QWN0aXZlRWxlbWVudHNPblRvcCA9IHRydWU7XG5cbiAgICB0aGlzLmRlc2NyaWJlKF9kZXNjcmlwdG9ycyk7XG4gICAgdGhpcy5hcHBseShfYXBwbGllcnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gc2NvcGVcblx0ICogQHBhcmFtIHtvYmplY3R9IFt2YWx1ZXNdXG5cdCAqL1xuICBzZXQoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQodGhpcywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHNjb3BlXG5cdCAqL1xuICBnZXQoc2NvcGUpIHtcbiAgICByZXR1cm4gZ2V0U2NvcGUodGhpcywgc2NvcGUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gc2NvcGVcblx0ICogQHBhcmFtIHtvYmplY3R9IFt2YWx1ZXNdXG5cdCAqL1xuICBkZXNjcmliZShzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldChkZXNjcmlwdG9ycywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cblxuICBvdmVycmlkZShzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldChvdmVycmlkZXMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJvdXRlcyB0aGUgbmFtZWQgZGVmYXVsdHMgdG8gZmFsbGJhY2sgdG8gYW5vdGhlciBzY29wZS9uYW1lLlxuXHQgKiBUaGlzIHJvdXRpbmcgaXMgdXNlZnVsIHdoZW4gdGhvc2UgdGFyZ2V0IHZhbHVlcywgbGlrZSBkZWZhdWx0cy5jb2xvciwgYXJlIGNoYW5nZWQgcnVudGltZS5cblx0ICogSWYgdGhlIHZhbHVlcyB3b3VsZCBiZSBjb3BpZWQsIHRoZSBydW50aW1lIGNoYW5nZSB3b3VsZCBub3QgdGFrZSBlZmZlY3QuIEJ5IHJvdXRpbmcsIHRoZVxuXHQgKiBmYWxsYmFjayBpcyBldmFsdWF0ZWQgYXQgZWFjaCBhY2Nlc3MsIHNvIGl0cyBhbHdheXMgdXAgdG8gZGF0ZS5cblx0ICpcblx0ICogRXhhbXBsZTpcblx0ICpcblx0ICogXHRkZWZhdWx0cy5yb3V0ZSgnZWxlbWVudHMuYXJjJywgJ2JhY2tncm91bmRDb2xvcicsICcnLCAnY29sb3InKVxuXHQgKiAgIC0gcmVhZHMgdGhlIGJhY2tncm91bmRDb2xvciBmcm9tIGRlZmF1bHRzLmNvbG9yIHdoZW4gdW5kZWZpbmVkIGxvY2FsbHlcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHNjb3BlIFNjb3BlIHRoaXMgcm91dGUgYXBwbGllcyB0by5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgUHJvcGVydHkgbmFtZSB0aGF0IHNob3VsZCBiZSByb3V0ZWQgdG8gZGlmZmVyZW50IG5hbWVzcGFjZSB3aGVuIG5vdCBkZWZpbmVkIGhlcmUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRTY29wZSBUaGUgbmFtZXNwYWNlIHdoZXJlIHRob3NlIHByb3BlcnRpZXMgc2hvdWxkIGJlIHJvdXRlZCB0by5cblx0ICogRW1wdHkgc3RyaW5nICgnJykgaXMgdGhlIHJvb3Qgb2YgZGVmYXVsdHMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXROYW1lIFRoZSB0YXJnZXQgbmFtZSBpbiB0aGUgdGFyZ2V0IHNjb3BlIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgcm91dGVkIHRvLlxuXHQgKi9cbiAgcm91dGUoc2NvcGUsIG5hbWUsIHRhcmdldFNjb3BlLCB0YXJnZXROYW1lKSB7XG4gICAgY29uc3Qgc2NvcGVPYmplY3QgPSBnZXRTY29wZSh0aGlzLCBzY29wZSk7XG4gICAgY29uc3QgdGFyZ2V0U2NvcGVPYmplY3QgPSBnZXRTY29wZSh0aGlzLCB0YXJnZXRTY29wZSk7XG4gICAgY29uc3QgcHJpdmF0ZU5hbWUgPSAnXycgKyBuYW1lO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2NvcGVPYmplY3QsIHtcbiAgICAgIC8vIEEgcHJpdmF0ZSBwcm9wZXJ0eSBpcyBkZWZpbmVkIHRvIGhvbGQgdGhlIGFjdHVhbCB2YWx1ZSwgd2hlbiB0aGlzIHByb3BlcnR5IGlzIHNldCBpbiBpdHMgc2NvcGUgKHNldCBpbiB0aGUgc2V0dGVyKVxuICAgICAgW3ByaXZhdGVOYW1lXToge1xuICAgICAgICB2YWx1ZTogc2NvcGVPYmplY3RbbmFtZV0sXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgLy8gVGhlIGFjdHVhbCBwcm9wZXJ0eSBpcyBkZWZpbmVkIGFzIGdldHRlci9zZXR0ZXIgc28gd2UgY2FuIGRvIHRoZSByb3V0aW5nIHdoZW4gdmFsdWUgaXMgbm90IGxvY2FsbHkgc2V0LlxuICAgICAgW25hbWVdOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBjb25zdCBsb2NhbCA9IHRoaXNbcHJpdmF0ZU5hbWVdO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldFNjb3BlT2JqZWN0W3RhcmdldE5hbWVdO1xuICAgICAgICAgIGlmIChpc09iamVjdChsb2NhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQsIGxvY2FsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlT3JEZWZhdWx0KGxvY2FsLCB0YXJnZXQpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICB0aGlzW3ByaXZhdGVOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBhcHBseShhcHBsaWVycykge1xuICAgIGFwcGxpZXJzLmZvckVhY2goKGFwcGx5KSA9PiBhcHBseSh0aGlzKSk7XG4gIH1cbn1cblxuLy8gc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgZGVmYXVsdCAvKiAjX19QVVJFX18gKi8gbmV3IERlZmF1bHRzKHtcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdvbicpLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2V2ZW50cycsXG4gIGhvdmVyOiB7XG4gICAgX2ZhbGxiYWNrOiAnaW50ZXJhY3Rpb24nXG4gIH0sXG4gIGludGVyYWN0aW9uOiB7XG4gICAgX3NjcmlwdGFibGU6IGZhbHNlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9XG59LCBbYXBwbHlBbmltYXRpb25zRGVmYXVsdHMsIGFwcGx5TGF5b3V0c0RlZmF1bHRzLCBhcHBseVNjYWxlRGVmYXVsdHNdKTtcbiIsICJpbXBvcnQgdHlwZSB7XG4gIENoYXJ0LFxuICBQb2ludCxcbiAgRm9udFNwZWMsXG4gIENhbnZhc0ZvbnRTcGVjLFxuICBQb2ludFN0eWxlLFxuICBSZW5kZXJUZXh0T3B0cyxcbiAgQmFja2Ryb3BPcHRpb25zXG59IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtcbiAgVFJCTCxcbiAgU3BsaW5lUG9pbnQsXG4gIFJvdW5kZWRSZWN0LFxuICBUUkJMQ29ybmVyc1xufSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuaW1wb3J0IHtpc0FycmF5LCBpc051bGxPclVuZGVmfSBmcm9tICcuL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge1BJLCBUQVUsIEhBTEZfUEksIFFVQVJURVJfUEksIFRXT19USElSRFNfUEksIFJBRF9QRVJfREVHfSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGZvbnQgb2JqZWN0IGludG8gYSBDU1MgZm9udCBzdHJpbmcuXG4gKiBAcGFyYW0gZm9udCAtIEEgZm9udCBvYmplY3QuXG4gKiBAcmV0dXJuIFRoZSBDU1MgZm9udCBzdHJpbmcuIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRm9udFN0cmluZyhmb250OiBGb250U3BlYykge1xuICBpZiAoIWZvbnQgfHwgaXNOdWxsT3JVbmRlZihmb250LnNpemUpIHx8IGlzTnVsbE9yVW5kZWYoZm9udC5mYW1pbHkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gKGZvbnQuc3R5bGUgPyBmb250LnN0eWxlICsgJyAnIDogJycpXG5cdFx0KyAoZm9udC53ZWlnaHQgPyBmb250LndlaWdodCArICcgJyA6ICcnKVxuXHRcdCsgZm9udC5zaXplICsgJ3B4ICdcblx0XHQrIGZvbnQuZmFtaWx5O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbWVhc3VyZVRleHQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LFxuICBnYzogc3RyaW5nW10sXG4gIGxvbmdlc3Q6IG51bWJlcixcbiAgc3RyaW5nOiBzdHJpbmdcbikge1xuICBsZXQgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddO1xuICBpZiAoIXRleHRXaWR0aCkge1xuICAgIHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXSA9IGN0eC5tZWFzdXJlVGV4dChzdHJpbmcpLndpZHRoO1xuICAgIGdjLnB1c2goc3RyaW5nKTtcbiAgfVxuICBpZiAodGV4dFdpZHRoID4gbG9uZ2VzdCkge1xuICAgIGxvbmdlc3QgPSB0ZXh0V2lkdGg7XG4gIH1cbiAgcmV0dXJuIGxvbmdlc3Q7XG59XG5cbnR5cGUgVGhpbmcgPSBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsXG50eXBlIFRoaW5ncyA9IChUaGluZyB8IFRoaW5nW10pW11cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIF9sb25nZXN0VGV4dChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGZvbnQ6IHN0cmluZyxcbiAgYXJyYXlPZlRoaW5nczogVGhpbmdzLFxuICBjYWNoZT86IHtkYXRhPzogUmVjb3JkPHN0cmluZywgbnVtYmVyPiwgZ2FyYmFnZUNvbGxlY3Q/OiBzdHJpbmdbXSwgZm9udD86IHN0cmluZ31cbikge1xuICBjYWNoZSA9IGNhY2hlIHx8IHt9O1xuICBsZXQgZGF0YSA9IGNhY2hlLmRhdGEgPSBjYWNoZS5kYXRhIHx8IHt9O1xuICBsZXQgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0IHx8IFtdO1xuXG4gIGlmIChjYWNoZS5mb250ICE9PSBmb250KSB7XG4gICAgZGF0YSA9IGNhY2hlLmRhdGEgPSB7fTtcbiAgICBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gW107XG4gICAgY2FjaGUuZm9udCA9IGZvbnQ7XG4gIH1cblxuICBjdHguc2F2ZSgpO1xuXG4gIGN0eC5mb250ID0gZm9udDtcbiAgbGV0IGxvbmdlc3QgPSAwO1xuICBjb25zdCBpbGVuID0gYXJyYXlPZlRoaW5ncy5sZW5ndGg7XG4gIGxldCBpOiBudW1iZXIsIGo6IG51bWJlciwgamxlbjogbnVtYmVyLCB0aGluZzogVGhpbmcgfCBUaGluZ1tdLCBuZXN0ZWRUaGluZzogVGhpbmcgfCBUaGluZ1tdO1xuICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgdGhpbmcgPSBhcnJheU9mVGhpbmdzW2ldO1xuXG4gICAgLy8gVW5kZWZpbmVkIHN0cmluZ3MgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG4gICAgaWYgKHRoaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpbmcgIT09IG51bGwgJiYgIWlzQXJyYXkodGhpbmcpKSB7XG4gICAgICBsb25nZXN0ID0gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHRoaW5nKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodGhpbmcpKSB7XG4gICAgICAvLyBpZiBpdCBpcyBhbiBhcnJheSBsZXRzIG1lYXN1cmUgZWFjaCBlbGVtZW50XG4gICAgICAvLyB0byBkbyBtYXliZSBzaW1wbGlmeSB0aGlzIGZ1bmN0aW9uIGEgYml0IHNvIHdlIGNhbiBkbyB0aGlzIG1vcmUgcmVjdXJzaXZlbHk/XG4gICAgICBmb3IgKGogPSAwLCBqbGVuID0gdGhpbmcubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgIG5lc3RlZFRoaW5nID0gdGhpbmdbal07XG4gICAgICAgIC8vIFVuZGVmaW5lZCBzdHJpbmdzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuICAgICAgICBpZiAobmVzdGVkVGhpbmcgIT09IHVuZGVmaW5lZCAmJiBuZXN0ZWRUaGluZyAhPT0gbnVsbCAmJiAhaXNBcnJheShuZXN0ZWRUaGluZykpIHtcbiAgICAgICAgICBsb25nZXN0ID0gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIG5lc3RlZFRoaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGN0eC5yZXN0b3JlKCk7XG5cbiAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICBpZiAoZ2NMZW4gPiBhcnJheU9mVGhpbmdzLmxlbmd0aCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBnY0xlbjsgaSsrKSB7XG4gICAgICBkZWxldGUgZGF0YVtnY1tpXV07XG4gICAgfVxuICAgIGdjLnNwbGljZSgwLCBnY0xlbik7XG4gIH1cbiAgcmV0dXJuIGxvbmdlc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYWxpZ25lZCBwaXhlbCB2YWx1ZSB0byBhdm9pZCBhbnRpLWFsaWFzaW5nIGJsdXJcbiAqIEBwYXJhbSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cbiAqIEBwYXJhbSBwaXhlbCAtIEEgcGl4ZWwgdmFsdWUuXG4gKiBAcGFyYW0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGVsZW1lbnQuXG4gKiBAcmV0dXJucyBUaGUgYWxpZ25lZCBwaXhlbCB2YWx1ZS5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYWxpZ25QaXhlbChjaGFydDogQ2hhcnQsIHBpeGVsOiBudW1iZXIsIHdpZHRoOiBudW1iZXIpIHtcbiAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvO1xuICBjb25zdCBoYWxmV2lkdGggPSB3aWR0aCAhPT0gMCA/IE1hdGgubWF4KHdpZHRoIC8gMiwgMC41KSA6IDA7XG4gIHJldHVybiBNYXRoLnJvdW5kKChwaXhlbCAtIGhhbGZXaWR0aCkgKiBkZXZpY2VQaXhlbFJhdGlvKSAvIGRldmljZVBpeGVsUmF0aW8gKyBoYWxmV2lkdGg7XG59XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBlbnRpcmUgY2FudmFzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDYW52YXMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgY3R4PzogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gIGN0eCA9IGN0eCB8fCBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICBjdHguc2F2ZSgpO1xuICAvLyBjYW52YXMud2lkdGggYW5kIGNhbnZhcy5oZWlnaHQgZG8gbm90IGNvbnNpZGVyIHRoZSBjYW52YXMgdHJhbnNmb3JtLFxuICAvLyB3aGlsZSBjbGVhclJlY3QgZG9lc1xuICBjdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBjdHgucmVzdG9yZSgpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERyYXdQb2ludE9wdGlvbnMge1xuICBwb2ludFN0eWxlOiBQb2ludFN0eWxlO1xuICByb3RhdGlvbj86IG51bWJlcjtcbiAgcmFkaXVzOiBudW1iZXI7XG4gIGJvcmRlcldpZHRoOiBudW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkcmF3UG9pbnQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBvcHRpb25zOiBEcmF3UG9pbnRPcHRpb25zLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlclxuKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgZHJhd1BvaW50TGVnZW5kKGN0eCwgb3B0aW9ucywgeCwgeSwgbnVsbCk7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgZnVuY3Rpb24gZHJhd1BvaW50TGVnZW5kKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgb3B0aW9uczogRHJhd1BvaW50T3B0aW9ucyxcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXIsXG4gIHc6IG51bWJlclxuKSB7XG4gIGxldCB0eXBlOiBzdHJpbmcsIHhPZmZzZXQ6IG51bWJlciwgeU9mZnNldDogbnVtYmVyLCBzaXplOiBudW1iZXIsIGNvcm5lclJhZGl1czogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCB4T2Zmc2V0VzogbnVtYmVyLCB5T2Zmc2V0VzogbnVtYmVyO1xuICBjb25zdCBzdHlsZSA9IG9wdGlvbnMucG9pbnRTdHlsZTtcbiAgY29uc3Qgcm90YXRpb24gPSBvcHRpb25zLnJvdGF0aW9uO1xuICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cztcbiAgbGV0IHJhZCA9IChyb3RhdGlvbiB8fCAwKSAqIFJBRF9QRVJfREVHO1xuXG4gIGlmIChzdHlsZSAmJiB0eXBlb2Ygc3R5bGUgPT09ICdvYmplY3QnKSB7XG4gICAgdHlwZSA9IHN0eWxlLnRvU3RyaW5nKCk7XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEhUTUxJbWFnZUVsZW1lbnRdJyB8fCB0eXBlID09PSAnW29iamVjdCBIVE1MQ2FudmFzRWxlbWVudF0nKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGN0eC5yb3RhdGUocmFkKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc3R5bGUsIC1zdHlsZS53aWR0aCAvIDIsIC1zdHlsZS5oZWlnaHQgLyAyLCBzdHlsZS53aWR0aCwgc3R5bGUuaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTmFOKHJhZGl1cykgfHwgcmFkaXVzIDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgc3dpdGNoIChzdHlsZSkge1xuICAvLyBEZWZhdWx0IGluY2x1ZGVzIGNpcmNsZVxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodykge1xuICAgICAgICBjdHguZWxsaXBzZSh4LCB5LCB3IC8gMiwgcmFkaXVzLCAwLCAwLCBUQVUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIFRBVSk7XG4gICAgICB9XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0cmlhbmdsZSc6XG4gICAgICB3aWR0aCA9IHcgPyB3IC8gMiA6IHJhZGl1cztcbiAgICAgIGN0eC5tb3ZlVG8oeCArIE1hdGguc2luKHJhZCkgKiB3aWR0aCwgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogd2lkdGgsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICAgIHJhZCArPSBUV09fVEhJUkRTX1BJO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHdpZHRoLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyZWN0Um91bmRlZCc6XG4gICAgLy8gTk9URTogdGhlIHJvdW5kZWQgcmVjdCBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIHRvIHVzZSBgYXJjYCBpbnN0ZWFkIG9mXG4gICAgLy8gYHF1YWRyYXRpY0N1cnZlVG9gIHNpbmNlIGl0IGdlbmVyYXRlcyBiZXR0ZXIgcmVzdWx0cyB3aGVuIHJlY3QgaXNcbiAgICAvLyBhbG1vc3QgYSBjaXJjbGUuIDAuNTE2IChpbnN0ZWFkIG9mIDAuNSkgcHJvZHVjZXMgcmVzdWx0cyB3aXRoIHZpc3VhbGx5XG4gICAgLy8gY2xvc2VyIHByb3BvcnRpb24gdG8gdGhlIHByZXZpb3VzIGltcGwgYW5kIGl0IGlzIGluc2NyaWJlZCBpbiB0aGVcbiAgICAvLyBjaXJjbGUgd2l0aCBgcmFkaXVzYC4gRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZSBmb2xsb3dpbmcgUFJzOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81NTk3XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU4NThcbiAgICAgIGNvcm5lclJhZGl1cyA9IHJhZGl1cyAqIDAuNTE2O1xuICAgICAgc2l6ZSA9IHJhZGl1cyAtIGNvcm5lclJhZGl1cztcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogKHcgPyB3IC8gMiAtIGNvcm5lclJhZGl1cyA6IHNpemUpO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiAodyA/IHcgLyAyIC0gY29ybmVyUmFkaXVzIDogc2l6ZSk7XG4gICAgICBjdHguYXJjKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gUEksIHJhZCAtIEhBTEZfUEkpO1xuICAgICAgY3R4LmFyYyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIEhBTEZfUEksIHJhZCk7XG4gICAgICBjdHguYXJjKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkLCByYWQgKyBIQUxGX1BJKTtcbiAgICAgIGN0eC5hcmMoeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgKyBIQUxGX1BJLCByYWQgKyBQSSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyZWN0JzpcbiAgICAgIGlmICghcm90YXRpb24pIHtcbiAgICAgICAgc2l6ZSA9IE1hdGguU1FSVDFfMiAqIHJhZGl1cztcbiAgICAgICAgd2lkdGggPSB3ID8gdyAvIDIgOiBzaXplO1xuICAgICAgICBjdHgucmVjdCh4IC0gd2lkdGgsIHkgLSBzaXplLCAyICogd2lkdGgsIDIgKiBzaXplKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSAncmVjdFJvdCc6XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjcm9zc1JvdCc6XG4gICAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSAnY3Jvc3MnOlxuICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc3Rhcic6XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCk7XG4gICAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCk7XG4gICAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgeE9mZnNldCA9IHcgPyB3IC8gMiA6IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Rhc2gnOlxuICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKSwgeSArIE1hdGguc2luKHJhZCkgKiByYWRpdXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmYWxzZTpcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgY3R4LmZpbGwoKTtcbiAgaWYgKG9wdGlvbnMuYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIHRlc3RcbiAqIEBwYXJhbSBhcmVhIC0gVGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIG1hcmdpbiAtIGFsbG93ZWQgbWFyZ2luXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2lzUG9pbnRJbkFyZWEoXG4gIHBvaW50OiBQb2ludCxcbiAgYXJlYTogVFJCTCxcbiAgbWFyZ2luPzogbnVtYmVyXG4pIHtcbiAgbWFyZ2luID0gbWFyZ2luIHx8IDAuNTsgLy8gbWFyZ2luIC0gZGVmYXVsdCBpcyB0byBtYXRjaCByb3VuZGVkIGRlY2ltYWxzXG5cbiAgcmV0dXJuICFhcmVhIHx8IChwb2ludCAmJiBwb2ludC54ID4gYXJlYS5sZWZ0IC0gbWFyZ2luICYmIHBvaW50LnggPCBhcmVhLnJpZ2h0ICsgbWFyZ2luICYmXG5cdFx0cG9pbnQueSA+IGFyZWEudG9wIC0gbWFyZ2luICYmIHBvaW50LnkgPCBhcmVhLmJvdHRvbSArIG1hcmdpbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGlwQXJlYShjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgYXJlYTogVFJCTCkge1xuICBjdHguc2F2ZSgpO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5yZWN0KGFyZWEubGVmdCwgYXJlYS50b3AsIGFyZWEucmlnaHQgLSBhcmVhLmxlZnQsIGFyZWEuYm90dG9tIC0gYXJlYS50b3ApO1xuICBjdHguY2xpcCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5jbGlwQXJlYShjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICBjdHgucmVzdG9yZSgpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc3RlcHBlZExpbmVUbyhcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHByZXZpb3VzOiBQb2ludCxcbiAgdGFyZ2V0OiBQb2ludCxcbiAgZmxpcD86IGJvb2xlYW4sXG4gIG1vZGU/OiBzdHJpbmdcbikge1xuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbiAgfVxuICBpZiAobW9kZSA9PT0gJ21pZGRsZScpIHtcbiAgICBjb25zdCBtaWRwb2ludCA9IChwcmV2aW91cy54ICsgdGFyZ2V0LngpIC8gMi4wO1xuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHByZXZpb3VzLnkpO1xuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHRhcmdldC55KTtcbiAgfSBlbHNlIGlmIChtb2RlID09PSAnYWZ0ZXInICE9PSAhIWZsaXApIHtcbiAgICBjdHgubGluZVRvKHByZXZpb3VzLngsIHRhcmdldC55KTtcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVRvKHRhcmdldC54LCBwcmV2aW91cy55KTtcbiAgfVxuICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9iZXppZXJDdXJ2ZVRvKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgcHJldmlvdXM6IFNwbGluZVBvaW50LFxuICB0YXJnZXQ6IFNwbGluZVBvaW50LFxuICBmbGlwPzogYm9vbGVhblxuKSB7XG4gIGlmICghcHJldmlvdXMpIHtcbiAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICB9XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF4IDogcHJldmlvdXMuY3AyeCxcbiAgICBmbGlwID8gcHJldmlvdXMuY3AxeSA6IHByZXZpb3VzLmNwMnksXG4gICAgZmxpcCA/IHRhcmdldC5jcDJ4IDogdGFyZ2V0LmNwMXgsXG4gICAgZmxpcCA/IHRhcmdldC5jcDJ5IDogdGFyZ2V0LmNwMXksXG4gICAgdGFyZ2V0LngsXG4gICAgdGFyZ2V0LnkpO1xufVxuXG5mdW5jdGlvbiBzZXRSZW5kZXJPcHRzKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBvcHRzOiBSZW5kZXJUZXh0T3B0cykge1xuICBpZiAob3B0cy50cmFuc2xhdGlvbikge1xuICAgIGN0eC50cmFuc2xhdGUob3B0cy50cmFuc2xhdGlvblswXSwgb3B0cy50cmFuc2xhdGlvblsxXSk7XG4gIH1cblxuICBpZiAoIWlzTnVsbE9yVW5kZWYob3B0cy5yb3RhdGlvbikpIHtcbiAgICBjdHgucm90YXRlKG9wdHMucm90YXRpb24pO1xuICB9XG5cbiAgaWYgKG9wdHMuY29sb3IpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0cy5jb2xvcjtcbiAgfVxuXG4gIGlmIChvcHRzLnRleHRBbGlnbikge1xuICAgIGN0eC50ZXh0QWxpZ24gPSBvcHRzLnRleHRBbGlnbjtcbiAgfVxuXG4gIGlmIChvcHRzLnRleHRCYXNlbGluZSkge1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBvcHRzLnRleHRCYXNlbGluZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWNvcmF0ZVRleHQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAgbGluZTogc3RyaW5nLFxuICBvcHRzOiBSZW5kZXJUZXh0T3B0c1xuKSB7XG4gIGlmIChvcHRzLnN0cmlrZXRocm91Z2ggfHwgb3B0cy51bmRlcmxpbmUpIHtcbiAgICAvKipcbiAgICAgKiBOb3cgdGhhdCBJRTExIHN1cHBvcnQgaGFzIGJlZW4gZHJvcHBlZCwgd2UgY2FuIHVzZSBtb3JlXG4gICAgICogb2YgdGhlIFRleHRNZXRyaWNzIG9iamVjdC4gVGhlIGFjdHVhbCBib3VuZGluZyBib3hlc1xuICAgICAqIGFyZSB1bmZsYWdnZWQgaW4gQ2hyb21lLCBGaXJlZm94LCBFZGdlLCBhbmQgU2FmYXJpIHNvIHRoZXlcbiAgICAgKiBjYW4gYmUgc2FmZWx5IHVzZWQuXG4gICAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UZXh0TWV0cmljcyNCcm93c2VyX2NvbXBhdGliaWxpdHlcbiAgICAgKi9cbiAgICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KGxpbmUpO1xuICAgIGNvbnN0IGxlZnQgPSB4IC0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveExlZnQ7XG4gICAgY29uc3QgcmlnaHQgPSB4ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0O1xuICAgIGNvbnN0IHRvcCA9IHkgLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50O1xuICAgIGNvbnN0IGJvdHRvbSA9IHkgKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudDtcbiAgICBjb25zdCB5RGVjb3JhdGlvbiA9IG9wdHMuc3RyaWtldGhyb3VnaCA/ICh0b3AgKyBib3R0b20pIC8gMiA6IGJvdHRvbTtcblxuICAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRzLmRlY29yYXRpb25XaWR0aCB8fCAyO1xuICAgIGN0eC5tb3ZlVG8obGVmdCwgeURlY29yYXRpb24pO1xuICAgIGN0eC5saW5lVG8ocmlnaHQsIHlEZWNvcmF0aW9uKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd0JhY2tkcm9wKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBvcHRzOiBCYWNrZHJvcE9wdGlvbnMpIHtcbiAgY29uc3Qgb2xkQ29sb3IgPSBjdHguZmlsbFN0eWxlO1xuXG4gIGN0eC5maWxsU3R5bGUgPSBvcHRzLmNvbG9yIGFzIHN0cmluZztcbiAgY3R4LmZpbGxSZWN0KG9wdHMubGVmdCwgb3B0cy50b3AsIG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KTtcbiAgY3R4LmZpbGxTdHlsZSA9IG9sZENvbG9yO1xufVxuXG4vKipcbiAqIFJlbmRlciB0ZXh0IG9udG8gdGhlIGNhbnZhc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyVGV4dChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHRleHQ6IHN0cmluZyB8IHN0cmluZ1tdLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAgZm9udDogQ2FudmFzRm9udFNwZWMsXG4gIG9wdHM6IFJlbmRlclRleHRPcHRzID0ge31cbikge1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkodGV4dCkgPyB0ZXh0IDogW3RleHRdO1xuICBjb25zdCBzdHJva2UgPSBvcHRzLnN0cm9rZVdpZHRoID4gMCAmJiBvcHRzLnN0cm9rZUNvbG9yICE9PSAnJztcbiAgbGV0IGk6IG51bWJlciwgbGluZTogc3RyaW5nO1xuXG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5mb250ID0gZm9udC5zdHJpbmc7XG4gIHNldFJlbmRlck9wdHMoY3R4LCBvcHRzKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICBsaW5lID0gbGluZXNbaV07XG5cbiAgICBpZiAob3B0cy5iYWNrZHJvcCkge1xuICAgICAgZHJhd0JhY2tkcm9wKGN0eCwgb3B0cy5iYWNrZHJvcCk7XG4gICAgfVxuXG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgaWYgKG9wdHMuc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0cy5zdHJva2VDb2xvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG9wdHMuc3Ryb2tlV2lkdGgpKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBvcHRzLnN0cm9rZVdpZHRoO1xuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICB9XG5cbiAgICBjdHguZmlsbFRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XG4gICAgZGVjb3JhdGVUZXh0KGN0eCwgeCwgeSwgbGluZSwgb3B0cyk7XG5cbiAgICB5ICs9IE51bWJlcihmb250LmxpbmVIZWlnaHQpO1xuICB9XG5cbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuLyoqXG4gKiBBZGQgYSBwYXRoIG9mIGEgcmVjdGFuZ2xlIHdpdGggcm91bmRlZCBjb3JuZXJzIHRvIHRoZSBjdXJyZW50IHN1Yi1wYXRoXG4gKiBAcGFyYW0gY3R4IC0gQ29udGV4dFxuICogQHBhcmFtIHJlY3QgLSBCb3VuZGluZyByZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRSb3VuZGVkUmVjdFBhdGgoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICByZWN0OiBSb3VuZGVkUmVjdCAmIHsgcmFkaXVzOiBUUkJMQ29ybmVycyB9XG4pIHtcbiAgY29uc3Qge3gsIHksIHcsIGgsIHJhZGl1c30gPSByZWN0O1xuXG4gIC8vIHRvcCBsZWZ0IGFyY1xuICBjdHguYXJjKHggKyByYWRpdXMudG9wTGVmdCwgeSArIHJhZGl1cy50b3BMZWZ0LCByYWRpdXMudG9wTGVmdCwgMS41ICogUEksIFBJLCB0cnVlKTtcblxuICAvLyBsaW5lIGZyb20gdG9wIGxlZnQgdG8gYm90dG9tIGxlZnRcbiAgY3R4LmxpbmVUbyh4LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21MZWZ0KTtcblxuICAvLyBib3R0b20gbGVmdCBhcmNcbiAgY3R4LmFyYyh4ICsgcmFkaXVzLmJvdHRvbUxlZnQsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQsIHJhZGl1cy5ib3R0b21MZWZ0LCBQSSwgSEFMRl9QSSwgdHJ1ZSk7XG5cbiAgLy8gbGluZSBmcm9tIGJvdHRvbSBsZWZ0IHRvIGJvdHRvbSByaWdodFxuICBjdHgubGluZVRvKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCk7XG5cbiAgLy8gYm90dG9tIHJpZ2h0IGFyY1xuICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21SaWdodCwgcmFkaXVzLmJvdHRvbVJpZ2h0LCBIQUxGX1BJLCAwLCB0cnVlKTtcblxuICAvLyBsaW5lIGZyb20gYm90dG9tIHJpZ2h0IHRvIHRvcCByaWdodFxuICBjdHgubGluZVRvKHggKyB3LCB5ICsgcmFkaXVzLnRvcFJpZ2h0KTtcblxuICAvLyB0b3AgcmlnaHQgYXJjXG4gIGN0eC5hcmMoeCArIHcgLSByYWRpdXMudG9wUmlnaHQsIHkgKyByYWRpdXMudG9wUmlnaHQsIHJhZGl1cy50b3BSaWdodCwgMCwgLUhBTEZfUEksIHRydWUpO1xuXG4gIC8vIGxpbmUgZnJvbSB0b3AgcmlnaHQgdG8gdG9wIGxlZnRcbiAgY3R4LmxpbmVUbyh4ICsgcmFkaXVzLnRvcExlZnQsIHkpO1xufVxuIiwgImltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9jb3JlL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHtpc0FycmF5LCBpc09iamVjdCwgdG9EaW1lbnNpb24sIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge3RvRm9udFN0cmluZ30gZnJvbSAnLi9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRBcmVhLCBGb250U3BlYywgUG9pbnR9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtUUkJMLCBUUkJMQ29ybmVyc30gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcblxuY29uc3QgTElORV9IRUlHSFQgPSAvXihub3JtYWx8KFxcZCsoPzpcXC5cXGQrKT8pKHB4fGVtfCUpPykkLztcbmNvbnN0IEZPTlRfU1RZTEUgPSAvXihub3JtYWx8aXRhbGljfGluaXRpYWx8aW5oZXJpdHx1bnNldHwob2JsaXF1ZSggLT9bMC05XT9bMC05XWRlZyk/KSkkLztcblxuLyoqXG4gKiBAYWxpYXMgQ2hhcnQuaGVscGVycy5vcHRpb25zXG4gKiBAbmFtZXNwYWNlXG4gKi9cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGxpbmUgaGVpZ2h0IGB2YWx1ZWAgaW4gcGl4ZWxzIGZvciBhIHNwZWNpZmljIGZvbnQgYHNpemVgLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGxpbmVIZWlnaHQgdG8gcGFyc2UgKGVnLiAxLjYsICcxNHB4JywgJzc1JScsICcxLjZlbScpLlxuICogQHBhcmFtIHNpemUgLSBUaGUgZm9udCBzaXplIChpbiBwaXhlbHMpIHVzZWQgdG8gcmVzb2x2ZSByZWxhdGl2ZSBgdmFsdWVgLlxuICogQHJldHVybnMgVGhlIGVmZmVjdGl2ZSBsaW5lIGhlaWdodCBpbiBwaXhlbHMgKHNpemUgKiAxLjIgaWYgdmFsdWUgaXMgaW52YWxpZCkuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9saW5lLWhlaWdodFxuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0xpbmVIZWlnaHQodmFsdWU6IG51bWJlciB8IHN0cmluZywgc2l6ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgbWF0Y2hlcyA9ICgnJyArIHZhbHVlKS5tYXRjaChMSU5FX0hFSUdIVCk7XG4gIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzWzFdID09PSAnbm9ybWFsJykge1xuICAgIHJldHVybiBzaXplICogMS4yO1xuICB9XG5cbiAgdmFsdWUgPSArbWF0Y2hlc1syXTtcblxuICBzd2l0Y2ggKG1hdGNoZXNbM10pIHtcbiAgICBjYXNlICdweCc6XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY2FzZSAnJSc6XG4gICAgICB2YWx1ZSAvPSAxMDA7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gc2l6ZSAqIHZhbHVlO1xufVxuXG5jb25zdCBudW1iZXJPclplcm8gPSAodjogdW5rbm93bikgPT4gK3YgfHwgMDtcblxuLyoqXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBwcm9wc1xuICovXG5leHBvcnQgZnVuY3Rpb24gX3JlYWRWYWx1ZVRvUHJvcHM8SyBleHRlbmRzIHN0cmluZz4odmFsdWU6IG51bWJlciB8IFJlY29yZDxLLCBudW1iZXI+LCBwcm9wczogS1tdKTogUmVjb3JkPEssIG51bWJlcj47XG5leHBvcnQgZnVuY3Rpb24gX3JlYWRWYWx1ZVRvUHJvcHM8SyBleHRlbmRzIHN0cmluZywgVCBleHRlbmRzIHN0cmluZz4odmFsdWU6IG51bWJlciB8IFJlY29yZDxLICYgVCwgbnVtYmVyPiwgcHJvcHM6IFJlY29yZDxULCBLPik6IFJlY29yZDxULCBudW1iZXI+O1xuZXhwb3J0IGZ1bmN0aW9uIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlOiBudW1iZXIgfCBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LCBwcm9wczogc3RyaW5nW10gfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBjb25zdCBvYmpQcm9wcyA9IGlzT2JqZWN0KHByb3BzKTtcbiAgY29uc3Qga2V5cyA9IG9ialByb3BzID8gT2JqZWN0LmtleXMocHJvcHMpIDogcHJvcHM7XG4gIGNvbnN0IHJlYWQgPSBpc09iamVjdCh2YWx1ZSlcbiAgICA/IG9ialByb3BzXG4gICAgICA/IHByb3AgPT4gdmFsdWVPckRlZmF1bHQodmFsdWVbcHJvcF0sIHZhbHVlW3Byb3BzW3Byb3BdXSlcbiAgICAgIDogcHJvcCA9PiB2YWx1ZVtwcm9wXVxuICAgIDogKCkgPT4gdmFsdWU7XG5cbiAgZm9yIChjb25zdCBwcm9wIG9mIGtleXMpIHtcbiAgICByZXRbcHJvcF0gPSBudW1iZXJPclplcm8ocmVhZChwcm9wKSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIFRSQkwgb2JqZWN0LlxuICogQHBhcmFtIHZhbHVlIC0gSWYgYSBudW1iZXIsIHNldCB0aGUgdmFsdWUgdG8gYWxsIFRSQkwgY29tcG9uZW50LFxuICogIGVsc2UsIGlmIGFuIG9iamVjdCwgdXNlIGRlZmluZWQgcHJvcGVydGllcyBhbmQgc2V0cyB1bmRlZmluZWQgb25lcyB0byAwLlxuICogIHggLyB5IGFyZSBzaG9ydGhhbmRzIGZvciBzYW1lIHZhbHVlIGZvciBsZWZ0L3JpZ2h0IGFuZCB0b3AvYm90dG9tLlxuICogQHJldHVybnMgVGhlIHBhZGRpbmcgdmFsdWVzICh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQpXG4gKiBAc2luY2UgMy4wLjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVFJCTCh2YWx1ZTogbnVtYmVyIHwgVFJCTCB8IFBvaW50KSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwge3RvcDogJ3knLCByaWdodDogJ3gnLCBib3R0b206ICd5JywgbGVmdDogJ3gnfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBUUkJMIGNvcm5lcnMgb2JqZWN0IChzaW1pbGFyIHdpdGggY3NzIGJvcmRlci1yYWRpdXMpLlxuICogQHBhcmFtIHZhbHVlIC0gSWYgYSBudW1iZXIsIHNldCB0aGUgdmFsdWUgdG8gYWxsIFRSQkwgY29ybmVyIGNvbXBvbmVudHMsXG4gKiAgZWxzZSwgaWYgYW4gb2JqZWN0LCB1c2UgZGVmaW5lZCBwcm9wZXJ0aWVzIGFuZCBzZXRzIHVuZGVmaW5lZCBvbmVzIHRvIDAuXG4gKiBAcmV0dXJucyBUaGUgVFJCTCBjb3JuZXIgdmFsdWVzICh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHQpXG4gKiBAc2luY2UgMy4wLjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVFJCTENvcm5lcnModmFsdWU6IG51bWJlciB8IFRSQkxDb3JuZXJzKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgWyd0b3BMZWZ0JywgJ3RvcFJpZ2h0JywgJ2JvdHRvbUxlZnQnLCAnYm90dG9tUmlnaHQnXSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBwYWRkaW5nIG9iamVjdCB3aXRoIHByZS1jb21wdXRlZCB3aWR0aC9oZWlnaHQuXG4gKiBAcGFyYW0gdmFsdWUgLSBJZiBhIG51bWJlciwgc2V0IHRoZSB2YWx1ZSB0byBhbGwgVFJCTCBjb21wb25lbnQsXG4gKiAgZWxzZSwgaWYgYW4gb2JqZWN0LCB1c2UgZGVmaW5lZCBwcm9wZXJ0aWVzIGFuZCBzZXRzIHVuZGVmaW5lZCBvbmVzIHRvIDAuXG4gKiAgeCAvIHkgYXJlIHNob3J0aGFuZHMgZm9yIHNhbWUgdmFsdWUgZm9yIGxlZnQvcmlnaHQgYW5kIHRvcC9ib3R0b20uXG4gKiBAcmV0dXJucyBUaGUgcGFkZGluZyB2YWx1ZXMgKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgd2lkdGgsIGhlaWdodClcbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9QYWRkaW5nKHZhbHVlPzogbnVtYmVyIHwgVFJCTCk6IENoYXJ0QXJlYSB7XG4gIGNvbnN0IG9iaiA9IHRvVFJCTCh2YWx1ZSkgYXMgQ2hhcnRBcmVhO1xuXG4gIG9iai53aWR0aCA9IG9iai5sZWZ0ICsgb2JqLnJpZ2h0O1xuICBvYmouaGVpZ2h0ID0gb2JqLnRvcCArIG9iai5ib3R0b207XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBQYXJzZXMgZm9udCBvcHRpb25zIGFuZCByZXR1cm5zIHRoZSBmb250IG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQSBvYmplY3QgdGhhdCBjb250YWlucyBmb250IG9wdGlvbnMgdG8gYmUgcGFyc2VkLlxuICogQHBhcmFtIGZhbGxiYWNrIC0gQSBvYmplY3QgdGhhdCBjb250YWlucyBmYWxsYmFjayBmb250IG9wdGlvbnMuXG4gKiBAcmV0dXJuIFRoZSBmb250IG9iamVjdC5cbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRvRm9udChvcHRpb25zOiBQYXJ0aWFsPEZvbnRTcGVjPiwgZmFsbGJhY2s/OiBQYXJ0aWFsPEZvbnRTcGVjPikge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZmFsbGJhY2sgPSBmYWxsYmFjayB8fCBkZWZhdWx0cy5mb250IGFzIEZvbnRTcGVjO1xuXG4gIGxldCBzaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5zaXplLCBmYWxsYmFjay5zaXplKTtcblxuICBpZiAodHlwZW9mIHNpemUgPT09ICdzdHJpbmcnKSB7XG4gICAgc2l6ZSA9IHBhcnNlSW50KHNpemUsIDEwKTtcbiAgfVxuICBsZXQgc3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnN0eWxlLCBmYWxsYmFjay5zdHlsZSk7XG4gIGlmIChzdHlsZSAmJiAhKCcnICsgc3R5bGUpLm1hdGNoKEZPTlRfU1RZTEUpKSB7XG4gICAgY29uc29sZS53YXJuKCdJbnZhbGlkIGZvbnQgc3R5bGUgc3BlY2lmaWVkOiBcIicgKyBzdHlsZSArICdcIicpO1xuICAgIHN0eWxlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgZm9udCA9IHtcbiAgICBmYW1pbHk6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZmFtaWx5LCBmYWxsYmFjay5mYW1pbHkpLFxuICAgIGxpbmVIZWlnaHQ6IHRvTGluZUhlaWdodCh2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmxpbmVIZWlnaHQsIGZhbGxiYWNrLmxpbmVIZWlnaHQpLCBzaXplKSxcbiAgICBzaXplLFxuICAgIHN0eWxlLFxuICAgIHdlaWdodDogdmFsdWVPckRlZmF1bHQob3B0aW9ucy53ZWlnaHQsIGZhbGxiYWNrLndlaWdodCksXG4gICAgc3RyaW5nOiAnJ1xuICB9O1xuXG4gIGZvbnQuc3RyaW5nID0gdG9Gb250U3RyaW5nKGZvbnQpO1xuICByZXR1cm4gZm9udDtcbn1cblxuLyoqXG4gKiBFdmFsdWF0ZXMgdGhlIGdpdmVuIGBpbnB1dHNgIHNlcXVlbnRpYWxseSBhbmQgcmV0dXJucyB0aGUgZmlyc3QgZGVmaW5lZCB2YWx1ZS5cbiAqIEBwYXJhbSBpbnB1dHMgLSBBbiBhcnJheSBvZiB2YWx1ZXMsIGZhbGxpbmcgYmFjayB0byB0aGUgbGFzdCB2YWx1ZS5cbiAqIEBwYXJhbSBjb250ZXh0IC0gSWYgZGVmaW5lZCBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgaXMgYSBmdW5jdGlvbiwgdGhlIHZhbHVlXG4gKiBpcyBjYWxsZWQgd2l0aCBgY29udGV4dGAgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHRoZSByZXN1bHQgYmVjb21lcyB0aGUgbmV3IGlucHV0LlxuICogQHBhcmFtIGluZGV4IC0gSWYgZGVmaW5lZCBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgaXMgYW4gYXJyYXksIHRoZSB2YWx1ZVxuICogYXQgYGluZGV4YCBiZWNvbWUgdGhlIG5ldyBpbnB1dC5cbiAqIEBwYXJhbSBpbmZvIC0gb2JqZWN0IHRvIHJldHVybiBpbmZvcm1hdGlvbiBhYm91dCByZXNvbHV0aW9uIGluXG4gKiBAcGFyYW0gaW5mby5jYWNoZWFibGUgLSBXaWxsIGJlIHNldCB0byBgZmFsc2VgIGlmIG9wdGlvbiBpcyBub3QgY2FjaGVhYmxlLlxuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlKGlucHV0czogQXJyYXk8dW5rbm93bj4sIGNvbnRleHQ/OiBvYmplY3QsIGluZGV4PzogbnVtYmVyLCBpbmZvPzogeyBjYWNoZWFibGU6IGJvb2xlYW4gfSkge1xuICBsZXQgY2FjaGVhYmxlID0gdHJ1ZTtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCB2YWx1ZTogdW5rbm93bjtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gaW5wdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHZhbHVlID0gaW5wdXRzW2ldO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUoY29udGV4dCk7XG4gICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWVbaW5kZXggJSB2YWx1ZS5sZW5ndGhdO1xuICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaW5mbyAmJiAhY2FjaGVhYmxlKSB7XG4gICAgICAgIGluZm8uY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIG1pbm1heFxuICogQHBhcmFtIGdyYWNlXG4gKiBAcGFyYW0gYmVnaW5BdFplcm9cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYWRkR3JhY2UobWlubWF4OiB7IG1pbjogbnVtYmVyOyBtYXg6IG51bWJlcjsgfSwgZ3JhY2U6IG51bWJlciB8IHN0cmluZywgYmVnaW5BdFplcm86IGJvb2xlYW4pIHtcbiAgY29uc3Qge21pbiwgbWF4fSA9IG1pbm1heDtcbiAgY29uc3QgY2hhbmdlID0gdG9EaW1lbnNpb24oZ3JhY2UsIChtYXggLSBtaW4pIC8gMik7XG4gIGNvbnN0IGtlZXBaZXJvID0gKHZhbHVlOiBudW1iZXIsIGFkZDogbnVtYmVyKSA9PiBiZWdpbkF0WmVybyAmJiB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSArIGFkZDtcbiAgcmV0dXJuIHtcbiAgICBtaW46IGtlZXBaZXJvKG1pbiwgLU1hdGguYWJzKGNoYW5nZSkpLFxuICAgIG1heDoga2VlcFplcm8obWF4LCBjaGFuZ2UpXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY29udGV4dCBpbmhlcml0aW5nIHBhcmVudENvbnRleHRcbiAqIEBwYXJhbSBwYXJlbnRDb250ZXh0XG4gKiBAcGFyYW0gY29udGV4dFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQ8VCBleHRlbmRzIG9iamVjdD4ocGFyZW50Q29udGV4dDogbnVsbCwgY29udGV4dDogVCk6IFQ7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGV4dDxUIGV4dGVuZHMgb2JqZWN0LCBQIGV4dGVuZHMgVD4ocGFyZW50Q29udGV4dDogUCwgY29udGV4dDogVCk6IFAgJiBUO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQocGFyZW50Q29udGV4dDogb2JqZWN0LCBjb250ZXh0OiBvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShwYXJlbnRDb250ZXh0KSwgY29udGV4dCk7XG59XG4iLCAiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lICovXG5pbXBvcnQgdHlwZSB7QW55T2JqZWN0fSBmcm9tICcuLi90eXBlcy9iYXNpYy5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRNZXRhfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7XG4gIFJlc29sdmVyT2JqZWN0S2V5LFxuICBSZXNvbHZlckNhY2hlLFxuICBSZXNvbHZlclByb3h5LFxuICBEZXNjcmlwdG9yRGVmYXVsdHMsXG4gIERlc2NyaXB0b3IsXG4gIENvbnRleHRDYWNoZSxcbiAgQ29udGV4dFByb3h5XG59IGZyb20gJy4vaGVscGVycy5jb25maWcudHlwZXMuanMnO1xuaW1wb3J0IHtpc0FycmF5LCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgcmVzb2x2ZU9iamVjdEtleSwgX2NhcGl0YWxpemV9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcblxuZXhwb3J0ICogZnJvbSAnLi9oZWxwZXJzLmNvbmZpZy50eXBlcy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFByb3h5IGZvciByZXNvbHZpbmcgcmF3IHZhbHVlcyBmb3Igb3B0aW9ucy5cbiAqIEBwYXJhbSBzY29wZXMgLSBUaGUgb3B0aW9uIHNjb3BlcyB0byBsb29rIGZvciB2YWx1ZXMsIGluIHJlc29sdXRpb24gb3JkZXJcbiAqIEBwYXJhbSBwcmVmaXhlcyAtIFRoZSBwcmVmaXhlcyBmb3IgdmFsdWVzLCBpbiByZXNvbHV0aW9uIG9yZGVyLlxuICogQHBhcmFtIHJvb3RTY29wZXMgLSBUaGUgcm9vdCBvcHRpb24gc2NvcGVzXG4gKiBAcGFyYW0gZmFsbGJhY2sgLSBQYXJlbnQgc2NvcGVzIGZhbGxiYWNrXG4gKiBAcGFyYW0gZ2V0VGFyZ2V0IC0gY2FsbGJhY2sgZm9yIGdldHRpbmcgdGhlIHRhcmdldCBmb3IgY2hhbmdlZCB2YWx1ZXNcbiAqIEByZXR1cm5zIFByb3h5XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NyZWF0ZVJlc29sdmVyPFxuICBUIGV4dGVuZHMgQW55T2JqZWN0W10gPSBBbnlPYmplY3RbXSxcbiAgUiBleHRlbmRzIEFueU9iamVjdFtdID0gVFxuPihcbiAgc2NvcGVzOiBULFxuICBwcmVmaXhlcyA9IFsnJ10sXG4gIHJvb3RTY29wZXM/OiBSLFxuICBmYWxsYmFjaz86IFJlc29sdmVyT2JqZWN0S2V5LFxuICBnZXRUYXJnZXQgPSAoKSA9PiBzY29wZXNbMF1cbikge1xuICBjb25zdCBmaW5hbFJvb3RTY29wZXMgPSByb290U2NvcGVzIHx8IHNjb3BlcztcbiAgaWYgKHR5cGVvZiBmYWxsYmFjayA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmYWxsYmFjayA9IF9yZXNvbHZlKCdfZmFsbGJhY2snLCBzY29wZXMpO1xuICB9XG4gIGNvbnN0IGNhY2hlOiBSZXNvbHZlckNhY2hlPFQsIFI+ID0ge1xuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnT2JqZWN0JyxcbiAgICBfY2FjaGVhYmxlOiB0cnVlLFxuICAgIF9zY29wZXM6IHNjb3BlcyxcbiAgICBfcm9vdFNjb3BlczogZmluYWxSb290U2NvcGVzLFxuICAgIF9mYWxsYmFjazogZmFsbGJhY2ssXG4gICAgX2dldFRhcmdldDogZ2V0VGFyZ2V0LFxuICAgIG92ZXJyaWRlOiAoc2NvcGU6IEFueU9iamVjdCkgPT4gX2NyZWF0ZVJlc29sdmVyKFtzY29wZSwgLi4uc2NvcGVzXSwgcHJlZml4ZXMsIGZpbmFsUm9vdFNjb3BlcywgZmFsbGJhY2spLFxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgZGVsZXRlIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcDogc3RyaW5nKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdOyAvLyByZW1vdmUgZnJvbSBjYWNoZVxuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5czsgLy8gcmVtb3ZlIGNhY2hlZCBrZXlzXG4gICAgICBkZWxldGUgc2NvcGVzWzBdW3Byb3BdOyAvLyByZW1vdmUgZnJvbSB0b3AgbGV2ZWwgc2NvcGVcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIGdldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGdldCh0YXJnZXQsIHByb3A6IHN0cmluZykge1xuICAgICAgcmV0dXJuIF9jYWNoZWQodGFyZ2V0LCBwcm9wLFxuICAgICAgICAoKSA9PiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhwcm9wLCBwcmVmaXhlcywgc2NvcGVzLCB0YXJnZXQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLlxuICAgICAqIEFsc28gdXNlZCBieSBPYmplY3QuaGFzT3duUHJvcGVydHkuXG4gICAgICovXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5fc2NvcGVzWzBdLCBwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YuXG4gICAgICovXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihzY29wZXNbMF0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHRoZSBpbiBvcGVyYXRvci5cbiAgICAgKi9cbiAgICBoYXModGFyZ2V0LCBwcm9wOiBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpLmluY2x1ZGVzKHByb3ApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIGFuZCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLlxuICAgICAqL1xuICAgIG93bktleXModGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBzZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBzZXQodGFyZ2V0LCBwcm9wOiBzdHJpbmcsIHZhbHVlKSB7XG4gICAgICBjb25zdCBzdG9yYWdlID0gdGFyZ2V0Ll9zdG9yYWdlIHx8ICh0YXJnZXQuX3N0b3JhZ2UgPSBnZXRUYXJnZXQoKSk7XG4gICAgICB0YXJnZXRbcHJvcF0gPSBzdG9yYWdlW3Byb3BdID0gdmFsdWU7IC8vIHNldCB0byB0b3AgbGV2ZWwgc2NvcGUgKyBjYWNoZVxuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5czsgLy8gcmVtb3ZlIGNhY2hlZCBrZXlzXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pIGFzIFJlc29sdmVyUHJveHk8VCwgUj47XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBQcm94eSBmb3IgcmVzb2x2aW5nIG9wdGlvbiB2YWx1ZXMgd2l0aCBjb250ZXh0LlxuICogQHBhcmFtIHByb3h5IC0gVGhlIFByb3h5IHJldHVybmVkIGJ5IGBfY3JlYXRlUmVzb2x2ZXJgXG4gKiBAcGFyYW0gY29udGV4dCAtIENvbnRleHQgb2JqZWN0IGZvciBzY3JpcHRhYmxlL2luZGV4YWJsZSBvcHRpb25zXG4gKiBAcGFyYW0gc3ViUHJveHkgLSBUaGUgcHJveHkgcHJvdmlkZWQgZm9yIHNjcmlwdGFibGUgb3B0aW9uc1xuICogQHBhcmFtIGRlc2NyaXB0b3JEZWZhdWx0cyAtIERlZmF1bHRzIGZvciBkZXNjcmlwdG9yc1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hdHRhY2hDb250ZXh0PFxuICBUIGV4dGVuZHMgQW55T2JqZWN0W10gPSBBbnlPYmplY3RbXSxcbiAgUiBleHRlbmRzIEFueU9iamVjdFtdID0gVFxuPihcbiAgcHJveHk6IFJlc29sdmVyUHJveHk8VCwgUj4sXG4gIGNvbnRleHQ6IEFueU9iamVjdCxcbiAgc3ViUHJveHk/OiBSZXNvbHZlclByb3h5PFQsIFI+LFxuICBkZXNjcmlwdG9yRGVmYXVsdHM/OiBEZXNjcmlwdG9yRGVmYXVsdHNcbikge1xuICBjb25zdCBjYWNoZTogQ29udGV4dENhY2hlPFQsIFI+ID0ge1xuICAgIF9jYWNoZWFibGU6IGZhbHNlLFxuICAgIF9wcm94eTogcHJveHksXG4gICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgX3N1YlByb3h5OiBzdWJQcm94eSxcbiAgICBfc3RhY2s6IG5ldyBTZXQoKSxcbiAgICBfZGVzY3JpcHRvcnM6IF9kZXNjcmlwdG9ycyhwcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICBzZXRDb250ZXh0OiAoY3R4OiBBbnlPYmplY3QpID0+IF9hdHRhY2hDb250ZXh0KHByb3h5LCBjdHgsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpLFxuICAgIG92ZXJyaWRlOiAoc2NvcGU6IEFueU9iamVjdCkgPT4gX2F0dGFjaENvbnRleHQocHJveHkub3ZlcnJpZGUoc2NvcGUpLCBjb250ZXh0LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKVxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgZGVsZXRlIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gY2FjaGVcbiAgICAgIGRlbGV0ZSBwcm94eVtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gcHJveHlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIGdldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGdldCh0YXJnZXQsIHByb3A6IHN0cmluZywgcmVjZWl2ZXIpIHtcbiAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCxcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoQ29udGV4dCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvci5cbiAgICAgKiBBbHNvIHVzZWQgYnkgT2JqZWN0Lmhhc093blByb3BlcnR5LlxuICAgICAqL1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiB0YXJnZXQuX2Rlc2NyaXB0b3JzLmFsbEtleXNcbiAgICAgICAgPyBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCkgPyB7ZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSA6IHVuZGVmaW5lZFxuICAgICAgICA6IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3h5LCBwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YuXG4gICAgICovXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihwcm94eSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgdGhlIGluIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgYW5kIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMuXG4gICAgICovXG4gICAgb3duS2V5cygpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMocHJveHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHNldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBwcm94eVtwcm9wXSA9IHZhbHVlOyAvLyBzZXQgdG8gcHJveHlcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07IC8vIHJlbW92ZSBmcm9tIGNhY2hlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pIGFzIENvbnRleHRQcm94eTxULCBSPjtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2Rlc2NyaXB0b3JzKFxuICBwcm94eTogUmVzb2x2ZXJDYWNoZSxcbiAgZGVmYXVsdHM6IERlc2NyaXB0b3JEZWZhdWx0cyA9IHtzY3JpcHRhYmxlOiB0cnVlLCBpbmRleGFibGU6IHRydWV9XG4pOiBEZXNjcmlwdG9yIHtcbiAgY29uc3Qge19zY3JpcHRhYmxlID0gZGVmYXVsdHMuc2NyaXB0YWJsZSwgX2luZGV4YWJsZSA9IGRlZmF1bHRzLmluZGV4YWJsZSwgX2FsbEtleXMgPSBkZWZhdWx0cy5hbGxLZXlzfSA9IHByb3h5O1xuICByZXR1cm4ge1xuICAgIGFsbEtleXM6IF9hbGxLZXlzLFxuICAgIHNjcmlwdGFibGU6IF9zY3JpcHRhYmxlLFxuICAgIGluZGV4YWJsZTogX2luZGV4YWJsZSxcbiAgICBpc1NjcmlwdGFibGU6IGlzRnVuY3Rpb24oX3NjcmlwdGFibGUpID8gX3NjcmlwdGFibGUgOiAoKSA9PiBfc2NyaXB0YWJsZSxcbiAgICBpc0luZGV4YWJsZTogaXNGdW5jdGlvbihfaW5kZXhhYmxlKSA/IF9pbmRleGFibGUgOiAoKSA9PiBfaW5kZXhhYmxlXG4gIH07XG59XG5cbmNvbnN0IHJlYWRLZXkgPSAocHJlZml4OiBzdHJpbmcsIG5hbWU6IHN0cmluZykgPT4gcHJlZml4ID8gcHJlZml4ICsgX2NhcGl0YWxpemUobmFtZSkgOiBuYW1lO1xuY29uc3QgbmVlZHNTdWJSZXNvbHZlciA9IChwcm9wOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgcHJvcCAhPT0gJ2FkYXB0ZXJzJyAmJlxuICAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gbnVsbCB8fCB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KTtcblxuZnVuY3Rpb24gX2NhY2hlZChcbiAgdGFyZ2V0OiBBbnlPYmplY3QsXG4gIHByb3A6IHN0cmluZyxcbiAgcmVzb2x2ZTogKCkgPT4gdW5rbm93blxuKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBwcm9wKSkge1xuICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gIH1cblxuICBjb25zdCB2YWx1ZSA9IHJlc29sdmUoKTtcbiAgLy8gY2FjaGUgdGhlIHJlc29sdmVkIHZhbHVlXG4gIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aENvbnRleHQoXG4gIHRhcmdldDogQ29udGV4dENhY2hlLFxuICBwcm9wOiBzdHJpbmcsXG4gIHJlY2VpdmVyOiBBbnlPYmplY3Rcbikge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzfSA9IHRhcmdldDtcbiAgbGV0IHZhbHVlID0gX3Byb3h5W3Byb3BdOyAvLyByZXNvbHZlIGZyb20gcHJveHlcblxuICAvLyByZXNvbHZlIHdpdGggY29udGV4dFxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkgJiYgZGVzY3JpcHRvcnMuaXNTY3JpcHRhYmxlKHByb3ApKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZVNjcmlwdGFibGUocHJvcCwgdmFsdWUsIHRhcmdldCwgcmVjZWl2ZXIpO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlQXJyYXkocHJvcCwgdmFsdWUsIHRhcmdldCwgZGVzY3JpcHRvcnMuaXNJbmRleGFibGUpO1xuICB9XG4gIGlmIChuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKSkge1xuICAgIC8vIGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhbiBvYmplY3QsIGNyZWF0ZSBhIHN1YiByZXNvbHZlciBmb3IgaXRcbiAgICB2YWx1ZSA9IF9hdHRhY2hDb250ZXh0KHZhbHVlLCBfY29udGV4dCwgX3N1YlByb3h5ICYmIF9zdWJQcm94eVtwcm9wXSwgZGVzY3JpcHRvcnMpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVTY3JpcHRhYmxlKFxuICBwcm9wOiBzdHJpbmcsXG4gIGdldFZhbHVlOiAoY3R4OiBBbnlPYmplY3QsIHN1YjogQW55T2JqZWN0KSA9PiB1bmtub3duLFxuICB0YXJnZXQ6IENvbnRleHRDYWNoZSxcbiAgcmVjZWl2ZXI6IEFueU9iamVjdFxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9zdGFja30gPSB0YXJnZXQ7XG4gIGlmIChfc3RhY2suaGFzKHByb3ApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWN1cnNpb24gZGV0ZWN0ZWQ6ICcgKyBBcnJheS5mcm9tKF9zdGFjaykuam9pbignLT4nKSArICctPicgKyBwcm9wKTtcbiAgfVxuICBfc3RhY2suYWRkKHByb3ApO1xuICBsZXQgdmFsdWUgPSBnZXRWYWx1ZShfY29udGV4dCwgX3N1YlByb3h5IHx8IHJlY2VpdmVyKTtcbiAgX3N0YWNrLmRlbGV0ZShwcm9wKTtcbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgLy8gV2hlbiBzY3JpcHRhYmxlIG9wdGlvbiByZXR1cm5zIGFuIG9iamVjdCwgY3JlYXRlIGEgcmVzb2x2ZXIgb24gdGhhdC5cbiAgICB2YWx1ZSA9IGNyZWF0ZVN1YlJlc29sdmVyKF9wcm94eS5fc2NvcGVzLCBfcHJveHksIHByb3AsIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlQXJyYXkoXG4gIHByb3A6IHN0cmluZyxcbiAgdmFsdWU6IHVua25vd25bXSxcbiAgdGFyZ2V0OiBDb250ZXh0Q2FjaGUsXG4gIGlzSW5kZXhhYmxlOiAoa2V5OiBzdHJpbmcpID0+IGJvb2xlYW5cbikge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzfSA9IHRhcmdldDtcblxuICBpZiAodHlwZW9mIF9jb250ZXh0LmluZGV4ICE9PSAndW5kZWZpbmVkJyAmJiBpc0luZGV4YWJsZShwcm9wKSkge1xuICAgIHJldHVybiB2YWx1ZVtfY29udGV4dC5pbmRleCAlIHZhbHVlLmxlbmd0aF07XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWVbMF0pKSB7XG4gICAgLy8gQXJyYXkgb2Ygb2JqZWN0cywgcmV0dXJuIGFycmF5IG9yIHJlc29sdmVyc1xuICAgIGNvbnN0IGFyciA9IHZhbHVlO1xuICAgIGNvbnN0IHNjb3BlcyA9IF9wcm94eS5fc2NvcGVzLmZpbHRlcihzID0+IHMgIT09IGFycik7XG4gICAgdmFsdWUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICBjb25zdCByZXNvbHZlciA9IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgX3Byb3h5LCBwcm9wLCBpdGVtKTtcbiAgICAgIHZhbHVlLnB1c2goX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVGYWxsYmFjayhcbiAgZmFsbGJhY2s6IFJlc29sdmVyT2JqZWN0S2V5IHwgKChwcm9wOiBSZXNvbHZlck9iamVjdEtleSwgdmFsdWU6IHVua25vd24pID0+IFJlc29sdmVyT2JqZWN0S2V5KSxcbiAgcHJvcDogUmVzb2x2ZXJPYmplY3RLZXksXG4gIHZhbHVlOiB1bmtub3duXG4pIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oZmFsbGJhY2spID8gZmFsbGJhY2socHJvcCwgdmFsdWUpIDogZmFsbGJhY2s7XG59XG5cbmNvbnN0IGdldFNjb3BlID0gKGtleTogUmVzb2x2ZXJPYmplY3RLZXksIHBhcmVudDogQW55T2JqZWN0KSA9PiBrZXkgPT09IHRydWUgPyBwYXJlbnRcbiAgOiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IHJlc29sdmVPYmplY3RLZXkocGFyZW50LCBrZXkpIDogdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBhZGRTY29wZXMoXG4gIHNldDogU2V0PEFueU9iamVjdD4sXG4gIHBhcmVudFNjb3BlczogQW55T2JqZWN0W10sXG4gIGtleTogUmVzb2x2ZXJPYmplY3RLZXksXG4gIHBhcmVudEZhbGxiYWNrOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBmb3IgKGNvbnN0IHBhcmVudCBvZiBwYXJlbnRTY29wZXMpIHtcbiAgICBjb25zdCBzY29wZSA9IGdldFNjb3BlKGtleSwgcGFyZW50KTtcbiAgICBpZiAoc2NvcGUpIHtcbiAgICAgIHNldC5hZGQoc2NvcGUpO1xuICAgICAgY29uc3QgZmFsbGJhY2sgPSByZXNvbHZlRmFsbGJhY2soc2NvcGUuX2ZhbGxiYWNrLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICh0eXBlb2YgZmFsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGZhbGxiYWNrICE9PSBrZXkgJiYgZmFsbGJhY2sgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgcmVhY2ggdGhlIGRlc2NyaXB0b3IgdGhhdCBkZWZpbmVzIGEgbmV3IF9mYWxsYmFjaywgcmV0dXJuIHRoYXQuXG4gICAgICAgIC8vIFRoZSBmYWxsYmFjayB3aWxsIHJlc3VtZSB0byB0aGF0IG5ldyBzY29wZS5cbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2NvcGUgPT09IGZhbHNlICYmIHR5cGVvZiBwYXJlbnRGYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcgJiYga2V5ICE9PSBwYXJlbnRGYWxsYmFjaykge1xuICAgICAgLy8gRmFsbGJhY2sgdG8gYGZhbHNlYCByZXN1bHRzIHRvIGBmYWxzZWAsIHdoZW4gZmFsbGluZyBiYWNrIHRvIGRpZmZlcmVudCBrZXkuXG4gICAgICAvLyBGb3IgZXhhbXBsZSBgaW50ZXJhY3Rpb25gIGZyb20gYGhvdmVyYCBvciBgcGx1Z2lucy50b29sdGlwYCBhbmQgYGFuaW1hdGlvbmAgZnJvbSBgYW5pbWF0aW9uc2BcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN1YlJlc29sdmVyKFxuICBwYXJlbnRTY29wZXM6IEFueU9iamVjdFtdLFxuICByZXNvbHZlcjogUmVzb2x2ZXJDYWNoZSxcbiAgcHJvcDogUmVzb2x2ZXJPYmplY3RLZXksXG4gIHZhbHVlOiB1bmtub3duXG4pIHtcbiAgY29uc3Qgcm9vdFNjb3BlcyA9IHJlc29sdmVyLl9yb290U2NvcGVzO1xuICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhyZXNvbHZlci5fZmFsbGJhY2ssIHByb3AsIHZhbHVlKTtcbiAgY29uc3QgYWxsU2NvcGVzID0gWy4uLnBhcmVudFNjb3BlcywgLi4ucm9vdFNjb3Blc107XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQ8QW55T2JqZWN0PigpO1xuICBzZXQuYWRkKHZhbHVlKTtcbiAgbGV0IGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIHByb3AsIGZhbGxiYWNrIHx8IHByb3AsIHZhbHVlKTtcbiAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGZhbGxiYWNrICE9PSAndW5kZWZpbmVkJyAmJiBmYWxsYmFjayAhPT0gcHJvcCkge1xuICAgIGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIGZhbGxiYWNrLCBrZXksIHZhbHVlKTtcbiAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfY3JlYXRlUmVzb2x2ZXIoQXJyYXkuZnJvbShzZXQpLCBbJyddLCByb290U2NvcGVzLCBmYWxsYmFjayxcbiAgICAoKSA9PiBzdWJHZXRUYXJnZXQocmVzb2x2ZXIsIHByb3AgYXMgc3RyaW5nLCB2YWx1ZSkpO1xufVxuXG5mdW5jdGlvbiBhZGRTY29wZXNGcm9tS2V5KFxuICBzZXQ6IFNldDxBbnlPYmplY3Q+LFxuICBhbGxTY29wZXM6IEFueU9iamVjdFtdLFxuICBrZXk6IFJlc29sdmVyT2JqZWN0S2V5LFxuICBmYWxsYmFjazogUmVzb2x2ZXJPYmplY3RLZXksXG4gIGl0ZW06IHVua25vd25cbikge1xuICB3aGlsZSAoa2V5KSB7XG4gICAga2V5ID0gYWRkU2NvcGVzKHNldCwgYWxsU2NvcGVzLCBrZXksIGZhbGxiYWNrLCBpdGVtKTtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuXG5mdW5jdGlvbiBzdWJHZXRUYXJnZXQoXG4gIHJlc29sdmVyOiBSZXNvbHZlckNhY2hlLFxuICBwcm9wOiBzdHJpbmcsXG4gIHZhbHVlOiB1bmtub3duXG4pIHtcbiAgY29uc3QgcGFyZW50ID0gcmVzb2x2ZXIuX2dldFRhcmdldCgpO1xuICBpZiAoIShwcm9wIGluIHBhcmVudCkpIHtcbiAgICBwYXJlbnRbcHJvcF0gPSB7fTtcbiAgfVxuICBjb25zdCB0YXJnZXQgPSBwYXJlbnRbcHJvcF07XG4gIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgLy8gRm9yIGFycmF5IG9mIG9iamVjdHMsIHRoZSBvYmplY3QgaXMgdXNlZCB0byBzdG9yZSB1cGRhdGVkIHZhbHVlc1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0IHx8IHt9O1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhcbiAgcHJvcDogc3RyaW5nLFxuICBwcmVmaXhlczogc3RyaW5nW10sXG4gIHNjb3BlczogQW55T2JqZWN0W10sXG4gIHByb3h5OiBSZXNvbHZlclByb3h5XG4pIHtcbiAgbGV0IHZhbHVlOiB1bmtub3duO1xuICBmb3IgKGNvbnN0IHByZWZpeCBvZiBwcmVmaXhlcykge1xuICAgIHZhbHVlID0gX3Jlc29sdmUocmVhZEtleShwcmVmaXgsIHByb3ApLCBzY29wZXMpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSlcbiAgICAgICAgPyBjcmVhdGVTdWJSZXNvbHZlcihzY29wZXMsIHByb3h5LCBwcm9wLCB2YWx1ZSlcbiAgICAgICAgOiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX3Jlc29sdmUoa2V5OiBzdHJpbmcsIHNjb3BlczogQW55T2JqZWN0W10pIHtcbiAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICBpZiAoIXNjb3BlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBzY29wZVtrZXldO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldDogUmVzb2x2ZXJDYWNoZSkge1xuICBsZXQga2V5cyA9IHRhcmdldC5fa2V5cztcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5cyA9IHRhcmdldC5fa2V5cyA9IHJlc29sdmVLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQuX3Njb3Blcyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVLZXlzRnJvbUFsbFNjb3BlcyhzY29wZXM6IEFueU9iamVjdFtdKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjb3BlKS5maWx0ZXIoayA9PiAhay5zdGFydHNXaXRoKCdfJykpKSB7XG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUoXG4gIG1ldGE6IENoYXJ0TWV0YTwnbGluZScgfCAnc2NhdHRlcic+LFxuICBkYXRhOiBBbnlPYmplY3RbXSxcbiAgc3RhcnQ6IG51bWJlcixcbiAgY291bnQ6IG51bWJlclxuKSB7XG4gIGNvbnN0IHtpU2NhbGV9ID0gbWV0YTtcbiAgY29uc3Qge2tleSA9ICdyJ30gPSB0aGlzLl9wYXJzaW5nO1xuICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXk8e3I6IHVua25vd259Pihjb3VudCk7XG4gIGxldCBpOiBudW1iZXIsIGlsZW46IG51bWJlciwgaW5kZXg6IG51bWJlciwgaXRlbTogQW55T2JqZWN0O1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICBwYXJzZWRbaV0gPSB7XG4gICAgICByOiBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCBrZXkpLCBpbmRleClcbiAgICB9O1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG4iLCAiaW1wb3J0IHthbG1vc3RFcXVhbHMsIGRpc3RhbmNlQmV0d2VlblBvaW50cywgc2lnbn0gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfaXNQb2ludEluQXJlYX0gZnJvbSAnLi9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRBcmVhfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7U3BsaW5lUG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5cbmNvbnN0IEVQU0lMT04gPSBOdW1iZXIuRVBTSUxPTiB8fCAxZS0xNDtcblxudHlwZSBPcHRpb25hbFNwbGluZVBvaW50ID0gU3BsaW5lUG9pbnQgfCBmYWxzZVxuY29uc3QgZ2V0UG9pbnQgPSAocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBpOiBudW1iZXIpOiBPcHRpb25hbFNwbGluZVBvaW50ID0+IGkgPCBwb2ludHMubGVuZ3RoICYmICFwb2ludHNbaV0uc2tpcCAmJiBwb2ludHNbaV07XG5jb25zdCBnZXRWYWx1ZUF4aXMgPSAoaW5kZXhBeGlzOiAneCcgfCAneScpID0+IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuXG5leHBvcnQgZnVuY3Rpb24gc3BsaW5lQ3VydmUoXG4gIGZpcnN0UG9pbnQ6IFNwbGluZVBvaW50LFxuICBtaWRkbGVQb2ludDogU3BsaW5lUG9pbnQsXG4gIGFmdGVyUG9pbnQ6IFNwbGluZVBvaW50LFxuICB0OiBudW1iZXJcbik6IHtcbiAgICBwcmV2aW91czogU3BsaW5lUG9pbnRcbiAgICBuZXh0OiBTcGxpbmVQb2ludFxuICB9IHtcbiAgLy8gUHJvcHMgdG8gUm9iIFNwZW5jZXIgYXQgc2NhbGVkIGlubm92YXRpb24gZm9yIGhpcyBwb3N0IG9uIHNwbGluaW5nIGJldHdlZW4gcG9pbnRzXG4gIC8vIGh0dHA6Ly9zY2FsZWRpbm5vdmF0aW9uLmNvbS9hbmFseXRpY3Mvc3BsaW5lcy9hYm91dFNwbGluZXMuaHRtbFxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gbXVzdCBhbHNvIHJlc3BlY3QgXCJza2lwcGVkXCIgcG9pbnRzXG5cbiAgY29uc3QgcHJldmlvdXMgPSBmaXJzdFBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGZpcnN0UG9pbnQ7XG4gIGNvbnN0IGN1cnJlbnQgPSBtaWRkbGVQb2ludDtcbiAgY29uc3QgbmV4dCA9IGFmdGVyUG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogYWZ0ZXJQb2ludDtcbiAgY29uc3QgZDAxID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGN1cnJlbnQsIHByZXZpb3VzKTtcbiAgY29uc3QgZDEyID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKG5leHQsIGN1cnJlbnQpO1xuXG4gIGxldCBzMDEgPSBkMDEgLyAoZDAxICsgZDEyKTtcbiAgbGV0IHMxMiA9IGQxMiAvIChkMDEgKyBkMTIpO1xuXG4gIC8vIElmIGFsbCBwb2ludHMgYXJlIHRoZSBzYW1lLCBzMDEgJiBzMDIgd2lsbCBiZSBpbmZcbiAgczAxID0gaXNOYU4oczAxKSA/IDAgOiBzMDE7XG4gIHMxMiA9IGlzTmFOKHMxMikgPyAwIDogczEyO1xuXG4gIGNvbnN0IGZhID0gdCAqIHMwMTsgLy8gc2NhbGluZyBmYWN0b3IgZm9yIHRyaWFuZ2xlIFRhXG4gIGNvbnN0IGZiID0gdCAqIHMxMjtcblxuICByZXR1cm4ge1xuICAgIHByZXZpb3VzOiB7XG4gICAgICB4OiBjdXJyZW50LnggLSBmYSAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcbiAgICAgIHk6IGN1cnJlbnQueSAtIGZhICogKG5leHQueSAtIHByZXZpb3VzLnkpXG4gICAgfSxcbiAgICBuZXh0OiB7XG4gICAgICB4OiBjdXJyZW50LnggKyBmYiAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcbiAgICAgIHk6IGN1cnJlbnQueSArIGZiICogKG5leHQueSAtIHByZXZpb3VzLnkpXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEFkanVzdCB0YW5nZW50cyB0byBlbnN1cmUgbW9ub3RvbmljIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbW9ub3RvbmVBZGp1c3QocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBkZWx0YUs6IG51bWJlcltdLCBtSzogbnVtYmVyW10pIHtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcblxuICBsZXQgYWxwaGFLOiBudW1iZXIsIGJldGFLOiBudW1iZXIsIHRhdUs6IG51bWJlciwgc3F1YXJlZE1hZ25pdHVkZTogbnVtYmVyLCBwb2ludEN1cnJlbnQ6IE9wdGlvbmFsU3BsaW5lUG9pbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNMZW4gLSAxOyArK2kpIHtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCB8fCAhcG9pbnRBZnRlcikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGFsbW9zdEVxdWFscyhkZWx0YUtbaV0sIDAsIEVQU0lMT04pKSB7XG4gICAgICBtS1tpXSA9IG1LW2kgKyAxXSA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBhbHBoYUsgPSBtS1tpXSAvIGRlbHRhS1tpXTtcbiAgICBiZXRhSyA9IG1LW2kgKyAxXSAvIGRlbHRhS1tpXTtcbiAgICBzcXVhcmVkTWFnbml0dWRlID0gTWF0aC5wb3coYWxwaGFLLCAyKSArIE1hdGgucG93KGJldGFLLCAyKTtcbiAgICBpZiAoc3F1YXJlZE1hZ25pdHVkZSA8PSA5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0YXVLID0gMyAvIE1hdGguc3FydChzcXVhcmVkTWFnbml0dWRlKTtcbiAgICBtS1tpXSA9IGFscGhhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gICAgbUtbaSArIDFdID0gYmV0YUsgKiB0YXVLICogZGVsdGFLW2ldO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vbm90b25lQ29tcHV0ZShwb2ludHM6IFNwbGluZVBvaW50W10sIG1LOiBudW1iZXJbXSwgaW5kZXhBeGlzOiAneCcgfCAneScgPSAneCcpIHtcbiAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBkZWx0YTogbnVtYmVyLCBwb2ludEJlZm9yZTogT3B0aW9uYWxTcGxpbmVQb2ludCwgcG9pbnRDdXJyZW50OiBPcHRpb25hbFNwbGluZVBvaW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBpUGl4ZWwgPSBwb2ludEN1cnJlbnRbaW5kZXhBeGlzXTtcbiAgICBjb25zdCB2UGl4ZWwgPSBwb2ludEN1cnJlbnRbdmFsdWVBeGlzXTtcbiAgICBpZiAocG9pbnRCZWZvcmUpIHtcbiAgICAgIGRlbHRhID0gKGlQaXhlbCAtIHBvaW50QmVmb3JlW2luZGV4QXhpc10pIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgLSBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgLSBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgZGVsdGEgPSAocG9pbnRBZnRlcltpbmRleEF4aXNdIC0gaVBpeGVsKSAvIDM7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7aW5kZXhBeGlzfWBdID0gaVBpeGVsICsgZGVsdGE7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7dmFsdWVBeGlzfWBdID0gdlBpeGVsICsgZGVsdGEgKiBtS1tpXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgQsOpemllciBjb250cm9sIHBvaW50cyBpbiBhIHNpbWlsYXIgd2F5IHRoYW4gfHNwbGluZUN1cnZlfCxcbiAqIGJ1dCBwcmVzZXJ2ZXMgbW9ub3RvbmljaXR5IG9mIHRoZSBwcm92aWRlZCBkYXRhIGFuZCBlbnN1cmVzIG5vIGxvY2FsIGV4dHJlbXVtcyBhcmUgYWRkZWRcbiAqIGJldHdlZW4gdGhlIGRhdGFzZXQgZGlzY3JldGUgcG9pbnRzIGR1ZSB0byB0aGUgaW50ZXJwb2xhdGlvbi5cbiAqIFNlZSA6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vbm90b25lX2N1YmljX2ludGVycG9sYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBpbmRleEF4aXM6ICd4JyB8ICd5JyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgZGVsdGFLOiBudW1iZXJbXSA9IEFycmF5KHBvaW50c0xlbikuZmlsbCgwKTtcbiAgY29uc3QgbUs6IG51bWJlcltdID0gQXJyYXkocG9pbnRzTGVuKTtcblxuICAvLyBDYWxjdWxhdGUgc2xvcGVzIChkZWx0YUspIGFuZCBpbml0aWFsaXplIHRhbmdlbnRzIChtSylcbiAgbGV0IGksIHBvaW50QmVmb3JlOiBPcHRpb25hbFNwbGluZVBvaW50LCBwb2ludEN1cnJlbnQ6IE9wdGlvbmFsU3BsaW5lUG9pbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcbiAgICBwb2ludEJlZm9yZSA9IHBvaW50Q3VycmVudDtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHBvaW50QWZ0ZXIpIHtcbiAgICAgIGNvbnN0IHNsb3BlRGVsdGEgPSBwb2ludEFmdGVyW2luZGV4QXhpc10gLSBwb2ludEN1cnJlbnRbaW5kZXhBeGlzXTtcblxuICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgdHdvIHBvaW50cyB0aGF0IGFwcGVhciBhdCB0aGUgc2FtZSB4IHBpeGVsLCBzbG9wZURlbHRhWCBpcyAwXG4gICAgICBkZWx0YUtbaV0gPSBzbG9wZURlbHRhICE9PSAwID8gKHBvaW50QWZ0ZXJbdmFsdWVBeGlzXSAtIHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdKSAvIHNsb3BlRGVsdGEgOiAwO1xuICAgIH1cbiAgICBtS1tpXSA9ICFwb2ludEJlZm9yZSA/IGRlbHRhS1tpXVxuICAgICAgOiAhcG9pbnRBZnRlciA/IGRlbHRhS1tpIC0gMV1cbiAgICAgICAgOiAoc2lnbihkZWx0YUtbaSAtIDFdKSAhPT0gc2lnbihkZWx0YUtbaV0pKSA/IDBcbiAgICAgICAgICA6IChkZWx0YUtbaSAtIDFdICsgZGVsdGFLW2ldKSAvIDI7XG4gIH1cblxuICBtb25vdG9uZUFkanVzdChwb2ludHMsIGRlbHRhSywgbUspO1xuXG4gIG1vbm90b25lQ29tcHV0ZShwb2ludHMsIG1LLCBpbmRleEF4aXMpO1xufVxuXG5mdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQ6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihwdCwgbWF4KSwgbWluKTtcbn1cblxuZnVuY3Rpb24gY2FwQmV6aWVyUG9pbnRzKHBvaW50czogU3BsaW5lUG9pbnRbXSwgYXJlYTogQ2hhcnRBcmVhKSB7XG4gIGxldCBpLCBpbGVuLCBwb2ludCwgaW5BcmVhLCBpbkFyZWFQcmV2O1xuICBsZXQgaW5BcmVhTmV4dCA9IF9pc1BvaW50SW5BcmVhKHBvaW50c1swXSwgYXJlYSk7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaW5BcmVhUHJldiA9IGluQXJlYTtcbiAgICBpbkFyZWEgPSBpbkFyZWFOZXh0O1xuICAgIGluQXJlYU5leHQgPSBpIDwgaWxlbiAtIDEgJiYgX2lzUG9pbnRJbkFyZWEocG9pbnRzW2kgKyAxXSwgYXJlYSk7XG4gICAgaWYgKCFpbkFyZWEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICBpZiAoaW5BcmVhUHJldikge1xuICAgICAgcG9pbnQuY3AxeCA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDF4LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuICAgICAgcG9pbnQuY3AxeSA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDF5LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuICAgIH1cbiAgICBpZiAoaW5BcmVhTmV4dCkge1xuICAgICAgcG9pbnQuY3AyeCA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDJ4LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuICAgICAgcG9pbnQuY3AyeSA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDJ5LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyhcbiAgcG9pbnRzOiBTcGxpbmVQb2ludFtdLFxuICBvcHRpb25zLFxuICBhcmVhOiBDaGFydEFyZWEsXG4gIGxvb3A6IGJvb2xlYW4sXG4gIGluZGV4QXhpczogJ3gnIHwgJ3knXG4pIHtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCBwb2ludDogU3BsaW5lUG9pbnQsIGNvbnRyb2xQb2ludHM6IFJldHVyblR5cGU8dHlwZW9mIHNwbGluZUN1cnZlPjtcblxuICAvLyBPbmx5IGNvbnNpZGVyIHBvaW50cyB0aGF0IGFyZSBkcmF3biBpbiBjYXNlIHRoZSBzcGFuR2FwcyBvcHRpb24gaXMgdXNlZFxuICBpZiAob3B0aW9ucy5zcGFuR2Fwcykge1xuICAgIHBvaW50cyA9IHBvaW50cy5maWx0ZXIoKHB0KSA9PiAhcHQuc2tpcCk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMsIGluZGV4QXhpcyk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHByZXYgPSBsb29wID8gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSA6IHBvaW50c1swXTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb250cm9sUG9pbnRzID0gc3BsaW5lQ3VydmUoXG4gICAgICAgIHByZXYsXG4gICAgICAgIHBvaW50LFxuICAgICAgICBwb2ludHNbTWF0aC5taW4oaSArIDEsIGlsZW4gLSAobG9vcCA/IDAgOiAxKSkgJSBpbGVuXSxcbiAgICAgICAgb3B0aW9ucy50ZW5zaW9uXG4gICAgICApO1xuICAgICAgcG9pbnQuY3AxeCA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueDtcbiAgICAgIHBvaW50LmNwMXkgPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLnk7XG4gICAgICBwb2ludC5jcDJ4ID0gY29udHJvbFBvaW50cy5uZXh0Lng7XG4gICAgICBwb2ludC5jcDJ5ID0gY29udHJvbFBvaW50cy5uZXh0Lnk7XG4gICAgICBwcmV2ID0gcG9pbnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuY2FwQmV6aWVyUG9pbnRzKSB7XG4gICAgY2FwQmV6aWVyUG9pbnRzKHBvaW50cywgYXJlYSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7Q2hhcnRBcmVhLCBTY2FsZX0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUgQ2hhcnQgZnJvbSAnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0RXZlbnR9IGZyb20gJy4uL3R5cGVzLmpzJztcbmltcG9ydCB7SU5GSU5JVFl9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcblxuLyoqXG4gKiBOb3RlOiB0eXBlZGVmcyBhcmUgYXV0by1leHBvcnRlZCwgc28gdXNlIGEgbWFkZS11cCBgZG9tYCBuYW1lc3BhY2Ugd2hlcmVcbiAqIG5lY2Vzc2FyeSB0byBhdm9pZCBkdXBsaWNhdGVzIHdpdGggYGV4cG9ydCAqIGZyb20gJy4vaGVscGVyc2A7IHNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy80NjAxMVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IGRvbS5DaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL3R5cGVzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqL1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfaXNEb21TdXBwb3J0ZWQoKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0UGFyZW50Tm9kZShkb21Ob2RlOiBIVE1MQ2FudmFzRWxlbWVudCk6IEhUTUxDYW52YXNFbGVtZW50IHtcbiAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCAmJiBwYXJlbnQudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2hhZG93Um9vdF0nKSB7XG4gICAgcGFyZW50ID0gKHBhcmVudCBhcyBTaGFkb3dSb290KS5ob3N0O1xuICB9XG4gIHJldHVybiBwYXJlbnQgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG59XG5cbi8qKlxuICogY29udmVydCBtYXgtd2lkdGgvbWF4LWhlaWdodCB2YWx1ZXMgdGhhdCBtYXkgYmUgcGVyY2VudGFnZXMgaW50byBhIG51bWJlclxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU1heFN0eWxlKHN0eWxlVmFsdWU6IHN0cmluZyB8IG51bWJlciwgbm9kZTogSFRNTEVsZW1lbnQsIHBhcmVudFByb3BlcnR5OiBzdHJpbmcpIHtcbiAgbGV0IHZhbHVlSW5QaXhlbHM6IG51bWJlcjtcbiAgaWYgKHR5cGVvZiBzdHlsZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBwYXJzZUludChzdHlsZVZhbHVlLCAxMCk7XG5cbiAgICBpZiAoc3R5bGVWYWx1ZS5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICAvLyBwZXJjZW50YWdlICogc2l6ZSBpbiBkaW1lbnNpb25cbiAgICAgIHZhbHVlSW5QaXhlbHMgPSAodmFsdWVJblBpeGVscyAvIDEwMCkgKiBub2RlLnBhcmVudE5vZGVbcGFyZW50UHJvcGVydHldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZUluUGl4ZWxzID0gc3R5bGVWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZUluUGl4ZWxzO1xufVxuXG5jb25zdCBnZXRDb21wdXRlZFN0eWxlID0gKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQ1NTU3R5bGVEZWNsYXJhdGlvbiA9PlxuICBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0eWxlKGVsOiBIVE1MRWxlbWVudCwgcHJvcGVydHk6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbn1cblxuY29uc3QgcG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcbmZ1bmN0aW9uIGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZXM6IENTU1N0eWxlRGVjbGFyYXRpb24sIHN0eWxlOiBzdHJpbmcsIHN1ZmZpeD86IHN0cmluZyk6IENoYXJ0QXJlYSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9IGFzIENoYXJ0QXJlYTtcbiAgc3VmZml4ID0gc3VmZml4ID8gJy0nICsgc3VmZml4IDogJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgY29uc3QgcG9zID0gcG9zaXRpb25zW2ldO1xuICAgIHJlc3VsdFtwb3NdID0gcGFyc2VGbG9hdChzdHlsZXNbc3R5bGUgKyAnLScgKyBwb3MgKyBzdWZmaXhdKSB8fCAwO1xuICB9XG4gIHJlc3VsdC53aWR0aCA9IHJlc3VsdC5sZWZ0ICsgcmVzdWx0LnJpZ2h0O1xuICByZXN1bHQuaGVpZ2h0ID0gcmVzdWx0LnRvcCArIHJlc3VsdC5ib3R0b207XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IHVzZU9mZnNldFBvcyA9ICh4OiBudW1iZXIsIHk6IG51bWJlciwgdGFyZ2V0OiBIVE1MRWxlbWVudCB8IEV2ZW50VGFyZ2V0KSA9PlxuICAoeCA+IDAgfHwgeSA+IDApICYmICghdGFyZ2V0IHx8ICEodGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5zaGFkb3dSb290KTtcblxuLyoqXG4gKiBAcGFyYW0gZVxuICogQHBhcmFtIGNhbnZhc1xuICogQHJldHVybnMgQ2FudmFzIHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldENhbnZhc1Bvc2l0aW9uKFxuICBlOiBFdmVudCB8IFRvdWNoRXZlbnQgfCBNb3VzZUV2ZW50LFxuICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50XG4pOiB7XG4gICAgeDogbnVtYmVyO1xuICAgIHk6IG51bWJlcjtcbiAgICBib3g6IGJvb2xlYW47XG4gIH0ge1xuICBjb25zdCB0b3VjaGVzID0gKGUgYXMgVG91Y2hFdmVudCkudG91Y2hlcztcbiAgY29uc3Qgc291cmNlID0gKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGggPyB0b3VjaGVzWzBdIDogZSkgYXMgTW91c2VFdmVudDtcbiAgY29uc3Qge29mZnNldFgsIG9mZnNldFl9ID0gc291cmNlIGFzIE1vdXNlRXZlbnQ7XG4gIGxldCBib3ggPSBmYWxzZTtcbiAgbGV0IHgsIHk7XG4gIGlmICh1c2VPZmZzZXRQb3Mob2Zmc2V0WCwgb2Zmc2V0WSwgZS50YXJnZXQpKSB7XG4gICAgeCA9IG9mZnNldFg7XG4gICAgeSA9IG9mZnNldFk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB4ID0gc291cmNlLmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgeSA9IHNvdXJjZS5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgYm94ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4ge3gsIHksIGJveH07XG59XG5cbi8qKlxuICogR2V0cyBhbiBldmVudCdzIHgsIHkgY29vcmRpbmF0ZXMsIHJlbGF0aXZlIHRvIHRoZSBjaGFydCBhcmVhXG4gKiBAcGFyYW0gZXZlbnRcbiAqIEBwYXJhbSBjaGFydFxuICogQHJldHVybnMgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgZXZlbnRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihcbiAgZXZlbnQ6IEV2ZW50IHwgQ2hhcnRFdmVudCB8IFRvdWNoRXZlbnQgfCBNb3VzZUV2ZW50LFxuICBjaGFydDogQ2hhcnRcbik6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB7XG4gIGlmICgnbmF0aXZlJyBpbiBldmVudCkge1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG4gIGNvbnN0IHtjYW52YXMsIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvfSA9IGNoYXJ0O1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY2FudmFzKTtcbiAgY29uc3QgYm9yZGVyQm94ID0gc3R5bGUuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCc7XG4gIGNvbnN0IHBhZGRpbmdzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAncGFkZGluZycpO1xuICBjb25zdCBib3JkZXJzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gIGNvbnN0IHt4LCB5LCBib3h9ID0gZ2V0Q2FudmFzUG9zaXRpb24oZXZlbnQsIGNhbnZhcyk7XG4gIGNvbnN0IHhPZmZzZXQgPSBwYWRkaW5ncy5sZWZ0ICsgKGJveCAmJiBib3JkZXJzLmxlZnQpO1xuICBjb25zdCB5T2Zmc2V0ID0gcGFkZGluZ3MudG9wICsgKGJveCAmJiBib3JkZXJzLnRvcCk7XG5cbiAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNoYXJ0O1xuICBpZiAoYm9yZGVyQm94KSB7XG4gICAgd2lkdGggLT0gcGFkZGluZ3Mud2lkdGggKyBib3JkZXJzLndpZHRoO1xuICAgIGhlaWdodCAtPSBwYWRkaW5ncy5oZWlnaHQgKyBib3JkZXJzLmhlaWdodDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IE1hdGgucm91bmQoKHggLSB4T2Zmc2V0KSAvIHdpZHRoICogY2FudmFzLndpZHRoIC8gY3VycmVudERldmljZVBpeGVsUmF0aW8pLFxuICAgIHk6IE1hdGgucm91bmQoKHkgLSB5T2Zmc2V0KSAvIGhlaWdodCAqIGNhbnZhcy5oZWlnaHQgLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbylcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IFBhcnRpYWw8U2NhbGU+IHtcbiAgbGV0IG1heFdpZHRoOiBudW1iZXIsIG1heEhlaWdodDogbnVtYmVyO1xuXG4gIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgd2lkdGggPSBjYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICBoZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyB0aGlzIGlzIHRoZSBib3JkZXIgYm94IG9mIHRoZSBjb250YWluZXJcbiAgICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICAgICAgY29uc3QgY29udGFpbmVyQm9yZGVyID0gZ2V0UG9zaXRpb25lZFN0eWxlKGNvbnRhaW5lclN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gICAgICBjb25zdCBjb250YWluZXJQYWRkaW5nID0gZ2V0UG9zaXRpb25lZFN0eWxlKGNvbnRhaW5lclN0eWxlLCAncGFkZGluZycpO1xuICAgICAgd2lkdGggPSByZWN0LndpZHRoIC0gY29udGFpbmVyUGFkZGluZy53aWR0aCAtIGNvbnRhaW5lckJvcmRlci53aWR0aDtcbiAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0IC0gY29udGFpbmVyUGFkZGluZy5oZWlnaHQgLSBjb250YWluZXJCb3JkZXIuaGVpZ2h0O1xuICAgICAgbWF4V2lkdGggPSBwYXJzZU1heFN0eWxlKGNvbnRhaW5lclN0eWxlLm1heFdpZHRoLCBjb250YWluZXIsICdjbGllbnRXaWR0aCcpO1xuICAgICAgbWF4SGVpZ2h0ID0gcGFyc2VNYXhTdHlsZShjb250YWluZXJTdHlsZS5tYXhIZWlnaHQsIGNvbnRhaW5lciwgJ2NsaWVudEhlaWdodCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBtYXhXaWR0aDogbWF4V2lkdGggfHwgSU5GSU5JVFksXG4gICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHQgfHwgSU5GSU5JVFlcbiAgfTtcbn1cblxuY29uc3Qgcm91bmQxID0gKHY6IG51bWJlcikgPT4gTWF0aC5yb3VuZCh2ICogMTApIC8gMTA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgZnVuY3Rpb24gZ2V0TWF4aW11bVNpemUoXG4gIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsXG4gIGJiV2lkdGg/OiBudW1iZXIsXG4gIGJiSGVpZ2h0PzogbnVtYmVyLFxuICBhc3BlY3RSYXRpbz86IG51bWJlclxuKTogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9IHtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNhbnZhcyk7XG4gIGNvbnN0IG1hcmdpbnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdtYXJnaW4nKTtcbiAgY29uc3QgbWF4V2lkdGggPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heFdpZHRoLCBjYW52YXMsICdjbGllbnRXaWR0aCcpIHx8IElORklOSVRZO1xuICBjb25zdCBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heEhlaWdodCwgY2FudmFzLCAnY2xpZW50SGVpZ2h0JykgfHwgSU5GSU5JVFk7XG4gIGNvbnN0IGNvbnRhaW5lclNpemUgPSBnZXRDb250YWluZXJTaXplKGNhbnZhcywgYmJXaWR0aCwgYmJIZWlnaHQpO1xuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY29udGFpbmVyU2l6ZTtcblxuICBpZiAoc3R5bGUuYm94U2l6aW5nID09PSAnY29udGVudC1ib3gnKSB7XG4gICAgY29uc3QgYm9yZGVycyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICAgIGNvbnN0IHBhZGRpbmdzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAncGFkZGluZycpO1xuICAgIHdpZHRoIC09IHBhZGRpbmdzLndpZHRoICsgYm9yZGVycy53aWR0aDtcbiAgICBoZWlnaHQgLT0gcGFkZGluZ3MuaGVpZ2h0ICsgYm9yZGVycy5oZWlnaHQ7XG4gIH1cbiAgd2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCAtIG1hcmdpbnMud2lkdGgpO1xuICBoZWlnaHQgPSBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbyA/IHdpZHRoIC8gYXNwZWN0UmF0aW8gOiBoZWlnaHQgLSBtYXJnaW5zLmhlaWdodCk7XG4gIHdpZHRoID0gcm91bmQxKE1hdGgubWluKHdpZHRoLCBtYXhXaWR0aCwgY29udGFpbmVyU2l6ZS5tYXhXaWR0aCkpO1xuICBoZWlnaHQgPSByb3VuZDEoTWF0aC5taW4oaGVpZ2h0LCBtYXhIZWlnaHQsIGNvbnRhaW5lclNpemUubWF4SGVpZ2h0KSk7XG4gIGlmICh3aWR0aCAmJiAhaGVpZ2h0KSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQ2NTlcbiAgICAvLyBJZiB0aGUgY2FudmFzIGhhcyB3aWR0aCwgYnV0IG5vIGhlaWdodCwgZGVmYXVsdCB0byBhc3BlY3RSYXRpbyBvZiAyIChjYW52YXMgZGVmYXVsdClcbiAgICBoZWlnaHQgPSByb3VuZDEod2lkdGggLyAyKTtcbiAgfVxuXG4gIGNvbnN0IG1haW50YWluSGVpZ2h0ID0gYmJXaWR0aCAhPT0gdW5kZWZpbmVkIHx8IGJiSGVpZ2h0ICE9PSB1bmRlZmluZWQ7XG5cbiAgaWYgKG1haW50YWluSGVpZ2h0ICYmIGFzcGVjdFJhdGlvICYmIGNvbnRhaW5lclNpemUuaGVpZ2h0ICYmIGhlaWdodCA+IGNvbnRhaW5lclNpemUuaGVpZ2h0KSB7XG4gICAgaGVpZ2h0ID0gY29udGFpbmVyU2l6ZS5oZWlnaHQ7XG4gICAgd2lkdGggPSByb3VuZDEoTWF0aC5mbG9vcihoZWlnaHQgKiBhc3BlY3RSYXRpbykpO1xuICB9XG5cbiAgcmV0dXJuIHt3aWR0aCwgaGVpZ2h0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gY2hhcnRcbiAqIEBwYXJhbSBmb3JjZVJhdGlvXG4gKiBAcGFyYW0gZm9yY2VTdHlsZVxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgY2FudmFzIGNvbnRleHQgc2l6ZSBvciB0cmFuc2Zvcm1hdGlvbiBoYXMgY2hhbmdlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldGluYVNjYWxlKFxuICBjaGFydDogQ2hhcnQsXG4gIGZvcmNlUmF0aW86IG51bWJlcixcbiAgZm9yY2VTdHlsZT86IGJvb2xlYW5cbik6IGJvb2xlYW4gfCB2b2lkIHtcbiAgY29uc3QgcGl4ZWxSYXRpbyA9IGZvcmNlUmF0aW8gfHwgMTtcbiAgY29uc3QgZGV2aWNlSGVpZ2h0ID0gTWF0aC5mbG9vcihjaGFydC5oZWlnaHQgKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlV2lkdGggPSBNYXRoLmZsb29yKGNoYXJ0LndpZHRoICogcGl4ZWxSYXRpbyk7XG5cbiAgY2hhcnQuaGVpZ2h0ID0gTWF0aC5mbG9vcihjaGFydC5oZWlnaHQpO1xuICBjaGFydC53aWR0aCA9IE1hdGguZmxvb3IoY2hhcnQud2lkdGgpO1xuXG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcblxuICAvLyBJZiBubyBzdHlsZSBoYXMgYmVlbiBzZXQgb24gdGhlIGNhbnZhcywgdGhlIHJlbmRlciBzaXplIGlzIHVzZWQgYXMgZGlzcGxheSBzaXplLFxuICAvLyBtYWtpbmcgdGhlIGNoYXJ0IHZpc3VhbGx5IGJpZ2dlciwgc28gbGV0J3MgZW5mb3JjZSBpdCB0byB0aGUgXCJjb3JyZWN0XCIgdmFsdWVzLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzM1NzVcbiAgaWYgKGNhbnZhcy5zdHlsZSAmJiAoZm9yY2VTdHlsZSB8fCAoIWNhbnZhcy5zdHlsZS5oZWlnaHQgJiYgIWNhbnZhcy5zdHlsZS53aWR0aCkpKSB7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NoYXJ0LmhlaWdodH1weGA7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gYCR7Y2hhcnQud2lkdGh9cHhgO1xuICB9XG5cbiAgaWYgKGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBwaXhlbFJhdGlvXG4gICAgICB8fCBjYW52YXMuaGVpZ2h0ICE9PSBkZXZpY2VIZWlnaHRcbiAgICAgIHx8IGNhbnZhcy53aWR0aCAhPT0gZGV2aWNlV2lkdGgpIHtcbiAgICBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgY2FudmFzLmhlaWdodCA9IGRldmljZUhlaWdodDtcbiAgICBjYW52YXMud2lkdGggPSBkZXZpY2VXaWR0aDtcbiAgICBjaGFydC5jdHguc2V0VHJhbnNmb3JtKHBpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBEZXRlY3RzIHN1cHBvcnQgZm9yIG9wdGlvbnMgb2JqZWN0IGFyZ3VtZW50IGluIGFkZEV2ZW50TGlzdGVuZXIuXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNTYWZlbHlfZGV0ZWN0aW5nX29wdGlvbl9zdXBwb3J0XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3Qgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA9IChmdW5jdGlvbigpIHtcbiAgbGV0IHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZ2V0IHBhc3NpdmUoKSB7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYnJvd3NlciBhdHRlbXB0cyB0byBhY2Nlc3MgdGhlIHBhc3NpdmUgcHJvcGVydHkuXG4gICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBhcyBFdmVudExpc3RlbmVyT3B0aW9ucztcblxuICAgIGlmIChfaXNEb21TdXBwb3J0ZWQoKSkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuICB9XG4gIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xufSgpKTtcblxuLyoqXG4gKiBUaGUgXCJ1c2VkXCIgc2l6ZSBpcyB0aGUgZmluYWwgdmFsdWUgb2YgYSBkaW1lbnNpb24gcHJvcGVydHkgYWZ0ZXIgYWxsIGNhbGN1bGF0aW9ucyBoYXZlXG4gKiBiZWVuIHBlcmZvcm1lZC4gVGhpcyBtZXRob2QgdXNlcyB0aGUgY29tcHV0ZWQgc3R5bGUgb2YgYGVsZW1lbnRgIGJ1dCByZXR1cm5zIHVuZGVmaW5lZFxuICogaWYgdGhlIGNvbXB1dGVkIHN0eWxlIGlzIG5vdCBleHByZXNzZWQgaW4gcGl4ZWxzLiBUaGF0IGNhbiBoYXBwZW4gaW4gc29tZSBjYXNlcyB3aGVyZVxuICogYGVsZW1lbnRgIGhhcyBhIHNpemUgcmVsYXRpdmUgdG8gaXRzIHBhcmVudCBhbmQgdGhpcyBsYXN0IG9uZSBpcyBub3QgeWV0IGRpc3BsYXllZCxcbiAqIGZvciBleGFtcGxlIGJlY2F1c2Ugb2YgYGRpc3BsYXk6IG5vbmVgIG9uIGEgcGFyZW50IG5vZGUuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy91c2VkX3ZhbHVlXG4gKiBAcmV0dXJucyBTaXplIGluIHBpeGVscyBvciB1bmRlZmluZWQgaWYgdW5rbm93bi5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmVhZFVzZWRTaXplKFxuICBlbGVtZW50OiBIVE1MRWxlbWVudCxcbiAgcHJvcGVydHk6ICd3aWR0aCcgfCAnaGVpZ2h0J1xuKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgdmFsdWUgPSBnZXRTdHlsZShlbGVtZW50LCBwcm9wZXJ0eSk7XG4gIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcbiAgcmV0dXJuIG1hdGNoZXMgPyArbWF0Y2hlc1sxXSA6IHVuZGVmaW5lZDtcbn1cbiIsICJpbXBvcnQgdHlwZSB7UG9pbnQsIFNwbGluZVBvaW50fSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfcG9pbnRJbkxpbmUocDE6IFBvaW50LCBwMjogUG9pbnQsIHQ6IG51bWJlciwgbW9kZT8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuIHtcbiAgICB4OiBwMS54ICsgdCAqIChwMi54IC0gcDEueCksXG4gICAgeTogcDEueSArIHQgKiAocDIueSAtIHAxLnkpXG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zdGVwcGVkSW50ZXJwb2xhdGlvbihcbiAgcDE6IFBvaW50LFxuICBwMjogUG9pbnQsXG4gIHQ6IG51bWJlciwgbW9kZTogJ21pZGRsZScgfCAnYWZ0ZXInIHwgdW5rbm93blxuKSB7XG4gIHJldHVybiB7XG4gICAgeDogcDEueCArIHQgKiAocDIueCAtIHAxLngpLFxuICAgIHk6IG1vZGUgPT09ICdtaWRkbGUnID8gdCA8IDAuNSA/IHAxLnkgOiBwMi55XG4gICAgICA6IG1vZGUgPT09ICdhZnRlcicgPyB0IDwgMSA/IHAxLnkgOiBwMi55XG4gICAgICAgIDogdCA+IDAgPyBwMi55IDogcDEueVxuICB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYmV6aWVySW50ZXJwb2xhdGlvbihwMTogU3BsaW5lUG9pbnQsIHAyOiBTcGxpbmVQb2ludCwgdDogbnVtYmVyLCBtb2RlPykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBjb25zdCBjcDEgPSB7eDogcDEuY3AyeCwgeTogcDEuY3AyeX07XG4gIGNvbnN0IGNwMiA9IHt4OiBwMi5jcDF4LCB5OiBwMi5jcDF5fTtcbiAgY29uc3QgYSA9IF9wb2ludEluTGluZShwMSwgY3AxLCB0KTtcbiAgY29uc3QgYiA9IF9wb2ludEluTGluZShjcDEsIGNwMiwgdCk7XG4gIGNvbnN0IGMgPSBfcG9pbnRJbkxpbmUoY3AyLCBwMiwgdCk7XG4gIGNvbnN0IGQgPSBfcG9pbnRJbkxpbmUoYSwgYiwgdCk7XG4gIGNvbnN0IGUgPSBfcG9pbnRJbkxpbmUoYiwgYywgdCk7XG4gIHJldHVybiBfcG9pbnRJbkxpbmUoZCwgZSwgdCk7XG59XG4iLCAiZXhwb3J0IGludGVyZmFjZSBSVExBZGFwdGVyIHtcbiAgeCh4OiBudW1iZXIpOiBudW1iZXI7XG4gIHNldFdpZHRoKHc6IG51bWJlcik6IHZvaWQ7XG4gIHRleHRBbGlnbihhbGlnbjogJ2NlbnRlcicgfCAnbGVmdCcgfCAncmlnaHQnKTogJ2NlbnRlcicgfCAnbGVmdCcgfCAncmlnaHQnO1xuICB4UGx1cyh4OiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiBudW1iZXI7XG4gIGxlZnRGb3JMdHIoeDogbnVtYmVyLCBpdGVtV2lkdGg6IG51bWJlcik6IG51bWJlcjtcbn1cblxuY29uc3QgZ2V0UmlnaHRUb0xlZnRBZGFwdGVyID0gZnVuY3Rpb24ocmVjdFg6IG51bWJlciwgd2lkdGg6IG51bWJlcik6IFJUTEFkYXB0ZXIge1xuICByZXR1cm4ge1xuICAgIHgoeCkge1xuICAgICAgcmV0dXJuIHJlY3RYICsgcmVjdFggKyB3aWR0aCAtIHg7XG4gICAgfSxcbiAgICBzZXRXaWR0aCh3KSB7XG4gICAgICB3aWR0aCA9IHc7XG4gICAgfSxcbiAgICB0ZXh0QWxpZ24oYWxpZ24pIHtcbiAgICAgIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIGFsaWduO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsaWduID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9LFxuICAgIHhQbHVzKHgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4geCAtIHZhbHVlO1xuICAgIH0sXG4gICAgbGVmdEZvckx0cih4LCBpdGVtV2lkdGgpIHtcbiAgICAgIHJldHVybiB4IC0gaXRlbVdpZHRoO1xuICAgIH0sXG4gIH07XG59O1xuXG5jb25zdCBnZXRMZWZ0VG9SaWdodEFkYXB0ZXIgPSBmdW5jdGlvbigpOiBSVExBZGFwdGVyIHtcbiAgcmV0dXJuIHtcbiAgICB4KHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG4gICAgc2V0V2lkdGgodykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgfSxcbiAgICB0ZXh0QWxpZ24oYWxpZ24pIHtcbiAgICAgIHJldHVybiBhbGlnbjtcbiAgICB9LFxuICAgIHhQbHVzKHgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4geCArIHZhbHVlO1xuICAgIH0sXG4gICAgbGVmdEZvckx0cih4LCBfaXRlbVdpZHRoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuICB9O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJ0bEFkYXB0ZXIocnRsOiBib29sZWFuLCByZWN0WDogbnVtYmVyLCB3aWR0aDogbnVtYmVyKSB7XG4gIHJldHVybiBydGwgPyBnZXRSaWdodFRvTGVmdEFkYXB0ZXIocmVjdFgsIHdpZHRoKSA6IGdldExlZnRUb1JpZ2h0QWRhcHRlcigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBkaXJlY3Rpb246ICdsdHInIHwgJ3J0bCcpIHtcbiAgbGV0IHN0eWxlOiBDU1NTdHlsZURlY2xhcmF0aW9uLCBvcmlnaW5hbDogW3N0cmluZywgc3RyaW5nXTtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ2x0cicgfHwgZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHN0eWxlID0gY3R4LmNhbnZhcy5zdHlsZTtcbiAgICBvcmlnaW5hbCA9IFtcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpLFxuICAgICAgc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eSgnZGlyZWN0aW9uJyksXG4gICAgXTtcblxuICAgIHN0eWxlLnNldFByb3BlcnR5KCdkaXJlY3Rpb24nLCBkaXJlY3Rpb24sICdpbXBvcnRhbnQnKTtcbiAgICAoY3R4IGFzIHsgcHJldlRleHREaXJlY3Rpb24/OiBbc3RyaW5nLCBzdHJpbmddIH0pLnByZXZUZXh0RGlyZWN0aW9uID0gb3JpZ2luYWw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBvcmlnaW5hbD86IFtzdHJpbmcsIHN0cmluZ10pIHtcbiAgaWYgKG9yaWdpbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWxldGUgKGN0eCBhcyB7IHByZXZUZXh0RGlyZWN0aW9uPzogW3N0cmluZywgc3RyaW5nXSB9KS5wcmV2VGV4dERpcmVjdGlvbjtcbiAgICBjdHguY2FudmFzLnN0eWxlLnNldFByb3BlcnR5KCdkaXJlY3Rpb24nLCBvcmlnaW5hbFswXSwgb3JpZ2luYWxbMV0pO1xuICB9XG59XG4iLCAiaW1wb3J0IHtfYW5nbGVCZXR3ZWVuLCBfYW5nbGVEaWZmLCBfaXNCZXR3ZWVuLCBfbm9ybWFsaXplQW5nbGV9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7Y3JlYXRlQ29udGV4dH0gZnJvbSAnLi9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtpc1BhdHRlcm5PckdyYWRpZW50fSBmcm9tICcuL2hlbHBlcnMuY29sb3IuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9lbGVtZW50cy9lbGVtZW50LmxpbmUuanMnKS5kZWZhdWx0IH0gTGluZUVsZW1lbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9lbGVtZW50cy9lbGVtZW50LnBvaW50LmpzJykuZGVmYXVsdCB9IFBvaW50RWxlbWVudFxuICogQHR5cGVkZWYge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgbG9vcDogYm9vbGVhbiwgc3R5bGU/OiBhbnl9fSBTZWdtZW50XG4gKi9cblxuZnVuY3Rpb24gcHJvcGVydHlGbihwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmV0d2VlbjogX2FuZ2xlQmV0d2VlbixcbiAgICAgIGNvbXBhcmU6IF9hbmdsZURpZmYsXG4gICAgICBub3JtYWxpemU6IF9ub3JtYWxpemVBbmdsZSxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgYmV0d2VlbjogX2lzQmV0d2VlbixcbiAgICBjb21wYXJlOiAoYSwgYikgPT4gYSAtIGIsXG4gICAgbm9ybWFsaXplOiB4ID0+IHhcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU2VnbWVudCh7c3RhcnQsIGVuZCwgY291bnQsIGxvb3AsIHN0eWxlfSkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCAlIGNvdW50LFxuICAgIGVuZDogZW5kICUgY291bnQsXG4gICAgbG9vcDogbG9vcCAmJiAoZW5kIC0gc3RhcnQgKyAxKSAlIGNvdW50ID09PSAwLFxuICAgIHN0eWxlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpIHtcbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IHtiZXR3ZWVuLCBub3JtYWxpemV9ID0gcHJvcGVydHlGbihwcm9wZXJ0eSk7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge3N0YXJ0LCBlbmQsIGxvb3B9ID0gc2VnbWVudDtcbiAgbGV0IGksIGlsZW47XG5cbiAgaWYgKGxvb3ApIHtcbiAgICBzdGFydCArPSBjb3VudDtcbiAgICBlbmQgKz0gY291bnQ7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAoIWJldHdlZW4obm9ybWFsaXplKHBvaW50c1tzdGFydCAlIGNvdW50XVtwcm9wZXJ0eV0pLCBzdGFydEJvdW5kLCBlbmRCb3VuZCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGFydC0tO1xuICAgICAgZW5kLS07XG4gICAgfVxuICAgIHN0YXJ0ICU9IGNvdW50O1xuICAgIGVuZCAlPSBjb3VudDtcbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkge1xuICAgIGVuZCArPSBjb3VudDtcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlOiBzZWdtZW50LnN0eWxlfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdWItc2VnbWVudChzKSBvZiBhIGxpbmUgc2VnbWVudCB0aGF0IGZhbGwgaW4gdGhlIGdpdmVuIGJvdW5kc1xuICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuICogQHBhcmFtIHtvYmplY3R9IFtzZWdtZW50LnN0eWxlXSAtIHNlZ21lbnQgc3R5bGVcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50cyAtIHRoZSBwb2ludHMgdGhhdCB0aGlzIHNlZ21lbnQgcmVmZXJzIHRvXG4gKiBAcGFyYW0ge29iamVjdH0gW2JvdW5kc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBib3VuZHMucHJvcGVydHkgLSB0aGUgcHJvcGVydHkgb2YgYSBgUG9pbnRFbGVtZW50YCB3ZSBhcmUgYm91bmRpbmcuIGB4YCwgYHlgIG9yIGBhbmdsZWAuXG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLnN0YXJ0IC0gc3RhcnQgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLmVuZCAtIGVuZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAqIEBwcml2YXRlXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBpZiAoIWJvdW5kcykge1xuICAgIHJldHVybiBbc2VnbWVudF07XG4gIH1cblxuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0OiBzdGFydEJvdW5kLCBlbmQ6IGVuZEJvdW5kfSA9IGJvdW5kcztcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7Y29tcGFyZSwgYmV0d2Vlbiwgbm9ybWFsaXplfSA9IHByb3BlcnR5Rm4ocHJvcGVydHkpO1xuICBjb25zdCB7c3RhcnQsIGVuZCwgbG9vcCwgc3R5bGV9ID0gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcyk7XG5cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBpbnNpZGUgPSBmYWxzZTtcbiAgbGV0IHN1YlN0YXJ0ID0gbnVsbDtcbiAgbGV0IHZhbHVlLCBwb2ludCwgcHJldlZhbHVlO1xuXG4gIGNvbnN0IHN0YXJ0SXNCZWZvcmUgPSAoKSA9PiBiZXR3ZWVuKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpICYmIGNvbXBhcmUoc3RhcnRCb3VuZCwgcHJldlZhbHVlKSAhPT0gMDtcbiAgY29uc3QgZW5kSXNCZWZvcmUgPSAoKSA9PiBjb21wYXJlKGVuZEJvdW5kLCB2YWx1ZSkgPT09IDAgfHwgYmV0d2VlbihlbmRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSk7XG4gIGNvbnN0IHNob3VsZFN0YXJ0ID0gKCkgPT4gaW5zaWRlIHx8IHN0YXJ0SXNCZWZvcmUoKTtcbiAgY29uc3Qgc2hvdWxkU3RvcCA9ICgpID0+ICFpbnNpZGUgfHwgZW5kSXNCZWZvcmUoKTtcblxuICBmb3IgKGxldCBpID0gc3RhcnQsIHByZXYgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW2kgJSBjb3VudF07XG5cbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFsdWUgPSBub3JtYWxpemUocG9pbnRbcHJvcGVydHldKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gcHJldlZhbHVlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpbnNpZGUgPSBiZXR3ZWVuKHZhbHVlLCBzdGFydEJvdW5kLCBlbmRCb3VuZCk7XG5cbiAgICBpZiAoc3ViU3RhcnQgPT09IG51bGwgJiYgc2hvdWxkU3RhcnQoKSkge1xuICAgICAgc3ViU3RhcnQgPSBjb21wYXJlKHZhbHVlLCBzdGFydEJvdW5kKSA9PT0gMCA/IGkgOiBwcmV2O1xuICAgIH1cblxuICAgIGlmIChzdWJTdGFydCAhPT0gbnVsbCAmJiBzaG91bGRTdG9wKCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0OiBzdWJTdGFydCwgZW5kOiBpLCBsb29wLCBjb3VudCwgc3R5bGV9KSk7XG4gICAgICBzdWJTdGFydCA9IG51bGw7XG4gICAgfVxuICAgIHByZXYgPSBpO1xuICAgIHByZXZWYWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgaWYgKHN1YlN0YXJ0ICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2gobm9ybWFsaXplU2VnbWVudCh7c3RhcnQ6IHN1YlN0YXJ0LCBlbmQsIGxvb3AsIGNvdW50LCBzdHlsZX0pKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzZWdtZW50cyBvZiB0aGUgbGluZSB0aGF0IGFyZSBpbnNpZGUgZ2l2ZW4gYm91bmRzXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gW2JvdW5kc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBib3VuZHMucHJvcGVydHkgLSB0aGUgcHJvcGVydHkgd2UgYXJlIGJvdW5kaW5nIHdpdGguIGB4YCwgYHlgIG9yIGBhbmdsZWAuXG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLnN0YXJ0IC0gc3RhcnQgdmFsdWUgb2YgdGhlIGBwcm9wZXJ0eWBcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3VuZHMuZW5kIC0gZW5kIHZhbHVlIG9mIHRoZSBgcHJvcGVydHlgXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2JvdW5kU2VnbWVudHMobGluZSwgYm91bmRzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHN1YiA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudHNbaV0sIGxpbmUucG9pbnRzLCBib3VuZHMpO1xuICAgIGlmIChzdWIubGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaCguLi5zdWIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEZpbmQgc3RhcnQgYW5kIGVuZCBpbmRleCBvZiBhIGxpbmUuXG4gKi9cbmZ1bmN0aW9uIGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcykge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gY291bnQgLSAxO1xuXG4gIGlmIChsb29wICYmICFzcGFuR2Fwcykge1xuICAgIC8vIGxvb3AgYW5kIG5vdCBzcGFubmluZyBnYXBzLCBmaXJzdCBmaW5kIGEgZ2FwIHRvIHN0YXJ0IGZyb21cbiAgICB3aGlsZSAoc3RhcnQgPCBjb3VudCAmJiAhcG9pbnRzW3N0YXJ0XS5za2lwKSB7XG4gICAgICBzdGFydCsrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpbmQgZmlyc3Qgbm9uIHNraXBwZWQgcG9pbnQgKGFmdGVyIHRoZSBmaXJzdCBnYXAgcG9zc2libHkpXG4gIHdoaWxlIChzdGFydCA8IGNvdW50ICYmIHBvaW50c1tzdGFydF0uc2tpcCkge1xuICAgIHN0YXJ0Kys7XG4gIH1cblxuICAvLyBpZiB3ZSBsb29wZWQgdG8gY291bnQsIHN0YXJ0IG5lZWRzIHRvIGJlIDBcbiAgc3RhcnQgJT0gY291bnQ7XG5cbiAgaWYgKGxvb3ApIHtcbiAgICAvLyBsb29wIHdpbGwgZ28gcGFzdCBjb3VudCwgaWYgc3RhcnQgPiAwXG4gICAgZW5kICs9IHN0YXJ0O1xuICB9XG5cbiAgd2hpbGUgKGVuZCA+IHN0YXJ0ICYmIHBvaW50c1tlbmQgJSBjb3VudF0uc2tpcCkge1xuICAgIGVuZC0tO1xuICB9XG5cbiAgLy8gZW5kIGNvdWxkIGJlIG1vcmUgdGhhbiBjb3VudCwgbm9ybWFsaXplXG4gIGVuZCAlPSBjb3VudDtcblxuICByZXR1cm4ge3N0YXJ0LCBlbmR9O1xufVxuXG4vKipcbiAqIENvbXB1dGUgc29saWQgc2VnbWVudHMgZnJvbSBQb2ludHMsIHdoZW4gc3BhbkdhcHMgPT09IGZhbHNlXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHMgLSB0aGUgcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIG1heCBpbmRleCAoY2FuIGdvIHBhc3QgY291bnQgb24gYSBsb29wKVxuICogQHBhcmFtIHtib29sZWFufSBsb29wIC0gYm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgdGhpcyB3b3VsZCBiZSBhIGxvb3AgaWYgbm8gZ2FwcyBhcmUgZm91bmRcbiAqL1xuZnVuY3Rpb24gc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGxvb3ApIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGxhc3QgPSBzdGFydDtcbiAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnRdO1xuICBsZXQgZW5kO1xuXG4gIGZvciAoZW5kID0gc3RhcnQgKyAxOyBlbmQgPD0gbWF4OyArK2VuZCkge1xuICAgIGNvbnN0IGN1ciA9IHBvaW50c1tlbmQgJSBjb3VudF07XG4gICAgaWYgKGN1ci5za2lwIHx8IGN1ci5zdG9wKSB7XG4gICAgICBpZiAoIXByZXYuc2tpcCkge1xuICAgICAgICBsb29wID0gZmFsc2U7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiAoZW5kIC0gMSkgJSBjb3VudCwgbG9vcH0pO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHN0YXJ0ID0gbGFzdCA9IGN1ci5zdG9wID8gZW5kIDogbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IGVuZDtcbiAgICAgIGlmIChwcmV2LnNraXApIHtcbiAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIHByZXYgPSBjdXI7XG4gIH1cblxuICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiBsYXN0ICUgY291bnQsIGxvb3B9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgY29udGludW91cyBzZWdtZW50cyB0aGF0IGRlZmluZSB0aGUgd2hvbGUgbGluZVxuICogVGhlcmUgY2FuIGJlIHNraXBwZWQgcG9pbnRzIHdpdGhpbiBhIHNlZ21lbnQsIGlmIHNwYW5HYXBzIGlzIHRydWUuXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gW3NlZ21lbnRPcHRpb25zXVxuICogQHJldHVybiB7U2VnbWVudFtdfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jb21wdXRlU2VnbWVudHMobGluZSwgc2VnbWVudE9wdGlvbnMpIHtcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHNwYW5HYXBzID0gbGluZS5vcHRpb25zLnNwYW5HYXBzO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgaWYgKCFjb3VudCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IGxvb3AgPSAhIWxpbmUuX2xvb3A7XG4gIGNvbnN0IHtzdGFydCwgZW5kfSA9IGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcyk7XG5cbiAgaWYgKHNwYW5HYXBzID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgW3tzdGFydCwgZW5kLCBsb29wfV0sIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xuICB9XG5cbiAgY29uc3QgbWF4ID0gZW5kIDwgc3RhcnQgPyBlbmQgKyBjb3VudCA6IGVuZDtcbiAgY29uc3QgY29tcGxldGVMb29wID0gISFsaW5lLl9mdWxsTG9vcCAmJiBzdGFydCA9PT0gMCAmJiBlbmQgPT09IGNvdW50IC0gMTtcbiAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGNvbXBsZXRlTG9vcCksIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2VnbWVudFtdfSBzZWdtZW50c1xuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXX0gcG9pbnRzXG4gKiBAcGFyYW0ge29iamVjdH0gW3NlZ21lbnRPcHRpb25zXVxuICogQHJldHVybiB7U2VnbWVudFtdfVxuICovXG5mdW5jdGlvbiBzcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGlmICghc2VnbWVudE9wdGlvbnMgfHwgIXNlZ21lbnRPcHRpb25zLnNldENvbnRleHQgfHwgIXBvaW50cykge1xuICAgIHJldHVybiBzZWdtZW50cztcbiAgfVxuICByZXR1cm4gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge1NlZ21lbnRbXX0gc2VnbWVudHNcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50c1xuICogQHBhcmFtIHtvYmplY3R9IFtzZWdtZW50T3B0aW9uc11cbiAqIEByZXR1cm4ge1NlZ21lbnRbXX1cbiAqL1xuZnVuY3Rpb24gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGNvbnN0IGNoYXJ0Q29udGV4dCA9IGxpbmUuX2NoYXJ0LmdldENvbnRleHQoKTtcbiAgY29uc3QgYmFzZVN0eWxlID0gcmVhZFN0eWxlKGxpbmUub3B0aW9ucyk7XG4gIGNvbnN0IHtfZGF0YXNldEluZGV4OiBkYXRhc2V0SW5kZXgsIG9wdGlvbnM6IHtzcGFuR2Fwc319ID0gbGluZTtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IHByZXZTdHlsZSA9IGJhc2VTdHlsZTtcbiAgbGV0IHN0YXJ0ID0gc2VnbWVudHNbMF0uc3RhcnQ7XG4gIGxldCBpID0gc3RhcnQ7XG5cbiAgZnVuY3Rpb24gYWRkU3R5bGUocywgZSwgbCwgc3QpIHtcbiAgICBjb25zdCBkaXIgPSBzcGFuR2FwcyA/IC0xIDogMTtcbiAgICBpZiAocyA9PT0gZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTdHlsZSBjYW4gbm90IHN0YXJ0L2VuZCBvbiBhIHNraXBwZWQgcG9pbnQsIGFkanVzdCBpbmRpY2VzIGFjY29yZGluZ2x5XG4gICAgcyArPSBjb3VudDtcbiAgICB3aGlsZSAocG9pbnRzW3MgJSBjb3VudF0uc2tpcCkge1xuICAgICAgcyAtPSBkaXI7XG4gICAgfVxuICAgIHdoaWxlIChwb2ludHNbZSAlIGNvdW50XS5za2lwKSB7XG4gICAgICBlICs9IGRpcjtcbiAgICB9XG4gICAgaWYgKHMgJSBjb3VudCAhPT0gZSAlIGNvdW50KSB7XG4gICAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHMgJSBjb3VudCwgZW5kOiBlICUgY291bnQsIGxvb3A6IGwsIHN0eWxlOiBzdH0pO1xuICAgICAgcHJldlN0eWxlID0gc3Q7XG4gICAgICBzdGFydCA9IGUgJSBjb3VudDtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzdGFydCA9IHNwYW5HYXBzID8gc3RhcnQgOiBzZWdtZW50LnN0YXJ0O1xuICAgIGxldCBwcmV2ID0gcG9pbnRzW3N0YXJ0ICUgY291bnRdO1xuICAgIGxldCBzdHlsZTtcbiAgICBmb3IgKGkgPSBzdGFydCArIDE7IGkgPD0gc2VnbWVudC5lbmQ7IGkrKykge1xuICAgICAgY29uc3QgcHQgPSBwb2ludHNbaSAlIGNvdW50XTtcbiAgICAgIHN0eWxlID0gcmVhZFN0eWxlKHNlZ21lbnRPcHRpb25zLnNldENvbnRleHQoY3JlYXRlQ29udGV4dChjaGFydENvbnRleHQsIHtcbiAgICAgICAgdHlwZTogJ3NlZ21lbnQnLFxuICAgICAgICBwMDogcHJldixcbiAgICAgICAgcDE6IHB0LFxuICAgICAgICBwMERhdGFJbmRleDogKGkgLSAxKSAlIGNvdW50LFxuICAgICAgICBwMURhdGFJbmRleDogaSAlIGNvdW50LFxuICAgICAgICBkYXRhc2V0SW5kZXhcbiAgICAgIH0pKSk7XG4gICAgICBpZiAoc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpKSB7XG4gICAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xuICAgICAgfVxuICAgICAgcHJldiA9IHB0O1xuICAgICAgcHJldlN0eWxlID0gc3R5bGU7XG4gICAgfVxuICAgIGlmIChzdGFydCA8IGkgLSAxKSB7XG4gICAgICBhZGRTdHlsZShzdGFydCwgaSAtIDEsIHNlZ21lbnQubG9vcCwgcHJldlN0eWxlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZWFkU3R5bGUob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgYm9yZGVyQ2FwU3R5bGU6IG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUsXG4gICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICBib3JkZXJKb2luU3R5bGU6IG9wdGlvbnMuYm9yZGVySm9pblN0eWxlLFxuICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yXG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlQ2hhbmdlZChzdHlsZSwgcHJldlN0eWxlKSB7XG4gIGlmICghcHJldlN0eWxlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGNhY2hlID0gW107XG4gIGNvbnN0IHJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIGlmICghaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKCFjYWNoZS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgIGNhY2hlLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGUuaW5kZXhPZih2YWx1ZSk7XG4gIH07XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHlsZSwgcmVwbGFjZXIpICE9PSBKU09OLnN0cmluZ2lmeShwcmV2U3R5bGUsIHJlcGxhY2VyKTtcbn1cbiIsICJpbXBvcnQge3JlcXVlc3RBbmltRnJhbWV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuYW5pbWF0aW9uLmpzJykuZGVmYXVsdCB9IEFuaW1hdGlvblxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuLyoqXG4gKiBQbGVhc2UgdXNlIHRoZSBtb2R1bGUncyBkZWZhdWx0IGV4cG9ydCB3aGljaCBwcm92aWRlcyBhIHNpbmdsZXRvbiBpbnN0YW5jZVxuICogTm90ZTogY2xhc3MgaXMgZXhwb3J0IGZvciB0eXBlZG9jXG4gKi9cbmV4cG9ydCBjbGFzcyBBbmltYXRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMuX2NoYXJ0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fbGFzdERhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCB0eXBlKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gYW5pbXMubGlzdGVuZXJzW3R5cGVdO1xuICAgIGNvbnN0IG51bVN0ZXBzID0gYW5pbXMuZHVyYXRpb247XG5cbiAgICBjYWxsYmFja3MuZm9yRWFjaChmbiA9PiBmbih7XG4gICAgICBjaGFydCxcbiAgICAgIGluaXRpYWw6IGFuaW1zLmluaXRpYWwsXG4gICAgICBudW1TdGVwcyxcbiAgICAgIGN1cnJlbnRTdGVwOiBNYXRoLm1pbihkYXRlIC0gYW5pbXMuc3RhcnQsIG51bVN0ZXBzKVxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3JlZnJlc2goKSB7XG4gICAgaWYgKHRoaXMuX3JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG5cbiAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlKGRhdGUgPSBEYXRlLm5vdygpKSB7XG4gICAgbGV0IHJlbWFpbmluZyA9IDA7XG5cbiAgICB0aGlzLl9jaGFydHMuZm9yRWFjaCgoYW5pbXMsIGNoYXJ0KSA9PiB7XG4gICAgICBpZiAoIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGRyYXcgPSBmYWxzZTtcbiAgICAgIGxldCBpdGVtO1xuXG4gICAgICBmb3IgKDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuXG4gICAgICAgIGlmIChpdGVtLl9hY3RpdmUpIHtcbiAgICAgICAgICBpZiAoaXRlbS5fdG90YWwgPiBhbmltcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGFuaW1hdGlvbiBoYXMgYmVlbiB1cGRhdGVkIGFuZCBpdHMgZHVyYXRpb24gcHJvbG9uZ2VkLFxuICAgICAgICAgICAgLy8gdXBkYXRlIHRvIHRvdGFsIGR1cmF0aW9uIG9mIGN1cnJlbnQgYW5pbWF0aW9ucyBydW4gKGZvciBwcm9ncmVzcyBldmVudClcbiAgICAgICAgICAgIGFuaW1zLmR1cmF0aW9uID0gaXRlbS5fdG90YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0udGljayhkYXRlKTtcbiAgICAgICAgICBkcmF3ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIGl0ZW0gYnkgcmVwbGFjaW5nIGl0IHdpdGggbGFzdCBpdGVtIGFuZCByZW1vdmluZyB0aGUgbGFzdFxuICAgICAgICAgIC8vIEEgbG90IGZhc3RlciB0aGFuIHNwbGljZS5cbiAgICAgICAgICBpdGVtc1tpXSA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGl0ZW1zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkcmF3KSB7XG4gICAgICAgIGNoYXJ0LmRyYXcoKTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ3Byb2dyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGFuaW1zLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ2NvbXBsZXRlJyk7XG4gICAgICAgIGFuaW1zLmluaXRpYWwgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmVtYWluaW5nICs9IGl0ZW1zLmxlbmd0aDtcbiAgICB9KTtcblxuICAgIHRoaXMuX2xhc3REYXRlID0gZGF0ZTtcblxuICAgIGlmIChyZW1haW5pbmcgPT09IDApIHtcbiAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRBbmltcyhjaGFydCkge1xuICAgIGNvbnN0IGNoYXJ0cyA9IHRoaXMuX2NoYXJ0cztcbiAgICBsZXQgYW5pbXMgPSBjaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zKSB7XG4gICAgICBhbmltcyA9IHtcbiAgICAgICAgcnVubmluZzogZmFsc2UsXG4gICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgY29tcGxldGU6IFtdLFxuICAgICAgICAgIHByb2dyZXNzOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhcnRzLnNldChjaGFydCwgYW5pbXMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbXM7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gZXZlbnQgbmFtZVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGNhbGxiYWNrXG5cdCAqL1xuICBsaXN0ZW4oY2hhcnQsIGV2ZW50LCBjYikge1xuICAgIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5saXN0ZW5lcnNbZXZlbnRdLnB1c2goY2IpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZCBhbmltYXRpb25zXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7QW5pbWF0aW9uW119IGl0ZW1zIC0gYW5pbWF0aW9uc1xuXHQgKi9cbiAgYWRkKGNoYXJ0LCBpdGVtcykge1xuICAgIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkuaXRlbXMucHVzaCguLi5pdGVtcyk7XG4gIH1cblxuICAvKipcblx0ICogQ291bnRzIG51bWJlciBvZiBhY3RpdmUgYW5pbWF0aW9ucyBmb3IgdGhlIGNoYXJ0XG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqL1xuICBoYXMoY2hhcnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcblx0ICogU3RhcnQgYW5pbWF0aW5nIChhbGwgY2hhcnRzKVxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKi9cbiAgc3RhcnQoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYW5pbXMucnVubmluZyA9IHRydWU7XG4gICAgYW5pbXMuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGFuaW1zLmR1cmF0aW9uID0gYW5pbXMuaXRlbXMucmVkdWNlKChhY2MsIGN1cikgPT4gTWF0aC5tYXgoYWNjLCBjdXIuX2R1cmF0aW9uKSwgMCk7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG5cbiAgcnVubmluZyhjaGFydCkge1xuICAgIGlmICghdGhpcy5fcnVubmluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTdG9wIGFsbCBhbmltYXRpb25zIGZvciB0aGUgY2hhcnRcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICovXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcblxuICAgIGZvciAoOyBpID49IDA7IC0taSkge1xuICAgICAgaXRlbXNbaV0uY2FuY2VsKCk7XG4gICAgfVxuICAgIGFuaW1zLml0ZW1zID0gW107XG4gICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgRGF0ZS5ub3coKSwgJ2NvbXBsZXRlJyk7XG4gIH1cblxuICAvKipcblx0ICogUmVtb3ZlIGNoYXJ0IGZyb20gQW5pbWF0b3Jcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICovXG4gIHJlbW92ZShjaGFydCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFydHMuZGVsZXRlKGNoYXJ0KTtcbiAgfVxufVxuXG4vLyBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBkZWZhdWx0IC8qICNfX1BVUkVfXyAqLyBuZXcgQW5pbWF0b3IoKTtcbiIsICJpbXBvcnQgZWZmZWN0cyBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZWFzaW5nLmpzJztcbmltcG9ydCB7cmVzb2x2ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtjb2xvciBhcyBoZWxwZXJzQ29sb3J9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xvci5qcyc7XG5cbmNvbnN0IHRyYW5zcGFyZW50ID0gJ3RyYW5zcGFyZW50JztcbmNvbnN0IGludGVycG9sYXRvcnMgPSB7XG4gIGJvb2xlYW4oZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIHJldHVybiBmYWN0b3IgPiAwLjUgPyB0byA6IGZyb207XG4gIH0sXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZhY3RvclxuICAgKi9cbiAgY29sb3IoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIGNvbnN0IGMwID0gaGVscGVyc0NvbG9yKGZyb20gfHwgdHJhbnNwYXJlbnQpO1xuICAgIGNvbnN0IGMxID0gYzAudmFsaWQgJiYgaGVscGVyc0NvbG9yKHRvIHx8IHRyYW5zcGFyZW50KTtcbiAgICByZXR1cm4gYzEgJiYgYzEudmFsaWRcbiAgICAgID8gYzEubWl4KGMwLCBmYWN0b3IpLmhleFN0cmluZygpXG4gICAgICA6IHRvO1xuICB9LFxuICBudW1iZXIoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiBmYWN0b3I7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGNmZywgdGFyZ2V0LCBwcm9wLCB0bykge1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRhcmdldFtwcm9wXTtcblxuICAgIHRvID0gcmVzb2x2ZShbY2ZnLnRvLCB0bywgY3VycmVudFZhbHVlLCBjZmcuZnJvbV0pO1xuICAgIGNvbnN0IGZyb20gPSByZXNvbHZlKFtjZmcuZnJvbSwgY3VycmVudFZhbHVlLCB0b10pO1xuXG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLl9mbiA9IGNmZy5mbiB8fCBpbnRlcnBvbGF0b3JzW2NmZy50eXBlIHx8IHR5cGVvZiBmcm9tXTtcbiAgICB0aGlzLl9lYXNpbmcgPSBlZmZlY3RzW2NmZy5lYXNpbmddIHx8IGVmZmVjdHMubGluZWFyO1xuICAgIHRoaXMuX3N0YXJ0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpICsgKGNmZy5kZWxheSB8fCAwKSk7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbCA9IE1hdGguZmxvb3IoY2ZnLmR1cmF0aW9uKTtcbiAgICB0aGlzLl9sb29wID0gISFjZmcubG9vcDtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5fcHJvcCA9IHByb3A7XG4gICAgdGhpcy5fZnJvbSA9IGZyb207XG4gICAgdGhpcy5fdG8gPSB0bztcbiAgICB0aGlzLl9wcm9taXNlcyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICB9XG5cbiAgdXBkYXRlKGNmZywgdG8sIGRhdGUpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl9ub3RpZnkoZmFsc2UpO1xuXG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLl90YXJnZXRbdGhpcy5fcHJvcF07XG4gICAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xuICAgICAgY29uc3QgcmVtYWluID0gdGhpcy5fZHVyYXRpb24gLSBlbGFwc2VkO1xuICAgICAgdGhpcy5fc3RhcnQgPSBkYXRlO1xuICAgICAgdGhpcy5fZHVyYXRpb24gPSBNYXRoLmZsb29yKE1hdGgubWF4KHJlbWFpbiwgY2ZnLmR1cmF0aW9uKSk7XG4gICAgICB0aGlzLl90b3RhbCArPSBlbGFwc2VkO1xuICAgICAgdGhpcy5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgICB0aGlzLl90byA9IHJlc29sdmUoW2NmZy50bywgdG8sIGN1cnJlbnRWYWx1ZSwgY2ZnLmZyb21dKTtcbiAgICAgIHRoaXMuX2Zyb20gPSByZXNvbHZlKFtjZmcuZnJvbSwgY3VycmVudFZhbHVlLCB0b10pO1xuICAgIH1cbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICAvLyB1cGRhdGUgY3VycmVudCBldmFsdWF0ZWQgdmFsdWUsIGZvciBzbW9vdGhlciBhbmltYXRpb25zXG4gICAgICB0aGlzLnRpY2soRGF0ZS5ub3coKSk7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX25vdGlmeShmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgdGljayhkYXRlKSB7XG4gICAgY29uc3QgZWxhcHNlZCA9IGRhdGUgLSB0aGlzLl9zdGFydDtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgIGNvbnN0IHByb3AgPSB0aGlzLl9wcm9wO1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLl9mcm9tO1xuICAgIGNvbnN0IGxvb3AgPSB0aGlzLl9sb29wO1xuICAgIGNvbnN0IHRvID0gdGhpcy5fdG87XG4gICAgbGV0IGZhY3RvcjtcblxuICAgIHRoaXMuX2FjdGl2ZSA9IGZyb20gIT09IHRvICYmIChsb29wIHx8IChlbGFwc2VkIDwgZHVyYXRpb24pKTtcblxuICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSB0bztcbiAgICAgIHRoaXMuX25vdGlmeSh0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxhcHNlZCA8IDApIHtcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IGZyb207XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmFjdG9yID0gKGVsYXBzZWQgLyBkdXJhdGlvbikgJSAyO1xuICAgIGZhY3RvciA9IGxvb3AgJiYgZmFjdG9yID4gMSA/IDIgLSBmYWN0b3IgOiBmYWN0b3I7XG4gICAgZmFjdG9yID0gdGhpcy5fZWFzaW5nKE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGZhY3RvcikpKTtcblxuICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IHRoaXMuX2ZuKGZyb20sIHRvLCBmYWN0b3IpO1xuICB9XG5cbiAgd2FpdCgpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8ICh0aGlzLl9wcm9taXNlcyA9IFtdKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICBwcm9taXNlcy5wdXNoKHtyZXMsIHJlan0pO1xuICAgIH0pO1xuICB9XG5cbiAgX25vdGlmeShyZXNvbHZlZCkge1xuICAgIGNvbnN0IG1ldGhvZCA9IHJlc29sdmVkID8gJ3JlcycgOiAncmVqJztcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb21pc2VzW2ldW21ldGhvZF0oKTtcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgYW5pbWF0b3IgZnJvbSAnLi9jb3JlLmFuaW1hdG9yLmpzJztcbmltcG9ydCBBbmltYXRpb24gZnJvbSAnLi9jb3JlLmFuaW1hdGlvbi5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNPYmplY3R9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBjb25maWcpIHtcbiAgICB0aGlzLl9jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jb25maWd1cmUoY29uZmlnKTtcbiAgfVxuXG4gIGNvbmZpZ3VyZShjb25maWcpIHtcbiAgICBpZiAoIWlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gT2JqZWN0LmtleXMoZGVmYXVsdHMuYW5pbWF0aW9uKTtcbiAgICBjb25zdCBhbmltYXRlZFByb3BzID0gdGhpcy5fcHJvcGVydGllcztcblxuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNvbmZpZykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgY2ZnID0gY29uZmlnW2tleV07XG4gICAgICBpZiAoIWlzT2JqZWN0KGNmZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzb2x2ZWQgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGFuaW1hdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgcmVzb2x2ZWRbb3B0aW9uXSA9IGNmZ1tvcHRpb25dO1xuICAgICAgfVxuXG4gICAgICAoaXNBcnJheShjZmcucHJvcGVydGllcykgJiYgY2ZnLnByb3BlcnRpZXMgfHwgW2tleV0pLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgaWYgKHByb3AgPT09IGtleSB8fCAhYW5pbWF0ZWRQcm9wcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICBhbmltYXRlZFByb3BzLnNldChwcm9wLCByZXNvbHZlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgdG8gaGFuZGxlIGFuaW1hdGlvbiBvZiBgb3B0aW9uc2AuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBjb25zdCBuZXdPcHRpb25zID0gdmFsdWVzLm9wdGlvbnM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHJlc29sdmVUYXJnZXRPcHRpb25zKHRhcmdldCwgbmV3T3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnMob3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgaWYgKG5ld09wdGlvbnMuJHNoYXJlZCkge1xuICAgICAgLy8gR29pbmcgdG8gc2hhcmVkIG9wdGlvbnM6XG4gICAgICAvLyBBZnRlciBhbGwgYW5pbWF0aW9ucyBhcmUgZG9uZSwgYXNzaWduIHRoZSBzaGFyZWQgb3B0aW9ucyBvYmplY3QgdG8gdGhlIGVsZW1lbnRcbiAgICAgIC8vIFNvIGFueSBuZXcgdXBkYXRlcyB0byB0aGUgc2hhcmVkIG9wdGlvbnMgYXJlIG9ic2VydmVkXG4gICAgICBhd2FpdEFsbCh0YXJnZXQub3B0aW9ucy4kYW5pbWF0aW9ucywgbmV3T3B0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAgIHRhcmdldC5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICAgIH0sICgpID0+IHtcbiAgICAgICAgLy8gcmVqZWN0ZWQsIG5vb3BcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY3JlYXRlQW5pbWF0aW9ucyh0YXJnZXQsIHZhbHVlcykge1xuICAgIGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBbXTtcbiAgICBjb25zdCBydW5uaW5nID0gdGFyZ2V0LiRhbmltYXRpb25zIHx8ICh0YXJnZXQuJGFuaW1hdGlvbnMgPSB7fSk7XG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyh2YWx1ZXMpO1xuICAgIGNvbnN0IGRhdGUgPSBEYXRlLm5vdygpO1xuICAgIGxldCBpO1xuXG4gICAgZm9yIChpID0gcHJvcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIGlmIChwcm9wLmNoYXJBdCgwKSA9PT0gJyQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcCA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgIGFuaW1hdGlvbnMucHVzaCguLi50aGlzLl9hbmltYXRlT3B0aW9ucyh0YXJnZXQsIHZhbHVlcykpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW3Byb3BdO1xuICAgICAgbGV0IGFuaW1hdGlvbiA9IHJ1bm5pbmdbcHJvcF07XG4gICAgICBjb25zdCBjZmcgPSBhbmltYXRlZFByb3BzLmdldChwcm9wKTtcblxuICAgICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgICBpZiAoY2ZnICYmIGFuaW1hdGlvbi5hY3RpdmUoKSkge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIGFuIGV4aXN0aW5nIGFjdGl2ZSBhbmltYXRpb24sIGxldCdzIHVwZGF0ZSB0aGF0XG4gICAgICAgICAgYW5pbWF0aW9uLnVwZGF0ZShjZmcsIHZhbHVlLCBkYXRlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY2ZnIHx8ICFjZmcuZHVyYXRpb24pIHtcbiAgICAgICAgLy8gbm90IGFuaW1hdGVkLCBzZXQgZGlyZWN0bHkgdG8gbmV3IHZhbHVlXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcnVubmluZ1twcm9wXSA9IGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oY2ZnLCB0YXJnZXQsIHByb3AsIHZhbHVlKTtcbiAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuXG5cbiAgLyoqXG5cdCAqIFVwZGF0ZSBgdGFyZ2V0YCBwcm9wZXJ0aWVzIHRvIG5ldyB2YWx1ZXMsIHVzaW5nIGNvbmZpZ3VyZWQgYW5pbWF0aW9uc1xuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gb2JqZWN0IHRvIHVwZGF0ZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIC0gbmV3IHRhcmdldCBwcm9wZXJ0aWVzXG5cdCAqIEByZXR1cm5zIHtib29sZWFufHVuZGVmaW5lZH0gLSBgdHJ1ZWAgaWYgYW5pbWF0aW9ucyB3ZXJlIHN0YXJ0ZWRcblx0ICoqL1xuICB1cGRhdGUodGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBpZiAodGhpcy5fcHJvcGVydGllcy5zaXplID09PSAwKSB7XG4gICAgICAvLyBOb3RoaW5nIGlzIGFuaW1hdGVkLCBqdXN0IGFwcGx5IHRoZSBuZXcgdmFsdWVzLlxuICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHZhbHVlcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpO1xuXG4gICAgaWYgKGFuaW1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICBhbmltYXRvci5hZGQodGhpcy5fY2hhcnQsIGFuaW1hdGlvbnMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGF3YWl0QWxsKGFuaW1hdGlvbnMsIHByb3BlcnRpZXMpIHtcbiAgY29uc3QgcnVubmluZyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFuaW0gPSBhbmltYXRpb25zW2tleXNbaV1dO1xuICAgIGlmIChhbmltICYmIGFuaW0uYWN0aXZlKCkpIHtcbiAgICAgIHJ1bm5pbmcucHVzaChhbmltLndhaXQoKSk7XG4gICAgfVxuICB9XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIFByb21pc2UuYWxsKHJ1bm5pbmcpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0T3B0aW9ucyh0YXJnZXQsIG5ld09wdGlvbnMpIHtcbiAgaWYgKCFuZXdPcHRpb25zKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBvcHRpb25zID0gdGFyZ2V0Lm9wdGlvbnM7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHRhcmdldC5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG9wdGlvbnMuJHNoYXJlZCkge1xuICAgIC8vIEdvaW5nIGZyb20gc2hhcmVkIG9wdGlvbnMgdG8gZGlzdGluY3Qgb25lOlxuICAgIC8vIENyZWF0ZSBuZXcgb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyB0aGUgb2xkIHNoYXJlZCB2YWx1ZXMgYW5kIHN0YXJ0IHVwZGF0aW5nIHRoYXQuXG4gICAgdGFyZ2V0Lm9wdGlvbnMgPSBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyRzaGFyZWQ6IGZhbHNlLCAkYW5pbWF0aW9uczoge319KTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cbiIsICJpbXBvcnQgQW5pbWF0aW9ucyBmcm9tICcuL2NvcmUuYW5pbWF0aW9ucy5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNGaW5pdGUsIGlzT2JqZWN0LCB2YWx1ZU9yRGVmYXVsdCwgcmVzb2x2ZU9iamVjdEtleSwgZGVmaW5lZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtsaXN0ZW5BcnJheUV2ZW50cywgdW5saXN0ZW5BcnJheUV2ZW50c30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCBzaWdufSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0IH0gU2NhbGVcbiAqL1xuXG5mdW5jdGlvbiBzY2FsZUNsaXAoc2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBjb25zdCBvcHRzID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcmV2ZXJzZSA9IG9wdHMucmV2ZXJzZTtcbiAgY29uc3QgbWluID0gb3B0cy5taW4gPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gIGNvbnN0IG1heCA9IG9wdHMubWF4ID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiByZXZlcnNlID8gbWF4IDogbWluLFxuICAgIGVuZDogcmV2ZXJzZSA/IG1pbiA6IG1heFxuICB9O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q2xpcCh4U2NhbGUsIHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XG4gIGlmIChhbGxvd2VkT3ZlcmZsb3cgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHggPSBzY2FsZUNsaXAoeFNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpO1xuICBjb25zdCB5ID0gc2NhbGVDbGlwKHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcblxuICByZXR1cm4ge1xuICAgIHRvcDogeS5lbmQsXG4gICAgcmlnaHQ6IHguZW5kLFxuICAgIGJvdHRvbTogeS5zdGFydCxcbiAgICBsZWZ0OiB4LnN0YXJ0XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRvQ2xpcCh2YWx1ZSkge1xuICBsZXQgdCwgciwgYiwgbDtcblxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdCA9IHZhbHVlLnRvcDtcbiAgICByID0gdmFsdWUucmlnaHQ7XG4gICAgYiA9IHZhbHVlLmJvdHRvbTtcbiAgICBsID0gdmFsdWUubGVmdDtcbiAgfSBlbHNlIHtcbiAgICB0ID0gciA9IGIgPSBsID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcDogdCxcbiAgICByaWdodDogcixcbiAgICBib3R0b206IGIsXG4gICAgbGVmdDogbCxcbiAgICBkaXNhYmxlZDogdmFsdWUgPT09IGZhbHNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCBmaWx0ZXJWaXNpYmxlKSB7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpO1xuICBsZXQgaSwgaWxlbjtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5cy5wdXNoKG1ldGFzZXRzW2ldLmluZGV4KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIGRzSW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBrZXlzID0gc3RhY2sua2V5cztcbiAgY29uc3Qgc2luZ2xlTW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gJ3NpbmdsZSc7XG4gIGxldCBpLCBpbGVuLCBkYXRhc2V0SW5kZXgsIG90aGVyVmFsdWU7XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgZGF0YXNldEluZGV4ID0gK2tleXNbaV07XG4gICAgaWYgKGRhdGFzZXRJbmRleCA9PT0gZHNJbmRleCkge1xuICAgICAgaWYgKG9wdGlvbnMuYWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG90aGVyVmFsdWUgPSBzdGFjay52YWx1ZXNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAoaXNGaW5pdGUob3RoZXJWYWx1ZSkgJiYgKHNpbmdsZU1vZGUgfHwgKHZhbHVlID09PSAwIHx8IHNpZ24odmFsdWUpID09PSBzaWduKG90aGVyVmFsdWUpKSkpIHtcbiAgICAgIHZhbHVlICs9IG90aGVyVmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY29udmVydE9iamVjdERhdGFUb0FycmF5KGRhdGEpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICBjb25zdCBhZGF0YSA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gIGxldCBpLCBpbGVuLCBrZXk7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgYWRhdGFbaV0gPSB7XG4gICAgICB4OiBrZXksXG4gICAgICB5OiBkYXRhW2tleV1cbiAgICB9O1xuICB9XG4gIHJldHVybiBhZGF0YTtcbn1cblxuZnVuY3Rpb24gaXNTdGFja2VkKHNjYWxlLCBtZXRhKSB7XG4gIGNvbnN0IHN0YWNrZWQgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG4gIHJldHVybiBzdGFja2VkIHx8IChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayAhPT0gdW5kZWZpbmVkKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhY2tLZXkoaW5kZXhTY2FsZSwgdmFsdWVTY2FsZSwgbWV0YSkge1xuICByZXR1cm4gYCR7aW5kZXhTY2FsZS5pZH0uJHt2YWx1ZVNjYWxlLmlkfS4ke21ldGEuc3RhY2sgfHwgbWV0YS50eXBlfWA7XG59XG5cbmZ1bmN0aW9uIGdldFVzZXJCb3VuZHMoc2NhbGUpIHtcbiAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgcmV0dXJuIHtcbiAgICBtaW46IG1pbkRlZmluZWQgPyBtaW4gOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgbWF4OiBtYXhEZWZpbmVkID8gbWF4IDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBzdGFja0tleSwgaW5kZXhWYWx1ZSkge1xuICBjb25zdCBzdWJTdGFjayA9IHN0YWNrc1tzdGFja0tleV0gfHwgKHN0YWNrc1tzdGFja0tleV0gPSB7fSk7XG4gIHJldHVybiBzdWJTdGFja1tpbmRleFZhbHVlXSB8fCAoc3ViU3RhY2tbaW5kZXhWYWx1ZV0gPSB7fSk7XG59XG5cbmZ1bmN0aW9uIGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgcG9zaXRpdmUsIHR5cGUpIHtcbiAgZm9yIChjb25zdCBtZXRhIG9mIHZTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKS5yZXZlcnNlKCkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0YWNrW21ldGEuaW5kZXhdO1xuICAgIGlmICgocG9zaXRpdmUgJiYgdmFsdWUgPiAwKSB8fCAoIXBvc2l0aXZlICYmIHZhbHVlIDwgMCkpIHtcbiAgICAgIHJldHVybiBtZXRhLmluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdGFja3MoY29udHJvbGxlciwgcGFyc2VkKSB7XG4gIGNvbnN0IHtjaGFydCwgX2NhY2hlZE1ldGE6IG1ldGF9ID0gY29udHJvbGxlcjtcbiAgY29uc3Qgc3RhY2tzID0gY2hhcnQuX3N0YWNrcyB8fCAoY2hhcnQuX3N0YWNrcyA9IHt9KTsgLy8gbWFwIHN0cnVjdHVyZSBpcyB7c3RhY2tLZXk6IHtkYXRhc2V0SW5kZXg6IHZhbHVlfX1cbiAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBpbmRleDogZGF0YXNldEluZGV4fSA9IG1ldGE7XG4gIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gIGNvbnN0IGtleSA9IGdldFN0YWNrS2V5KGlTY2FsZSwgdlNjYWxlLCBtZXRhKTtcbiAgY29uc3QgaWxlbiA9IHBhcnNlZC5sZW5ndGg7XG4gIGxldCBzdGFjaztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIGNvbnN0IGl0ZW0gPSBwYXJzZWRbaV07XG4gICAgY29uc3Qge1tpQXhpc106IGluZGV4LCBbdkF4aXNdOiB2YWx1ZX0gPSBpdGVtO1xuICAgIGNvbnN0IGl0ZW1TdGFja3MgPSBpdGVtLl9zdGFja3MgfHwgKGl0ZW0uX3N0YWNrcyA9IHt9KTtcbiAgICBzdGFjayA9IGl0ZW1TdGFja3NbdkF4aXNdID0gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIGtleSwgaW5kZXgpO1xuICAgIHN0YWNrW2RhdGFzZXRJbmRleF0gPSB2YWx1ZTtcblxuICAgIHN0YWNrLl90b3AgPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHRydWUsIG1ldGEudHlwZSk7XG4gICAgc3RhY2suX2JvdHRvbSA9IGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgZmFsc2UsIG1ldGEudHlwZSk7XG5cbiAgICBjb25zdCB2aXN1YWxWYWx1ZXMgPSBzdGFjay5fdmlzdWFsVmFsdWVzIHx8IChzdGFjay5fdmlzdWFsVmFsdWVzID0ge30pO1xuICAgIHZpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCBheGlzKSB7XG4gIGNvbnN0IHNjYWxlcyA9IGNoYXJ0LnNjYWxlcztcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNjYWxlcykuZmlsdGVyKGtleSA9PiBzY2FsZXNba2V5XS5heGlzID09PSBheGlzKS5zaGlmdCgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEYXRhc2V0Q29udGV4dChwYXJlbnQsIGluZGV4KSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCxcbiAgICB7XG4gICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgZGF0YXNldDogdW5kZWZpbmVkLFxuICAgICAgZGF0YXNldEluZGV4OiBpbmRleCxcbiAgICAgIGluZGV4LFxuICAgICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgICAgdHlwZTogJ2RhdGFzZXQnXG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEYXRhQ29udGV4dChwYXJlbnQsIGluZGV4LCBlbGVtZW50KSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICBwYXJzZWQ6IHVuZGVmaW5lZCxcbiAgICByYXc6IHVuZGVmaW5lZCxcbiAgICBlbGVtZW50LFxuICAgIGluZGV4LFxuICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICB0eXBlOiAnZGF0YSdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyU3RhY2tzKG1ldGEsIGl0ZW1zKSB7XG4gIC8vIE5vdCB1c2luZyBtZXRhLmluZGV4IGhlcmUsIGJlY2F1c2UgaXQgbWlnaHQgYmUgYWxyZWFkeSB1cGRhdGVkIGlmIHRoZSBkYXRhc2V0IGNoYW5nZWQgbG9jYXRpb25cbiAgY29uc3QgZGF0YXNldEluZGV4ID0gbWV0YS5jb250cm9sbGVyLmluZGV4O1xuICBjb25zdCBheGlzID0gbWV0YS52U2NhbGUgJiYgbWV0YS52U2NhbGUuYXhpcztcbiAgaWYgKCFheGlzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaXRlbXMgPSBpdGVtcyB8fCBtZXRhLl9wYXJzZWQ7XG4gIGZvciAoY29uc3QgcGFyc2VkIG9mIGl0ZW1zKSB7XG4gICAgY29uc3Qgc3RhY2tzID0gcGFyc2VkLl9zdGFja3M7XG4gICAgaWYgKCFzdGFja3MgfHwgc3RhY2tzW2F4aXNdID09PSB1bmRlZmluZWQgfHwgc3RhY2tzW2F4aXNdW2RhdGFzZXRJbmRleF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgc3RhY2tzW2F4aXNdW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKHN0YWNrc1theGlzXS5fdmlzdWFsVmFsdWVzICE9PSB1bmRlZmluZWQgJiYgc3RhY2tzW2F4aXNdLl92aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWxldGUgc3RhY2tzW2F4aXNdLl92aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaXNEaXJlY3RVcGRhdGVNb2RlID0gKG1vZGUpID0+IG1vZGUgPT09ICdyZXNldCcgfHwgbW9kZSA9PT0gJ25vbmUnO1xuY29uc3QgY2xvbmVJZk5vdFNoYXJlZCA9IChjYWNoZWQsIHNoYXJlZCkgPT4gc2hhcmVkID8gY2FjaGVkIDogT2JqZWN0LmFzc2lnbih7fSwgY2FjaGVkKTtcbmNvbnN0IGNyZWF0ZVN0YWNrID0gKGNhblN0YWNrLCBtZXRhLCBjaGFydCkgPT4gY2FuU3RhY2sgJiYgIW1ldGEuaGlkZGVuICYmIG1ldGEuX3N0YWNrZWRcbiAgJiYge2tleXM6IGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCB0cnVlKSwgdmFsdWVzOiBudWxsfTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge307XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgdHlwZSB1c2VkIHRvIGdlbmVyYXRlIGEgbWV0YSBkYXRhc2V0IChlLmcuIENoYXJ0LmVsZW1lbnQuTGluZUVsZW1lbnQpLlxuICAgKi9cbiAgc3RhdGljIGRhdGFzZXRFbGVtZW50VHlwZSA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgdHlwZSB1c2VkIHRvIGdlbmVyYXRlIGEgbWV0YSBkYXRhIChlLmcuIENoYXJ0LmVsZW1lbnQuUG9pbnRFbGVtZW50KS5cbiAgICovXG4gIHN0YXRpYyBkYXRhRWxlbWVudFR5cGUgPSBudWxsO1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gZGF0YXNldEluZGV4XG5cdCAqL1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuX2N0eCA9IGNoYXJ0LmN0eDtcbiAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gICAgdGhpcy5fY2FjaGVkTWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuICAgIHRoaXMuX3R5cGUgPSB0aGlzLl9jYWNoZWRNZXRhLnR5cGU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IG9iamVjdH0gKi9cbiAgICB0aGlzLl9wYXJzaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vYmplY3REYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NoYXJlZE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcbiAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IG5ldy50YXJnZXQuZGF0YXNldEVsZW1lbnRUeXBlO1xuICAgIHRoaXMuZGF0YUVsZW1lbnRUeXBlID0gbmV3LnRhcmdldC5kYXRhRWxlbWVudFR5cGU7XG5cbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy5jb25maWd1cmUoKTtcbiAgICB0aGlzLmxpbmtTY2FsZXMoKTtcbiAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcbiAgICB0aGlzLmFkZEVsZW1lbnRzKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmZpbGwgJiYgIXRoaXMuY2hhcnQuaXNQbHVnaW5FbmFibGVkKCdmaWxsZXInKSkge1xuICAgICAgY29uc29sZS53YXJuKFwiVHJpZWQgdG8gdXNlIHRoZSAnZmlsbCcgb3B0aW9uIHdpdGhvdXQgdGhlICdGaWxsZXInIHBsdWdpbiBlbmFibGVkLiBQbGVhc2UgaW1wb3J0IGFuZCByZWdpc3RlciB0aGUgJ0ZpbGxlcicgcGx1Z2luIGFuZCBtYWtlIHN1cmUgaXQgaXMgbm90IGRpc2FibGVkIGluIHRoZSBvcHRpb25zXCIpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUluZGV4KGRhdGFzZXRJbmRleCkge1xuICAgIGlmICh0aGlzLmluZGV4ICE9PSBkYXRhc2V0SW5kZXgpIHtcbiAgICAgIGNsZWFyU3RhY2tzKHRoaXMuX2NhY2hlZE1ldGEpO1xuICAgIH1cbiAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICB9XG5cbiAgbGlua1NjYWxlcygpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuXG4gICAgY29uc3QgY2hvb3NlSWQgPSAoYXhpcywgeCwgeSwgcikgPT4gYXhpcyA9PT0gJ3gnID8geCA6IGF4aXMgPT09ICdyJyA/IHIgOiB5O1xuXG4gICAgY29uc3QgeGlkID0gbWV0YS54QXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC54QXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICd4JykpO1xuICAgIGNvbnN0IHlpZCA9IG1ldGEueUF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueUF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneScpKTtcbiAgICBjb25zdCByaWQgPSBtZXRhLnJBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnJBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3InKSk7XG4gICAgY29uc3QgaW5kZXhBeGlzID0gbWV0YS5pbmRleEF4aXM7XG4gICAgY29uc3QgaWlkID0gbWV0YS5pQXhpc0lEID0gY2hvb3NlSWQoaW5kZXhBeGlzLCB4aWQsIHlpZCwgcmlkKTtcbiAgICBjb25zdCB2aWQgPSBtZXRhLnZBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHlpZCwgeGlkLCByaWQpO1xuICAgIG1ldGEueFNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHhpZCk7XG4gICAgbWV0YS55U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoeWlkKTtcbiAgICBtZXRhLnJTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChyaWQpO1xuICAgIG1ldGEuaVNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKGlpZCk7XG4gICAgbWV0YS52U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQodmlkKTtcbiAgfVxuXG4gIGdldERhdGFzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1t0aGlzLmluZGV4XTtcbiAgfVxuXG4gIGdldE1ldGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEodGhpcy5pbmRleCk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHNjYWxlSURcblx0ICogQHJldHVybiB7U2NhbGV9XG5cdCAqL1xuICBnZXRTY2FsZUZvcklkKHNjYWxlSUQpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5zY2FsZXNbc2NhbGVJRF07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRPdGhlclNjYWxlKHNjYWxlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgcmV0dXJuIHNjYWxlID09PSBtZXRhLmlTY2FsZVxuICAgICAgPyBtZXRhLnZTY2FsZVxuICAgICAgOiBtZXRhLmlTY2FsZTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3VwZGF0ZSgncmVzZXQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2Rlc3Ryb3koKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIHVubGlzdGVuQXJyYXlFdmVudHModGhpcy5fZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kYXRhQ2hlY2soKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0LmRhdGEgfHwgKGRhdGFzZXQuZGF0YSA9IFtdKTtcbiAgICBjb25zdCBfZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAvLyBJbiBvcmRlciB0byBjb3JyZWN0bHkgaGFuZGxlIGRhdGEgYWRkaXRpb24vZGVsZXRpb24gYW5pbWF0aW9uIChhbmQgdGh1cyBzaW11bGF0ZVxuICAgIC8vIHJlYWwtdGltZSBjaGFydHMpLCB3ZSBuZWVkIHRvIG1vbml0b3IgdGhlc2UgZGF0YSBtb2RpZmljYXRpb25zIGFuZCBzeW5jaHJvbml6ZVxuICAgIC8vIHRoZSBpbnRlcm5hbCBtZXRhZGF0YSBhY2NvcmRpbmdseS5cblxuICAgIGlmIChpc09iamVjdChkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKF9kYXRhICE9PSBkYXRhKSB7XG4gICAgICBpZiAoX2RhdGEpIHtcbiAgICAgICAgLy8gVGhpcyBjYXNlIGhhcHBlbnMgd2hlbiB0aGUgdXNlciByZXBsYWNlZCB0aGUgZGF0YSBhcnJheSBpbnN0YW5jZS5cbiAgICAgICAgdW5saXN0ZW5BcnJheUV2ZW50cyhfZGF0YSwgdGhpcyk7XG4gICAgICAgIC8vIERpc2NhcmQgb2xkIHBhcnNlZCBkYXRhIGFuZCBzdGFja3NcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgICAgICBtZXRhLl9wYXJzZWQgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhICYmIE9iamVjdC5pc0V4dGVuc2libGUoZGF0YSkpIHtcbiAgICAgICAgbGlzdGVuQXJyYXlFdmVudHMoZGF0YSwgdGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgfVxuICB9XG5cbiAgYWRkRWxlbWVudHMoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG5cbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcblxuICAgIGlmICh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgbWV0YS5kYXRhc2V0ID0gbmV3IHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKCk7XG4gICAgfVxuICB9XG5cbiAgYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IHN0YWNrQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5fZGF0YUNoZWNrKCk7XG5cbiAgICAvLyBtYWtlIHN1cmUgY2FjaGVkIF9zdGFja2VkIHN0YXR1cyBpcyBjdXJyZW50XG4gICAgY29uc3Qgb2xkU3RhY2tlZCA9IG1ldGEuX3N0YWNrZWQ7XG4gICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XG5cbiAgICAvLyBkZXRlY3QgY2hhbmdlIGluIHN0YWNrIG9wdGlvblxuICAgIGlmIChtZXRhLnN0YWNrICE9PSBkYXRhc2V0LnN0YWNrKSB7XG4gICAgICBzdGFja0NoYW5nZWQgPSB0cnVlO1xuICAgICAgLy8gcmVtb3ZlIHZhbHVlcyBmcm9tIG9sZCBzdGFja1xuICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICBtZXRhLnN0YWNrID0gZGF0YXNldC5zdGFjaztcbiAgICB9XG5cbiAgICAvLyBSZS1zeW5jIG1ldGEgZGF0YSBpbiBjYXNlIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IG9yIGlmIHdlIG1pc3NlZFxuICAgIC8vIGFueSB1cGRhdGVzIGFuZCBzbyBtYWtlIHN1cmUgdGhhdCB3ZSBoYW5kbGUgbnVtYmVyIG9mIGRhdGFwb2ludHMgY2hhbmdpbmcuXG4gICAgdGhpcy5fcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cyk7XG5cbiAgICAvLyBpZiBzdGFjayBjaGFuZ2VkLCB1cGRhdGUgc3RhY2sgdmFsdWVzIGZvciB0aGUgd2hvbGUgZGF0YXNldFxuICAgIGlmIChzdGFja0NoYW5nZWQgfHwgb2xkU3RhY2tlZCAhPT0gbWV0YS5fc3RhY2tlZCkge1xuICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIG1ldGEuX3BhcnNlZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIE1lcmdlcyB1c2VyLXN1cHBsaWVkIGFuZCBkZWZhdWx0IGRhdGFzZXQtbGV2ZWwgb3B0aW9uc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0U2NvcGVLZXlzKHRoaXMuX3R5cGUpO1xuICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cywgdHJ1ZSk7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIHRoaXMuX3BhcnNpbmcgPSB0aGlzLm9wdGlvbnMucGFyc2luZztcbiAgICB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnRcblx0ICovXG4gIHBhcnNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtfY2FjaGVkTWV0YTogbWV0YSwgX2RhdGE6IGRhdGF9ID0gdGhpcztcbiAgICBjb25zdCB7aVNjYWxlLCBfc3RhY2tlZH0gPSBtZXRhO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG5cbiAgICBsZXQgc29ydGVkID0gc3RhcnQgPT09IDAgJiYgY291bnQgPT09IGRhdGEubGVuZ3RoID8gdHJ1ZSA6IG1ldGEuX3NvcnRlZDtcbiAgICBsZXQgcHJldiA9IHN0YXJ0ID4gMCAmJiBtZXRhLl9wYXJzZWRbc3RhcnQgLSAxXTtcbiAgICBsZXQgaSwgY3VyLCBwYXJzZWQ7XG5cbiAgICBpZiAodGhpcy5fcGFyc2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIG1ldGEuX3BhcnNlZCA9IGRhdGE7XG4gICAgICBtZXRhLl9zb3J0ZWQgPSB0cnVlO1xuICAgICAgcGFyc2VkID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzQXJyYXkoZGF0YVtzdGFydF0pKSB7XG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZGF0YVtzdGFydF0pKSB7XG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldiA9ICgpID0+IGN1cltpQXhpc10gPT09IG51bGwgfHwgKHByZXYgJiYgY3VyW2lBeGlzXSA8IHByZXZbaUF4aXNdKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIG1ldGEuX3BhcnNlZFtpICsgc3RhcnRdID0gY3VyID0gcGFyc2VkW2ldO1xuICAgICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgICAgaWYgKGlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2KCkpIHtcbiAgICAgICAgICAgIHNvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmV2ID0gY3VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtZXRhLl9zb3J0ZWQgPSBzb3J0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKF9zdGFja2VkKSB7XG4gICAgICB1cGRhdGVTdGFja3ModGhpcywgcGFyc2VkKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2YgcHJpbWl0aXZlIHZhbHVlc1xuXHQgKiBAcGFyYW0ge29iamVjdH0gbWV0YSAtIGRhdGFzZXQgbWV0YVxuXHQgKiBAcGFyYW0ge2FycmF5fSBkYXRhIC0gZGF0YSBhcnJheS4gRXhhbXBsZSBbMSwzLDRdXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHN0YXJ0IGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIG51bWJlciBvZiBpdGVtcyB0byBwYXJzZVxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBwYXJzZWQgaXRlbSAtIGl0ZW0gY29udGFpbmluZyBpbmRleCBhbmQgYSBwYXJzZWQgdmFsdWVcblx0ICogZm9yIGVhY2ggc2NhbGUgaWQuXG5cdCAqIEV4YW1wbGU6IHt4U2NhbGUwOiAwLCB5U2NhbGUwOiAxfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IGxhYmVscyA9IGlTY2FsZS5nZXRMYWJlbHMoKTtcbiAgICBjb25zdCBzaW5nbGVTY2FsZSA9IGlTY2FsZSA9PT0gdlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4O1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgW2lBeGlzXTogc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpbmRleF0sIGluZGV4KSxcbiAgICAgICAgW3ZBeGlzXTogdlNjYWxlLnBhcnNlKGRhdGFbaW5kZXhdLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2YgYXJyYXlzXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhIC0gZGF0YXNldCBtZXRhXG5cdCAqIEBwYXJhbSB7YXJyYXl9IGRhdGEgLSBkYXRhIGFycmF5LiBFeGFtcGxlIFtbMSwyXSxbMyw0XV1cblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gc3RhcnQgaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gbnVtYmVyIG9mIGl0ZW1zIHRvIHBhcnNlXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHBhcnNlZCBpdGVtIC0gaXRlbSBjb250YWluaW5nIGluZGV4IGFuZCBhIHBhcnNlZCB2YWx1ZVxuXHQgKiBmb3IgZWFjaCBzY2FsZSBpZC5cblx0ICogRXhhbXBsZToge3g6IDAsIHk6IDF9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKGl0ZW1bMF0sIGluZGV4KSxcbiAgICAgICAgeTogeVNjYWxlLnBhcnNlKGl0ZW1bMV0sIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBvYmplY3RzXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhIC0gZGF0YXNldCBtZXRhXG5cdCAqIEBwYXJhbSB7YXJyYXl9IGRhdGEgLSBkYXRhIGFycmF5LiBFeGFtcGxlIFt7eDoxLCB5OjV9LCB7eDoyLCB5OjEwfV1cblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gc3RhcnQgaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gbnVtYmVyIG9mIGl0ZW1zIHRvIHBhcnNlXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHBhcnNlZCBpdGVtIC0gaXRlbSBjb250YWluaW5nIGluZGV4IGFuZCBhIHBhcnNlZCB2YWx1ZVxuXHQgKiBmb3IgZWFjaCBzY2FsZSBpZC4gX2N1c3RvbSBpcyBvcHRpb25hbFxuXHQgKiBFeGFtcGxlOiB7eFNjYWxlMDogMCwgeVNjYWxlMDogMSwgX2N1c3RvbToge3I6IDEwLCBmb286ICdiYXInfX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHt4QXhpc0tleSA9ICd4JywgeUF4aXNLZXkgPSAneSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleCwgaXRlbTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBpdGVtID0gZGF0YVtpbmRleF07XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIHg6IHhTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHhBeGlzS2V5KSwgaW5kZXgpLFxuICAgICAgICB5OiB5U2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCB5QXhpc0tleSksIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRQYXJzZWQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkW2luZGV4XTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXREYXRhRWxlbWVudChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLmRhdGFbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGFwcGx5U3RhY2soc2NhbGUsIHBhcnNlZCwgbW9kZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnNlZFtzY2FsZS5heGlzXTtcbiAgICBjb25zdCBzdGFjayA9IHtcbiAgICAgIGtleXM6IGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCB0cnVlKSxcbiAgICAgIHZhbHVlczogcGFyc2VkLl9zdGFja3Nbc2NhbGUuYXhpc10uX3Zpc3VhbFZhbHVlc1xuICAgIH07XG4gICAgcmV0dXJuIGFwcGx5U3RhY2soc3RhY2ssIHZhbHVlLCBtZXRhLmluZGV4LCB7bW9kZX0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spIHtcbiAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlZFtzY2FsZS5heGlzXTtcbiAgICBsZXQgdmFsdWUgPSBwYXJzZWRWYWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHBhcnNlZFZhbHVlO1xuICAgIGNvbnN0IHZhbHVlcyA9IHN0YWNrICYmIHBhcnNlZC5fc3RhY2tzW3NjYWxlLmF4aXNdO1xuICAgIGlmIChzdGFjayAmJiB2YWx1ZXMpIHtcbiAgICAgIHN0YWNrLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgIHZhbHVlID0gYXBwbHlTdGFjayhzdGFjaywgcGFyc2VkVmFsdWUsIHRoaXMuX2NhY2hlZE1ldGEuaW5kZXgpO1xuICAgIH1cbiAgICByYW5nZS5taW4gPSBNYXRoLm1pbihyYW5nZS5taW4sIHZhbHVlKTtcbiAgICByYW5nZS5tYXggPSBNYXRoLm1heChyYW5nZS5tYXgsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNaW5NYXgoc2NhbGUsIGNhblN0YWNrKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgX3BhcnNlZCA9IG1ldGEuX3BhcnNlZDtcbiAgICBjb25zdCBzb3J0ZWQgPSBtZXRhLl9zb3J0ZWQgJiYgc2NhbGUgPT09IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IGlsZW4gPSBfcGFyc2VkLmxlbmd0aDtcbiAgICBjb25zdCBvdGhlclNjYWxlID0gdGhpcy5fZ2V0T3RoZXJTY2FsZShzY2FsZSk7XG4gICAgY29uc3Qgc3RhY2sgPSBjcmVhdGVTdGFjayhjYW5TdGFjaywgbWV0YSwgdGhpcy5jaGFydCk7XG4gICAgY29uc3QgcmFuZ2UgPSB7bWluOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIG1heDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZfTtcbiAgICBjb25zdCB7bWluOiBvdGhlck1pbiwgbWF4OiBvdGhlck1heH0gPSBnZXRVc2VyQm91bmRzKG90aGVyU2NhbGUpO1xuICAgIGxldCBpLCBwYXJzZWQ7XG5cbiAgICBmdW5jdGlvbiBfc2tpcCgpIHtcbiAgICAgIHBhcnNlZCA9IF9wYXJzZWRbaV07XG4gICAgICBjb25zdCBvdGhlclZhbHVlID0gcGFyc2VkW290aGVyU2NhbGUuYXhpc107XG4gICAgICByZXR1cm4gIWlzRmluaXRlKHBhcnNlZFtzY2FsZS5heGlzXSkgfHwgb3RoZXJNaW4gPiBvdGhlclZhbHVlIHx8IG90aGVyTWF4IDwgb3RoZXJWYWx1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAoX3NraXAoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgIC8vIGlmIHRoZSBkYXRhIGlzIHNvcnRlZCwgd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmdXJ0aGVyIGZyb20gdGhpcyBlbmQgb2YgYXJyYXlcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgIC8vIGluIHRoZSBzb3J0ZWQgY2FzZSwgZmluZCBmaXJzdCBub24tc2tpcHBlZCB2YWx1ZSBmcm9tIG90aGVyIGVuZCBvZiBhcnJheVxuICAgICAgZm9yIChpID0gaWxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmIChfc2tpcCgpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYW5nZTtcbiAgfVxuXG4gIGdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZDtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgdmFsdWU7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gcGFyc2VkLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdmFsdWUgPSBwYXJzZWRbaV1bc2NhbGUuYXhpc107XG4gICAgICBpZiAoaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ8Ym9vbGVhbn1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBpU2NhbGUgPyAnJyArIGlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFtpU2NhbGUuYXhpc10pIDogJycsXG4gICAgICB2YWx1ZTogdlNjYWxlID8gJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKSA6ICcnXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy51cGRhdGUobW9kZSB8fCAnZGVmYXVsdCcpO1xuICAgIG1ldGEuX2NsaXAgPSB0b0NsaXAodmFsdWVPckRlZmF1bHQodGhpcy5vcHRpb25zLmNsaXAsIGRlZmF1bHRDbGlwKG1ldGEueFNjYWxlLCBtZXRhLnlTY2FsZSwgdGhpcy5nZXRNYXhPdmVyZmxvdygpKSkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlXG5cdCAqL1xuICB1cGRhdGUobW9kZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIGRyYXcoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5fY3R4O1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBlbGVtZW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBjb25zdCBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IGFjdGl2ZSA9IFtdO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fZHJhd1N0YXJ0IHx8IDA7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLl9kcmF3Q291bnQgfHwgKGVsZW1lbnRzLmxlbmd0aCAtIHN0YXJ0KTtcbiAgICBjb25zdCBkcmF3QWN0aXZlRWxlbWVudHNPblRvcCA9IHRoaXMub3B0aW9ucy5kcmF3QWN0aXZlRWxlbWVudHNPblRvcDtcbiAgICBsZXQgaTtcblxuICAgIGlmIChtZXRhLmRhdGFzZXQpIHtcbiAgICAgIG1ldGEuZGF0YXNldC5kcmF3KGN0eCwgYXJlYSwgc3RhcnQsIGNvdW50KTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgaWYgKGVsZW1lbnQuaGlkZGVuKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQuYWN0aXZlICYmIGRyYXdBY3RpdmVFbGVtZW50c09uVG9wKSB7XG4gICAgICAgIGFjdGl2ZS5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5kcmF3KGN0eCwgYXJlYSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7ICsraSkge1xuICAgICAgYWN0aXZlW2ldLmRyYXcoY3R4LCBhcmVhKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHNldCBvZiBwcmVkZWZpbmVkIHN0eWxlIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZXByZXNlbnQgdGhlIGRhdGFzZXRcblx0ICogb3IgdGhlIGRhdGEgaWYgdGhlIGluZGV4IGlzIHNwZWNpZmllZFxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBkYXRhIGluZGV4XG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FjdGl2ZV0gLSB0cnVlIGlmIGhvdmVyXG5cdCAqIEByZXR1cm4ge29iamVjdH0gc3R5bGUgb2JqZWN0XG5cdCAqL1xuICBnZXRTdHlsZShpbmRleCwgYWN0aXZlKSB7XG4gICAgY29uc3QgbW9kZSA9IGFjdGl2ZSA/ICdhY3RpdmUnIDogJ2RlZmF1bHQnO1xuICAgIHJldHVybiBpbmRleCA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldFxuICAgICAgPyB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSlcbiAgICAgIDogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4IHx8IDAsIG1vZGUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSwgbW9kZSkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBsZXQgY29udGV4dDtcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX2NhY2hlZE1ldGEuZGF0YS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFbaW5kZXhdO1xuICAgICAgY29udGV4dCA9IGVsZW1lbnQuJGNvbnRleHQgfHxcbiAgICAgICAgKGVsZW1lbnQuJGNvbnRleHQgPSBjcmVhdGVEYXRhQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIGVsZW1lbnQpKTtcbiAgICAgIGNvbnRleHQucGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgICAgY29udGV4dC5yYXcgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xuICAgICAgY29udGV4dC5pbmRleCA9IGNvbnRleHQuZGF0YUluZGV4ID0gaW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzLiRjb250ZXh0IHx8XG4gICAgICAgICh0aGlzLiRjb250ZXh0ID0gY3JlYXRlRGF0YXNldENvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMuaW5kZXgpKTtcbiAgICAgIGNvbnRleHQuZGF0YXNldCA9IGRhdGFzZXQ7XG4gICAgICBjb250ZXh0LmluZGV4ID0gY29udGV4dC5kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgIH1cblxuICAgIGNvbnRleHQuYWN0aXZlID0gISFhY3RpdmU7XG4gICAgY29udGV4dC5tb2RlID0gbW9kZTtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW21vZGVdXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhc2V0RWxlbWVudFR5cGUuaWQsIG1vZGUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW21vZGVdXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YUVsZW1lbnRUeXBlLmlkLCBtb2RlLCBpbmRleCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZXNvbHZlRWxlbWVudE9wdGlvbnMoZWxlbWVudFR5cGUsIG1vZGUgPSAnZGVmYXVsdCcsIGluZGV4KSB7XG4gICAgY29uc3QgYWN0aXZlID0gbW9kZSA9PT0gJ2FjdGl2ZSc7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWREYXRhT3B0cztcbiAgICBjb25zdCBjYWNoZUtleSA9IGVsZW1lbnRUeXBlICsgJy0nICsgbW9kZTtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgY29uc3Qgc2hhcmluZyA9IHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyAmJiBkZWZpbmVkKGluZGV4KTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2xvbmVJZk5vdFNoYXJlZChjYWNoZWQsIHNoYXJpbmcpO1xuICAgIH1cbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldEVsZW1lbnRTY29wZUtleXModGhpcy5fdHlwZSwgZWxlbWVudFR5cGUpO1xuICAgIGNvbnN0IHByZWZpeGVzID0gYWN0aXZlID8gW2Ake2VsZW1lbnRUeXBlfUhvdmVyYCwgJ2hvdmVyJywgZWxlbWVudFR5cGUsICcnXSA6IFtlbGVtZW50VHlwZSwgJyddO1xuICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cyk7XG4gICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0cy5lbGVtZW50c1tlbGVtZW50VHlwZV0pO1xuICAgIC8vIGNvbnRleHQgaXMgcHJvdmlkZWQgYXMgYSBmdW5jdGlvbiwgYW5kIGlzIGNhbGxlZCBvbmx5IGlmIG5lZWRlZCxcbiAgICAvLyBzbyB3ZSBkb24ndCBjcmVhdGUgYSBjb250ZXh0IGZvciBlYWNoIGVsZW1lbnQgaWYgbm90IG5lZWRlZC5cbiAgICBjb25zdCBjb250ZXh0ID0gKCkgPT4gdGhpcy5nZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIG1vZGUpO1xuICAgIGNvbnN0IHZhbHVlcyA9IGNvbmZpZy5yZXNvbHZlTmFtZWRPcHRpb25zKHNjb3BlcywgbmFtZXMsIGNvbnRleHQsIHByZWZpeGVzKTtcblxuICAgIGlmICh2YWx1ZXMuJHNoYXJlZCkge1xuICAgICAgLy8gYCRzaGFyZWRgIGluZGljYXRlcyB0aGlzIHNldCBvZiBvcHRpb25zIGNhbiBiZSBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSBlbGVtZW50cy5cbiAgICAgIC8vIFNoYXJpbmcgaXMgdXNlZCB0byByZWR1Y2UgbnVtYmVyIG9mIHByb3BlcnRpZXMgdG8gY2hhbmdlIGR1cmluZyBhbmltYXRpb24uXG4gICAgICB2YWx1ZXMuJHNoYXJlZCA9IHNoYXJpbmc7XG5cbiAgICAgIC8vIFdlIGNhY2hlIG9wdGlvbnMgYnkgYG1vZGVgLCB3aGljaCBjYW4gYmUgJ2FjdGl2ZScgZm9yIGV4YW1wbGUuIFRoaXMgZW5hYmxlcyB1c1xuICAgICAgLy8gdG8gaGF2ZSB0aGUgJ2FjdGl2ZScgZWxlbWVudCBvcHRpb25zIGFuZCAnZGVmYXVsdCcgb3B0aW9ucyB0byBzd2l0Y2ggYmV0d2VlblxuICAgICAgLy8gd2hlbiBpbnRlcmFjdGluZy5cbiAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IE9iamVjdC5mcmVlemUoY2xvbmVJZk5vdFNoYXJlZCh2YWx1ZXMsIHNoYXJpbmcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgdHJhbnNpdGlvbiwgYWN0aXZlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkRGF0YU9wdHM7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBgYW5pbWF0aW9uLSR7dHJhbnNpdGlvbn1gO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBsZXQgb3B0aW9ucztcbiAgICBpZiAoY2hhcnQub3B0aW9ucy5hbmltYXRpb24gIT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNoYXJ0LmNvbmZpZztcbiAgICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzKHRoaXMuX3R5cGUsIHRyYW5zaXRpb24pO1xuICAgICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzKTtcbiAgICAgIG9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCB0aGlzLmdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSwgdHJhbnNpdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbnMoY2hhcnQsIG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRpb25zKTtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9jYWNoZWFibGUpIHtcbiAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IE9iamVjdC5mcmVlemUoYW5pbWF0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgZm9yIGdldHRpbmcgdGhlIG9wdGlvbnMgb2JqZWN0IHNoYXJlZCBiZXR3ZWVuIGVsZW1lbnRzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldFNoYXJlZE9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy4kc2hhcmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zaGFyZWRPcHRpb25zIHx8ICh0aGlzLl9zaGFyZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucykpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgZm9yIGRldGVybWluaW5nIGlmIGBvcHRpb25zYCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHVwZGF0ZWQgcHJvcGVydGllc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBpbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKSB7XG4gICAgcmV0dXJuICFzaGFyZWRPcHRpb25zIHx8IGlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSB8fCB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHRvZG8gdjQsIHJlbmFtZSB0byBnZXRTaGFyZWRPcHRpb25zIGFuZCByZW1vdmUgZXhjZXNzIGZ1bmN0aW9uc1xuICAgKi9cbiAgX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpIHtcbiAgICBjb25zdCBmaXJzdE9wdHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHByZXZpb3VzbHlTaGFyZWRPcHRpb25zID0gdGhpcy5fc2hhcmVkT3B0aW9ucztcbiAgICBjb25zdCBzaGFyZWRPcHRpb25zID0gdGhpcy5nZXRTaGFyZWRPcHRpb25zKGZpcnN0T3B0cyk7XG4gICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSB0aGlzLmluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpIHx8IChzaGFyZWRPcHRpb25zICE9PSBwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyk7XG4gICAgdGhpcy51cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIGZpcnN0T3B0cyk7XG4gICAgcmV0dXJuIHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc307XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSBmb3IgdXBkYXRpbmcgYW4gZWxlbWVudCB3aXRoIG5ldyBwcm9wZXJ0aWVzLCB1c2luZyBhbmltYXRpb25zIHdoZW4gYXBwcm9wcmlhdGUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHVwZGF0ZUVsZW1lbnQoZWxlbWVudCwgaW5kZXgsIHByb3BlcnRpZXMsIG1vZGUpIHtcbiAgICBpZiAoaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgbW9kZSkudXBkYXRlKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IHRvIGFuaW1hdGUgdGhlIHNoYXJlZCBvcHRpb25zLCB0aGF0IGFyZSBwb3RlbnRpYWxseSBhZmZlY3RpbmcgbXVsdGlwbGUgZWxlbWVudHMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgbmV3T3B0aW9ucykge1xuICAgIGlmIChzaGFyZWRPcHRpb25zICYmICFpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKHVuZGVmaW5lZCwgbW9kZSkudXBkYXRlKHNoYXJlZE9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCBtb2RlLCBhY3RpdmUpIHtcbiAgICBlbGVtZW50LmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5nZXRTdHlsZShpbmRleCwgYWN0aXZlKTtcbiAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgbW9kZSwgYWN0aXZlKS51cGRhdGUoZWxlbWVudCwge1xuICAgICAgLy8gV2hlbiBnb2luZyBmcm9tIGFjdGl2ZSB0byBpbmFjdGl2ZSwgd2UgbmVlZCB0byB1cGRhdGUgdG8gdGhlIHNoYXJlZCBvcHRpb25zLlxuICAgICAgLy8gVGhpcyB3YXkgdGhlIG9uY2UgaG92ZXJlZCBlbGVtZW50IHdpbGwgZW5kIHVwIHdpdGggdGhlIHNhbWUgb3JpZ2luYWwgc2hhcmVkIG9wdGlvbnMgaW5zdGFuY2UsIGFmdGVyIGFuaW1hdGlvbi5cbiAgICAgIG9wdGlvbnM6ICghYWN0aXZlICYmIHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhvcHRpb25zKSkgfHwgb3B0aW9uc1xuICAgIH0pO1xuICB9XG5cbiAgcmVtb3ZlSG92ZXJTdHlsZShlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsICdhY3RpdmUnLCBmYWxzZSk7XG4gIH1cblxuICBzZXRIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgJ2FjdGl2ZScsIHRydWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGUoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldDtcblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCB1bmRlZmluZWQsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfc2V0RGF0YXNldEhvdmVyU3R5bGUoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldDtcblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCB1bmRlZmluZWQsICdhY3RpdmUnLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZXN5bmNFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG5cbiAgICAvLyBBcHBseSBjaGFuZ2VzIGRldGVjdGVkIHRocm91Z2ggYXJyYXkgbGlzdGVuZXJzXG4gICAgZm9yIChjb25zdCBbbWV0aG9kLCBhcmcxLCBhcmcyXSBvZiB0aGlzLl9zeW5jTGlzdCkge1xuICAgICAgdGhpc1ttZXRob2RdKGFyZzEsIGFyZzIpO1xuICAgIH1cbiAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuXG4gICAgY29uc3QgbnVtTWV0YSA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICBjb25zdCBudW1EYXRhID0gZGF0YS5sZW5ndGg7XG4gICAgY29uc3QgY291bnQgPSBNYXRoLm1pbihudW1EYXRhLCBudW1NZXRhKTtcblxuICAgIGlmIChjb3VudCkge1xuICAgICAgLy8gVE9ETzogSXQgaXMgbm90IG9wdGltYWwgdG8gYWx3YXlzIHBhcnNlIHRoZSBvbGQgZGF0YVxuICAgICAgLy8gVGhpcyBpcyBkb25lIGJlY2F1c2Ugd2UgYXJlIG5vdCBkZXRlY3RpbmcgZGlyZWN0IGFzc2lnbm1lbnRzOlxuICAgICAgLy8gY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhWzVdID0gMTA7XG4gICAgICAvLyBjaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGFbNV0ueSA9IDEwO1xuICAgICAgdGhpcy5wYXJzZSgwLCBjb3VudCk7XG4gICAgfVxuXG4gICAgaWYgKG51bURhdGEgPiBudW1NZXRhKSB7XG4gICAgICB0aGlzLl9pbnNlcnRFbGVtZW50cyhudW1NZXRhLCBudW1EYXRhIC0gbnVtTWV0YSwgcmVzZXROZXdFbGVtZW50cyk7XG4gICAgfSBlbHNlIGlmIChudW1EYXRhIDwgbnVtTWV0YSkge1xuICAgICAgdGhpcy5fcmVtb3ZlRWxlbWVudHMobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2luc2VydEVsZW1lbnRzKHN0YXJ0LCBjb3VudCwgcmVzZXROZXdFbGVtZW50cyA9IHRydWUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgY291bnQ7XG4gICAgbGV0IGk7XG5cbiAgICBjb25zdCBtb3ZlID0gKGFycikgPT4ge1xuICAgICAgYXJyLmxlbmd0aCArPSBjb3VudDtcbiAgICAgIGZvciAoaSA9IGFyci5sZW5ndGggLSAxOyBpID49IGVuZDsgaS0tKSB7XG4gICAgICAgIGFycltpXSA9IGFycltpIC0gY291bnRdO1xuICAgICAgfVxuICAgIH07XG4gICAgbW92ZShkYXRhKTtcblxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIGRhdGFbaV0gPSBuZXcgdGhpcy5kYXRhRWxlbWVudFR5cGUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgbW92ZShtZXRhLl9wYXJzZWQpO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlKHN0YXJ0LCBjb3VudCk7XG5cbiAgICBpZiAocmVzZXROZXdFbGVtZW50cykge1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50cyhkYXRhLCBzdGFydCwgY291bnQsICdyZXNldCcpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKGVsZW1lbnQsIHN0YXJ0LCBjb3VudCwgbW9kZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3JlbW92ZUVsZW1lbnRzKHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICBjb25zdCByZW1vdmVkID0gbWV0YS5fcGFyc2VkLnNwbGljZShzdGFydCwgY291bnQpO1xuICAgICAgaWYgKG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgICAgY2xlYXJTdGFja3MobWV0YSwgcmVtb3ZlZCk7XG4gICAgICB9XG4gICAgfVxuICAgIG1ldGEuZGF0YS5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3N5bmMoYXJncykge1xuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICB0aGlzLl9zeW5jTGlzdC5wdXNoKGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbbWV0aG9kLCBhcmcxLCBhcmcyXSA9IGFyZ3M7XG4gICAgICB0aGlzW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgfVxuICAgIHRoaXMuY2hhcnQuX2RhdGFDaGFuZ2VzLnB1c2goW3RoaXMuaW5kZXgsIC4uLmFyZ3NdKTtcbiAgfVxuXG4gIF9vbkRhdGFQdXNoKCkge1xuICAgIGNvbnN0IGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgdGhpcy5nZXREYXRhc2V0KCkuZGF0YS5sZW5ndGggLSBjb3VudCwgY291bnRdKTtcbiAgfVxuXG4gIF9vbkRhdGFQb3AoKSB7XG4gICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIHRoaXMuX2NhY2hlZE1ldGEuZGF0YS5sZW5ndGggLSAxLCAxXSk7XG4gIH1cblxuICBfb25EYXRhU2hpZnQoKSB7XG4gICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIDAsIDFdKTtcbiAgfVxuXG4gIF9vbkRhdGFTcGxpY2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgc3RhcnQsIGNvdW50XSk7XG4gICAgfVxuICAgIGNvbnN0IG5ld0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgaWYgKG5ld0NvdW50KSB7XG4gICAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgc3RhcnQsIG5ld0NvdW50XSk7XG4gICAgfVxuICB9XG5cbiAgX29uRGF0YVVuc2hpZnQoKSB7XG4gICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIDAsIGFyZ3VtZW50cy5sZW5ndGhdKTtcbiAgfVxufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtcbiAgX2FycmF5VW5pcXVlLCBpc0FycmF5LCBpc051bGxPclVuZGVmLFxuICB2YWx1ZU9yRGVmYXVsdCwgcmVzb2x2ZU9iamVjdEtleSwgc2lnbiwgZGVmaW5lZFxufSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZnVuY3Rpb24gZ2V0QWxsU2NhbGVWYWx1ZXMoc2NhbGUsIHR5cGUpIHtcbiAgaWYgKCFzY2FsZS5fY2FjaGUuJGJhcikge1xuICAgIGNvbnN0IHZpc2libGVNZXRhcyA9IHNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpO1xuICAgIGxldCB2YWx1ZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdmlzaWJsZU1ldGFzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh2aXNpYmxlTWV0YXNbaV0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXMoc2NhbGUpKTtcbiAgICB9XG4gICAgc2NhbGUuX2NhY2hlLiRiYXIgPSBfYXJyYXlVbmlxdWUodmFsdWVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKSk7XG4gIH1cbiAgcmV0dXJuIHNjYWxlLl9jYWNoZS4kYmFyO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBcIm9wdGltYWxcIiBzYW1wbGUgc2l6ZSB0byBtYWludGFpbiBiYXJzIGVxdWFsbHkgc2l6ZWQgd2hpbGUgcHJldmVudGluZyBvdmVybGFwLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZU1pblNhbXBsZVNpemUobWV0YSkge1xuICBjb25zdCBzY2FsZSA9IG1ldGEuaVNjYWxlO1xuICBjb25zdCB2YWx1ZXMgPSBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSwgbWV0YS50eXBlKTtcbiAgbGV0IG1pbiA9IHNjYWxlLl9sZW5ndGg7XG4gIGxldCBpLCBpbGVuLCBjdXJyLCBwcmV2O1xuICBjb25zdCB1cGRhdGVNaW5BbmRQcmV2ID0gKCkgPT4ge1xuICAgIGlmIChjdXJyID09PSAzMjc2NyB8fCBjdXJyID09PSAtMzI3NjgpIHtcbiAgICAgIC8vIElnbm9yZSB0cnVuY2F0ZWQgcGl4ZWxzXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkZWZpbmVkKHByZXYpKSB7XG4gICAgICAvLyBjdXJyIC0gcHJldiA9PT0gMCBpcyBpZ25vcmVkXG4gICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguYWJzKGN1cnIgLSBwcmV2KSB8fCBtaW4pO1xuICAgIH1cbiAgICBwcmV2ID0gY3VycjtcbiAgfTtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlc1tpXSk7XG4gICAgdXBkYXRlTWluQW5kUHJldigpO1xuICB9XG5cbiAgcHJldiA9IHVuZGVmaW5lZDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHNjYWxlLnRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2soaSk7XG4gICAgdXBkYXRlTWluQW5kUHJldigpO1xuICB9XG5cbiAgcmV0dXJuIG1pbjtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyBhbiBcImlkZWFsXCIgY2F0ZWdvcnkgYmFzZWQgb24gdGhlIGFic29sdXRlIGJhciB0aGlja25lc3Mgb3IsIGlmIHVuZGVmaW5lZCBvciBudWxsLFxuICogdXNlcyB0aGUgc21hbGxlc3QgaW50ZXJ2YWwgKHNlZSBjb21wdXRlTWluU2FtcGxlU2l6ZSkgdGhhdCBwcmV2ZW50cyBiYXIgb3ZlcmxhcHBpbmcuIFRoaXNcbiAqIG1vZGUgY3VycmVudGx5IGFsd2F5cyBnZW5lcmF0ZXMgYmFycyBlcXVhbGx5IHNpemVkICh1bnRpbCB3ZSBpbnRyb2R1Y2Ugc2NyaXB0YWJsZSBvcHRpb25zPykuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KSB7XG4gIGNvbnN0IHRoaWNrbmVzcyA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzO1xuICBsZXQgc2l6ZSwgcmF0aW87XG5cbiAgaWYgKGlzTnVsbE9yVW5kZWYodGhpY2tuZXNzKSkge1xuICAgIHNpemUgPSBydWxlci5taW4gKiBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcbiAgICByYXRpbyA9IG9wdGlvbnMuYmFyUGVyY2VudGFnZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXaGVuIGJhciB0aGlja25lc3MgaXMgZW5mb3JjZWQsIGNhdGVnb3J5IGFuZCBiYXIgcGVyY2VudGFnZXMgYXJlIGlnbm9yZWQuXG4gICAgLy8gTm90ZShTQik6IHdlIGNvdWxkIGFkZCBzdXBwb3J0IGZvciByZWxhdGl2ZSBiYXIgdGhpY2tuZXNzIChlLmcuIGJhclRoaWNrbmVzczogJzUwJScpXG4gICAgLy8gYW5kIGRlcHJlY2F0ZSBiYXJQZXJjZW50YWdlIHNpbmNlIHRoaXMgdmFsdWUgaXMgaWdub3JlZCB3aGVuIHRoaWNrbmVzcyBpcyBhYnNvbHV0ZS5cbiAgICBzaXplID0gdGhpY2tuZXNzICogc3RhY2tDb3VudDtcbiAgICByYXRpbyA9IDE7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNodW5rOiBzaXplIC8gc3RhY2tDb3VudCxcbiAgICByYXRpbyxcbiAgICBzdGFydDogcnVsZXIucGl4ZWxzW2luZGV4XSAtIChzaXplIC8gMilcbiAgfTtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyBhbiBcIm9wdGltYWxcIiBjYXRlZ29yeSB0aGF0IGdsb2JhbGx5IGFycmFuZ2VzIGJhcnMgc2lkZSBieSBzaWRlIChubyBnYXAgd2hlblxuICogcGVyY2VudGFnZSBvcHRpb25zIGFyZSAxKSwgYmFzZWQgb24gdGhlIHByZXZpb3VzIGFuZCBmb2xsb3dpbmcgY2F0ZWdvcmllcy4gVGhpcyBtb2RlXG4gKiBnZW5lcmF0ZXMgYmFycyB3aXRoIGRpZmZlcmVudCB3aWR0aHMgd2hlbiBkYXRhIGFyZSBub3QgZXZlbmx5IHNwYWNlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KSB7XG4gIGNvbnN0IHBpeGVscyA9IHJ1bGVyLnBpeGVscztcbiAgY29uc3QgY3VyciA9IHBpeGVsc1tpbmRleF07XG4gIGxldCBwcmV2ID0gaW5kZXggPiAwID8gcGl4ZWxzW2luZGV4IC0gMV0gOiBudWxsO1xuICBsZXQgbmV4dCA9IGluZGV4IDwgcGl4ZWxzLmxlbmd0aCAtIDEgPyBwaXhlbHNbaW5kZXggKyAxXSA6IG51bGw7XG4gIGNvbnN0IHBlcmNlbnQgPSBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcblxuICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgIC8vIGZpcnN0IGRhdGE6IGl0cyBzaXplIGlzIGRvdWJsZSBiYXNlZCBvbiB0aGUgbmV4dCBwb2ludCBvcixcbiAgICAvLyBpZiBpdCdzIGFsc28gdGhlIGxhc3QgZGF0YSwgd2UgdXNlIHRoZSBzY2FsZSBzaXplLlxuICAgIHByZXYgPSBjdXJyIC0gKG5leHQgPT09IG51bGwgPyBydWxlci5lbmQgLSBydWxlci5zdGFydCA6IG5leHQgLSBjdXJyKTtcbiAgfVxuXG4gIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgLy8gbGFzdCBkYXRhOiBpdHMgc2l6ZSBpcyBhbHNvIGRvdWJsZSBiYXNlZCBvbiB0aGUgcHJldmlvdXMgcG9pbnQuXG4gICAgbmV4dCA9IGN1cnIgKyBjdXJyIC0gcHJldjtcbiAgfVxuXG4gIGNvbnN0IHN0YXJ0ID0gY3VyciAtIChjdXJyIC0gTWF0aC5taW4ocHJldiwgbmV4dCkpIC8gMiAqIHBlcmNlbnQ7XG4gIGNvbnN0IHNpemUgPSBNYXRoLmFicyhuZXh0IC0gcHJldikgLyAyICogcGVyY2VudDtcblxuICByZXR1cm4ge1xuICAgIGNodW5rOiBzaXplIC8gc3RhY2tDb3VudCxcbiAgICByYXRpbzogb3B0aW9ucy5iYXJQZXJjZW50YWdlLFxuICAgIHN0YXJ0XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlRmxvYXRCYXIoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICBjb25zdCBzdGFydFZhbHVlID0gdlNjYWxlLnBhcnNlKGVudHJ5WzBdLCBpKTtcbiAgY29uc3QgZW5kVmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMV0sIGkpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgbGV0IGJhclN0YXJ0ID0gbWluO1xuICBsZXQgYmFyRW5kID0gbWF4O1xuXG4gIGlmIChNYXRoLmFicyhtaW4pID4gTWF0aC5hYnMobWF4KSkge1xuICAgIGJhclN0YXJ0ID0gbWF4O1xuICAgIGJhckVuZCA9IG1pbjtcbiAgfVxuXG4gIC8vIFN0b3JlIGBiYXJFbmRgIChmdXJ0aGVzdCBhd2F5IGZyb20gb3JpZ2luKSBhcyBwYXJzZWQgdmFsdWUsXG4gIC8vIHRvIG1ha2Ugc3RhY2tpbmcgc3RyYWlnaHQgZm9yd2FyZFxuICBpdGVtW3ZTY2FsZS5heGlzXSA9IGJhckVuZDtcblxuICBpdGVtLl9jdXN0b20gPSB7XG4gICAgYmFyU3RhcnQsXG4gICAgYmFyRW5kLFxuICAgIHN0YXJ0OiBzdGFydFZhbHVlLFxuICAgIGVuZDogZW5kVmFsdWUsXG4gICAgbWluLFxuICAgIG1heFxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVZhbHVlKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpIHtcbiAgaWYgKGlzQXJyYXkoZW50cnkpKSB7XG4gICAgcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKTtcbiAgfSBlbHNlIHtcbiAgICBpdGVtW3ZTY2FsZS5heGlzXSA9IHZTY2FsZS5wYXJzZShlbnRyeSwgaSk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5cbmZ1bmN0aW9uIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XG4gIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gIGNvbnN0IHBhcnNlZCA9IFtdO1xuICBsZXQgaSwgaWxlbiwgaXRlbSwgZW50cnk7XG5cbiAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgZW50cnkgPSBkYXRhW2ldO1xuICAgIGl0ZW0gPSB7fTtcbiAgICBpdGVtW2lTY2FsZS5heGlzXSA9IHNpbmdsZVNjYWxlIHx8IGlTY2FsZS5wYXJzZShsYWJlbHNbaV0sIGkpO1xuICAgIHBhcnNlZC5wdXNoKHBhcnNlVmFsdWUoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkpO1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG5cbmZ1bmN0aW9uIGlzRmxvYXRCYXIoY3VzdG9tKSB7XG4gIHJldHVybiBjdXN0b20gJiYgY3VzdG9tLmJhclN0YXJ0ICE9PSB1bmRlZmluZWQgJiYgY3VzdG9tLmJhckVuZCAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBiYXJTaWduKHNpemUsIHZTY2FsZSwgYWN0dWFsQmFzZSkge1xuICBpZiAoc2l6ZSAhPT0gMCkge1xuICAgIHJldHVybiBzaWduKHNpemUpO1xuICB9XG4gIHJldHVybiAodlNjYWxlLmlzSG9yaXpvbnRhbCgpID8gMSA6IC0xKSAqICh2U2NhbGUubWluID49IGFjdHVhbEJhc2UgPyAxIDogLTEpO1xufVxuXG5mdW5jdGlvbiBib3JkZXJQcm9wcyhwcm9wZXJ0aWVzKSB7XG4gIGxldCByZXZlcnNlLCBzdGFydCwgZW5kLCB0b3AsIGJvdHRvbTtcbiAgaWYgKHByb3BlcnRpZXMuaG9yaXpvbnRhbCkge1xuICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPiBwcm9wZXJ0aWVzLng7XG4gICAgc3RhcnQgPSAnbGVmdCc7XG4gICAgZW5kID0gJ3JpZ2h0JztcbiAgfSBlbHNlIHtcbiAgICByZXZlcnNlID0gcHJvcGVydGllcy5iYXNlIDwgcHJvcGVydGllcy55O1xuICAgIHN0YXJ0ID0gJ2JvdHRvbSc7XG4gICAgZW5kID0gJ3RvcCc7XG4gIH1cbiAgaWYgKHJldmVyc2UpIHtcbiAgICB0b3AgPSAnZW5kJztcbiAgICBib3R0b20gPSAnc3RhcnQnO1xuICB9IGVsc2Uge1xuICAgIHRvcCA9ICdzdGFydCc7XG4gICAgYm90dG9tID0gJ2VuZCc7XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgZW5kLCByZXZlcnNlLCB0b3AsIGJvdHRvbX07XG59XG5cbmZ1bmN0aW9uIHNldEJvcmRlclNraXBwZWQocHJvcGVydGllcywgb3B0aW9ucywgc3RhY2ssIGluZGV4KSB7XG4gIGxldCBlZGdlID0gb3B0aW9ucy5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCByZXMgPSB7fTtcblxuICBpZiAoIWVkZ2UpIHtcbiAgICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSByZXM7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVkZ2UgPT09IHRydWUpIHtcbiAgICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSB7dG9wOiB0cnVlLCByaWdodDogdHJ1ZSwgYm90dG9tOiB0cnVlLCBsZWZ0OiB0cnVlfTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB7c3RhcnQsIGVuZCwgcmV2ZXJzZSwgdG9wLCBib3R0b219ID0gYm9yZGVyUHJvcHMocHJvcGVydGllcyk7XG5cbiAgaWYgKGVkZ2UgPT09ICdtaWRkbGUnICYmIHN0YWNrKSB7XG4gICAgcHJvcGVydGllcy5lbmFibGVCb3JkZXJSYWRpdXMgPSB0cnVlO1xuICAgIGlmICgoc3RhY2suX3RvcCB8fCAwKSA9PT0gaW5kZXgpIHtcbiAgICAgIGVkZ2UgPSB0b3A7XG4gICAgfSBlbHNlIGlmICgoc3RhY2suX2JvdHRvbSB8fCAwKSA9PT0gaW5kZXgpIHtcbiAgICAgIGVkZ2UgPSBib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1twYXJzZUVkZ2UoYm90dG9tLCBzdGFydCwgZW5kLCByZXZlcnNlKV0gPSB0cnVlO1xuICAgICAgZWRnZSA9IHRvcDtcbiAgICB9XG4gIH1cblxuICByZXNbcGFyc2VFZGdlKGVkZ2UsIHN0YXJ0LCBlbmQsIHJldmVyc2UpXSA9IHRydWU7XG4gIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHJlcztcbn1cblxuZnVuY3Rpb24gcGFyc2VFZGdlKGVkZ2UsIGEsIGIsIHJldmVyc2UpIHtcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBlZGdlID0gc3dhcChlZGdlLCBhLCBiKTtcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYiwgYSk7XG4gIH0gZWxzZSB7XG4gICAgZWRnZSA9IHN0YXJ0RW5kKGVkZ2UsIGEsIGIpO1xuICB9XG4gIHJldHVybiBlZGdlO1xufVxuXG5mdW5jdGlvbiBzd2FwKG9yaWcsIHYxLCB2Mikge1xuICByZXR1cm4gb3JpZyA9PT0gdjEgPyB2MiA6IG9yaWcgPT09IHYyID8gdjEgOiBvcmlnO1xufVxuXG5mdW5jdGlvbiBzdGFydEVuZCh2LCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiB2ID09PSAnc3RhcnQnID8gc3RhcnQgOiB2ID09PSAnZW5kJyA/IGVuZCA6IHY7XG59XG5cbmZ1bmN0aW9uIHNldEluZmxhdGVBbW91bnQocHJvcGVydGllcywge2luZmxhdGVBbW91bnR9LCByYXRpbykge1xuICBwcm9wZXJ0aWVzLmluZmxhdGVBbW91bnQgPSBpbmZsYXRlQW1vdW50ID09PSAnYXV0bydcbiAgICA/IHJhdGlvID09PSAxID8gMC4zMyA6IDBcbiAgICA6IGluZmxhdGVBbW91bnQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ2Jhcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdiYXInLFxuXG4gICAgY2F0ZWdvcnlQZXJjZW50YWdlOiAwLjgsXG4gICAgYmFyUGVyY2VudGFnZTogMC45LFxuICAgIGdyb3VwZWQ6IHRydWUsXG5cbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdiYXNlJywgJ3dpZHRoJywgJ2hlaWdodCddXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBzY2FsZXM6IHtcbiAgICAgIF9pbmRleF86IHtcbiAgICAgICAgdHlwZTogJ2NhdGVnb3J5JyxcbiAgICAgICAgb2Zmc2V0OiB0cnVlLFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgb2Zmc2V0OiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfdmFsdWVfOiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInLFxuICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cblxuICAvKipcblx0ICogT3ZlcnJpZGluZyBwcmltaXRpdmUgZGF0YSBwYXJzaW5nIHNpbmNlIHdlIHN1cHBvcnQgbWl4ZWQgcHJpbWl0aXZlL2FycmF5XG5cdCAqIGRhdGEgZm9yIGZsb2F0IGJhcnNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBPdmVycmlkaW5nIGFycmF5IGRhdGEgcGFyc2luZyBzaW5jZSB3ZSBzdXBwb3J0IG1peGVkIHByaW1pdGl2ZS9hcnJheVxuXHQgKiBkYXRhIGZvciBmbG9hdCBiYXJzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBPdmVycmlkaW5nIG9iamVjdCBkYXRhIHBhcnNpbmcgc2luY2Ugd2Ugc3VwcG9ydCBtaXhlZCBwcmltaXRpdmUvYXJyYXlcblx0ICogdmFsdWUtc2NhbGUgZGF0YSBmb3IgZmxvYXQgYmFyc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IGlBeGlzS2V5ID0gaVNjYWxlLmF4aXMgPT09ICd4JyA/IHhBeGlzS2V5IDogeUF4aXNLZXk7XG4gICAgY29uc3QgdkF4aXNLZXkgPSB2U2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgaXRlbSwgb2JqO1xuICAgIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgb2JqID0gZGF0YVtpXTtcbiAgICAgIGl0ZW0gPSB7fTtcbiAgICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gaVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkob2JqLCBpQXhpc0tleSksIGkpO1xuICAgICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShyZXNvbHZlT2JqZWN0S2V5KG9iaiwgdkF4aXNLZXkpLCBpdGVtLCB2U2NhbGUsIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKSB7XG4gICAgc3VwZXIudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgaWYgKGN1c3RvbSAmJiBzY2FsZSA9PT0gdGhpcy5fY2FjaGVkTWV0YS52U2NhbGUpIHtcbiAgICAgIC8vIGZsb2F0IGJhcjogb25seSBvbmUgZW5kIG9mIHRoZSBiYXIgaXMgY29uc2lkZXJlZCBieSBgc3VwZXJgXG4gICAgICByYW5nZS5taW4gPSBNYXRoLm1pbihyYW5nZS5taW4sIGN1c3RvbS5taW4pO1xuICAgICAgcmFuZ2UubWF4ID0gTWF0aC5tYXgocmFuZ2UubWF4LCBjdXN0b20ubWF4KTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7bnVtYmVyfGJvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgY29uc3QgdmFsdWUgPSBpc0Zsb2F0QmFyKGN1c3RvbSlcbiAgICAgID8gJ1snICsgY3VzdG9tLnN0YXJ0ICsgJywgJyArIGN1c3RvbS5lbmQgKyAnXSdcbiAgICAgIDogJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogJycgKyBpU2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbaVNjYWxlLmF4aXNdKSxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcblxuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcblxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIG1ldGEuc3RhY2sgPSB0aGlzLmdldERhdGFzZXQoKS5zdGFjaztcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhtZXRhLmRhdGEsIDAsIG1ldGEuZGF0YS5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMoYmFycywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpbmRleCwgX2NhY2hlZE1ldGE6IHt2U2NhbGV9fSA9IHRoaXM7XG4gICAgY29uc3QgYmFzZSA9IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgICBjb25zdCBob3Jpem9udGFsID0gdlNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHJ1bGVyID0gdGhpcy5fZ2V0UnVsZXIoKTtcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgdnBpeGVscyA9IHJlc2V0IHx8IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZTY2FsZS5heGlzXSkgPyB7YmFzZSwgaGVhZDogYmFzZX0gOiB0aGlzLl9jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyhpKTtcbiAgICAgIGNvbnN0IGlwaXhlbHMgPSB0aGlzLl9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhpLCBydWxlcik7XG4gICAgICBjb25zdCBzdGFjayA9IChwYXJzZWQuX3N0YWNrcyB8fCB7fSlbdlNjYWxlLmF4aXNdO1xuXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBob3Jpem9udGFsLFxuICAgICAgICBiYXNlOiB2cGl4ZWxzLmJhc2UsXG4gICAgICAgIGVuYWJsZUJvcmRlclJhZGl1czogIXN0YWNrIHx8IGlzRmxvYXRCYXIocGFyc2VkLl9jdXN0b20pIHx8IChpbmRleCA9PT0gc3RhY2suX3RvcCB8fCBpbmRleCA9PT0gc3RhY2suX2JvdHRvbSksXG4gICAgICAgIHg6IGhvcml6b250YWwgPyB2cGl4ZWxzLmhlYWQgOiBpcGl4ZWxzLmNlbnRlcixcbiAgICAgICAgeTogaG9yaXpvbnRhbCA/IGlwaXhlbHMuY2VudGVyIDogdnBpeGVscy5oZWFkLFxuICAgICAgICBoZWlnaHQ6IGhvcml6b250YWwgPyBpcGl4ZWxzLnNpemUgOiBNYXRoLmFicyh2cGl4ZWxzLnNpemUpLFxuICAgICAgICB3aWR0aDogaG9yaXpvbnRhbCA/IE1hdGguYWJzKHZwaXhlbHMuc2l6ZSkgOiBpcGl4ZWxzLnNpemVcbiAgICAgIH07XG5cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBiYXJzW2ldLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRpb25zID0gcHJvcGVydGllcy5vcHRpb25zIHx8IGJhcnNbaV0ub3B0aW9ucztcbiAgICAgIHNldEJvcmRlclNraXBwZWQocHJvcGVydGllcywgb3B0aW9ucywgc3RhY2ssIGluZGV4KTtcbiAgICAgIHNldEluZmxhdGVBbW91bnQocHJvcGVydGllcywgb3B0aW9ucywgcnVsZXIucmF0aW8pO1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGJhcnNbaV0sIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdGFja3MgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtsYXN0XSAtIFRoZSBkYXRhc2V0IGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YUluZGV4XSAtIFRoZSBkYXRhIGluZGV4IG9mIHRoZSBydWxlclxuXHQgKiBAcmV0dXJucyB7c3RyaW5nW119IFRoZSBsaXN0IG9mIHN0YWNrIElEc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFN0YWNrcyhsYXN0LCBkYXRhSW5kZXgpIHtcbiAgICBjb25zdCB7aVNjYWxlfSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbWV0YXNldHMgPSBpU2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModGhpcy5fdHlwZSlcbiAgICAgIC5maWx0ZXIobWV0YSA9PiBtZXRhLmNvbnRyb2xsZXIub3B0aW9ucy5ncm91cGVkKTtcbiAgICBjb25zdCBzdGFja2VkID0gaVNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcbiAgICBjb25zdCBzdGFja3MgPSBbXTtcblxuICAgIGNvbnN0IHNraXBOdWxsID0gKG1ldGEpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IG1ldGEuY29udHJvbGxlci5nZXRQYXJzZWQoZGF0YUluZGV4KTtcbiAgICAgIGNvbnN0IHZhbCA9IHBhcnNlZCAmJiBwYXJzZWRbbWV0YS52U2NhbGUuYXhpc107XG5cbiAgICAgIGlmIChpc051bGxPclVuZGVmKHZhbCkgfHwgaXNOYU4odmFsKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBtZXRhIG9mIG1ldGFzZXRzKSB7XG4gICAgICBpZiAoZGF0YUluZGV4ICE9PSB1bmRlZmluZWQgJiYgc2tpcE51bGwobWV0YSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHN0YWNrZWQgICB8IG1ldGEuc3RhY2tcbiAgICAgIC8vICAgICAgICAgICB8IGZvdW5kIHwgbm90IGZvdW5kIHwgdW5kZWZpbmVkXG4gICAgICAvLyBmYWxzZSAgICAgfCAgIHggICB8ICAgICB4ICAgICB8ICAgICB4XG4gICAgICAvLyB0cnVlICAgICAgfCAgICAgICB8ICAgICB4ICAgICB8XG4gICAgICAvLyB1bmRlZmluZWQgfCAgICAgICB8ICAgICB4ICAgICB8ICAgICB4XG4gICAgICBpZiAoc3RhY2tlZCA9PT0gZmFsc2UgfHwgc3RhY2tzLmluZGV4T2YobWV0YS5zdGFjaykgPT09IC0xIHx8XG5cdFx0XHRcdChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBzdGFja3MucHVzaChtZXRhLnN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRhLmluZGV4ID09PSBsYXN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIHN0YWNrcz8gdGhhdCBtZWFucyB0aGVyZSBpcyBubyB2aXNpYmxlIGRhdGEuIExldCdzIHN0aWxsIGluaXRpYWxpemUgYW4gYHVuZGVmaW5lZGBcbiAgICAvLyBzdGFjayB3aGVyZSBwb3NzaWJsZSBpbnZpc2libGUgYmFycyB3aWxsIGJlIGxvY2F0ZWQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzYzNjhcbiAgICBpZiAoIXN0YWNrcy5sZW5ndGgpIHtcbiAgICAgIHN0YWNrcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBlZmZlY3RpdmUgbnVtYmVyIG9mIHN0YWNrcyBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFN0YWNrQ291bnQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U3RhY2tzKHVuZGVmaW5lZCwgaW5kZXgpLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdGFjayBpbmRleCBmb3IgdGhlIGdpdmVuIGRhdGFzZXQgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhc2V0SW5kZXhdIC0gVGhlIGRhdGFzZXQgaW5kZXhcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSAtIFRoZSBzdGFjayBuYW1lIHRvIGZpbmRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhSW5kZXhdXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzdGFjayBpbmRleFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFN0YWNrSW5kZXgoZGF0YXNldEluZGV4LCBuYW1lLCBkYXRhSW5kZXgpIHtcbiAgICBjb25zdCBzdGFja3MgPSB0aGlzLl9nZXRTdGFja3MoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpO1xuICAgIGNvbnN0IGluZGV4ID0gKG5hbWUgIT09IHVuZGVmaW5lZClcbiAgICAgID8gc3RhY2tzLmluZGV4T2YobmFtZSlcbiAgICAgIDogLTE7IC8vIGluZGV4T2YgcmV0dXJucyAtMSBpZiBlbGVtZW50IGlzIG5vdCBwcmVzZW50XG5cbiAgICByZXR1cm4gKGluZGV4ID09PSAtMSlcbiAgICAgID8gc3RhY2tzLmxlbmd0aCAtIDFcbiAgICAgIDogaW5kZXg7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRSdWxlcigpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IHBpeGVscyA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGEuZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHBpeGVscy5wdXNoKGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGkpW2lTY2FsZS5heGlzXSwgaSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGJhclRoaWNrbmVzcyA9IG9wdHMuYmFyVGhpY2tuZXNzO1xuICAgIGNvbnN0IG1pbiA9IGJhclRoaWNrbmVzcyB8fCBjb21wdXRlTWluU2FtcGxlU2l6ZShtZXRhKTtcblxuICAgIHJldHVybiB7XG4gICAgICBtaW4sXG4gICAgICBwaXhlbHMsXG4gICAgICBzdGFydDogaVNjYWxlLl9zdGFydFBpeGVsLFxuICAgICAgZW5kOiBpU2NhbGUuX2VuZFBpeGVsLFxuICAgICAgc3RhY2tDb3VudDogdGhpcy5fZ2V0U3RhY2tDb3VudCgpLFxuICAgICAgc2NhbGU6IGlTY2FsZSxcbiAgICAgIGdyb3VwZWQ6IG9wdHMuZ3JvdXBlZCxcbiAgICAgIC8vIGJhciB0aGlja25lc3MgcmF0aW8gdXNlZCBmb3Igbm9uLWdyb3VwZWQgYmFyc1xuICAgICAgcmF0aW86IGJhclRoaWNrbmVzcyA/IDEgOiBvcHRzLmNhdGVnb3J5UGVyY2VudGFnZSAqIG9wdHMuYmFyUGVyY2VudGFnZVxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogTm90ZTogcGl4ZWwgdmFsdWVzIGFyZSBub3QgY2xhbXBlZCB0byB0aGUgc2NhbGUgYXJlYS5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyhpbmRleCkge1xuICAgIGNvbnN0IHtfY2FjaGVkTWV0YToge3ZTY2FsZSwgX3N0YWNrZWQsIGluZGV4OiBkYXRhc2V0SW5kZXh9LCBvcHRpb25zOiB7YmFzZTogYmFzZVZhbHVlLCBtaW5CYXJMZW5ndGh9fSA9IHRoaXM7XG4gICAgY29uc3QgYWN0dWFsQmFzZSA9IGJhc2VWYWx1ZSB8fCAwO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBjb25zdCBmbG9hdGluZyA9IGlzRmxvYXRCYXIoY3VzdG9tKTtcbiAgICBsZXQgdmFsdWUgPSBwYXJzZWRbdlNjYWxlLmF4aXNdO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGxlbmd0aCA9IF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiB2YWx1ZTtcbiAgICBsZXQgaGVhZCwgc2l6ZTtcblxuICAgIGlmIChsZW5ndGggIT09IHZhbHVlKSB7XG4gICAgICBzdGFydCA9IGxlbmd0aCAtIHZhbHVlO1xuICAgICAgbGVuZ3RoID0gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGZsb2F0aW5nKSB7XG4gICAgICB2YWx1ZSA9IGN1c3RvbS5iYXJTdGFydDtcbiAgICAgIGxlbmd0aCA9IGN1c3RvbS5iYXJFbmQgLSBjdXN0b20uYmFyU3RhcnQ7XG4gICAgICAvLyBiYXJzIGNyb3NzaW5nIG9yaWdpbiBhcmUgbm90IHN0YWNrZWRcbiAgICAgIGlmICh2YWx1ZSAhPT0gMCAmJiBzaWduKHZhbHVlKSAhPT0gc2lnbihjdXN0b20uYmFyRW5kKSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBzdGFydCArPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydFZhbHVlID0gIWlzTnVsbE9yVW5kZWYoYmFzZVZhbHVlKSAmJiAhZmxvYXRpbmcgPyBiYXNlVmFsdWUgOiBzdGFydDtcbiAgICBsZXQgYmFzZSA9IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0VmFsdWUpO1xuXG4gICAgaWYgKHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICBoZWFkID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnQgKyBsZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXaGVuIG5vdCB2aXNpYmxlLCBubyBoZWlnaHRcbiAgICAgIGhlYWQgPSBiYXNlO1xuICAgIH1cblxuICAgIHNpemUgPSBoZWFkIC0gYmFzZTtcblxuICAgIGlmIChNYXRoLmFicyhzaXplKSA8IG1pbkJhckxlbmd0aCkge1xuICAgICAgc2l6ZSA9IGJhclNpZ24oc2l6ZSwgdlNjYWxlLCBhY3R1YWxCYXNlKSAqIG1pbkJhckxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZSA9PT0gYWN0dWFsQmFzZSkge1xuICAgICAgICBiYXNlIC09IHNpemUgLyAyO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRQaXhlbCA9IHZTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMCk7XG4gICAgICBjb25zdCBlbmRQaXhlbCA9IHZTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMSk7XG4gICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihzdGFydFBpeGVsLCBlbmRQaXhlbCk7XG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1heChzdGFydFBpeGVsLCBlbmRQaXhlbCk7XG4gICAgICBiYXNlID0gTWF0aC5tYXgoTWF0aC5taW4oYmFzZSwgbWF4KSwgbWluKTtcbiAgICAgIGhlYWQgPSBiYXNlICsgc2l6ZTtcblxuICAgICAgaWYgKF9zdGFja2VkICYmICFmbG9hdGluZykge1xuICAgICAgICAvLyB2aXN1YWwgZGF0YSBjb29yZGluYXRlcyBhZnRlciBhcHBseWluZyBtaW5CYXJMZW5ndGhcbiAgICAgICAgcGFyc2VkLl9zdGFja3NbdlNjYWxlLmF4aXNdLl92aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XSA9IHZTY2FsZS5nZXRWYWx1ZUZvclBpeGVsKGhlYWQpIC0gdlNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoYmFzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKGFjdHVhbEJhc2UpKSB7XG4gICAgICBjb25zdCBoYWxmR3JpZCA9IHNpZ24oc2l6ZSkgKiB2U2NhbGUuZ2V0TGluZVdpZHRoRm9yVmFsdWUoYWN0dWFsQmFzZSkgLyAyO1xuICAgICAgYmFzZSArPSBoYWxmR3JpZDtcbiAgICAgIHNpemUgLT0gaGFsZkdyaWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNpemUsXG4gICAgICBiYXNlLFxuICAgICAgaGVhZCxcbiAgICAgIGNlbnRlcjogaGVhZCArIHNpemUgLyAyXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGluZGV4LCBydWxlcikge1xuICAgIGNvbnN0IHNjYWxlID0gcnVsZXIuc2NhbGU7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBza2lwTnVsbCA9IG9wdGlvbnMuc2tpcE51bGw7XG4gICAgY29uc3QgbWF4QmFyVGhpY2tuZXNzID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5tYXhCYXJUaGlja25lc3MsIEluZmluaXR5KTtcbiAgICBsZXQgY2VudGVyLCBzaXplO1xuICAgIGlmIChydWxlci5ncm91cGVkKSB7XG4gICAgICBjb25zdCBzdGFja0NvdW50ID0gc2tpcE51bGwgPyB0aGlzLl9nZXRTdGFja0NvdW50KGluZGV4KSA6IHJ1bGVyLnN0YWNrQ291bnQ7XG4gICAgICBjb25zdCByYW5nZSA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzID09PSAnZmxleCdcbiAgICAgICAgPyBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudClcbiAgICAgICAgOiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KTtcblxuICAgICAgY29uc3Qgc3RhY2tJbmRleCA9IHRoaXMuX2dldFN0YWNrSW5kZXgodGhpcy5pbmRleCwgdGhpcy5fY2FjaGVkTWV0YS5zdGFjaywgc2tpcE51bGwgPyBpbmRleCA6IHVuZGVmaW5lZCk7XG4gICAgICBjZW50ZXIgPSByYW5nZS5zdGFydCArIChyYW5nZS5jaHVuayAqIHN0YWNrSW5kZXgpICsgKHJhbmdlLmNodW5rIC8gMik7XG4gICAgICBzaXplID0gTWF0aC5taW4obWF4QmFyVGhpY2tuZXNzLCByYW5nZS5jaHVuayAqIHJhbmdlLnJhdGlvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIG5vbi1ncm91cGVkIGJhciBjaGFydHMsIGV4YWN0IHBpeGVsIHZhbHVlcyBhcmUgdXNlZFxuICAgICAgY2VudGVyID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpbmRleClbc2NhbGUuYXhpc10sIGluZGV4KTtcbiAgICAgIHNpemUgPSBNYXRoLm1pbihtYXhCYXJUaGlja25lc3MsIHJ1bGVyLm1pbiAqIHJ1bGVyLnJhdGlvKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYmFzZTogY2VudGVyIC0gc2l6ZSAvIDIsXG4gICAgICBoZWFkOiBjZW50ZXIgKyBzaXplIC8gMixcbiAgICAgIGNlbnRlcixcbiAgICAgIHNpemVcbiAgICB9O1xuICB9XG5cbiAgZHJhdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgICBjb25zdCByZWN0cyA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBpbGVuID0gcmVjdHMubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcblxuICAgIGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAodGhpcy5nZXRQYXJzZWQoaSlbdlNjYWxlLmF4aXNdICE9PSBudWxsKSB7XG4gICAgICAgIHJlY3RzW2ldLmRyYXcodGhpcy5fY3R4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHt2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdWJibGVDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdidWJibGUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnYm9yZGVyV2lkdGgnLCAncmFkaXVzJ11cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIHNjYWxlczoge1xuICAgICAgeDoge1xuICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBwcmltaXRpdmUgdmFsdWVzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXM7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2YgYXJyYXlzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW3N0YXJ0ICsgaV07XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHZhbHVlT3JEZWZhdWx0KGl0ZW1bMl0sIHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2Ygb2JqZWN0c1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW3N0YXJ0ICsgaV07XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHZhbHVlT3JEZWZhdWx0KGl0ZW0gJiYgaXRlbS5yICYmICtpdGVtLnIsIHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIGxldCBtYXggPSAwO1xuICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGFbaV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSkpIC8gMik7XG4gICAgfVxuICAgIHJldHVybiBtYXggPiAwICYmIG1heDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5jaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgeCA9IHhTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC54KTtcbiAgICBjb25zdCB5ID0geVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLnkpO1xuICAgIGNvbnN0IHIgPSBwYXJzZWQuX2N1c3RvbTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlOiAnKCcgKyB4ICsgJywgJyArIHkgKyAociA/ICcsICcgKyByIDogJycpICsgJyknXG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuXG4gICAgLy8gVXBkYXRlIFBvaW50c1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gIXJlc2V0ICYmIHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHt9O1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSByZXNldCA/IGlTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMC41KSA6IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10pO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFt2QXhpc10pO1xuXG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCk7XG5cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuXG4gICAgICAgIGlmIChyZXNldCkge1xuICAgICAgICAgIHByb3BlcnRpZXMub3B0aW9ucy5yYWRpdXMgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW21vZGVdXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgbGV0IHZhbHVlcyA9IHN1cGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpO1xuXG4gICAgLy8gSW4gY2FzZSB2YWx1ZXMgd2VyZSBjYWNoZWQgKGFuZCB0aHVzIGZyb3plbiksIHdlIG5lZWQgdG8gY2xvbmUgdGhlIHZhbHVlc1xuICAgIGlmICh2YWx1ZXMuJHNoYXJlZCkge1xuICAgICAgdmFsdWVzID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWVzLCB7JHNoYXJlZDogZmFsc2V9KTtcbiAgICB9XG5cbiAgICAvLyBDdXN0b20gcmFkaXVzIHJlc29sdXRpb25cbiAgICBjb25zdCByYWRpdXMgPSB2YWx1ZXMucmFkaXVzO1xuICAgIGlmIChtb2RlICE9PSAnYWN0aXZlJykge1xuICAgICAgdmFsdWVzLnJhZGl1cyA9IDA7XG4gICAgfVxuICAgIHZhbHVlcy5yYWRpdXMgKz0gdmFsdWVPckRlZmF1bHQocGFyc2VkICYmIHBhcnNlZC5fY3VzdG9tLCByYWRpdXMpO1xuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtpc09iamVjdCwgcmVzb2x2ZU9iamVjdEtleSwgdG9QZXJjZW50YWdlLCB0b0RpbWVuc2lvbiwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7Zm9ybWF0TnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50bC5qcyc7XG5pbXBvcnQge3RvUmFkaWFucywgUEksIFRBVSwgSEFMRl9QSSwgX2FuZ2xlQmV0d2Vlbn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICovXG5cbmZ1bmN0aW9uIGdldFJhdGlvQW5kT2Zmc2V0KHJvdGF0aW9uLCBjaXJjdW1mZXJlbmNlLCBjdXRvdXQpIHtcbiAgbGV0IHJhdGlvWCA9IDE7XG4gIGxldCByYXRpb1kgPSAxO1xuICBsZXQgb2Zmc2V0WCA9IDA7XG4gIGxldCBvZmZzZXRZID0gMDtcbiAgLy8gSWYgdGhlIGNoYXJ0J3MgY2lyY3VtZmVyZW5jZSBpc24ndCBhIGZ1bGwgY2lyY2xlLCBjYWxjdWxhdGUgc2l6ZSBhcyBhIHJhdGlvIG9mIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIGFyY1xuICBpZiAoY2lyY3VtZmVyZW5jZSA8IFRBVSkge1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSByb3RhdGlvbjtcbiAgICBjb25zdCBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlO1xuICAgIGNvbnN0IHN0YXJ0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IHN0YXJ0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IGVuZFggPSBNYXRoLmNvcyhlbmRBbmdsZSk7XG4gICAgY29uc3QgZW5kWSA9IE1hdGguc2luKGVuZEFuZ2xlKTtcbiAgICBjb25zdCBjYWxjTWF4ID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAxIDogTWF0aC5tYXgoYSwgYSAqIGN1dG91dCwgYiwgYiAqIGN1dG91dCk7XG4gICAgY29uc3QgY2FsY01pbiA9IChhbmdsZSwgYSwgYikgPT4gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHRydWUpID8gLTEgOiBNYXRoLm1pbihhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICBjb25zdCBtYXhYID0gY2FsY01heCgwLCBzdGFydFgsIGVuZFgpO1xuICAgIGNvbnN0IG1heFkgPSBjYWxjTWF4KEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgY29uc3QgbWluWCA9IGNhbGNNaW4oUEksIHN0YXJ0WCwgZW5kWCk7XG4gICAgY29uc3QgbWluWSA9IGNhbGNNaW4oUEkgKyBIQUxGX1BJLCBzdGFydFksIGVuZFkpO1xuICAgIHJhdGlvWCA9IChtYXhYIC0gbWluWCkgLyAyO1xuICAgIHJhdGlvWSA9IChtYXhZIC0gbWluWSkgLyAyO1xuICAgIG9mZnNldFggPSAtKG1heFggKyBtaW5YKSAvIDI7XG4gICAgb2Zmc2V0WSA9IC0obWF4WSArIG1pblkpIC8gMjtcbiAgfVxuICByZXR1cm4ge3JhdGlvWCwgcmF0aW9ZLCBvZmZzZXRYLCBvZmZzZXRZfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG91Z2hudXRDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdkb3VnaG51dCc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdhcmMnLFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgLy8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSB0aGUgcm90YXRpb24gb2YgdGhlIERvdWdobnV0XG4gICAgICBhbmltYXRlUm90YXRlOiB0cnVlLFxuICAgICAgLy8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSBzY2FsaW5nIHRoZSBEb3VnaG51dCBmcm9tIHRoZSBjZW50cmVcbiAgICAgIGFuaW1hdGVTY2FsZTogZmFsc2VcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsnY2lyY3VtZmVyZW5jZScsICdlbmRBbmdsZScsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cycsICdzdGFydEFuZ2xlJywgJ3gnLCAneScsICdvZmZzZXQnLCAnYm9yZGVyV2lkdGgnLCAnc3BhY2luZyddXG4gICAgICB9LFxuICAgIH0sXG4gICAgLy8gVGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGNoYXJ0IHRoYXQgd2UgY3V0IG91dCBvZiB0aGUgbWlkZGxlLlxuICAgIGN1dG91dDogJzUwJScsXG5cbiAgICAvLyBUaGUgcm90YXRpb24gb2YgdGhlIGNoYXJ0LCB3aGVyZSB0aGUgZmlyc3QgZGF0YSBhcmMgYmVnaW5zLlxuICAgIHJvdGF0aW9uOiAwLFxuXG4gICAgLy8gVGhlIHRvdGFsIGNpcmN1bWZlcmVuY2Ugb2YgdGhlIGNoYXJ0LlxuICAgIGNpcmN1bWZlcmVuY2U6IDM2MCxcblxuICAgIC8vIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIGNoYXJ0XG4gICAgcmFkaXVzOiAnMTAwJScsXG5cbiAgICAvLyBTcGFjaW5nIGJldHdlZW4gYXJjc1xuICAgIHNwYWNpbmc6IDAsXG5cbiAgICBpbmRleEF4aXM6ICdyJyxcbiAgfTtcblxuICBzdGF0aWMgZGVzY3JpcHRvcnMgPSB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnc3BhY2luZycsXG4gICAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdzcGFjaW5nJyAmJiAhbmFtZS5zdGFydHNXaXRoKCdib3JkZXJEYXNoJykgJiYgIW5hbWUuc3RhcnRzV2l0aCgnaG92ZXJCb3JkZXJEYXNoJyksXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIGFzcGVjdFJhdGlvOiAxLFxuXG4gICAgLy8gTmVlZCB0byBvdmVycmlkZSB0aGVzZSB0byBnaXZlIGEgbmljZSBkZWZhdWx0XG4gICAgcGx1Z2luczoge1xuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29uc3Qge2xhYmVsczoge3BvaW50U3R5bGUsIGNvbG9yfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcblxuICAgICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHMubWFwKChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgZm9udENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG5cbiAgICAgICAgICAgICAgICAgIC8vIEV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGNvcnJlY3QgaXRlbVxuICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgICAgbGVnZW5kLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcblxuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub2Zmc2V0WCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9mZnNldFkgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBsaW5rU2NhbGVzKCkge31cblxuICAvKipcblx0ICogT3ZlcnJpZGUgZGF0YSBwYXJzaW5nLCBzaW5jZSB3ZSBhcmUgbm90IHVzaW5nIHNjYWxlc1xuXHQgKi9cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YXNldCgpLmRhdGE7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG5cbiAgICBpZiAodGhpcy5fcGFyc2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIG1ldGEuX3BhcnNlZCA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBnZXR0ZXIgPSAoaSkgPT4gK2RhdGFbaV07XG5cbiAgICAgIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgY29uc3Qge2tleSA9ICd2YWx1ZSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICAgICAgZ2V0dGVyID0gKGkpID0+ICtyZXNvbHZlT2JqZWN0S2V5KGRhdGFbaV0sIGtleSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBpLCBpbGVuO1xuICAgICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIG1ldGEuX3BhcnNlZFtpXSA9IGdldHRlcihpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRSb3RhdGlvbigpIHtcbiAgICByZXR1cm4gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy5yb3RhdGlvbiAtIDkwKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldENpcmN1bWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMuY2lyY3VtZmVyZW5jZSk7XG4gIH1cblxuICAvKipcblx0ICogR2V0IHRoZSBtYXhpbWFsIHJvdGF0aW9uICYgY2lyY3VtZmVyZW5jZSBleHRlbnRzXG5cdCAqIGFjcm9zcyBhbGwgdmlzaWJsZSBkYXRhc2V0cy5cblx0ICovXG4gIF9nZXRSb3RhdGlvbkV4dGVudHMoKSB7XG4gICAgbGV0IG1pbiA9IFRBVTtcbiAgICBsZXQgbWF4ID0gLVRBVTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSkudHlwZSA9PT0gdGhpcy5fdHlwZSkge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyO1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGNvbnRyb2xsZXIuX2dldFJvdGF0aW9uKCk7XG4gICAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSBjb250cm9sbGVyLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG5cbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByb3RhdGlvbik7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcm90YXRpb24gKyBjaXJjdW1mZXJlbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcm90YXRpb246IG1pbixcbiAgICAgIGNpcmN1bWZlcmVuY2U6IG1heCAtIG1pbixcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlXG5cdCAqL1xuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCB7Y2hhcnRBcmVhfSA9IGNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGFyY3MgPSBtZXRhLmRhdGE7XG4gICAgY29uc3Qgc3BhY2luZyA9IHRoaXMuZ2V0TWF4Qm9yZGVyV2lkdGgoKSArIHRoaXMuZ2V0TWF4T2Zmc2V0KGFyY3MpICsgdGhpcy5vcHRpb25zLnNwYWNpbmc7XG4gICAgY29uc3QgbWF4U2l6ZSA9IE1hdGgubWF4KChNYXRoLm1pbihjaGFydEFyZWEud2lkdGgsIGNoYXJ0QXJlYS5oZWlnaHQpIC0gc3BhY2luZykgLyAyLCAwKTtcbiAgICBjb25zdCBjdXRvdXQgPSBNYXRoLm1pbih0b1BlcmNlbnRhZ2UodGhpcy5vcHRpb25zLmN1dG91dCwgbWF4U2l6ZSksIDEpO1xuICAgIGNvbnN0IGNoYXJ0V2VpZ2h0ID0gdGhpcy5fZ2V0UmluZ1dlaWdodCh0aGlzLmluZGV4KTtcblxuICAgIC8vIENvbXB1dGUgdGhlIG1heGltYWwgcm90YXRpb24gJiBjaXJjdW1mZXJlbmNlIGxpbWl0cy5cbiAgICAvLyBJZiB3ZSBvbmx5IGNvbnNpZGVyIG91ciBkYXRhc2V0LCB0aGlzIGNhbiBjYXVzZSBwcm9ibGVtcyB3aGVuIHR3byBkYXRhc2V0c1xuICAgIC8vIGFyZSBib3RoIGxlc3MgdGhhbiBhIGNpcmNsZSB3aXRoIGRpZmZlcmVudCByb3RhdGlvbnMgKHN0YXJ0aW5nIGFuZ2xlcylcbiAgICBjb25zdCB7Y2lyY3VtZmVyZW5jZSwgcm90YXRpb259ID0gdGhpcy5fZ2V0Um90YXRpb25FeHRlbnRzKCk7XG4gICAgY29uc3Qge3JhdGlvWCwgcmF0aW9ZLCBvZmZzZXRYLCBvZmZzZXRZfSA9IGdldFJhdGlvQW5kT2Zmc2V0KHJvdGF0aW9uLCBjaXJjdW1mZXJlbmNlLCBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFdpZHRoID0gKGNoYXJ0QXJlYS53aWR0aCAtIHNwYWNpbmcpIC8gcmF0aW9YO1xuICAgIGNvbnN0IG1heEhlaWdodCA9IChjaGFydEFyZWEuaGVpZ2h0IC0gc3BhY2luZykgLyByYXRpb1k7XG4gICAgY29uc3QgbWF4UmFkaXVzID0gTWF0aC5tYXgoTWF0aC5taW4obWF4V2lkdGgsIG1heEhlaWdodCkgLyAyLCAwKTtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IHRvRGltZW5zaW9uKHRoaXMub3B0aW9ucy5yYWRpdXMsIG1heFJhZGl1cyk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvdXRlclJhZGl1cyAqIGN1dG91dCwgMCk7XG4gICAgY29uc3QgcmFkaXVzTGVuZ3RoID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gdGhpcy5fZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpO1xuICAgIHRoaXMub2Zmc2V0WCA9IG9mZnNldFggKiBvdXRlclJhZGl1cztcbiAgICB0aGlzLm9mZnNldFkgPSBvZmZzZXRZICogb3V0ZXJSYWRpdXM7XG5cbiAgICBtZXRhLnRvdGFsID0gdGhpcy5jYWxjdWxhdGVUb3RhbCgpO1xuXG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gTWF0aC5tYXgodGhpcy5vdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIGNoYXJ0V2VpZ2h0LCAwKTtcblxuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoYXJjcywgMCwgYXJjcy5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2lyY3VtZmVyZW5jZShpLCByZXNldCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2dldENpcmN1bWZlcmVuY2UoKTtcbiAgICBpZiAoKHJlc2V0ICYmIG9wdHMuYW5pbWF0aW9uLmFuaW1hdGVSb3RhdGUpIHx8ICF0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpIHx8IG1ldGEuX3BhcnNlZFtpXSA9PT0gbnVsbCB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZShtZXRhLl9wYXJzZWRbaV0gKiBjaXJjdW1mZXJlbmNlIC8gVEFVKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKGFyY3MsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICBjb25zdCBjZW50ZXJYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyO1xuICAgIGNvbnN0IGFuaW1hdGVTY2FsZSA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IHRoaXMuaW5uZXJSYWRpdXM7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogdGhpcy5vdXRlclJhZGl1cztcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgbGV0IHN0YXJ0QW5nbGUgPSB0aGlzLl9nZXRSb3RhdGlvbigpO1xuICAgIGxldCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXJ0OyArK2kpIHtcbiAgICAgIHN0YXJ0QW5nbGUgKz0gdGhpcy5fY2lyY3VtZmVyZW5jZShpLCByZXNldCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYICsgdGhpcy5vZmZzZXRYLFxuICAgICAgICB5OiBjZW50ZXJZICsgdGhpcy5vZmZzZXRZLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZTogc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgICBpbm5lclJhZGl1c1xuICAgICAgfTtcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBhcmMuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0QW5nbGUgKz0gY2lyY3VtZmVyZW5jZTtcblxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGFyYywgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlVG90YWwoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbWV0YURhdGEgPSBtZXRhLmRhdGE7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBtZXRhRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWUgPSBtZXRhLl9wYXJzZWRbaV07XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgIWlzTmFOKHZhbHVlKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpICYmICFtZXRhRGF0YVtpXS5oaWRkZW4pIHtcbiAgICAgICAgdG90YWwgKz0gTWF0aC5hYnModmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxuXG4gIGNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UodmFsdWUpIHtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMuX2NhY2hlZE1ldGEudG90YWw7XG4gICAgaWYgKHRvdGFsID4gMCAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gVEFVICogKE1hdGguYWJzKHZhbHVlKSAvIHRvdGFsKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0sIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cblxuICBnZXRNYXhCb3JkZXJXaWR0aChhcmNzKSB7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGxldCBpLCBpbGVuLCBtZXRhLCBjb250cm9sbGVyLCBvcHRpb25zO1xuXG4gICAgaWYgKCFhcmNzKSB7XG4gICAgICAvLyBGaW5kIHRoZSBvdXRtb3N0IHZpc2libGUgZGF0YXNldFxuICAgICAgZm9yIChpID0gMCwgaWxlbiA9IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgICAgIGFyY3MgPSBtZXRhLmRhdGE7XG4gICAgICAgICAgY29udHJvbGxlciA9IG1ldGEuY29udHJvbGxlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghYXJjcykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBvcHRpb25zID0gY29udHJvbGxlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgaWYgKG9wdGlvbnMuYm9yZGVyQWxpZ24gIT09ICdpbm5lcicpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLmJvcmRlcldpZHRoIHx8IDAsIG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCB8fCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuXG4gIGdldE1heE9mZnNldChhcmNzKSB7XG4gICAgbGV0IG1heCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLm9mZnNldCB8fCAwLCBvcHRpb25zLmhvdmVyT2Zmc2V0IHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldCByYWRpdXMgbGVuZ3RoIG9mZnNldCBvZiB0aGUgZGF0YXNldCBpbiByZWxhdGlvbiB0byB0aGUgdmlzaWJsZSBkYXRhc2V0cyB3ZWlnaHRzLiBUaGlzIGFsbG93cyBkZXRlcm1pbmluZyB0aGUgaW5uZXIgYW5kIG91dGVyIHJhZGl1cyBjb3JyZWN0bHlcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRSaW5nV2VpZ2h0T2Zmc2V0KGRhdGFzZXRJbmRleCkge1xuICAgIGxldCByaW5nV2VpZ2h0T2Zmc2V0ID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXNldEluZGV4OyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgcmluZ1dlaWdodE9mZnNldCArPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByaW5nV2VpZ2h0T2Zmc2V0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0UmluZ1dlaWdodChkYXRhc2V0SW5kZXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodmFsdWVPckRlZmF1bHQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0ud2VpZ2h0LCAxKSwgMCk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc3VtIG9mIGFsbCB2aXNpYmxlIGRhdGEgc2V0IHdlaWdodHMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoKSB8fCAxO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtpc051bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cywgX3NjYWxlUmFuZ2VzQ2hhbmdlZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdsaW5lJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG5cbiAgICBzaG93TGluZTogdHJ1ZSxcbiAgICBzcGFuR2FwczogZmFsc2UsXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIHNjYWxlczoge1xuICAgICAgX2luZGV4Xzoge1xuICAgICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgICAgfSxcbiAgICAgIF92YWx1ZV86IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICB9LFxuICAgIH1cbiAgfTtcblxuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgdGhpcy5zdXBwb3J0c0RlY2ltYXRpb24gPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2RhdGFzZXQ6IGxpbmUsIGRhdGE6IHBvaW50cyA9IFtdLCBfZGF0YXNldH0gPSBtZXRhO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBhbmltYXRpb25zRGlzYWJsZWQgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgbGV0IHtzdGFydCwgY291bnR9ID0gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpO1xuXG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gY291bnQ7XG5cbiAgICBpZiAoX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBMaW5lXG4gICAgbGluZS5fY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGxpbmUuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgbGluZS5fZGVjaW1hdGVkID0gISFfZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgb3B0aW9ucy5ib3JkZXJXaWR0aCA9IDA7XG4gICAgfVxuICAgIG9wdGlvbnMuc2VnbWVudCA9IHRoaXMub3B0aW9ucy5zZWdtZW50O1xuICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHtcbiAgICAgIGFuaW1hdGVkOiAhYW5pbWF0aW9uc0Rpc2FibGVkLFxuICAgICAgb3B0aW9uc1xuICAgIH0sIG1vZGUpO1xuXG4gICAgLy8gVXBkYXRlIFBvaW50c1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBfc3RhY2tlZCwgX2RhdGFzZXR9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IHtzcGFuR2Fwcywgc2VnbWVudH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWF4R2FwTGVuZ3RoID0gaXNOdW1iZXIoc3BhbkdhcHMpID8gc3BhbkdhcHMgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgY29uc3QgZGlyZWN0VXBkYXRlID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IHJlc2V0IHx8IG1vZGUgPT09ICdub25lJztcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIGNvdW50O1xuICAgIGNvbnN0IHBvaW50c0NvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICBsZXQgcHJldlBhcnNlZCA9IHN0YXJ0ID4gMCAmJiB0aGlzLmdldFBhcnNlZChzdGFydCAtIDEpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNDb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkaXJlY3RVcGRhdGUgPyBwb2ludCA6IHt9O1xuXG4gICAgICBpZiAoaSA8IHN0YXJ0IHx8IGkgPj0gZW5kKSB7XG4gICAgICAgIHByb3BlcnRpZXMuc2tpcCA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IG51bGxEYXRhID0gaXNOdWxsT3JVbmRlZihwYXJzZWRbdkF4aXNdKTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSwgaSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0IHx8IG51bGxEYXRhID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHBhcnNlZFt2QXhpc10sIGkpO1xuXG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCkgfHwgbnVsbERhdGE7XG4gICAgICBwcm9wZXJ0aWVzLnN0b3AgPSBpID4gMCAmJiAoTWF0aC5hYnMocGFyc2VkW2lBeGlzXSAtIHByZXZQYXJzZWRbaUF4aXNdKSkgPiBtYXhHYXBMZW5ndGg7XG4gICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBwcm9wZXJ0aWVzLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgcHJvcGVydGllcy5yYXcgPSBfZGF0YXNldC5kYXRhW2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaXJlY3RVcGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgIH1cblxuICAgICAgcHJldlBhcnNlZCA9IHBhcnNlZDtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YXNldCA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBib3JkZXIgPSBkYXRhc2V0Lm9wdGlvbnMgJiYgZGF0YXNldC5vcHRpb25zLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYm9yZGVyO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFBvaW50ID0gZGF0YVswXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucygwKSk7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGRhdGEubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBNYXRoLm1heChib3JkZXIsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCkgLyAyO1xuICB9XG5cbiAgZHJhdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBtZXRhLmRhdGFzZXQudXBkYXRlQ29udHJvbFBvaW50cyh0aGlzLmNoYXJ0LmNoYXJ0QXJlYSwgbWV0YS5pU2NhbGUuYXhpcyk7XG4gICAgc3VwZXIuZHJhdygpO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge3RvUmFkaWFucywgUEksIGZvcm1hdE51bWJlciwgX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9sYXJBcmVhQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAncG9sYXJBcmVhJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdhcmMnLFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgYW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcbiAgICAgIGFuaW1hdGVTY2FsZTogdHJ1ZVxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnc3RhcnRBbmdsZScsICdlbmRBbmdsZScsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cyddXG4gICAgICB9LFxuICAgIH0sXG4gICAgaW5kZXhBeGlzOiAncicsXG4gICAgc3RhcnRBbmdsZTogMCxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgYXNwZWN0UmF0aW86IDEsXG5cbiAgICBwbHVnaW5zOiB7XG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb25zdCB7bGFiZWxzOiB7cG9pbnRTdHlsZSwgY29sb3J9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuXG4gICAgICAgICAgICAgIHJldHVybiBkYXRhLmxhYmVscy5tYXAoKGxhYmVsLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICBmb250Q29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgICBoaWRkZW46ICFjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSxcblxuICAgICAgICAgICAgICAgICAgLy8gRXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgY29ycmVjdCBpdGVtXG4gICAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgICAgIGxlZ2VuZC5jaGFydC50b2dnbGVEYXRhVmlzaWJpbGl0eShsZWdlbmRJdGVtLmluZGV4KTtcbiAgICAgICAgICBsZWdlbmQuY2hhcnQudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2NhbGVzOiB7XG4gICAgICByOiB7XG4gICAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuICAgICAgICBhbmdsZUxpbmVzOiB7XG4gICAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBjaXJjdWxhcjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBwb2ludExhYmVsczoge1xuICAgICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0QW5nbGU6IDBcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHN1cGVyKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xuXG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdE51bWJlcihtZXRhLl9wYXJzZWRbaW5kZXhdLnIsIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cblxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZS5iaW5kKHRoaXMpKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGFyY3MgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG5cbiAgICB0aGlzLl91cGRhdGVSYWRpdXMoKTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRNaW5NYXgoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgcmFuZ2UgPSB7bWluOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIG1heDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZfTtcblxuICAgIG1ldGEuZGF0YS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpLnI7XG5cbiAgICAgIGlmICghaXNOYU4ocGFyc2VkKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgICBpZiAocGFyc2VkIDwgcmFuZ2UubWluKSB7XG4gICAgICAgICAgcmFuZ2UubWluID0gcGFyc2VkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnNlZCA+IHJhbmdlLm1heCkge1xuICAgICAgICAgIHJhbmdlLm1heCA9IHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlUmFkaXVzKCkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgbWluU2l6ZSA9IE1hdGgubWluKGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0LCBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCk7XG5cbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KG1pblNpemUgLyAyLCAwKTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IE1hdGgubWF4KG9wdHMuY3V0b3V0UGVyY2VudGFnZSA/IChvdXRlclJhZGl1cyAvIDEwMCkgKiAob3B0cy5jdXRvdXRQZXJjZW50YWdlKSA6IDEsIDApO1xuICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIGNoYXJ0LmdldFZpc2libGVEYXRhc2V0Q291bnQoKTtcblxuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAtIChyYWRpdXNMZW5ndGggKiB0aGlzLmluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdGhpcy5vdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aDtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKGFyY3MsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS5yU2NhbGU7XG4gICAgY29uc3QgY2VudGVyWCA9IHNjYWxlLnhDZW50ZXI7XG4gICAgY29uc3QgY2VudGVyWSA9IHNjYWxlLnlDZW50ZXI7XG4gICAgY29uc3QgZGF0YXNldFN0YXJ0QW5nbGUgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKDApIC0gMC41ICogUEk7XG4gICAgbGV0IGFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGU7XG4gICAgbGV0IGk7XG5cbiAgICBjb25zdCBkZWZhdWx0QW5nbGUgPSAzNjAgLyB0aGlzLmNvdW50VmlzaWJsZUVsZW1lbnRzKCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSkge1xuICAgICAgYW5nbGUgKz0gdGhpcy5fY29tcHV0ZUFuZ2xlKGksIG1vZGUsIGRlZmF1bHRBbmdsZSk7XG4gICAgfVxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhcmMgPSBhcmNzW2ldO1xuICAgICAgbGV0IHN0YXJ0QW5nbGUgPSBhbmdsZTtcbiAgICAgIGxldCBlbmRBbmdsZSA9IGFuZ2xlICsgdGhpcy5fY29tcHV0ZUFuZ2xlKGksIG1vZGUsIGRlZmF1bHRBbmdsZSk7XG4gICAgICBsZXQgb3V0ZXJSYWRpdXMgPSBjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSA/IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGkpLnIpIDogMDtcbiAgICAgIGFuZ2xlID0gZW5kQW5nbGU7XG5cbiAgICAgIGlmIChyZXNldCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUpIHtcbiAgICAgICAgICBvdXRlclJhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSkge1xuICAgICAgICAgIHN0YXJ0QW5nbGUgPSBlbmRBbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHg6IGNlbnRlclgsXG4gICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgIGlubmVyUmFkaXVzOiAwLFxuICAgICAgICBvdXRlclJhZGl1cyxcbiAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGUsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBhcmMuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKVxuICAgICAgfTtcblxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGFyYywgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG5cbiAgY291bnRWaXNpYmxlRWxlbWVudHMoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbGV0IGNvdW50ID0gMDtcblxuICAgIG1ldGEuZGF0YS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgaWYgKCFpc05hTih0aGlzLmdldFBhcnNlZChpbmRleCkucikgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjb3VudDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbXB1dGVBbmdsZShpbmRleCwgbW9kZSwgZGVmYXVsdEFuZ2xlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpXG4gICAgICA/IHRvUmFkaWFucyh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpLmFuZ2xlIHx8IGRlZmF1bHRBbmdsZSlcbiAgICAgIDogMDtcbiAgfVxufVxuIiwgImltcG9ydCBEb3VnaG51dENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyLmRvdWdobnV0LmpzJztcblxuLy8gUGllIGNoYXJ0cyBhcmUgRG91Z2hudXQgY2hhcnQgd2l0aCBkaWZmZXJlbnQgZGVmYXVsdHNcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBpZUNvbnRyb2xsZXIgZXh0ZW5kcyBEb3VnaG51dENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdwaWUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC8vIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBjaGFydCB0aGF0IHdlIGN1dCBvdXQgb2YgdGhlIG1pZGRsZS5cbiAgICBjdXRvdXQ6IDAsXG5cbiAgICAvLyBUaGUgcm90YXRpb24gb2YgdGhlIGNoYXJ0LCB3aGVyZSB0aGUgZmlyc3QgZGF0YSBhcmMgYmVnaW5zLlxuICAgIHJvdGF0aW9uOiAwLFxuXG4gICAgLy8gVGhlIHRvdGFsIGNpcmN1bWZlcmVuY2Ugb2YgdGhlIGNoYXJ0LlxuICAgIGNpcmN1bWZlcmVuY2U6IDM2MCxcblxuICAgIC8vIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIGNoYXJ0XG4gICAgcmFkaXVzOiAnMTAwJSdcbiAgfTtcbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7X3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkYXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdyYWRhcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiAnbGluZScsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICAgIGluZGV4QXhpczogJ3InLFxuICAgIHNob3dMaW5lOiB0cnVlLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBsaW5lOiB7XG4gICAgICAgIGZpbGw6ICdzdGFydCdcbiAgICAgIH1cbiAgICB9LFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBhc3BlY3RSYXRpbzogMSxcblxuICAgIHNjYWxlczoge1xuICAgICAgcjoge1xuICAgICAgICB0eXBlOiAncmFkaWFsTGluZWFyJyxcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCB2U2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IHZTY2FsZS5nZXRMYWJlbHMoKVtpbmRleF0sXG4gICAgICB2YWx1ZTogJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKVxuICAgIH07XG4gIH1cblxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZS5iaW5kKHRoaXMpKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGxhYmVscyA9IG1ldGEuaVNjYWxlLmdldExhYmVscygpO1xuXG4gICAgLy8gVXBkYXRlIExpbmVcbiAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcbiAgICAvLyBJbiByZXNpemUgbW9kZSBvbmx5IHBvaW50IGxvY2F0aW9ucyBjaGFuZ2UsIHNvIG5vIG5lZWQgdG8gc2V0IHRoZSBwb2ludHMgb3Igb3B0aW9ucy5cbiAgICBpZiAobW9kZSAhPT0gJ3Jlc2l6ZScpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgX2xvb3A6IHRydWUsXG4gICAgICAgIF9mdWxsTG9vcDogbGFiZWxzLmxlbmd0aCA9PT0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfTtcblxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIFBvaW50c1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnJTY2FsZTtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCB0aGlzLmdldFBhcnNlZChpKS5yKTtcblxuICAgICAgY29uc3QgeCA9IHJlc2V0ID8gc2NhbGUueENlbnRlciA6IHBvaW50UG9zaXRpb24ueDtcbiAgICAgIGNvbnN0IHkgPSByZXNldCA/IHNjYWxlLnlDZW50ZXIgOiBwb2ludFBvc2l0aW9uLnk7XG5cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGFuZ2xlOiBwb2ludFBvc2l0aW9uLmFuZ2xlLFxuICAgICAgICBza2lwOiBpc05hTih4KSB8fCBpc05hTih5KSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfTtcblxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7aXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge2lzTnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzLCBfc2NhbGVSYW5nZXNDaGFuZ2VkfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NhdHRlckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ3NjYXR0ZXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICAgIHNob3dMaW5lOiBmYWxzZSxcbiAgICBmaWxsOiBmYWxzZVxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcblxuICAgIGludGVyYWN0aW9uOiB7XG4gICAgICBtb2RlOiAncG9pbnQnXG4gICAgfSxcblxuICAgIHNjYWxlczoge1xuICAgICAgeDoge1xuICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCB4ID0geFNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLngpO1xuICAgIGNvbnN0IHkgPSB5U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZTogJygnICsgeCArICcsICcgKyB5ICsgJyknXG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2RhdGE6IHBvaW50cyA9IFtdfSA9IG1ldGE7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGFuaW1hdGlvbnNEaXNhYmxlZCA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCk7XG5cbiAgICB0aGlzLl9kcmF3U3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSBjb3VudDtcblxuICAgIGlmIChfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMTEzMzNcbiAgICAgIGlmICghdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUpIHtcbiAgICAgICAgdGhpcy5hZGRFbGVtZW50cygpO1xuICAgICAgfVxuICAgICAgY29uc3Qge2RhdGFzZXQ6IGxpbmUsIF9kYXRhc2V0fSA9IG1ldGE7XG5cbiAgICAgIC8vIFVwZGF0ZSBMaW5lXG4gICAgICBsaW5lLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgICBsaW5lLl9kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgbGluZS5fZGVjaW1hdGVkID0gISFfZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG5cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgICBvcHRpb25zLnNlZ21lbnQgPSB0aGlzLm9wdGlvbnMuc2VnbWVudDtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHtcbiAgICAgICAgYW5pbWF0ZWQ6ICFhbmltYXRpb25zRGlzYWJsZWQsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0sIG1vZGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhc2V0RWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8xMTMzM1xuICAgICAgZGVsZXRlIG1ldGEuZGF0YXNldDtcbiAgICAgIHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIFBvaW50c1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpO1xuICB9XG5cbiAgYWRkRWxlbWVudHMoKSB7XG4gICAgY29uc3Qge3Nob3dMaW5lfSA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmICghdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgJiYgc2hvd0xpbmUpIHtcbiAgICAgIHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlID0gdGhpcy5jaGFydC5yZWdpc3RyeS5nZXRFbGVtZW50KCdsaW5lJyk7XG4gICAgfVxuXG4gICAgc3VwZXIuYWRkRWxlbWVudHMoKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgX3N0YWNrZWQsIF9kYXRhc2V0fSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBzaGFyZWRPcHRpb25zID0gdGhpcy5nZXRTaGFyZWRPcHRpb25zKGZpcnN0T3B0cyk7XG4gICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSB0aGlzLmluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCB7c3BhbkdhcHMsIHNlZ21lbnR9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1heEdhcExlbmd0aCA9IGlzTnVtYmVyKHNwYW5HYXBzKSA/IHNwYW5HYXBzIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGNvbnN0IGRpcmVjdFVwZGF0ZSA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZCB8fCByZXNldCB8fCBtb2RlID09PSAnbm9uZSc7XG4gICAgbGV0IHByZXZQYXJzZWQgPSBzdGFydCA+IDAgJiYgdGhpcy5nZXRQYXJzZWQoc3RhcnQgLSAxKTtcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkaXJlY3RVcGRhdGUgPyBwb2ludCA6IHt9O1xuICAgICAgY29uc3QgbnVsbERhdGEgPSBpc051bGxPclVuZGVmKHBhcnNlZFt2QXhpc10pO1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdLCBpKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgfHwgbnVsbERhdGEgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogcGFyc2VkW3ZBeGlzXSwgaSk7XG5cbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKSB8fCBudWxsRGF0YTtcbiAgICAgIHByb3BlcnRpZXMuc3RvcCA9IGkgPiAwICYmIChNYXRoLmFicyhwYXJzZWRbaUF4aXNdIC0gcHJldlBhcnNlZFtpQXhpc10pKSA+IG1heEdhcExlbmd0aDtcbiAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIHByb3BlcnRpZXMucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICBwcm9wZXJ0aWVzLnJhdyA9IF9kYXRhc2V0LmRhdGFbaV07XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpcmVjdFVwZGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgfVxuXG4gICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGEgfHwgW107XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgbGV0IG1heCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGFbaV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSkpIC8gMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF4ID4gMCAmJiBtYXg7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YXNldCA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBib3JkZXIgPSBkYXRhc2V0Lm9wdGlvbnMgJiYgZGF0YXNldC5vcHRpb25zLmJvcmRlcldpZHRoIHx8IDA7XG5cbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYm9yZGVyO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZGF0YS5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KGJvcmRlciwgZmlyc3RQb2ludCwgbGFzdFBvaW50KSAvIDI7XG4gIH1cbn1cbiIsICIvKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuX2FkYXB0ZXJzXG4gKiBAc2luY2UgMi44LjBcbiAqIEBwcml2YXRlXG4gKi9cblxuaW1wb3J0IHR5cGUge0FueU9iamVjdH0gZnJvbSAnLi4vdHlwZXMvYmFzaWMuanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0T3B0aW9uc30gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG5leHBvcnQgdHlwZSBUaW1lVW5pdCA9ICdtaWxsaXNlY29uZCcgfCAnc2Vjb25kJyB8ICdtaW51dGUnIHwgJ2hvdXInIHwgJ2RheScgfCAnd2VlaycgfCAnbW9udGgnIHwgJ3F1YXJ0ZXInIHwgJ3llYXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVBZGFwdGVyPFQgZXh0ZW5kcyBBbnlPYmplY3QgPSBBbnlPYmplY3Q+IHtcbiAgcmVhZG9ubHkgb3B0aW9uczogVDtcbiAgLyoqXG4gICAqIFdpbGwgY2FsbGVkIHdpdGggY2hhcnQgb3B0aW9ucyBhZnRlciBhZGFwdGVyIGNyZWF0aW9uLlxuICAgKi9cbiAgaW5pdCh0aGlzOiBEYXRlQWRhcHRlcjxUPiwgY2hhcnRPcHRpb25zOiBDaGFydE9wdGlvbnMpOiB2b2lkO1xuICAvKipcbiAgICogUmV0dXJucyBhIG1hcCBvZiB0aW1lIGZvcm1hdHMgZm9yIHRoZSBzdXBwb3J0ZWQgZm9ybWF0dGluZyB1bml0cyBkZWZpbmVkXG4gICAqIGluIFVuaXQgYXMgd2VsbCBhcyAnZGF0ZXRpbWUnIHJlcHJlc2VudGluZyBhIGRldGFpbGVkIGRhdGUvdGltZSBzdHJpbmcuXG4gICAqL1xuICBmb3JtYXRzKHRoaXM6IERhdGVBZGFwdGVyPFQ+KTogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZ2l2ZW4gYHZhbHVlYCBhbmQgcmV0dXJuIHRoZSBhc3NvY2lhdGVkIHRpbWVzdGFtcC5cbiAgICogQHBhcmFtIHZhbHVlIC0gdGhlIHZhbHVlIHRvIHBhcnNlICh1c3VhbGx5IGNvbWVzIGZyb20gdGhlIGRhdGEpXG4gICAqIEBwYXJhbSBbZm9ybWF0XSAtIHRoZSBleHBlY3RlZCBkYXRhIGZvcm1hdFxuICAgKi9cbiAgcGFyc2UodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHZhbHVlOiB1bmtub3duLCBmb3JtYXQ/OiBUaW1lVW5pdCk6IG51bWJlciB8IG51bGw7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmb3JtYXR0ZWQgZGF0ZSBpbiB0aGUgc3BlY2lmaWVkIGBmb3JtYXRgIGZvciBhIGdpdmVuIGB0aW1lc3RhbXBgLlxuICAgKiBAcGFyYW0gdGltZXN0YW1wIC0gdGhlIHRpbWVzdGFtcCB0byBmb3JtYXRcbiAgICogQHBhcmFtIGZvcm1hdCAtIHRoZSBkYXRlL3RpbWUgdG9rZW5cbiAgICovXG4gIGZvcm1hdCh0aGlzOiBEYXRlQWRhcHRlcjxUPiwgdGltZXN0YW1wOiBudW1iZXIsIGZvcm1hdDogVGltZVVuaXQpOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBZGRzIHRoZSBzcGVjaWZpZWQgYGFtb3VudGAgb2YgYHVuaXRgIHRvIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcbiAgICogQHBhcmFtIGFtb3VudCAtIHRoZSBhbW91bnQgdG8gYWRkXG4gICAqIEBwYXJhbSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG4gICAqL1xuICBhZGQodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHRpbWVzdGFtcDogbnVtYmVyLCBhbW91bnQ6IG51bWJlciwgdW5pdDogVGltZVVuaXQpOiBudW1iZXI7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYHVuaXRgIGJldHdlZW4gdGhlIGdpdmVuIHRpbWVzdGFtcHMuXG4gICAqIEBwYXJhbSBhIC0gdGhlIGlucHV0IHRpbWVzdGFtcCAocmVmZXJlbmNlKVxuICAgKiBAcGFyYW0gYiAtIHRoZSB0aW1lc3RhbXAgdG8gc3VidHJhY3RcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICovXG4gIGRpZmYodGhpczogRGF0ZUFkYXB0ZXI8VD4sIGE6IG51bWJlciwgYjogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCk6IG51bWJlcjtcbiAgLyoqXG4gICAqIFJldHVybnMgc3RhcnQgb2YgYHVuaXRgIGZvciB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXG4gICAqIEBwYXJhbSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG4gICAqIEBwYXJhbSBbd2Vla2RheV0gLSB0aGUgSVNPIGRheSBvZiB0aGUgd2VlayB3aXRoIDEgYmVpbmcgTW9uZGF5XG4gICAqIGFuZCA3IGJlaW5nIFN1bmRheSAob25seSBuZWVkZWQgaWYgcGFyYW0gKnVuaXQqIGlzIGBpc29XZWVrYCkuXG4gICAqL1xuICBzdGFydE9mKHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB0aW1lc3RhbXA6IG51bWJlciwgdW5pdDogVGltZVVuaXQgfCAnaXNvV2VlaycsIHdlZWtkYXk/OiBudW1iZXIpOiBudW1iZXI7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGVuZCBvZiBgdW5pdGAgZm9yIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICovXG4gIGVuZE9mKHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB0aW1lc3RhbXA6IG51bWJlciwgdW5pdDogVGltZVVuaXQgfCAnaXNvV2VlaycpOiBudW1iZXI7XG59XG5cbmZ1bmN0aW9uIGFic3RyYWN0PFQgPSB2b2lkPigpOiBUIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQ6IENoZWNrIHRoYXQgYSBjb21wbGV0ZSBkYXRlIGFkYXB0ZXIgaXMgcHJvdmlkZWQuJyk7XG59XG5cbi8qKlxuICogRGF0ZSBhZGFwdGVyIChjdXJyZW50IHVzZWQgYnkgdGhlIHRpbWUgc2NhbGUpXG4gKiBAbmFtZXNwYWNlIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZVxuICogQG1lbWJlcm9mIENoYXJ0Ll9hZGFwdGVyc1xuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgRGF0ZUFkYXB0ZXJCYXNlIGltcGxlbWVudHMgRGF0ZUFkYXB0ZXIge1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBkZWZhdWx0IGRhdGUgYWRhcHRlciBtZXRob2RzLlxuICAgKiBBY2NlcHRzIHR5cGUgcGFyYW1ldGVyIHRvIGRlZmluZSBvcHRpb25zIHR5cGUuXG4gICAqIEBleGFtcGxlXG4gICAqIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZS5vdmVycmlkZTx7bXlBZGFwdGVyT3B0aW9uOiBzdHJpbmd9Pih7XG4gICAqICAgaW5pdCgpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKHRoaXMub3B0aW9ucy5teUFkYXB0ZXJPcHRpb24pO1xuICAgKiAgIH1cbiAgICogfSlcbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZTxUIGV4dGVuZHMgQW55T2JqZWN0ID0gQW55T2JqZWN0PihcbiAgICBtZW1iZXJzOiBQYXJ0aWFsPE9taXQ8RGF0ZUFkYXB0ZXI8VD4sICdvcHRpb25zJz4+XG4gICkge1xuICAgIE9iamVjdC5hc3NpZ24oRGF0ZUFkYXB0ZXJCYXNlLnByb3RvdHlwZSwgbWVtYmVycyk7XG4gIH1cblxuICByZWFkb25seSBvcHRpb25zOiBBbnlPYmplY3Q7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogQW55T2JqZWN0KSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbiAgaW5pdCgpIHt9XG5cbiAgZm9ybWF0cygpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIHBhcnNlKCk6IG51bWJlciB8IG51bGwge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgZm9ybWF0KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBhZGQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIGRpZmYoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIHN0YXJ0T2YoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIGVuZE9mKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBfZGF0ZTogRGF0ZUFkYXB0ZXJCYXNlXG59O1xuIiwgImltcG9ydCB7X2xvb2t1cEJ5S2V5LCBfcmxvb2t1cEJ5S2V5fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5pbXBvcnQge2dldFJlbGF0aXZlUG9zaXRpb259IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5kb20uanMnO1xuaW1wb3J0IHtfYW5nbGVCZXR3ZWVuLCBnZXRBbmdsZUZyb21Qb2ludH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfaXNQb2ludEluQXJlYX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYge3theGlzPzogc3RyaW5nLCBpbnRlcnNlY3Q/OiBib29sZWFuLCBpbmNsdWRlSW52aXNpYmxlPzogYm9vbGVhbn19IEludGVyYWN0aW9uT3B0aW9uc1xuICogQHR5cGVkZWYge3tkYXRhc2V0SW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlciwgZWxlbWVudDogaW1wb3J0KCcuL2NvcmUuZWxlbWVudC5qcycpLmRlZmF1bHR9fSBJbnRlcmFjdGlvbkl0ZW1cbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLlBvaW50IH0gUG9pbnRcbiAqL1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBkbyBiaW5hcnkgc2VhcmNoIHdoZW4gcG9zc2libGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhc2V0IC0gdGhlIGRhdGFzZXQgbWV0YVxuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyBtb2RlLiB4fHl8eHl8clxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIGZpbmRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBzaG91bGQgdGhlIGVsZW1lbnQgaW50ZXJzZWN0XG4gKiBAcmV0dXJucyB7e2xvOm51bWJlciwgaGk6bnVtYmVyfX0gaW5kaWNlcyB0byBzZWFyY2ggZGF0YSBhcnJheSBiZXR3ZWVuXG4gKi9cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChtZXRhc2V0LCBheGlzLCB2YWx1ZSwgaW50ZXJzZWN0KSB7XG4gIGNvbnN0IHtjb250cm9sbGVyLCBkYXRhLCBfc29ydGVkfSA9IG1ldGFzZXQ7XG4gIGNvbnN0IGlTY2FsZSA9IGNvbnRyb2xsZXIuX2NhY2hlZE1ldGEuaVNjYWxlO1xuICBpZiAoaVNjYWxlICYmIGF4aXMgPT09IGlTY2FsZS5heGlzICYmIGF4aXMgIT09ICdyJyAmJiBfc29ydGVkICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgY29uc3QgbG9va3VwTWV0aG9kID0gaVNjYWxlLl9yZXZlcnNlUGl4ZWxzID8gX3Jsb29rdXBCeUtleSA6IF9sb29rdXBCeUtleTtcbiAgICBpZiAoIWludGVyc2VjdCkge1xuICAgICAgcmV0dXJuIGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVyLl9zaGFyZWRPcHRpb25zKSB7XG4gICAgICAvLyBfc2hhcmVkT3B0aW9ucyBpbmRpY2F0ZXMgdGhhdCBlYWNoIGVsZW1lbnQgaGFzIGVxdWFsIG9wdGlvbnMgLT4gZXF1YWwgcHJvcG9ydGlvbnNcbiAgICAgIC8vIFNvIHdlIGNhbiBkbyBhIHJhbmdlZCBiaW5hcnkgc2VhcmNoIGJhc2VkIG9uIHRoZSByYW5nZSBvZiBmaXJzdCBlbGVtZW50IGFuZFxuICAgICAgLy8gYmUgY29uZmlkZW50IHRvIGdldCB0aGUgZnVsbCByYW5nZSBvZiBpbmRpY2VzIHRoYXQgY2FuIGludGVyc2VjdCB3aXRoIHRoZSB2YWx1ZS5cbiAgICAgIGNvbnN0IGVsID0gZGF0YVswXTtcbiAgICAgIGNvbnN0IHJhbmdlID0gdHlwZW9mIGVsLmdldFJhbmdlID09PSAnZnVuY3Rpb24nICYmIGVsLmdldFJhbmdlKGF4aXMpO1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlIC0gcmFuZ2UpO1xuICAgICAgICBjb25zdCBlbmQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgKyByYW5nZSk7XG4gICAgICAgIHJldHVybiB7bG86IHN0YXJ0LmxvLCBoaTogZW5kLmhpfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gRGVmYXVsdCB0byBhbGwgZWxlbWVudHMsIHdoZW4gYmluYXJ5IHNlYXJjaCBjYW4gbm90IGJlIHVzZWQuXG4gIHJldHVybiB7bG86IDAsIGhpOiBkYXRhLmxlbmd0aCAtIDF9O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBzZWxlY3QgY2FuZGlkYXRlIGVsZW1lbnRzIGZvciBpbnRlcmFjdGlvblxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5fHJcbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gdGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgZm9yIGVhY2ggdmlzaWJsZSBpdGVtXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gY29uc2lkZXIgaW50ZXJzZWN0aW5nIGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGhhbmRsZXIsIGludGVyc2VjdCkge1xuICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltheGlzXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjb25zdCB7aW5kZXgsIGRhdGF9ID0gbWV0YXNldHNbaV07XG4gICAgY29uc3Qge2xvLCBoaX0gPSBiaW5hcnlTZWFyY2gobWV0YXNldHNbaV0sIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpO1xuICAgIGZvciAobGV0IGogPSBsbzsgaiA8PSBoaTsgKytqKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZGF0YVtqXTtcbiAgICAgIGlmICghZWxlbWVudC5za2lwKSB7XG4gICAgICAgIGhhbmRsZXIoZWxlbWVudCwgaW5kZXgsIGopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCBhIGRpc3RhbmNlIG1ldHJpYyBmdW5jdGlvbiBmb3IgdHdvIHBvaW50cyBiYXNlZCBvbiB0aGVcbiAqIGF4aXMgbW9kZSBzZXR0aW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eXxyXG4gKi9cbmZ1bmN0aW9uIGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKSB7XG4gIGNvbnN0IHVzZVggPSBheGlzLmluZGV4T2YoJ3gnKSAhPT0gLTE7XG4gIGNvbnN0IHVzZVkgPSBheGlzLmluZGV4T2YoJ3knKSAhPT0gLTE7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG4gICAgY29uc3QgZGVsdGFYID0gdXNlWCA/IE1hdGguYWJzKHB0MS54IC0gcHQyLngpIDogMDtcbiAgICBjb25zdCBkZWx0YVkgPSB1c2VZID8gTWF0aC5hYnMocHQxLnkgLSBwdDIueSkgOiAwO1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZGVsdGFYLCAyKSArIE1hdGgucG93KGRlbHRhWSwgMikpO1xuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBldmVudCBwb3NpdGlvblxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eXxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSW52aXNpYmxlXSAtIGluY2x1ZGUgaW52aXNpYmxlIHBvaW50cyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBjaGFydCBhcmVhXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG5cbiAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFjaGFydC5pc1BvaW50SW5BcmVhKHBvc2l0aW9uKSkge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIGNvbnN0IGV2YWx1YXRpb25GdW5jID0gZnVuY3Rpb24oZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhX2lzUG9pbnRJbkFyZWEoZWxlbWVudCwgY2hhcnQuY2hhcnRBcmVhLCAwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9O1xuXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jLCB0cnVlKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGZvciBhIHJhZGlhbCBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhlcyBhbG9uZyB3aGljaCB0byBtZWFzdXJlIGRpc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICBsZXQgaXRlbXMgPSBbXTtcblxuICBmdW5jdGlvbiBldmFsdWF0aW9uRnVuYyhlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3Qge3N0YXJ0QW5nbGUsIGVuZEFuZ2xlfSA9IGVsZW1lbnQuZ2V0UHJvcHMoWydzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJ10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZX0gPSBnZXRBbmdsZUZyb21Qb2ludChlbGVtZW50LCB7eDogcG9zaXRpb24ueCwgeTogcG9zaXRpb24ueX0pO1xuXG4gICAgaWYgKF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfVxuXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGZvciBhIGNhcnRlc2lhbiBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhlcyBhbG9uZyB3aGljaCB0byBtZWFzdXJlIGRpc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gaWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJbnZpc2libGVdIC0gaW5jbHVkZSBpbnZpc2libGUgcG9pbnRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIGNoYXJ0IGFyZWFcbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgbGV0IGl0ZW1zID0gW107XG4gIGNvbnN0IGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpO1xuICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgZnVuY3Rpb24gZXZhbHVhdGlvbkZ1bmMoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGNvbnN0IGluUmFuZ2UgPSBlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgaWYgKGludGVyc2VjdCAmJiAhaW5SYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNlbnRlciA9IGVsZW1lbnQuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgcG9pbnRJbkFyZWEgPSAhIWluY2x1ZGVJbnZpc2libGUgfHwgY2hhcnQuaXNQb2ludEluQXJlYShjZW50ZXIpO1xuICAgIGlmICghcG9pbnRJbkFyZWEgJiYgIWluUmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkaXN0YW5jZSA9IGRpc3RhbmNlTWV0cmljKHBvc2l0aW9uLCBjZW50ZXIpO1xuICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICBpdGVtcyA9IFt7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH1dO1xuICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlID09PSBtaW5EaXN0YW5jZSkge1xuICAgICAgLy8gQ2FuIGhhdmUgbXVsdGlwbGUgaXRlbXMgYXQgdGhlIHNhbWUgZGlzdGFuY2UgaW4gd2hpY2ggY2FzZSB3ZSBzb3J0IGJ5IHNpemVcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH1cblxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYyk7XG4gIHJldHVybiBpdGVtcztcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyBuZWFyZXN0IHRvIHRoZSBldmVudCBwb3NpdGlvbiBjb25zaWRlcmluZyBhbGwgdmlzaWJsZSBpdGVtcyBpbiB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIGxvb2sgYXQgZWxlbWVudHMgZnJvbVxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4ZXMgYWxvbmcgd2hpY2ggdG8gbWVhc3VyZSBkaXN0YW5jZVxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIGlmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSW52aXNpYmxlXSAtIGluY2x1ZGUgaW52aXNpYmxlIHBvaW50cyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBjaGFydCBhcmVhXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhY2hhcnQuaXNQb2ludEluQXJlYShwb3NpdGlvbikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gYXhpcyA9PT0gJ3InICYmICFpbnRlcnNlY3RcbiAgICA/IGdldE5lYXJlc3RSYWRpYWxJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pXG4gICAgOiBnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG1hdGNoaW5nIGFsb25nIHRoZSBnaXZlbiBYIG9yIFkgYXhpc1xuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyB0byBtYXRjaFxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIGlmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGNvbnN0IHJhbmdlTWV0aG9kID0gYXhpcyA9PT0gJ3gnID8gJ2luWFJhbmdlJyA6ICdpbllSYW5nZSc7XG4gIGxldCBpbnRlcnNlY3RzSXRlbSA9IGZhbHNlO1xuXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIChlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSA9PiB7XG4gICAgaWYgKGVsZW1lbnRbcmFuZ2VNZXRob2RdKHBvc2l0aW9uW2F4aXNdLCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgICAgaW50ZXJzZWN0c0l0ZW0gPSBpbnRlcnNlY3RzSXRlbSB8fCBlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICB9KTtcblxuICAvLyBJZiB3ZSB3YW50IHRvIHRyaWdnZXIgb24gYW4gaW50ZXJzZWN0IGFuZCB3ZSBkb24ndCBoYXZlIGFueSBpdGVtc1xuICAvLyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb24sIHJldHVybiBub3RoaW5nXG4gIGlmIChpbnRlcnNlY3QgJiYgIWludGVyc2VjdHNJdGVtKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBpdGVtcztcbn1cblxuLyoqXG4gKiBDb250YWlucyBpbnRlcmFjdGlvbiByZWxhdGVkIGZ1bmN0aW9uc1xuICogQG5hbWVzcGFjZSBDaGFydC5JbnRlcmFjdGlvblxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8vIFBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgdG8gZmFjaWxpdGF0ZSBkZXZlbG9wZXJzIGNyZWF0aW5nIHRoZWlyIG93biBtb2Rlc1xuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMsXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBkaWZmZXJlbnQgbW9kZXNcbiAgbW9kZXM6IHtcbiAgICAvKipcblx0XHQgKiBSZXR1cm5zIGl0ZW1zIGF0IHRoZSBzYW1lIGluZGV4LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcblx0XHQgKiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgbW9kZSBpcyBmYWxzZSwgd2UgZmluZCB0aGUgbmVhcmVzdCBpdGVtIGFuZCByZXR1cm4gdGhlIGl0ZW1zIGF0IHRoZSBzYW1lIGluZGV4IGFzIHRoYXQgaXRlbVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbmRleFxuXHRcdCAqIEBzaW5jZSB2Mi40LjBcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgaW5kZXgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICAvLyBEZWZhdWx0IGF4aXMgZm9yIGluZGV4IG1vZGUgaXMgJ3gnIHRvIG1hdGNoIG9sZCBiZWhhdmlvdXJcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3gnO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIGNvbnN0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3RcbiAgICAgICAgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpXG4gICAgICAgIDogZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcblxuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkuZm9yRWFjaCgobWV0YSkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IGl0ZW1zWzBdLmluZGV4O1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gbWV0YS5kYXRhW2luZGV4XTtcblxuICAgICAgICAvLyBkb24ndCBjb3VudCBpdGVtcyB0aGF0IGFyZSBza2lwcGVkIChudWxsIGRhdGEpXG4gICAgICAgIGlmIChlbGVtZW50ICYmICFlbGVtZW50LnNraXApIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXgsIGluZGV4fSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIFJldHVybnMgaXRlbXMgaW4gdGhlIHNhbWUgZGF0YXNldC4gSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IHBhcmFtZXRlciBpcyB0cnVlLCB3ZSBvbmx5IHJldHVybiBpdGVtcyBpZiB3ZSBpbnRlcnNlY3Qgc29tZXRoaW5nXG5cdFx0ICogSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IGlzIGZhbHNlLCB3ZSBmaW5kIHRoZSBuZWFyZXN0IGl0ZW0gYW5kIHJldHVybiB0aGUgaXRlbXMgaW4gdGhhdCBkYXRhc2V0XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmRhdGFzZXRcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgZGF0YXNldChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICBsZXQgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdFxuICAgICAgICA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkgOlxuICAgICAgICBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBmYWxzZSwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG5cbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRJbmRleCA9IGl0ZW1zWzBdLmRhdGFzZXRJbmRleDtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuZGF0YTtcbiAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudDogZGF0YVtpXSwgZGF0YXNldEluZGV4LCBpbmRleDogaX0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogUG9pbnQgbW9kZSByZXR1cm5zIGFsbCBlbGVtZW50cyB0aGF0IGhpdCB0ZXN0IGJhc2VkIG9uIHRoZSBldmVudCBwb3NpdGlvblxuXHRcdCAqIG9mIHRoZSBldmVudFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbnRlcnNlY3Rcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgcG9pbnQoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIG5lYXJlc3QgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50IGNsb3Nlc3QgdG8gdGhlIHBvaW50XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmludGVyc2VjdFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICBuZWFyZXN0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIHJldHVybiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIHggbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50cyB0aGF0IGhpdC10ZXN0IGF0IHRoZSBjdXJyZW50IHggY29vcmRpbmF0ZVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy54XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIHgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICByZXR1cm4gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgJ3gnLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIHkgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50cyB0aGF0IGhpdC10ZXN0IGF0IHRoZSBjdXJyZW50IHkgY29vcmRpbmF0ZVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy55XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIHkoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICByZXR1cm4gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgJ3knLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICB9XG59O1xuIiwgImltcG9ydCB7ZGVmaW5lZCwgZWFjaCwgaXNPYmplY3R9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7dG9QYWRkaW5nfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuY29uc3QgU1RBVElDX1BPU0lUSU9OUyA9IFsnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJ107XG5cbmZ1bmN0aW9uIGZpbHRlckJ5UG9zaXRpb24oYXJyYXksIHBvc2l0aW9uKSB7XG4gIHJldHVybiBhcnJheS5maWx0ZXIodiA9PiB2LnBvcyA9PT0gcG9zaXRpb24pO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMoYXJyYXksIGF4aXMpIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IFNUQVRJQ19QT1NJVElPTlMuaW5kZXhPZih2LnBvcykgPT09IC0xICYmIHYuYm94LmF4aXMgPT09IGF4aXMpO1xufVxuXG5mdW5jdGlvbiBzb3J0QnlXZWlnaHQoYXJyYXksIHJldmVyc2UpIHtcbiAgcmV0dXJuIGFycmF5LnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCB2MCA9IHJldmVyc2UgPyBiIDogYTtcbiAgICBjb25zdCB2MSA9IHJldmVyc2UgPyBhIDogYjtcbiAgICByZXR1cm4gdjAud2VpZ2h0ID09PSB2MS53ZWlnaHQgP1xuICAgICAgdjAuaW5kZXggLSB2MS5pbmRleCA6XG4gICAgICB2MC53ZWlnaHQgLSB2MS53ZWlnaHQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3cmFwQm94ZXMoYm94ZXMpIHtcbiAgY29uc3QgbGF5b3V0Qm94ZXMgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGJveCwgcG9zLCBzdGFjaywgc3RhY2tXZWlnaHQ7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IChib3hlcyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgYm94ID0gYm94ZXNbaV07XG4gICAgKHtwb3NpdGlvbjogcG9zLCBvcHRpb25zOiB7c3RhY2ssIHN0YWNrV2VpZ2h0ID0gMX19ID0gYm94KTtcbiAgICBsYXlvdXRCb3hlcy5wdXNoKHtcbiAgICAgIGluZGV4OiBpLFxuICAgICAgYm94LFxuICAgICAgcG9zLFxuICAgICAgaG9yaXpvbnRhbDogYm94LmlzSG9yaXpvbnRhbCgpLFxuICAgICAgd2VpZ2h0OiBib3gud2VpZ2h0LFxuICAgICAgc3RhY2s6IHN0YWNrICYmIChwb3MgKyBzdGFjayksXG4gICAgICBzdGFja1dlaWdodFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBsYXlvdXRCb3hlcztcbn1cblxuZnVuY3Rpb24gYnVpbGRTdGFja3MobGF5b3V0cykge1xuICBjb25zdCBzdGFja3MgPSB7fTtcbiAgZm9yIChjb25zdCB3cmFwIG9mIGxheW91dHMpIHtcbiAgICBjb25zdCB7c3RhY2ssIHBvcywgc3RhY2tXZWlnaHR9ID0gd3JhcDtcbiAgICBpZiAoIXN0YWNrIHx8ICFTVEFUSUNfUE9TSVRJT05TLmluY2x1ZGVzKHBvcykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBfc3RhY2sgPSBzdGFja3Nbc3RhY2tdIHx8IChzdGFja3Nbc3RhY2tdID0ge2NvdW50OiAwLCBwbGFjZWQ6IDAsIHdlaWdodDogMCwgc2l6ZTogMH0pO1xuICAgIF9zdGFjay5jb3VudCsrO1xuICAgIF9zdGFjay53ZWlnaHQgKz0gc3RhY2tXZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHN0YWNrcztcbn1cblxuLyoqXG4gKiBzdG9yZSBkaW1lbnNpb25zIHVzZWQgaW5zdGVhZCBvZiBhdmFpbGFibGUgY2hhcnRBcmVhIGluIGZpdEJveGVzXG4gKiovXG5mdW5jdGlvbiBzZXRMYXlvdXREaW1zKGxheW91dHMsIHBhcmFtcykge1xuICBjb25zdCBzdGFja3MgPSBidWlsZFN0YWNrcyhsYXlvdXRzKTtcbiAgY29uc3Qge3ZCb3hNYXhXaWR0aCwgaEJveE1heEhlaWdodH0gPSBwYXJhbXM7XG4gIGxldCBpLCBpbGVuLCBsYXlvdXQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBsYXlvdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGxheW91dCA9IGxheW91dHNbaV07XG4gICAgY29uc3Qge2Z1bGxTaXplfSA9IGxheW91dC5ib3g7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXTtcbiAgICBjb25zdCBmYWN0b3IgPSBzdGFjayAmJiBsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQ7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBsYXlvdXQud2lkdGggPSBmYWN0b3IgPyBmYWN0b3IgKiB2Qm94TWF4V2lkdGggOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlV2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gaEJveE1heEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5b3V0LndpZHRoID0gdkJveE1heFdpZHRoO1xuICAgICAgbGF5b3V0LmhlaWdodCA9IGZhY3RvciA/IGZhY3RvciAqIGhCb3hNYXhIZWlnaHQgOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlSGVpZ2h0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuXG5mdW5jdGlvbiBidWlsZExheW91dEJveGVzKGJveGVzKSB7XG4gIGNvbnN0IGxheW91dEJveGVzID0gd3JhcEJveGVzKGJveGVzKTtcbiAgY29uc3QgZnVsbFNpemUgPSBzb3J0QnlXZWlnaHQobGF5b3V0Qm94ZXMuZmlsdGVyKHdyYXAgPT4gd3JhcC5ib3guZnVsbFNpemUpLCB0cnVlKTtcbiAgY29uc3QgbGVmdCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnbGVmdCcpLCB0cnVlKTtcbiAgY29uc3QgcmlnaHQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ3JpZ2h0JykpO1xuICBjb25zdCB0b3AgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ3RvcCcpLCB0cnVlKTtcbiAgY29uc3QgYm90dG9tID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdib3R0b20nKSk7XG4gIGNvbnN0IGNlbnRlckhvcml6b250YWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd4Jyk7XG4gIGNvbnN0IGNlbnRlclZlcnRpY2FsID0gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGxheW91dEJveGVzLCAneScpO1xuXG4gIHJldHVybiB7XG4gICAgZnVsbFNpemUsXG4gICAgbGVmdEFuZFRvcDogbGVmdC5jb25jYXQodG9wKSxcbiAgICByaWdodEFuZEJvdHRvbTogcmlnaHQuY29uY2F0KGNlbnRlclZlcnRpY2FsKS5jb25jYXQoYm90dG9tKS5jb25jYXQoY2VudGVySG9yaXpvbnRhbCksXG4gICAgY2hhcnRBcmVhOiBmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnY2hhcnRBcmVhJyksXG4gICAgdmVydGljYWw6IGxlZnQuY29uY2F0KHJpZ2h0KS5jb25jYXQoY2VudGVyVmVydGljYWwpLFxuICAgIGhvcml6b250YWw6IHRvcC5jb25jYXQoYm90dG9tKS5jb25jYXQoY2VudGVySG9yaXpvbnRhbClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCBhLCBiKSB7XG4gIHJldHVybiBNYXRoLm1heChtYXhQYWRkaW5nW2FdLCBjaGFydEFyZWFbYV0pICsgTWF0aC5tYXgobWF4UGFkZGluZ1tiXSwgY2hhcnRBcmVhW2JdKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCBib3hQYWRkaW5nKSB7XG4gIG1heFBhZGRpbmcudG9wID0gTWF0aC5tYXgobWF4UGFkZGluZy50b3AsIGJveFBhZGRpbmcudG9wKTtcbiAgbWF4UGFkZGluZy5sZWZ0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5sZWZ0LCBib3hQYWRkaW5nLmxlZnQpO1xuICBtYXhQYWRkaW5nLmJvdHRvbSA9IE1hdGgubWF4KG1heFBhZGRpbmcuYm90dG9tLCBib3hQYWRkaW5nLmJvdHRvbSk7XG4gIG1heFBhZGRpbmcucmlnaHQgPSBNYXRoLm1heChtYXhQYWRkaW5nLnJpZ2h0LCBib3hQYWRkaW5nLnJpZ2h0KTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpIHtcbiAgY29uc3Qge3BvcywgYm94fSA9IGxheW91dDtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuXG4gIC8vIGR5bmFtaWNhbGx5IHBsYWNlZCBib3hlcyBzaXplIGlzIG5vdCBjb25zaWRlcmVkXG4gIGlmICghaXNPYmplY3QocG9zKSkge1xuICAgIGlmIChsYXlvdXQuc2l6ZSkge1xuICAgICAgLy8gdGhpcyBsYXlvdXQgd2FzIGFscmVhZHkgY291bnRlZCBmb3IsIGxldHMgZmlyc3QgcmVkdWNlIG9sZCBzaXplXG4gICAgICBjaGFydEFyZWFbcG9zXSAtPSBsYXlvdXQuc2l6ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXSB8fCB7c2l6ZTogMCwgY291bnQ6IDF9O1xuICAgIHN0YWNrLnNpemUgPSBNYXRoLm1heChzdGFjay5zaXplLCBsYXlvdXQuaG9yaXpvbnRhbCA/IGJveC5oZWlnaHQgOiBib3gud2lkdGgpO1xuICAgIGxheW91dC5zaXplID0gc3RhY2suc2l6ZSAvIHN0YWNrLmNvdW50O1xuICAgIGNoYXJ0QXJlYVtwb3NdICs9IGxheW91dC5zaXplO1xuICB9XG5cbiAgaWYgKGJveC5nZXRQYWRkaW5nKSB7XG4gICAgdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCBib3guZ2V0UGFkZGluZygpKTtcbiAgfVxuXG4gIGNvbnN0IG5ld1dpZHRoID0gTWF0aC5tYXgoMCwgcGFyYW1zLm91dGVyV2lkdGggLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICdsZWZ0JywgJ3JpZ2h0JykpO1xuICBjb25zdCBuZXdIZWlnaHQgPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJIZWlnaHQgLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICd0b3AnLCAnYm90dG9tJykpO1xuICBjb25zdCB3aWR0aENoYW5nZWQgPSBuZXdXaWR0aCAhPT0gY2hhcnRBcmVhLnc7XG4gIGNvbnN0IGhlaWdodENoYW5nZWQgPSBuZXdIZWlnaHQgIT09IGNoYXJ0QXJlYS5oO1xuICBjaGFydEFyZWEudyA9IG5ld1dpZHRoO1xuICBjaGFydEFyZWEuaCA9IG5ld0hlaWdodDtcblxuICAvLyByZXR1cm4gYm9vbGVhbnMgb24gdGhlIGNoYW5nZXMgcGVyIGRpcmVjdGlvblxuICByZXR1cm4gbGF5b3V0Lmhvcml6b250YWxcbiAgICA/IHtzYW1lOiB3aWR0aENoYW5nZWQsIG90aGVyOiBoZWlnaHRDaGFuZ2VkfVxuICAgIDoge3NhbWU6IGhlaWdodENoYW5nZWQsIG90aGVyOiB3aWR0aENoYW5nZWR9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVNYXhQYWRkaW5nKGNoYXJ0QXJlYSkge1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9zKHBvcykge1xuICAgIGNvbnN0IGNoYW5nZSA9IE1hdGgubWF4KG1heFBhZGRpbmdbcG9zXSAtIGNoYXJ0QXJlYVtwb3NdLCAwKTtcbiAgICBjaGFydEFyZWFbcG9zXSArPSBjaGFuZ2U7XG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfVxuICBjaGFydEFyZWEueSArPSB1cGRhdGVQb3MoJ3RvcCcpO1xuICBjaGFydEFyZWEueCArPSB1cGRhdGVQb3MoJ2xlZnQnKTtcbiAgdXBkYXRlUG9zKCdyaWdodCcpO1xuICB1cGRhdGVQb3MoJ2JvdHRvbScpO1xufVxuXG5mdW5jdGlvbiBnZXRNYXJnaW5zKGhvcml6b250YWwsIGNoYXJ0QXJlYSkge1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG5cbiAgZnVuY3Rpb24gbWFyZ2luRm9yUG9zaXRpb25zKHBvc2l0aW9ucykge1xuICAgIGNvbnN0IG1hcmdpbiA9IHtsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDB9O1xuICAgIHBvc2l0aW9ucy5mb3JFYWNoKChwb3MpID0+IHtcbiAgICAgIG1hcmdpbltwb3NdID0gTWF0aC5tYXgoY2hhcnRBcmVhW3Bvc10sIG1heFBhZGRpbmdbcG9zXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcmdpbjtcbiAgfVxuXG4gIHJldHVybiBob3Jpem9udGFsXG4gICAgPyBtYXJnaW5Gb3JQb3NpdGlvbnMoWydsZWZ0JywgJ3JpZ2h0J10pXG4gICAgOiBtYXJnaW5Gb3JQb3NpdGlvbnMoWyd0b3AnLCAnYm90dG9tJ10pO1xufVxuXG5mdW5jdGlvbiBmaXRCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykge1xuICBjb25zdCByZWZpdEJveGVzID0gW107XG4gIGxldCBpLCBpbGVuLCBsYXlvdXQsIGJveCwgcmVmaXQsIGNoYW5nZWQ7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGJveGVzLmxlbmd0aCwgcmVmaXQgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGF5b3V0ID0gYm94ZXNbaV07XG4gICAgYm94ID0gbGF5b3V0LmJveDtcblxuICAgIGJveC51cGRhdGUoXG4gICAgICBsYXlvdXQud2lkdGggfHwgY2hhcnRBcmVhLncsXG4gICAgICBsYXlvdXQuaGVpZ2h0IHx8IGNoYXJ0QXJlYS5oLFxuICAgICAgZ2V0TWFyZ2lucyhsYXlvdXQuaG9yaXpvbnRhbCwgY2hhcnRBcmVhKVxuICAgICk7XG4gICAgY29uc3Qge3NhbWUsIG90aGVyfSA9IHVwZGF0ZURpbXMoY2hhcnRBcmVhLCBwYXJhbXMsIGxheW91dCwgc3RhY2tzKTtcblxuICAgIC8vIERpbWVuc2lvbnMgY2hhbmdlZCBhbmQgdGhlcmUgd2VyZSBub24gZnVsbCB3aWR0aCBib3hlcyBiZWZvcmUgdGhpc1xuICAgIC8vIC0+IHdlIGhhdmUgdG8gcmVmaXQgdGhvc2VcbiAgICByZWZpdCB8PSBzYW1lICYmIHJlZml0Qm94ZXMubGVuZ3RoO1xuXG4gICAgLy8gQ2hhcnQgYXJlYSBjaGFuZ2VkIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cbiAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBvdGhlcjtcblxuICAgIGlmICghYm94LmZ1bGxTaXplKSB7IC8vIGZ1bGxTaXplIGJveGVzIGRvbid0IG5lZWQgdG8gYmUgcmUtZml0dGVkIGluIGFueSBjYXNlXG4gICAgICByZWZpdEJveGVzLnB1c2gobGF5b3V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVmaXQgJiYgZml0Qm94ZXMocmVmaXRCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykgfHwgY2hhbmdlZDtcbn1cblxuZnVuY3Rpb24gc2V0Qm94RGltcyhib3gsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICBib3gudG9wID0gdG9wO1xuICBib3gubGVmdCA9IGxlZnQ7XG4gIGJveC5yaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgYm94LmJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgYm94LndpZHRoID0gd2lkdGg7XG4gIGJveC5oZWlnaHQgPSBoZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIHBsYWNlQm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHtcbiAgY29uc3QgdXNlclBhZGRpbmcgPSBwYXJhbXMucGFkZGluZztcbiAgbGV0IHt4LCB5fSA9IGNoYXJ0QXJlYTtcblxuICBmb3IgKGNvbnN0IGxheW91dCBvZiBib3hlcykge1xuICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXSB8fCB7Y291bnQ6IDEsIHBsYWNlZDogMCwgd2VpZ2h0OiAxfTtcbiAgICBjb25zdCB3ZWlnaHQgPSAobGF5b3V0LnN0YWNrV2VpZ2h0IC8gc3RhY2sud2VpZ2h0KSB8fCAxO1xuICAgIGlmIChsYXlvdXQuaG9yaXpvbnRhbCkge1xuICAgICAgY29uc3Qgd2lkdGggPSBjaGFydEFyZWEudyAqIHdlaWdodDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHN0YWNrLnNpemUgfHwgYm94LmhlaWdodDtcbiAgICAgIGlmIChkZWZpbmVkKHN0YWNrLnN0YXJ0KSkge1xuICAgICAgICB5ID0gc3RhY2suc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoYm94LmZ1bGxTaXplKSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB1c2VyUGFkZGluZy5sZWZ0LCB5LCBwYXJhbXMub3V0ZXJXaWR0aCAtIHVzZXJQYWRkaW5nLnJpZ2h0IC0gdXNlclBhZGRpbmcubGVmdCwgaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCBjaGFydEFyZWEubGVmdCArIHN0YWNrLnBsYWNlZCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBzdGFjay5zdGFydCA9IHk7XG4gICAgICBzdGFjay5wbGFjZWQgKz0gd2lkdGg7XG4gICAgICB5ID0gYm94LmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gY2hhcnRBcmVhLmggKiB3ZWlnaHQ7XG4gICAgICBjb25zdCB3aWR0aCA9IHN0YWNrLnNpemUgfHwgYm94LndpZHRoO1xuICAgICAgaWYgKGRlZmluZWQoc3RhY2suc3RhcnQpKSB7XG4gICAgICAgIHggPSBzdGFjay5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHgsIHVzZXJQYWRkaW5nLnRvcCwgd2lkdGgsIHBhcmFtcy5vdXRlckhlaWdodCAtIHVzZXJQYWRkaW5nLmJvdHRvbSAtIHVzZXJQYWRkaW5nLnRvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgeCwgY2hhcnRBcmVhLnRvcCArIHN0YWNrLnBsYWNlZCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBzdGFjay5zdGFydCA9IHg7XG4gICAgICBzdGFjay5wbGFjZWQgKz0gaGVpZ2h0O1xuICAgICAgeCA9IGJveC5yaWdodDtcbiAgICB9XG4gIH1cblxuICBjaGFydEFyZWEueCA9IHg7XG4gIGNoYXJ0QXJlYS55ID0geTtcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIExheW91dEl0ZW1cbiAqIEB0eXBlZGVmIHtvYmplY3R9IExheW91dEl0ZW1cbiAqIEBwcm9wIHtzdHJpbmd9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIGluIHRoZSBjaGFydCBsYXlvdXQuIFBvc3NpYmxlIHZhbHVlcyBhcmVcbiAqICdsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCBhbmQgJ2NoYXJ0QXJlYSdcbiAqIEBwcm9wIHtudW1iZXJ9IHdlaWdodCAtIFRoZSB3ZWlnaHQgdXNlZCB0byBzb3J0IHRoZSBpdGVtLiBIaWdoZXIgd2VpZ2h0cyBhcmUgZnVydGhlciBhd2F5IGZyb20gdGhlIGNoYXJ0IGFyZWFcbiAqIEBwcm9wIHtib29sZWFufSBmdWxsU2l6ZSAtIGlmIHRydWUsIGFuZCB0aGUgaXRlbSBpcyBob3Jpem9udGFsLCB0aGVuIHB1c2ggdmVydGljYWwgYm94ZXMgZG93blxuICogQHByb3Age2Z1bmN0aW9ufSBpc0hvcml6b250YWwgLSByZXR1cm5zIHRydWUgaWYgdGhlIGxheW91dCBpdGVtIGlzIGhvcml6b250YWwgKGllLiB0b3Agb3IgYm90dG9tKVxuICogQHByb3Age2Z1bmN0aW9ufSB1cGRhdGUgLSBUYWtlcyB0d28gcGFyYW1ldGVyczogd2lkdGggYW5kIGhlaWdodC4gUmV0dXJucyBzaXplIG9mIGl0ZW1cbiAqIEBwcm9wIHtmdW5jdGlvbn0gZHJhdyAtIERyYXdzIHRoZSBlbGVtZW50XG4gKiBAcHJvcCB7ZnVuY3Rpb259IFtnZXRQYWRkaW5nXSAtICBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHBhZGRpbmcgb24gdGhlIGVkZ2VzXG4gKiBAcHJvcCB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoIG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcbiAqIEBwcm9wIHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiBpdGVtLiBNdXN0IGJlIHZhbGlkIGFmdGVyIHVwZGF0ZSgpXG4gKiBAcHJvcCB7bnVtYmVyfSBsZWZ0IC0gTGVmdCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSB0b3AgLSBUb3AgZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuICogQHByb3Age251bWJlcn0gcmlnaHQgLSBSaWdodCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSBib3R0b20gLSBCb3R0b20gZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuICovXG5cbi8vIFRoZSBsYXlvdXQgc2VydmljZSBpcyB2ZXJ5IHNlbGYgZXhwbGFuYXRvcnkuICBJdCdzIHJlc3BvbnNpYmxlIGZvciB0aGUgbGF5b3V0IHdpdGhpbiBhIGNoYXJ0LlxuLy8gU2NhbGVzLCBMZWdlbmRzIGFuZCBQbHVnaW5zIGFsbCByZWx5IG9uIHRoZSBsYXlvdXQgc2VydmljZSBhbmQgY2FuIGVhc2lseSByZWdpc3RlciB0byBiZSBwbGFjZWQgYW55d2hlcmUgdGhleSBuZWVkXG4vLyBJdCBpcyB0aGlzIHNlcnZpY2UncyByZXNwb25zaWJpbGl0eSBvZiBjYXJyeWluZyBvdXQgdGhhdCBsYXlvdXQuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgLyoqXG5cdCAqIFJlZ2lzdGVyIGEgYm94IHRvIGEgY2hhcnQuXG5cdCAqIEEgYm94IGlzIHNpbXBseSBhIHJlZmVyZW5jZSB0byBhbiBvYmplY3QgdGhhdCByZXF1aXJlcyBsYXlvdXQuIGVnLiBTY2FsZXMsIExlZ2VuZCwgVGl0bGUuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIHVzZVxuXHQgKiBAcGFyYW0ge0xheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBhZGQgdG8gYmUgbGFpZCBvdXRcblx0ICovXG4gIGFkZEJveChjaGFydCwgaXRlbSkge1xuICAgIGlmICghY2hhcnQuYm94ZXMpIHtcbiAgICAgIGNoYXJ0LmJveGVzID0gW107XG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbGl6ZSBpdGVtIHdpdGggZGVmYXVsdCB2YWx1ZXNcbiAgICBpdGVtLmZ1bGxTaXplID0gaXRlbS5mdWxsU2l6ZSB8fCBmYWxzZTtcbiAgICBpdGVtLnBvc2l0aW9uID0gaXRlbS5wb3NpdGlvbiB8fCAndG9wJztcbiAgICBpdGVtLndlaWdodCA9IGl0ZW0ud2VpZ2h0IHx8IDA7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGl0ZW0uX2xheWVycyA9IGl0ZW0uX2xheWVycyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB6OiAwLFxuICAgICAgICBkcmF3KGNoYXJ0QXJlYSkge1xuICAgICAgICAgIGl0ZW0uZHJhdyhjaGFydEFyZWEpO1xuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9O1xuXG4gICAgY2hhcnQuYm94ZXMucHVzaChpdGVtKTtcbiAgfSxcblxuICAvKipcblx0ICogUmVtb3ZlIGEgbGF5b3V0SXRlbSBmcm9tIGEgY2hhcnRcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gcmVtb3ZlIHRoZSBib3ggZnJvbVxuXHQgKiBAcGFyYW0ge0xheW91dEl0ZW19IGxheW91dEl0ZW0gLSB0aGUgaXRlbSB0byByZW1vdmUgZnJvbSB0aGUgbGF5b3V0XG5cdCAqL1xuICByZW1vdmVCb3goY2hhcnQsIGxheW91dEl0ZW0pIHtcbiAgICBjb25zdCBpbmRleCA9IGNoYXJ0LmJveGVzID8gY2hhcnQuYm94ZXMuaW5kZXhPZihsYXlvdXRJdGVtKSA6IC0xO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGNoYXJ0LmJveGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuXHQgKiBTZXRzIChvciB1cGRhdGVzKSBvcHRpb25zIG9uIHRoZSBnaXZlbiBgaXRlbWAuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IGluIHdoaWNoIHRoZSBpdGVtIGxpdmVzIChvciB3aWxsIGJlIGFkZGVkIHRvKVxuXHQgKiBAcGFyYW0ge0xheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBjb25maWd1cmUgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIHRoZSBuZXcgaXRlbSBvcHRpb25zLlxuXHQgKi9cbiAgY29uZmlndXJlKGNoYXJ0LCBpdGVtLCBvcHRpb25zKSB7XG4gICAgaXRlbS5mdWxsU2l6ZSA9IG9wdGlvbnMuZnVsbFNpemU7XG4gICAgaXRlbS5wb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XG4gICAgaXRlbS53ZWlnaHQgPSBvcHRpb25zLndlaWdodDtcbiAgfSxcblxuICAvKipcblx0ICogRml0cyBib3hlcyBvZiB0aGUgZ2l2ZW4gY2hhcnQgaW50byB0aGUgZ2l2ZW4gc2l6ZSBieSBoYXZpbmcgZWFjaCBib3ggbWVhc3VyZSBpdHNlbGZcblx0ICogdGhlbiBydW5uaW5nIGEgZml0dGluZyBhbGdvcml0aG1cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gdGhlIHdpZHRoIHRvIGZpdCBpbnRvXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IHRvIGZpdCBpbnRvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5QYWRkaW5nIC0gbWluaW11bSBwYWRkaW5nIHJlcXVpcmVkIGZvciBlYWNoIHNpZGUgb2YgY2hhcnQgYXJlYVxuXHQgKi9cbiAgdXBkYXRlKGNoYXJ0LCB3aWR0aCwgaGVpZ2h0LCBtaW5QYWRkaW5nKSB7XG4gICAgaWYgKCFjaGFydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcoY2hhcnQub3B0aW9ucy5sYXlvdXQucGFkZGluZyk7XG4gICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSBNYXRoLm1heCh3aWR0aCAtIHBhZGRpbmcud2lkdGgsIDApO1xuICAgIGNvbnN0IGF2YWlsYWJsZUhlaWdodCA9IE1hdGgubWF4KGhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0LCAwKTtcbiAgICBjb25zdCBib3hlcyA9IGJ1aWxkTGF5b3V0Qm94ZXMoY2hhcnQuYm94ZXMpO1xuICAgIGNvbnN0IHZlcnRpY2FsQm94ZXMgPSBib3hlcy52ZXJ0aWNhbDtcbiAgICBjb25zdCBob3Jpem9udGFsQm94ZXMgPSBib3hlcy5ob3Jpem9udGFsO1xuXG4gICAgLy8gQmVmb3JlIGFueSBjaGFuZ2VzIGFyZSBtYWRlLCBub3RpZnkgYm94ZXMgdGhhdCBhbiB1cGRhdGUgaXMgYWJvdXQgdG8gYmVpbmdcbiAgICAvLyBUaGlzIGlzIHVzZWQgdG8gY2xlYXIgYW55IGNhY2hlZCBkYXRhIChlLmcuIHNjYWxlIGxpbWl0cylcbiAgICBlYWNoKGNoYXJ0LmJveGVzLCBib3ggPT4ge1xuICAgICAgaWYgKHR5cGVvZiBib3guYmVmb3JlTGF5b3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGJveC5iZWZvcmVMYXlvdXQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEVzc2VudGlhbGx5IHdlIG5vdyBoYXZlIGFueSBudW1iZXIgb2YgYm94ZXMgb24gZWFjaCBvZiB0aGUgNCBzaWRlcy5cbiAgICAvLyBPdXIgY2FudmFzIGxvb2tzIGxpa2UgdGhlIGZvbGxvd2luZy5cbiAgICAvLyBUaGUgYXJlYXMgTDEgYW5kIEwyIGFyZSB0aGUgbGVmdCBheGVzLiBSMSBpcyB0aGUgcmlnaHQgYXhpcywgVDEgaXMgdGhlIHRvcCBheGlzIGFuZFxuICAgIC8vIEIxIGlzIHRoZSBib3R0b20gYXhpc1xuICAgIC8vIFRoZXJlIGFyZSBhbHNvIDQgcXVhZHJhbnQtbGlrZSBsb2NhdGlvbnMgKGxlZnQgdG8gcmlnaHQgaW5zdGVhZCBvZiBjbG9ja3dpc2UpIHJlc2VydmVkIGZvciBjaGFydCBvdmVybGF5c1xuICAgIC8vIFRoZXNlIGxvY2F0aW9ucyBhcmUgc2luZ2xlLWJveCBsb2NhdGlvbnMgb25seSwgd2hlbiB0cnlpbmcgdG8gcmVnaXN0ZXIgYSBjaGFydEFyZWEgbG9jYXRpb24gdGhhdCBpcyBhbHJlYWR5IHRha2VuLFxuICAgIC8vIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgIC8vXG4gICAgLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gfCAgICAgICAgICAgICAgICAgIFQxIChGdWxsIFdpZHRoKSAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgIFQyICAgICAgICAgICAgICAgICAgfCAgICB8XG4gICAgLy8gfCAgICB8LS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS18XG4gICAgLy8gfCAgICB8ICAgIHwgQzEgfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQzIgfCAgICB8XG4gICAgLy8gfCAgICB8ICAgIHwtLS0tfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtLS0tfCAgICB8XG4gICAgLy8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8XG4gICAgLy8gfCBMMSB8IEwyIHwgICAgICAgICAgIENoYXJ0QXJlYSAoQzApICAgICAgICAgICAgfCBSMSB8XG4gICAgLy8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8XG4gICAgLy8gfCAgICB8ICAgIHwtLS0tfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtLS0tfCAgICB8XG4gICAgLy8gfCAgICB8ICAgIHwgQzMgfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQzQgfCAgICB8XG4gICAgLy8gfCAgICB8LS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS18XG4gICAgLy8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgIEIxICAgICAgICAgICAgICAgICAgfCAgICB8XG4gICAgLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gfCAgICAgICAgICAgICAgICAgIEIyIChGdWxsIFdpZHRoKSAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgLy9cblxuICAgIGNvbnN0IHZpc2libGVWZXJ0aWNhbEJveENvdW50ID0gdmVydGljYWxCb3hlcy5yZWR1Y2UoKHRvdGFsLCB3cmFwKSA9PlxuICAgICAgd3JhcC5ib3gub3B0aW9ucyAmJiB3cmFwLmJveC5vcHRpb25zLmRpc3BsYXkgPT09IGZhbHNlID8gdG90YWwgOiB0b3RhbCArIDEsIDApIHx8IDE7XG5cbiAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgIG91dGVyV2lkdGg6IHdpZHRoLFxuICAgICAgb3V0ZXJIZWlnaHQ6IGhlaWdodCxcbiAgICAgIHBhZGRpbmcsXG4gICAgICBhdmFpbGFibGVXaWR0aCxcbiAgICAgIGF2YWlsYWJsZUhlaWdodCxcbiAgICAgIHZCb3hNYXhXaWR0aDogYXZhaWxhYmxlV2lkdGggLyAyIC8gdmlzaWJsZVZlcnRpY2FsQm94Q291bnQsXG4gICAgICBoQm94TWF4SGVpZ2h0OiBhdmFpbGFibGVIZWlnaHQgLyAyXG4gICAgfSk7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IE9iamVjdC5hc3NpZ24oe30sIHBhZGRpbmcpO1xuICAgIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgdG9QYWRkaW5nKG1pblBhZGRpbmcpKTtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIG1heFBhZGRpbmcsXG4gICAgICB3OiBhdmFpbGFibGVXaWR0aCxcbiAgICAgIGg6IGF2YWlsYWJsZUhlaWdodCxcbiAgICAgIHg6IHBhZGRpbmcubGVmdCxcbiAgICAgIHk6IHBhZGRpbmcudG9wXG4gICAgfSwgcGFkZGluZyk7XG5cbiAgICBjb25zdCBzdGFja3MgPSBzZXRMYXlvdXREaW1zKHZlcnRpY2FsQm94ZXMuY29uY2F0KGhvcml6b250YWxCb3hlcyksIHBhcmFtcyk7XG5cbiAgICAvLyBGaXJzdCBmaXQgdGhlIGZ1bGxTaXplIGJveGVzLCB0byByZWR1Y2UgcHJvYmFiaWxpdHkgb2YgcmUtZml0dGluZy5cbiAgICBmaXRCb3hlcyhib3hlcy5mdWxsU2l6ZSwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG5cbiAgICAvLyBUaGVuIGZpdCB2ZXJ0aWNhbCBib3hlc1xuICAgIGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuXG4gICAgLy8gVGhlbiBmaXQgaG9yaXpvbnRhbCBib3hlc1xuICAgIGlmIChmaXRCb3hlcyhob3Jpem9udGFsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpKSB7XG4gICAgICAvLyBpZiB0aGUgYXJlYSBjaGFuZ2VkLCByZS1maXQgdmVydGljYWwgYm94ZXNcbiAgICAgIGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIH1cblxuICAgIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKTtcblxuICAgIC8vIEZpbmFsbHkgcGxhY2UgdGhlIGJveGVzIHRvIGNvcnJlY3QgY29vcmRpbmF0ZXNcbiAgICBwbGFjZUJveGVzKGJveGVzLmxlZnRBbmRUb3AsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuXG4gICAgLy8gTW92ZSB0byBvcHBvc2l0ZSBzaWRlIG9mIGNoYXJ0XG4gICAgY2hhcnRBcmVhLnggKz0gY2hhcnRBcmVhLnc7XG4gICAgY2hhcnRBcmVhLnkgKz0gY2hhcnRBcmVhLmg7XG5cbiAgICBwbGFjZUJveGVzKGJveGVzLnJpZ2h0QW5kQm90dG9tLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcblxuICAgIGNoYXJ0LmNoYXJ0QXJlYSA9IHtcbiAgICAgIGxlZnQ6IGNoYXJ0QXJlYS5sZWZ0LFxuICAgICAgdG9wOiBjaGFydEFyZWEudG9wLFxuICAgICAgcmlnaHQ6IGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLncsXG4gICAgICBib3R0b206IGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuaCxcbiAgICAgIGhlaWdodDogY2hhcnRBcmVhLmgsXG4gICAgICB3aWR0aDogY2hhcnRBcmVhLncsXG4gICAgfTtcblxuICAgIC8vIEZpbmFsbHkgdXBkYXRlIGJveGVzIGluIGNoYXJ0QXJlYSAocmFkaWFsIHNjYWxlIGZvciBleGFtcGxlKVxuICAgIGVhY2goYm94ZXMuY2hhcnRBcmVhLCAobGF5b3V0KSA9PiB7XG4gICAgICBjb25zdCBib3ggPSBsYXlvdXQuYm94O1xuICAgICAgT2JqZWN0LmFzc2lnbihib3gsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gICAgICBib3gudXBkYXRlKGNoYXJ0QXJlYS53LCBjaGFydEFyZWEuaCwge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMH0pO1xuICAgIH0pO1xuICB9XG59O1xuIiwgIlxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHRoYXQgYWxsb3dzIGFic3RyYWN0aW5nIHBsYXRmb3JtIGRlcGVuZGVuY2llcyBhd2F5IGZyb20gdGhlIGNoYXJ0LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlUGxhdGZvcm0ge1xuICAvKipcblx0ICogQ2FsbGVkIGF0IGNoYXJ0IGNvbnN0cnVjdGlvbiB0aW1lLCByZXR1cm5zIGEgY29udGV4dDJkIGluc3RhbmNlIGltcGxlbWVudGluZ1xuXHQgKiB0aGUgW1czQyBDYW52YXMgMkQgQ29udGV4dCBBUEkgc3RhbmRhcmRde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yZGNvbnRleHQvfS5cblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gVGhlIGNhbnZhcyBmcm9tIHdoaWNoIHRvIGFjcXVpcmUgY29udGV4dCAocGxhdGZvcm0gc3BlY2lmaWMpXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dIC0gVGhlIGNoYXJ0IG9wdGlvbnNcblx0ICovXG4gIGFjcXVpcmVDb250ZXh0KGNhbnZhcywgYXNwZWN0UmF0aW8pIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcblx0ICogQ2FsbGVkIGF0IGNoYXJ0IGRlc3RydWN0aW9uIHRpbWUsIHJlbGVhc2VzIGFueSByZXNvdXJjZXMgYXNzb2NpYXRlZCB0byB0aGUgY29udGV4dFxuXHQgKiBwcmV2aW91c2x5IHJldHVybmVkIGJ5IHRoZSBhY3F1aXJlQ29udGV4dCgpIG1ldGhvZC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY29udGV4dDJkIGluc3RhbmNlXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBtZXRob2Qgc3VjY2VlZGVkLCBlbHNlIGZhbHNlXG5cdCAqL1xuICByZWxlYXNlQ29udGV4dChjb250ZXh0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcblx0ICogUmVnaXN0ZXJzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgb24gdGhlIGdpdmVuIGNoYXJ0LlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gbGlzdGVuIGZvciBldmVudFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSAoe0BsaW5rIENoYXJ0RXZlbnR9KSB0eXBlIHRvIGxpc3RlbiBmb3Jcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBSZWNlaXZlcyBhIG5vdGlmaWNhdGlvbiAoYW4gb2JqZWN0IHRoYXQgaW1wbGVtZW50c1xuXHQgKiB0aGUge0BsaW5rIENoYXJ0RXZlbnR9IGludGVyZmFjZSkgd2hlbiBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb2NjdXJzLlxuXHQgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcblx0ICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIGFkZEV2ZW50TGlzdGVuZXIuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gQ2hhcnQgZnJvbSB3aGljaCB0byByZW1vdmUgdGhlIGxpc3RlbmVyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlICh7QGxpbmsgQ2hhcnRFdmVudH0pIHR5cGUgdG8gcmVtb3ZlXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHJlbW92ZSBmcm9tIHRoZSBldmVudCB0YXJnZXQuXG5cdCAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgY3VycmVudCBkZXZpY2VQaXhlbFJhdGlvIG9mIHRoZSBkZXZpY2UgdGhpcyBwbGF0Zm9ybSBpcyBjb25uZWN0ZWQgdG8uXG5cdCAqL1xuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIG1heGltdW0gc2l6ZSBpbiBwaXhlbHMgb2YgZ2l2ZW4gY2FudmFzIGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGVsZW1lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gLSBjb250ZW50IHdpZHRoIG9mIHBhcmVudCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XSAtIGNvbnRlbnQgaGVpZ2h0IG9mIHBhcmVudCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dIC0gYXNwZWN0IHJhdGlvIHRvIG1haW50YWluXG5cdCAqL1xuICBnZXRNYXhpbXVtU2l6ZShlbGVtZW50LCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICAgIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggfHwgZWxlbWVudC53aWR0aCk7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IGVsZW1lbnQuaGVpZ2h0O1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodDogTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyBNYXRoLmZsb29yKHdpZHRoIC8gYXNwZWN0UmF0aW8pIDogaGVpZ2h0KVxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBjYW52YXMgaXMgYXR0YWNoZWQgdG8gdGhlIHBsYXRmb3JtLCBmYWxzZSBpZiBub3QuXG5cdCAqL1xuICBpc0F0dGFjaGVkKGNhbnZhcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBjb25maWcgd2l0aCBwbGF0Zm9ybSBzcGVjaWZpYyByZXF1aXJlbWVudHNcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uL2NvcmUvY29yZS5jb25maWcuanMnKS5kZWZhdWx0fSBjb25maWdcbiAgICovXG4gIHVwZGF0ZUNvbmZpZyhjb25maWcpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIC8vIG5vLW9wXG4gIH1cbn1cbiIsICIvKipcbiAqIFBsYXRmb3JtIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIChtaW5pbWFsKS5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTkxI2lzc3VlY29tbWVudC0zMTk1NzU5MzlcbiAqL1xuXG5pbXBvcnQgQmFzZVBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uYmFzZS5qcyc7XG5cbi8qKlxuICogUGxhdGZvcm0gY2xhc3MgZm9yIGNoYXJ0cyB3aXRob3V0IGFjY2VzcyB0byB0aGUgRE9NIG9yIHRvIG1hbnkgZWxlbWVudCBwcm9wZXJ0aWVzXG4gKiBUaGlzIHBsYXRmb3JtIGlzIHVzZWQgYnkgZGVmYXVsdCBmb3IgYW55IGNoYXJ0IHBhc3NlZCBhbiBPZmZzY3JlZW5DYW52YXMuXG4gKiBAZXh0ZW5kcyBCYXNlUGxhdGZvcm1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzaWNQbGF0Zm9ybSBleHRlbmRzIEJhc2VQbGF0Zm9ybSB7XG4gIGFjcXVpcmVDb250ZXh0KGl0ZW0pIHtcbiAgICAvLyBUbyBwcmV2ZW50IGNhbnZhcyBmaW5nZXJwcmludGluZywgc29tZSBhZGQtb25zIHVuZGVmaW5lIHRoZSBnZXRDb250ZXh0XG4gICAgLy8gbWV0aG9kLCBmb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL2trYXBzbmVyL0NhbnZhc0Jsb2NrZXJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xuICAgIHJldHVybiBpdGVtICYmIGl0ZW0uZ2V0Q29udGV4dCAmJiBpdGVtLmdldENvbnRleHQoJzJkJykgfHwgbnVsbDtcbiAgfVxuICB1cGRhdGVDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnLm9wdGlvbnMuYW5pbWF0aW9uID0gZmFsc2U7XG4gIH1cbn1cbiIsICIvKipcbiAqIENoYXJ0LlBsYXRmb3JtIGltcGxlbWVudGF0aW9uIGZvciB0YXJnZXRpbmcgYSB3ZWIgYnJvd3NlclxuICovXG5cbmltcG9ydCBCYXNlUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybS5iYXNlLmpzJztcbmltcG9ydCB7X2dldFBhcmVudE5vZGUsIGdldFJlbGF0aXZlUG9zaXRpb24sIHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMsIHJlYWRVc2VkU2l6ZSwgZ2V0TWF4aW11bVNpemV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5kb20uanMnO1xuaW1wb3J0IHt0aHJvdHRsZWR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuaW1wb3J0IHtpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuY29uc3QgRVhQQU5ET19LRVkgPSAnJGNoYXJ0anMnO1xuXG4vKipcbiAqIERPTSBldmVudCB0eXBlcyAtPiBDaGFydC5qcyBldmVudCB0eXBlcy5cbiAqIE5vdGU6IG9ubHkgZXZlbnRzIHdpdGggZGlmZmVyZW50IHR5cGVzIGFyZSBtYXBwZWQuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50c1xuICovXG5jb25zdCBFVkVOVF9UWVBFUyA9IHtcbiAgdG91Y2hzdGFydDogJ21vdXNlZG93bicsXG4gIHRvdWNobW92ZTogJ21vdXNlbW92ZScsXG4gIHRvdWNoZW5kOiAnbW91c2V1cCcsXG4gIHBvaW50ZXJlbnRlcjogJ21vdXNlZW50ZXInLFxuICBwb2ludGVyZG93bjogJ21vdXNlZG93bicsXG4gIHBvaW50ZXJtb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgcG9pbnRlcnVwOiAnbW91c2V1cCcsXG4gIHBvaW50ZXJsZWF2ZTogJ21vdXNlb3V0JyxcbiAgcG9pbnRlcm91dDogJ21vdXNlb3V0J1xufTtcblxuY29uc3QgaXNOdWxsT3JFbXB0eSA9IHZhbHVlID0+IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJztcbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNhbnZhcyBzdHlsZSBhbmQgcmVuZGVyIHNpemUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIGNhbnZhcyBkaXNwbGF5IHNpemUsXG4gKiBzaW5jZSByZXNwb25zaXZlbmVzcyBpcyBoYW5kbGVkIGJ5IHRoZSBjb250cm9sbGVyLnJlc2l6ZSgpIG1ldGhvZC4gVGhlIGNvbmZpZyBpcyB1c2VkXG4gKiB0byBkZXRlcm1pbmUgdGhlIGFzcGVjdCByYXRpbyB0byBhcHBseSBpbiBjYXNlIG5vIGV4cGxpY2l0IGhlaWdodCBoYXMgYmVlbiBzcGVjaWZpZWQuXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dXG4gKi9cbmZ1bmN0aW9uIGluaXRDYW52YXMoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICBjb25zdCBzdHlsZSA9IGNhbnZhcy5zdHlsZTtcblxuICAvLyBOT1RFKFNCKSBjYW52YXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpICE9PSBjYW52YXMud2lkdGg6IGluIHRoZSBmaXJzdCBjYXNlIGl0XG4gIC8vIHJldHVybnMgbnVsbCBvciAnJyBpZiBubyBleHBsaWNpdCB2YWx1ZSBoYXMgYmVlbiBzZXQgdG8gdGhlIGNhbnZhcyBhdHRyaWJ1dGUuXG4gIGNvbnN0IHJlbmRlckhlaWdodCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuICBjb25zdCByZW5kZXJXaWR0aCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG5cbiAgLy8gQ2hhcnQuanMgbW9kaWZpZXMgc29tZSBjYW52YXMgdmFsdWVzIHRoYXQgd2Ugd2FudCB0byByZXN0b3JlIG9uIGRlc3Ryb3lcbiAgY2FudmFzW0VYUEFORE9fS0VZXSA9IHtcbiAgICBpbml0aWFsOiB7XG4gICAgICBoZWlnaHQ6IHJlbmRlckhlaWdodCxcbiAgICAgIHdpZHRoOiByZW5kZXJXaWR0aCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IHN0eWxlLmRpc3BsYXksXG4gICAgICAgIGhlaWdodDogc3R5bGUuaGVpZ2h0LFxuICAgICAgICB3aWR0aDogc3R5bGUud2lkdGhcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gRm9yY2UgY2FudmFzIHRvIGRpc3BsYXkgYXMgYmxvY2sgdG8gYXZvaWQgZXh0cmEgc3BhY2UgY2F1c2VkIGJ5IGlubGluZVxuICAvLyBlbGVtZW50cywgd2hpY2ggd291bGQgaW50ZXJmZXJlIHdpdGggdGhlIHJlc3BvbnNpdmUgcmVzaXplIHByb2Nlc3MuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yNTM4XG4gIHN0eWxlLmRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5IHx8ICdibG9jayc7XG4gIC8vIEluY2x1ZGUgcG9zc2libGUgYm9yZGVycyBpbiB0aGUgc2l6ZVxuICBzdHlsZS5ib3hTaXppbmcgPSBzdHlsZS5ib3hTaXppbmcgfHwgJ2JvcmRlci1ib3gnO1xuXG4gIGlmIChpc051bGxPckVtcHR5KHJlbmRlcldpZHRoKSkge1xuICAgIGNvbnN0IGRpc3BsYXlXaWR0aCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICd3aWR0aCcpO1xuICAgIGlmIChkaXNwbGF5V2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FudmFzLndpZHRoID0gZGlzcGxheVdpZHRoO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc051bGxPckVtcHR5KHJlbmRlckhlaWdodCkpIHtcbiAgICBpZiAoY2FudmFzLnN0eWxlLmhlaWdodCA9PT0gJycpIHtcbiAgICAgIC8vIElmIG5vIGV4cGxpY2l0IHJlbmRlciBoZWlnaHQgYW5kIHN0eWxlIGhlaWdodCwgbGV0J3MgYXBwbHkgdGhlIGFzcGVjdCByYXRpbyxcbiAgICAgIC8vIHdoaWNoIG9uZSBjYW4gYmUgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIGJ1dCBhbHNvIGJ5IGNoYXJ0cyBhcyBkZWZhdWx0IG9wdGlvblxuICAgICAgLy8gKGkuZS4gb3B0aW9ucy5hc3BlY3RSYXRpbykuIElmIG5vdCBzcGVjaWZpZWQsIHVzZSBjYW52YXMgYXNwZWN0IHJhdGlvIG9mIDIuXG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLndpZHRoIC8gKGFzcGVjdFJhdGlvIHx8IDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkaXNwbGF5SGVpZ2h0ID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ2hlaWdodCcpO1xuICAgICAgaWYgKGRpc3BsYXlIZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gZGlzcGxheUhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FudmFzO1xufVxuXG4vLyBEZWZhdWx0IHBhc3NpdmUgdG8gdHJ1ZSBhcyBleHBlY3RlZCBieSBDaHJvbWUgZm9yICd0b3VjaHN0YXJ0JyBhbmQgJ3RvdWNoZW5kJyBldmVudHMuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDI4N1xuY29uc3QgZXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG5cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmIChub2RlKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmIChjaGFydCAmJiBjaGFydC5jYW52YXMpIHtcbiAgICBjaGFydC5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpIHtcbiAgY29uc3QgdHlwZSA9IEVWRU5UX1RZUEVTW2V2ZW50LnR5cGVdIHx8IGV2ZW50LnR5cGU7XG4gIGNvbnN0IHt4LCB5fSA9IGdldFJlbGF0aXZlUG9zaXRpb24oZXZlbnQsIGNoYXJ0KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIGNoYXJ0LFxuICAgIG5hdGl2ZTogZXZlbnQsXG4gICAgeDogeCAhPT0gdW5kZWZpbmVkID8geCA6IG51bGwsXG4gICAgeTogeSAhPT0gdW5kZWZpbmVkID8geSA6IG51bGwsXG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vZGVMaXN0Q29udGFpbnMobm9kZUxpc3QsIGNhbnZhcykge1xuICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZUxpc3QpIHtcbiAgICBpZiAobm9kZSA9PT0gY2FudmFzIHx8IG5vZGUuY29udGFpbnMoY2FudmFzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUF0dGFjaE9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgbGV0IHRyaWdnZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyIHx8IG5vZGVMaXN0Q29udGFpbnMoZW50cnkuYWRkZWROb2RlcywgY2FudmFzKTtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyICYmICFub2RlTGlzdENvbnRhaW5zKGVudHJ5LnJlbW92ZWROb2RlcywgY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURldGFjaE9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgbGV0IHRyaWdnZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyIHx8IG5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkuYWRkZWROb2RlcywgY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5cbmNvbnN0IGRycExpc3RlbmluZ0NoYXJ0cyA9IG5ldyBNYXAoKTtcbmxldCBvbGREZXZpY2VQaXhlbFJhdGlvID0gMDtcblxuZnVuY3Rpb24gb25XaW5kb3dSZXNpemUoKSB7XG4gIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICBpZiAoZHByID09PSBvbGREZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG9sZERldmljZVBpeGVsUmF0aW8gPSBkcHI7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5mb3JFYWNoKChyZXNpemUsIGNoYXJ0KSA9PiB7XG4gICAgaWYgKGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBkcHIpIHtcbiAgICAgIHJlc2l6ZSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpIHtcbiAgaWYgKCFkcnBMaXN0ZW5pbmdDaGFydHMuc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG4gIH1cbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLnNldChjaGFydCwgcmVzaXplKTtcbn1cblxuZnVuY3Rpb24gdW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCkge1xuICBkcnBMaXN0ZW5pbmdDaGFydHMuZGVsZXRlKGNoYXJ0KTtcbiAgaWYgKCFkcnBMaXN0ZW5pbmdDaGFydHMuc2l6ZSkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVzaXplT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3QgY29udGFpbmVyID0gY2FudmFzICYmIF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlc2l6ZSA9IHRocm90dGxlZCgod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHcgPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgbGlzdGVuZXIod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKHcgPCBjb250YWluZXIuY2xpZW50V2lkdGgpIHtcbiAgICAgIC8vIElmIHRoZSBjb250YWluZXIgc2l6ZSBzaHJhbmsgZHVyaW5nIGNoYXJ0IHJlc2l6ZSwgbGV0J3MgYXNzdW1lXG4gICAgICAvLyBzY3JvbGxiYXIgYXBwZWFyZWQuIFNvIHdlIHJlc2l6ZSBhZ2FpbiB3aXRoIHRoZSBzY3JvbGxiYXIgdmlzaWJsZSAtXG4gICAgICAvLyBlZmZlY3RpdmVseSBtYWtpbmcgY2hhcnQgc21hbGxlciBhbmQgdGhlIHNjcm9sbGJhciBoaWRkZW4gYWdhaW4uXG4gICAgICAvLyBCZWNhdXNlIHdlIGFyZSBpbnNpZGUgYHRocm90dGxlZGAsIGFuZCBjdXJyZW50bHkgYHRpY2tpbmdgLCBzY3JvbGxcbiAgICAgIC8vIGV2ZW50cyBhcmUgaWdub3JlZCBkdXJpbmcgdGhpcyB3aG9sZSAyIHJlc2l6ZSBwcm9jZXNzLlxuICAgICAgLy8gSWYgd2UgYXNzdW1lZCB3cm9uZyBhbmQgc29tZXRoaW5nIGVsc2UgaGFwcGVuZWQsIHdlIGFyZSByZXNpemluZ1xuICAgICAgLy8gdHdpY2UgaW4gYSBmcmFtZSAocG90ZW50aWFsIHBlcmZvcm1hbmNlIGlzc3VlKVxuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0sIHdpbmRvdyk7XG5cbiAgLy8gQHRzLWlnbm9yZSB1bnRpbCBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzM3ODYxIGltcGxlbWVudGVkXG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1swXTtcbiAgICBjb25zdCB3aWR0aCA9IGVudHJ5LmNvbnRlbnRSZWN0LndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGVudHJ5LmNvbnRlbnRSZWN0LmhlaWdodDtcbiAgICAvLyBXaGVuIGl0cyBjb250YWluZXIncyBkaXNwbGF5IGlzIHNldCB0byAnbm9uZScgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggYVxuICAgIC8vIHNpemUgb2YgKDAsIDApLCB3aGljaCB3aWxsIGNhdXNlIHRoZSBjaGFydCB0byBsb3NlIGl0cyBvcmlnaW5hbCBoZWlnaHQsIHNvIHNraXBcbiAgICAvLyByZXNpemluZyBpbiBzdWNoIGNhc2UuXG4gICAgaWYgKHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXNpemUod2lkdGgsIGhlaWdodCk7XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lcik7XG4gIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpO1xuXG4gIHJldHVybiBvYnNlcnZlcjtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZU9ic2VydmVyKGNoYXJ0LCB0eXBlLCBvYnNlcnZlcikge1xuICBpZiAob2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdyZXNpemUnKSB7XG4gICAgdW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJveHlBbmRMaXN0ZW4oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3QgcHJveHkgPSB0aHJvdHRsZWQoKGV2ZW50KSA9PiB7XG4gICAgLy8gVGhpcyBjYXNlIGNhbiBvY2N1ciBpZiB0aGUgY2hhcnQgaXMgZGVzdHJveWVkIHdoaWxlIHdhaXRpbmdcbiAgICAvLyBmb3IgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB0byBvY2N1ci4gV2UgcHJldmVudCBjcmFzaGVzIGJ5IGNoZWNraW5nXG4gICAgLy8gZm9yIGEgZGVzdHJveWVkIGNoYXJ0XG4gICAgaWYgKGNoYXJ0LmN0eCAhPT0gbnVsbCkge1xuICAgICAgbGlzdGVuZXIoZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkpO1xuICAgIH1cbiAgfSwgY2hhcnQpO1xuXG4gIGFkZExpc3RlbmVyKGNhbnZhcywgdHlwZSwgcHJveHkpO1xuXG4gIHJldHVybiBwcm94eTtcbn1cblxuLyoqXG4gKiBQbGF0Zm9ybSBjbGFzcyBmb3IgY2hhcnRzIHRoYXQgY2FuIGFjY2VzcyB0aGUgRE9NIGFuZCBnbG9iYWwgd2luZG93L2RvY3VtZW50IHByb3BlcnRpZXNcbiAqIEBleHRlbmRzIEJhc2VQbGF0Zm9ybVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb21QbGF0Zm9ybSBleHRlbmRzIEJhc2VQbGF0Zm9ybSB7XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FzcGVjdFJhdGlvXVxuXHQgKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8bnVsbH1cblx0ICovXG4gIGFjcXVpcmVDb250ZXh0KGNhbnZhcywgYXNwZWN0UmF0aW8pIHtcbiAgICAvLyBUbyBwcmV2ZW50IGNhbnZhcyBmaW5nZXJwcmludGluZywgc29tZSBhZGQtb25zIHVuZGVmaW5lIHRoZSBnZXRDb250ZXh0XG4gICAgLy8gbWV0aG9kLCBmb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL2trYXBzbmVyL0NhbnZhc0Jsb2NrZXJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQgJiYgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAvLyBgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudC9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkRgIGZhaWxzIHdoZW4gdGhlIGNhbnZhcyBpc1xuICAgIC8vIGluc2lkZSBhbiBpZnJhbWUgb3Igd2hlbiBydW5uaW5nIGluIGEgcHJvdGVjdGVkIGVudmlyb25tZW50LiBXZSBjb3VsZCBndWVzcyB0aGVcbiAgICAvLyB0eXBlcyBmcm9tIHRoZWlyIHRvU3RyaW5nKCkgdmFsdWUgYnV0IGxldCdzIGtlZXAgdGhpbmdzIGZsZXhpYmxlIGFuZCBhc3N1bWUgaXQnc1xuICAgIC8vIGEgc3VmZmljaWVudCBjb25kaXRpb24gaWYgdGhlIGNhbnZhcyBoYXMgYSBjb250ZXh0MkQgd2hpY2ggaGFzIGNhbnZhcyBhcyBgY2FudmFzYC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzg4N1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80MTAyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxNTJcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcyA9PT0gY2FudmFzKSB7XG4gICAgICAvLyBMb2FkIHBsYXRmb3JtIHJlc291cmNlcyBvbiBmaXJzdCBjaGFydCBjcmVhdGlvbiwgdG8gbWFrZSBpdCBwb3NzaWJsZSB0b1xuICAgICAgLy8gaW1wb3J0IHRoZSBsaWJyYXJ5IGJlZm9yZSBzZXR0aW5nIHBsYXRmb3JtIG9wdGlvbnMuXG4gICAgICBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pO1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHRcblx0ICovXG4gIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICBpZiAoIWNhbnZhc1tFWFBBTkRPX0tFWV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBpbml0aWFsID0gY2FudmFzW0VYUEFORE9fS0VZXS5pbml0aWFsO1xuICAgIFsnaGVpZ2h0JywgJ3dpZHRoJ10uZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBpbml0aWFsW3Byb3BdO1xuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKHByb3AsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHN0eWxlID0gaW5pdGlhbC5zdHlsZSB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjYW52YXMuc3R5bGVba2V5XSA9IHN0eWxlW2tleV07XG4gICAgfSk7XG5cbiAgICAvLyBUaGUgY2FudmFzIHJlbmRlciBzaXplIG1pZ2h0IGhhdmUgYmVlbiBjaGFuZ2VkIChhbmQgdGh1cyB0aGUgc3RhdGUgc3RhY2sgZGlzY2FyZGVkKSxcbiAgICAvLyB3ZSBjYW4ndCB1c2Ugc2F2ZSgpIGFuZCByZXN0b3JlKCkgdG8gcmVzdG9yZSB0aGUgaW5pdGlhbCBzdGF0ZS4gU28gbWFrZSBzdXJlIHRoYXQgYXRcbiAgICAvLyBsZWFzdCB0aGUgY2FudmFzIGNvbnRleHQgaXMgcmVzZXQgdG8gdGhlIGRlZmF1bHQgc3RhdGUgYnkgc2V0dGluZyB0aGUgY2FudmFzIHdpZHRoLlxuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDExL1dELWh0bWw1LTIwMTEwNTI1L3RoZS1jYW52YXMtZWxlbWVudC5odG1sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtYXNzaWduXG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuXG4gICAgZGVsZXRlIGNhbnZhc1tFWFBBTkRPX0tFWV07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcblx0ICpcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXJcblx0ICovXG4gIGFkZEV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgLy8gQ2FuIGhhdmUgb25seSBvbmUgbGlzdGVuZXIgcGVyIHR5cGUsIHNvIG1ha2Ugc3VyZSBwcmV2aW91cyBpcyByZW1vdmVkXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlKTtcblxuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICBhdHRhY2g6IGNyZWF0ZUF0dGFjaE9ic2VydmVyLFxuICAgICAgZGV0YWNoOiBjcmVhdGVEZXRhY2hPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogY3JlYXRlUmVzaXplT2JzZXJ2ZXJcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXSB8fCBjcmVhdGVQcm94eUFuZExpc3RlbjtcbiAgICBwcm94aWVzW3R5cGVdID0gaGFuZGxlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcblx0ICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpIHtcbiAgICBjb25zdCBwcm94aWVzID0gY2hhcnQuJHByb3hpZXMgfHwgKGNoYXJ0LiRwcm94aWVzID0ge30pO1xuICAgIGNvbnN0IHByb3h5ID0gcHJveGllc1t0eXBlXTtcblxuICAgIGlmICghcHJveHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGF0dGFjaDogcmVsZWFzZU9ic2VydmVyLFxuICAgICAgZGV0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICByZXNpemU6IHJlbGVhc2VPYnNlcnZlclxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IHJlbW92ZUxpc3RlbmVyO1xuICAgIGhhbmRsZXIoY2hhcnQsIHR5cGUsIHByb3h5KTtcbiAgICBwcm94aWVzW3R5cGVdID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdIC0gY29udGVudCB3aWR0aCBvZiBwYXJlbnQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodF0gLSBjb250ZW50IGhlaWdodCBvZiBwYXJlbnQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FzcGVjdFJhdGlvXSAtIGFzcGVjdCByYXRpbyB0byBtYWludGFpblxuXHQgKi9cbiAgZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICAgIHJldHVybiBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcblx0ICovXG4gIGlzQXR0YWNoZWQoY2FudmFzKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICByZXR1cm4gISEoY29udGFpbmVyICYmIGNvbnRhaW5lci5pc0Nvbm5lY3RlZCk7XG4gIH1cbn1cbiIsICJpbXBvcnQge19pc0RvbVN1cHBvcnRlZH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQgQmFzZVBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uYmFzZS5qcyc7XG5pbXBvcnQgQmFzaWNQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmJhc2ljLmpzJztcbmltcG9ydCBEb21QbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmRvbS5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBfZGV0ZWN0UGxhdGZvcm0oY2FudmFzKSB7XG4gIGlmICghX2lzRG9tU3VwcG9ydGVkKCkgfHwgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykpIHtcbiAgICByZXR1cm4gQmFzaWNQbGF0Zm9ybTtcbiAgfVxuICByZXR1cm4gRG9tUGxhdGZvcm07XG59XG5cbmV4cG9ydCB7QmFzZVBsYXRmb3JtLCBCYXNpY1BsYXRmb3JtLCBEb21QbGF0Zm9ybX07XG4iLCAiaW1wb3J0IHR5cGUge0FueU9iamVjdH0gZnJvbSAnLi4vdHlwZXMvYmFzaWMuanMnO1xuaW1wb3J0IHR5cGUge1BvaW50fSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuaW1wb3J0IHR5cGUge0FuaW1hdGlvbn0gZnJvbSAnLi4vdHlwZXMvYW5pbWF0aW9uLmpzJztcbmltcG9ydCB7aXNOdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWxlbWVudDxUID0gQW55T2JqZWN0LCBPID0gQW55T2JqZWN0PiB7XG5cbiAgc3RhdGljIGRlZmF1bHRzID0ge307XG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0gdW5kZWZpbmVkO1xuXG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xuICBhY3RpdmUgPSBmYWxzZTtcbiAgb3B0aW9uczogTztcbiAgJGFuaW1hdGlvbnM6IFJlY29yZDxrZXlvZiBULCBBbmltYXRpb24+O1xuXG4gIHRvb2x0aXBQb3NpdGlvbih1c2VGaW5hbFBvc2l0aW9uOiBib29sZWFuKTogUG9pbnQge1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHt4LCB5fSBhcyBQb2ludDtcbiAgfVxuXG4gIGhhc1ZhbHVlKCkge1xuICAgIHJldHVybiBpc051bWJlcih0aGlzLngpICYmIGlzTnVtYmVyKHRoaXMueSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBvciBmaW5hbCB2YWx1ZSBvZiBlYWNoIHByb3AuIENhbiByZXR1cm4gZXh0cmEgcHJvcGVydGllcyAod2hvbGUgb2JqZWN0KS5cbiAgICogQHBhcmFtIHByb3BzIC0gcHJvcGVydGllcyB0byBnZXRcbiAgICogQHBhcmFtIFtmaW5hbF0gLSBnZXQgdGhlIGZpbmFsIHZhbHVlIChhbmltYXRpb24gdGFyZ2V0KVxuICAgKi9cbiAgZ2V0UHJvcHM8UCBleHRlbmRzIChrZXlvZiBUKVtdPihwcm9wczogUCwgZmluYWw/OiBib29sZWFuKTogUGljazxULCBQW251bWJlcl0+O1xuICBnZXRQcm9wczxQIGV4dGVuZHMgc3RyaW5nPihwcm9wczogUFtdLCBmaW5hbD86IGJvb2xlYW4pOiBQYXJ0aWFsPFJlY29yZDxQLCB1bmtub3duPj47XG4gIGdldFByb3BzKHByb3BzOiBzdHJpbmdbXSwgZmluYWw/OiBib29sZWFuKTogUGFydGlhbDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4ge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICBpZiAoIWZpbmFsIHx8ICFhbmltcykge1xuICAgICAgLy8gbGV0J3Mgbm90IGNyZWF0ZSBhbiBvYmplY3QsIGlmIG5vdCBuZWVkZWRcbiAgICAgIHJldHVybiB0aGlzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgIH1cbiAgICBjb25zdCByZXQ6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307XG4gICAgcHJvcHMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgcmV0W3Byb3BdID0gYW5pbXNbcHJvcF0gJiYgYW5pbXNbcHJvcF0uYWN0aXZlKCkgPyBhbmltc1twcm9wXS5fdG8gOiB0aGlzW3Byb3AgYXMgc3RyaW5nXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG59XG4iLCAiaW1wb3J0IHtpc051bGxPclVuZGVmLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtfZmFjdG9yaXplfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHt7dmFsdWU6bnVtYmVyIHwgc3RyaW5nLCBsYWJlbD86c3RyaW5nLCBtYWpvcj86Ym9vbGVhbiwgJGNvbnRleHQ/OmFueX19IFRpY2tcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBzdWJzZXQgb2YgdGlja3MgdG8gYmUgcGxvdHRlZCB0byBhdm9pZCBvdmVybGFwcGluZyBsYWJlbHMuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdH0gc2NhbGVcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICogQHJldHVybiB7VGlja1tdfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF1dG9Ta2lwKHNjYWxlLCB0aWNrcykge1xuICBjb25zdCB0aWNrT3B0cyA9IHNjYWxlLm9wdGlvbnMudGlja3M7XG4gIGNvbnN0IGRldGVybWluZWRNYXhUaWNrcyA9IGRldGVybWluZU1heFRpY2tzKHNjYWxlKTtcbiAgY29uc3QgdGlja3NMaW1pdCA9IE1hdGgubWluKHRpY2tPcHRzLm1heFRpY2tzTGltaXQgfHwgZGV0ZXJtaW5lZE1heFRpY2tzLCBkZXRlcm1pbmVkTWF4VGlja3MpO1xuICBjb25zdCBtYWpvckluZGljZXMgPSB0aWNrT3B0cy5tYWpvci5lbmFibGVkID8gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSA6IFtdO1xuICBjb25zdCBudW1NYWpvckluZGljZXMgPSBtYWpvckluZGljZXMubGVuZ3RoO1xuICBjb25zdCBmaXJzdCA9IG1ham9ySW5kaWNlc1swXTtcbiAgY29uc3QgbGFzdCA9IG1ham9ySW5kaWNlc1tudW1NYWpvckluZGljZXMgLSAxXTtcbiAgY29uc3QgbmV3VGlja3MgPSBbXTtcblxuICAvLyBJZiB0aGVyZSBhcmUgdG9vIG1hbnkgbWFqb3IgdGlja3MgdG8gZGlzcGxheSB0aGVtIGFsbFxuICBpZiAobnVtTWFqb3JJbmRpY2VzID4gdGlja3NMaW1pdCkge1xuICAgIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIG51bU1ham9ySW5kaWNlcyAvIHRpY2tzTGltaXQpO1xuICAgIHJldHVybiBuZXdUaWNrcztcbiAgfVxuXG4gIGNvbnN0IHNwYWNpbmcgPSBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIHRpY2tzTGltaXQpO1xuXG4gIGlmIChudW1NYWpvckluZGljZXMgPiAwKSB7XG4gICAgbGV0IGksIGlsZW47XG4gICAgY29uc3QgYXZnTWFqb3JTcGFjaW5nID0gbnVtTWFqb3JJbmRpY2VzID4gMSA/IE1hdGgucm91bmQoKGxhc3QgLSBmaXJzdCkgLyAobnVtTWFqb3JJbmRpY2VzIC0gMSkpIDogbnVsbDtcbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gMCA6IGZpcnN0IC0gYXZnTWFqb3JTcGFjaW5nLCBmaXJzdCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG51bU1ham9ySW5kaWNlcyAtIDE7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvckluZGljZXNbaV0sIG1ham9ySW5kaWNlc1tpICsgMV0pO1xuICAgIH1cbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbGFzdCwgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gdGlja3MubGVuZ3RoIDogbGFzdCArIGF2Z01ham9yU3BhY2luZyk7XG4gICAgcmV0dXJuIG5ld1RpY2tzO1xuICB9XG4gIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nKTtcbiAgcmV0dXJuIG5ld1RpY2tzO1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVNYXhUaWNrcyhzY2FsZSkge1xuICBjb25zdCBvZmZzZXQgPSBzY2FsZS5vcHRpb25zLm9mZnNldDtcbiAgY29uc3QgdGlja0xlbmd0aCA9IHNjYWxlLl90aWNrU2l6ZSgpO1xuICBjb25zdCBtYXhTY2FsZSA9IHNjYWxlLl9sZW5ndGggLyB0aWNrTGVuZ3RoICsgKG9mZnNldCA/IDAgOiAxKTtcbiAgY29uc3QgbWF4Q2hhcnQgPSBzY2FsZS5fbWF4TGVuZ3RoIC8gdGlja0xlbmd0aDtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5taW4obWF4U2NhbGUsIG1heENoYXJ0KSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJbXX0gbWFqb3JJbmRpY2VzXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrc0xpbWl0XG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgdGlja3NMaW1pdCkge1xuICBjb25zdCBldmVuTWFqb3JTcGFjaW5nID0gZ2V0RXZlblNwYWNpbmcobWFqb3JJbmRpY2VzKTtcbiAgY29uc3Qgc3BhY2luZyA9IHRpY2tzLmxlbmd0aCAvIHRpY2tzTGltaXQ7XG5cbiAgLy8gSWYgdGhlIG1ham9yIHRpY2tzIGFyZSBldmVubHkgc3BhY2VkIGFwYXJ0LCBwbGFjZSB0aGUgbWlub3IgdGlja3NcbiAgLy8gc28gdGhhdCB0aGV5IGRpdmlkZSB0aGUgbWFqb3IgdGlja3MgaW50byBldmVuIGNodW5rc1xuICBpZiAoIWV2ZW5NYWpvclNwYWNpbmcpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG4gIH1cblxuICBjb25zdCBmYWN0b3JzID0gX2ZhY3Rvcml6ZShldmVuTWFqb3JTcGFjaW5nKTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBmYWN0b3JzLmxlbmd0aCAtIDE7IGkgPCBpbGVuOyBpKyspIHtcbiAgICBjb25zdCBmYWN0b3IgPSBmYWN0b3JzW2ldO1xuICAgIGlmIChmYWN0b3IgPiBzcGFjaW5nKSB7XG4gICAgICByZXR1cm4gZmFjdG9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKi9cbmZ1bmN0aW9uIGdldE1ham9ySW5kaWNlcyh0aWNrcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGksIGlsZW47XG4gIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICBpZiAodGlja3NbaV0ubWFqb3IpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICogQHBhcmFtIHtUaWNrW119IG5ld1RpY2tzXG4gKiBAcGFyYW0ge251bWJlcltdfSBtYWpvckluZGljZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzcGFjaW5nXG4gKi9cbmZ1bmN0aW9uIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIHNwYWNpbmcpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IG5leHQgPSBtYWpvckluZGljZXNbMF07XG4gIGxldCBpO1xuXG4gIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpID09PSBuZXh0KSB7XG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBuZXh0ID0gbWFqb3JJbmRpY2VzW2NvdW50ICogc3BhY2luZ107XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKiBAcGFyYW0ge1RpY2tbXX0gbmV3VGlja3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBzcGFjaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gW21ham9yU3RhcnRdXG4gKiBAcGFyYW0ge251bWJlcn0gW21ham9yRW5kXVxuICovXG5mdW5jdGlvbiBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbWFqb3JTdGFydCwgbWFqb3JFbmQpIHtcbiAgY29uc3Qgc3RhcnQgPSB2YWx1ZU9yRGVmYXVsdChtYWpvclN0YXJ0LCAwKTtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4odmFsdWVPckRlZmF1bHQobWFqb3JFbmQsIHRpY2tzLmxlbmd0aCksIHRpY2tzLmxlbmd0aCk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBsZW5ndGgsIGksIG5leHQ7XG5cbiAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcbiAgaWYgKG1ham9yRW5kKSB7XG4gICAgbGVuZ3RoID0gbWFqb3JFbmQgLSBtYWpvclN0YXJ0O1xuICAgIHNwYWNpbmcgPSBsZW5ndGggLyBNYXRoLmZsb29yKGxlbmd0aCAvIHNwYWNpbmcpO1xuICB9XG5cbiAgbmV4dCA9IHN0YXJ0O1xuXG4gIHdoaWxlIChuZXh0IDwgMCkge1xuICAgIGNvdW50Kys7XG4gICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICB9XG5cbiAgZm9yIChpID0gTWF0aC5tYXgoc3RhcnQsIDApOyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gbmV4dCkge1xuICAgICAgbmV3VGlja3MucHVzaCh0aWNrc1tpXSk7XG4gICAgICBjb3VudCsrO1xuICAgICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJbXX0gYXJyXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW5TcGFjaW5nKGFycikge1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSwgZGlmZjtcblxuICBpZiAobGVuIDwgMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoZGlmZiA9IGFyclswXSwgaSA9IDE7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhcnJbaV0gLSBhcnJbaSAtIDFdICE9PSBkaWZmKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBkaWZmO1xufVxuIiwgImltcG9ydCBFbGVtZW50IGZyb20gJy4vY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7X2FsaWduUGl4ZWwsIF9tZWFzdXJlVGV4dCwgcmVuZGVyVGV4dCwgY2xpcEFyZWEsIHVuY2xpcEFyZWF9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtjYWxsYmFjayBhcyBjYWxsLCBlYWNoLCBmaW5pdGVPckRlZmF1bHQsIGlzQXJyYXksIGlzRmluaXRlLCBpc051bGxPclVuZGVmLCBpc09iamVjdCwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7dG9EZWdyZWVzLCB0b1JhZGlhbnMsIF9pbnQxNlJhbmdlLCBfbGltaXRWYWx1ZSwgSEFMRl9QSX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfYWxpZ25TdGFydEVuZCwgX3RvTGVmdFJpZ2h0Q2VudGVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcbmltcG9ydCB7Y3JlYXRlQ29udGV4dCwgdG9Gb250LCB0b1BhZGRpbmcsIF9hZGRHcmFjZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHthdXRvU2tpcH0gZnJvbSAnLi9jb3JlLnNjYWxlLmF1dG9za2lwLmpzJztcblxuY29uc3QgcmV2ZXJzZUFsaWduID0gKGFsaWduKSA9PiBhbGlnbiA9PT0gJ2xlZnQnID8gJ3JpZ2h0JyA6IGFsaWduID09PSAncmlnaHQnID8gJ2xlZnQnIDogYWxpZ247XG5jb25zdCBvZmZzZXRGcm9tRWRnZSA9IChzY2FsZSwgZWRnZSwgb2Zmc2V0KSA9PiBlZGdlID09PSAndG9wJyB8fCBlZGdlID09PSAnbGVmdCcgPyBzY2FsZVtlZGdlXSArIG9mZnNldCA6IHNjYWxlW2VkZ2VdIC0gb2Zmc2V0O1xuY29uc3QgZ2V0VGlja3NMaW1pdCA9ICh0aWNrc0xlbmd0aCwgbWF4VGlja3NMaW1pdCkgPT4gTWF0aC5taW4obWF4VGlja3NMaW1pdCB8fCB0aWNrc0xlbmd0aCwgdGlja3NMZW5ndGgpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHt7dmFsdWU6bnVtYmVyIHwgc3RyaW5nLCBsYWJlbD86c3RyaW5nLCBtYWpvcj86Ym9vbGVhbiwgJGNvbnRleHQ/OmFueX19IFRpY2tcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgYXJyYXkgY29udGFpbmluZyBudW1JdGVtcyBmcm9tIGFyclxuICogQHBhcmFtIHthbnlbXX0gYXJyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtSXRlbXNcbiAqL1xuZnVuY3Rpb24gc2FtcGxlKGFyciwgbnVtSXRlbXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGluY3JlbWVudCA9IGFyci5sZW5ndGggLyBudW1JdGVtcztcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgbGVuOyBpICs9IGluY3JlbWVudCkge1xuICAgIHJlc3VsdC5wdXNoKGFycltNYXRoLmZsb29yKGkpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9mZnNldEdyaWRMaW5lc1xuICovXG5mdW5jdGlvbiBnZXRQaXhlbEZvckdyaWRMaW5lKHNjYWxlLCBpbmRleCwgb2Zmc2V0R3JpZExpbmVzKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHNjYWxlLnRpY2tzLmxlbmd0aDtcbiAgY29uc3QgdmFsaWRJbmRleCA9IE1hdGgubWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgY29uc3Qgc3RhcnQgPSBzY2FsZS5fc3RhcnRQaXhlbDtcbiAgY29uc3QgZW5kID0gc2NhbGUuX2VuZFBpeGVsO1xuICBjb25zdCBlcHNpbG9uID0gMWUtNjsgLy8gMWUtNiBpcyBtYXJnaW4gaW4gcGl4ZWxzIGZvciBhY2N1bXVsYXRlZCBlcnJvci5cbiAgbGV0IGxpbmVWYWx1ZSA9IHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4KTtcbiAgbGV0IG9mZnNldDtcblxuICBpZiAob2Zmc2V0R3JpZExpbmVzKSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgobGluZVZhbHVlIC0gc3RhcnQsIGVuZCAtIGxpbmVWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgb2Zmc2V0ID0gKHNjYWxlLmdldFBpeGVsRm9yVGljaygxKSAtIGxpbmVWYWx1ZSkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgPSAobGluZVZhbHVlIC0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXggLSAxKSkgLyAyO1xuICAgIH1cbiAgICBsaW5lVmFsdWUgKz0gdmFsaWRJbmRleCA8IGluZGV4ID8gb2Zmc2V0IDogLW9mZnNldDtcblxuICAgIC8vIFJldHVybiB1bmRlZmluZWQgaWYgdGhlIHBpeGVsIGlzIG91dCBvZiB0aGUgcmFuZ2VcbiAgICBpZiAobGluZVZhbHVlIDwgc3RhcnQgLSBlcHNpbG9uIHx8IGxpbmVWYWx1ZSA+IGVuZCArIGVwc2lsb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpbmVWYWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gY2FjaGVzXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGdhcmJhZ2VDb2xsZWN0KGNhY2hlcywgbGVuZ3RoKSB7XG4gIGVhY2goY2FjaGVzLCAoY2FjaGUpID0+IHtcbiAgICBjb25zdCBnYyA9IGNhY2hlLmdjO1xuICAgIGNvbnN0IGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcbiAgICBsZXQgaTtcbiAgICBpZiAoZ2NMZW4gPiBsZW5ndGgpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBnY0xlbjsgKytpKSB7XG4gICAgICAgIGRlbGV0ZSBjYWNoZS5kYXRhW2djW2ldXTtcbiAgICAgIH1cbiAgICAgIGdjLnNwbGljZSgwLCBnY0xlbik7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmRyYXdUaWNrcyA/IG9wdGlvbnMudGlja0xlbmd0aCA6IDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gZ2V0VGl0bGVIZWlnaHQob3B0aW9ucywgZmFsbGJhY2spIHtcbiAgaWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGNvbnN0IGZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb250LCBmYWxsYmFjayk7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgY29uc3QgbGluZXMgPSBpc0FycmF5KG9wdGlvbnMudGV4dCkgPyBvcHRpb25zLnRleHQubGVuZ3RoIDogMTtcblxuICByZXR1cm4gKGxpbmVzICogZm9udC5saW5lSGVpZ2h0KSArIHBhZGRpbmcuaGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTY2FsZUNvbnRleHQocGFyZW50LCBzY2FsZSkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBzY2FsZSxcbiAgICB0eXBlOiAnc2NhbGUnXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUaWNrQ29udGV4dChwYXJlbnQsIGluZGV4LCB0aWNrKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHRpY2ssXG4gICAgaW5kZXgsXG4gICAgdHlwZTogJ3RpY2snXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0aXRsZUFsaWduKGFsaWduLCBwb3NpdGlvbiwgcmV2ZXJzZSkge1xuICAvKiogQHR5cGUge0NhbnZhc1RleHRBbGlnbn0gKi9cbiAgbGV0IHJldCA9IF90b0xlZnRSaWdodENlbnRlcihhbGlnbik7XG4gIGlmICgocmV2ZXJzZSAmJiBwb3NpdGlvbiAhPT0gJ3JpZ2h0JykgfHwgKCFyZXZlcnNlICYmIHBvc2l0aW9uID09PSAncmlnaHQnKSkge1xuICAgIHJldCA9IHJldmVyc2VBbGlnbihyZXQpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHRpdGxlQXJncyhzY2FsZSwgb2Zmc2V0LCBwb3NpdGlvbiwgYWxpZ24pIHtcbiAgY29uc3Qge3RvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgY2hhcnR9ID0gc2NhbGU7XG4gIGNvbnN0IHtjaGFydEFyZWEsIHNjYWxlc30gPSBjaGFydDtcbiAgbGV0IHJvdGF0aW9uID0gMDtcbiAgbGV0IG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcbiAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcblxuICBpZiAoc2NhbGUuaXNIb3Jpem9udGFsKCkpIHtcbiAgICB0aXRsZVggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbGVmdCwgcmlnaHQpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgIHRpdGxlWSA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRpdGxlWSA9IChjaGFydEFyZWEuYm90dG9tICsgY2hhcnRBcmVhLnRvcCkgLyAyICsgaGVpZ2h0IC0gb2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZVkgPSBvZmZzZXRGcm9tRWRnZShzY2FsZSwgcG9zaXRpb24sIG9mZnNldCk7XG4gICAgfVxuICAgIG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICB9IGVsc2Uge1xuICAgIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICB0aXRsZVggPSBzY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpIC0gd2lkdGggKyBvZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRpdGxlWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyIC0gd2lkdGggKyBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlWCA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGJvdHRvbSwgdG9wKTtcbiAgICByb3RhdGlvbiA9IHBvc2l0aW9uID09PSAnbGVmdCcgPyAtSEFMRl9QSSA6IEhBTEZfUEk7XG4gIH1cbiAgcmV0dXJuIHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NhbGUgZXh0ZW5kcyBFbGVtZW50IHtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMuaWQgPSBjZmcuaWQ7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpcy50eXBlID0gY2ZnLnR5cGU7XG4gICAgLyoqIEB0eXBlIHthbnl9ICovXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAqL1xuICAgIHRoaXMuY3R4ID0gY2ZnLmN0eDtcbiAgICAvKiogQHR5cGUge0NoYXJ0fSAqL1xuICAgIHRoaXMuY2hhcnQgPSBjZmcuY2hhcnQ7XG5cbiAgICAvLyBpbXBsZW1lbnRzIGJveFxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH07XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLm1heEhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBhZGRpbmdUb3AgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5wYWRkaW5nQm90dG9tID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucGFkZGluZ0xlZnQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5wYWRkaW5nUmlnaHQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBzY2FsZS1zcGVjaWZpYyBwcm9wZXJ0aWVzXG4gICAgLyoqIEB0eXBlIHtzdHJpbmc9fSAqL1xuICAgIHRoaXMuYXhpcyA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcj19ICovXG4gICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JhbmdlID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7VGlja1tdfSAqL1xuICAgIHRoaXMudGlja3MgPSBbXTtcbiAgICAvKiogQHR5cGUge29iamVjdFtdfG51bGx9ICovXG4gICAgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtvYmplY3RbXXxudWxsfSAqL1xuICAgIHRoaXMuX2xhYmVsSXRlbXMgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7b2JqZWN0fG51bGx9ICovXG4gICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXhMZW5ndGggPSAwO1xuICAgIHRoaXMuX2xvbmdlc3RUZXh0Q2FjaGUgPSB7fTtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9zdGFydFBpeGVsID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX2VuZFBpeGVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSBmYWxzZTtcbiAgICB0aGlzLl91c2VyTWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3VzZXJNaW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90aWNrc0xlbmd0aCA9IDA7XG4gICAgdGhpcy5fYm9yZGVyVmFsdWUgPSAwO1xuICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHthbnl9IG9wdGlvbnNcblx0ICogQHNpbmNlIDMuMFxuXHQgKi9cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcblxuICAgIHRoaXMuYXhpcyA9IG9wdGlvbnMuYXhpcztcblxuICAgIC8vIHBhcnNlIG1pbi9tYXggdmFsdWUsIHNvIHdlIGNhbiBwcm9wZXJseSBkZXRlcm1pbmUgbWluL21heCBmb3Igb3RoZXIgc2NhbGVzXG4gICAgdGhpcy5fdXNlck1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5taW4pO1xuICAgIHRoaXMuX3VzZXJNYXggPSB0aGlzLnBhcnNlKG9wdGlvbnMubWF4KTtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNaW4gPSB0aGlzLnBhcnNlKG9wdGlvbnMuc3VnZ2VzdGVkTWluKTtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB0aGlzLnBhcnNlKG9wdGlvbnMuc3VnZ2VzdGVkTWF4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhIHN1cHBvcnRlZCBpbnB1dCB2YWx1ZSB0byBpbnRlcm5hbCByZXByZXNlbnRhdGlvbi5cblx0ICogQHBhcmFtIHsqfSByYXdcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF1cblx0ICogQHNpbmNlIDMuMFxuXHQgKi9cbiAgcGFyc2UocmF3LCBpbmRleCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgcmV0dXJuIHJhdztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBtaW5EZWZpbmVkOiBib29sZWFuLCBtYXhEZWZpbmVkOiBib29sZWFufX1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMy4wXG5cdCAqL1xuICBnZXRVc2VyQm91bmRzKCkge1xuICAgIGxldCB7X3VzZXJNaW4sIF91c2VyTWF4LCBfc3VnZ2VzdGVkTWluLCBfc3VnZ2VzdGVkTWF4fSA9IHRoaXM7XG4gICAgX3VzZXJNaW4gPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3VzZXJNYXggPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1pbiA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWluLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIF9zdWdnZXN0ZWRNYXggPSBmaW5pdGVPckRlZmF1bHQoX3N1Z2dlc3RlZE1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBmaW5pdGVPckRlZmF1bHQoX3VzZXJNaW4sIF9zdWdnZXN0ZWRNaW4pLFxuICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIF9zdWdnZXN0ZWRNYXgpLFxuICAgICAgbWluRGVmaW5lZDogaXNGaW5pdGUoX3VzZXJNaW4pLFxuICAgICAgbWF4RGVmaW5lZDogaXNGaW5pdGUoX3VzZXJNYXgpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGNhblN0YWNrXG5cdCAqIEByZXR1cm4ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAzLjBcblx0ICovXG4gIGdldE1pbk1heChjYW5TdGFjaykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICBsZXQge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCByYW5nZTtcblxuICAgIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQpIHtcbiAgICAgIHJldHVybiB7bWluLCBtYXh9O1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGFzID0gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICByYW5nZSA9IG1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0TWluTWF4KHRoaXMsIGNhblN0YWNrKTtcbiAgICAgIGlmICghbWluRGVmaW5lZCkge1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHJhbmdlLm1pbik7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCByYW5nZS5tYXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBtaW4gPD0gbWF4IHdoZW4gb25seSBtaW4gb3IgbWF4IGlzIGRlZmluZWQgYnkgdXNlciBhbmQgdGhlIGRhdGEgaXMgb3V0c2lkZSB0aGF0IHJhbmdlXG4gICAgbWluID0gbWF4RGVmaW5lZCAmJiBtaW4gPiBtYXggPyBtYXggOiBtaW47XG4gICAgbWF4ID0gbWluRGVmaW5lZCAmJiBtaW4gPiBtYXggPyBtaW4gOiBtYXg7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBmaW5pdGVPckRlZmF1bHQobWluLCBmaW5pdGVPckRlZmF1bHQobWF4LCBtaW4pKSxcbiAgICAgIG1heDogZmluaXRlT3JEZWZhdWx0KG1heCwgZmluaXRlT3JEZWZhdWx0KG1pbiwgbWF4KSlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldCB0aGUgcGFkZGluZyBuZWVkZWQgZm9yIHRoZSBzY2FsZVxuXHQgKiBAcmV0dXJuIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgYm90dG9tOiBudW1iZXIsIHJpZ2h0OiBudW1iZXJ9fSB0aGUgbmVjZXNzYXJ5IHBhZGRpbmdcblx0ICogQHByaXZhdGVcblx0ICovXG4gIGdldFBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IHRoaXMucGFkZGluZ0xlZnQgfHwgMCxcbiAgICAgIHRvcDogdGhpcy5wYWRkaW5nVG9wIHx8IDAsXG4gICAgICByaWdodDogdGhpcy5wYWRkaW5nUmlnaHQgfHwgMCxcbiAgICAgIGJvdHRvbTogdGhpcy5wYWRkaW5nQm90dG9tIHx8IDBcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHNjYWxlIHRpY2sgb2JqZWN0c1xuXHQgKiBAcmV0dXJuIHtUaWNrW119XG5cdCAqIEBzaW5jZSAyLjdcblx0ICovXG4gIGdldFRpY2tzKCkge1xuICAgIHJldHVybiB0aGlzLnRpY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge3N0cmluZ1tdfVxuXHQgKi9cbiAgZ2V0TGFiZWxzKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sYWJlbHMgfHwgKHRoaXMuaXNIb3Jpem9udGFsKCkgPyBkYXRhLnhMYWJlbHMgOiBkYXRhLnlMYWJlbHMpIHx8IGRhdGEubGFiZWxzIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydCgnLi4vdHlwZXMuanMnKS5MYWJlbEl0ZW1bXX1cbiAgICovXG4gIGdldExhYmVsSXRlbXMoY2hhcnRBcmVhID0gdGhpcy5jaGFydC5jaGFydEFyZWEpIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2xhYmVsSXRlbXMgfHwgKHRoaXMuX2xhYmVsSXRlbXMgPSB0aGlzLl9jb21wdXRlTGFiZWxJdGVtcyhjaGFydEFyZWEpKTtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICAvLyBXaGVuIGEgbmV3IGxheW91dCBpcyBjcmVhdGVkLCByZXNldCB0aGUgZGF0YSBsaW1pdHMgY2FjaGVcbiAgYmVmb3JlTGF5b3V0KCkge1xuICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gVGhlc2UgbWV0aG9kcyBhcmUgb3JkZXJlZCBieSBsaWZlY3ljbGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cbiAgLy8gQW55IGZ1bmN0aW9uIGRlZmluZWQgaGVyZSBpcyBpbmhlcml0ZWQgYnkgYWxsIHNjYWxlIHR5cGVzLlxuICAvLyBBbnkgZnVuY3Rpb24gY2FuIGJlIGV4dGVuZGVkIGJ5IHRoZSBzY2FsZSB0eXBlXG5cbiAgYmVmb3JlVXBkYXRlKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmJlZm9yZVVwZGF0ZSwgW3RoaXNdKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4V2lkdGggLSB0aGUgbWF4IHdpZHRoIGluIHBpeGVsc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4SGVpZ2h0IC0gdGhlIG1heCBoZWlnaHQgaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSB7e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCByaWdodDogbnVtYmVyfX0gbWFyZ2lucyAtIHRoZSBzcGFjZSBiZXR3ZWVuIHRoZSBlZGdlIG9mIHRoZSBvdGhlciBzY2FsZXMgYW5kIGVkZ2Ugb2YgdGhlIGNoYXJ0XG5cdCAqICAgVGhpcyBzcGFjZSBjb21lcyBmcm9tIHR3byBzb3VyY2VzOlxuXHQgKiAgICAgLSBwYWRkaW5nIC0gc3BhY2UgdGhhdCdzIHJlcXVpcmVkIHRvIHNob3cgdGhlIGxhYmVscyBhdCB0aGUgZWRnZXMgb2YgdGhlIHNjYWxlXG5cdCAqICAgICAtIHRoaWNrbmVzcyBvZiBzY2FsZXMgb3IgbGVnZW5kcyBpbiBhbm90aGVyIG9yaWVudGF0aW9uXG5cdCAqL1xuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuICAgIGNvbnN0IHtiZWdpbkF0WmVybywgZ3JhY2UsIHRpY2tzOiB0aWNrT3B0c30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2FtcGxlU2l6ZSA9IHRpY2tPcHRzLnNhbXBsZVNpemU7XG5cbiAgICAvLyBVcGRhdGUgTGlmZWN5Y2xlIC0gUHJvYmFibHkgZG9uJ3Qgd2FudCB0byBldmVyIGV4dGVuZCBvciBvdmVyd3JpdGUgdGhpcyBmdW5jdGlvbiA7KVxuICAgIHRoaXMuYmVmb3JlVXBkYXRlKCk7XG5cbiAgICAvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcbiAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IG1hcmdpbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH0sIG1hcmdpbnMpO1xuXG4gICAgdGhpcy50aWNrcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XG5cbiAgICAvLyBEaW1lbnNpb25zXG4gICAgdGhpcy5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5hZnRlclNldERpbWVuc2lvbnMoKTtcblxuICAgIHRoaXMuX21heExlbmd0aCA9IHRoaXMuaXNIb3Jpem9udGFsKClcbiAgICAgID8gdGhpcy53aWR0aCArIG1hcmdpbnMubGVmdCArIG1hcmdpbnMucmlnaHRcbiAgICAgIDogdGhpcy5oZWlnaHQgKyBtYXJnaW5zLnRvcCArIG1hcmdpbnMuYm90dG9tO1xuXG4gICAgLy8gRGF0YSBtaW4vbWF4XG4gICAgaWYgKCF0aGlzLl9kYXRhTGltaXRzQ2FjaGVkKSB7XG4gICAgICB0aGlzLmJlZm9yZURhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuZGV0ZXJtaW5lRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5hZnRlckRhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuX3JhbmdlID0gX2FkZEdyYWNlKHRoaXMsIGdyYWNlLCBiZWdpbkF0WmVybyk7XG4gICAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmJlZm9yZUJ1aWxkVGlja3MoKTtcblxuICAgIHRoaXMudGlja3MgPSB0aGlzLmJ1aWxkVGlja3MoKSB8fCBbXTtcblxuICAgIC8vIEFsbG93IG1vZGlmaWNhdGlvbiBvZiB0aWNrcyBpbiBjYWxsYmFjay5cbiAgICB0aGlzLmFmdGVyQnVpbGRUaWNrcygpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aWNrIHJvdGF0aW9uIGFuZCBmaXQgdXNpbmcgYSBzYW1wbGVkIHN1YnNldCBvZiBsYWJlbHNcbiAgICAvLyBXZSBnZW5lcmFsbHkgZG9uJ3QgbmVlZCB0byBjb21wdXRlIHRoZSBzaXplIG9mIGV2ZXJ5IHNpbmdsZSBsYWJlbCBmb3IgZGV0ZXJtaW5pbmcgc2NhbGUgc2l6ZVxuICAgIGNvbnN0IHNhbXBsaW5nRW5hYmxlZCA9IHNhbXBsZVNpemUgPCB0aGlzLnRpY2tzLmxlbmd0aDtcbiAgICB0aGlzLl9jb252ZXJ0VGlja3NUb0xhYmVscyhzYW1wbGluZ0VuYWJsZWQgPyBzYW1wbGUodGhpcy50aWNrcywgc2FtcGxlU2l6ZSkgOiB0aGlzLnRpY2tzKTtcblxuICAgIC8vIGNvbmZpZ3VyZSBpcyBjYWxsZWQgdHdpY2UsIG9uY2UgaGVyZSwgb25jZSBmcm9tIGNvcmUuY29udHJvbGxlci51cGRhdGVMYXlvdXQuXG4gICAgLy8gSGVyZSB3ZSBoYXZlbid0IGJlZW4gcG9zaXRpb25lZCB5ZXQsIGJ1dCBkaW1lbnNpb25zIGFyZSBjb3JyZWN0LlxuICAgIC8vIFZhcmlhYmxlcyBzZXQgaW4gY29uZmlndXJlIGFyZSBuZWVkZWQgZm9yIGNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIGFuZFxuICAgIC8vIGl0J3Mgb2sgdGhhdCBjb29yZGluYXRlcyBhcmUgbm90IGNvcnJlY3QgdGhlcmUsIG9ubHkgZGltZW5zaW9ucyBtYXR0ZXIuXG4gICAgdGhpcy5jb25maWd1cmUoKTtcblxuICAgIC8vIFRpY2sgUm90YXRpb25cbiAgICB0aGlzLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTsgLy8gUHJlY29uZGl0aW9uczogbnVtYmVyIG9mIHRpY2tzIGFuZCBzaXplcyBvZiBsYXJnZXN0IGxhYmVscyBtdXN0IGJlIGNhbGN1bGF0ZWQgYmVmb3JlaGFuZFxuICAgIHRoaXMuYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG5cbiAgICAvLyBBdXRvLXNraXBcbiAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiAodGlja09wdHMuYXV0b1NraXAgfHwgdGlja09wdHMuc291cmNlID09PSAnYXV0bycpKSB7XG4gICAgICB0aGlzLnRpY2tzID0gYXV0b1NraXAodGhpcywgdGhpcy50aWNrcyk7XG4gICAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICAgIHRoaXMuYWZ0ZXJBdXRvU2tpcCgpO1xuICAgIH1cblxuICAgIGlmIChzYW1wbGluZ0VuYWJsZWQpIHtcbiAgICAgIC8vIEdlbmVyYXRlIGxhYmVscyB1c2luZyBhbGwgbm9uLXNraXBwZWQgdGlja3NcbiAgICAgIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRoaXMudGlja3MpO1xuICAgIH1cblxuICAgIHRoaXMuYmVmb3JlRml0KCk7XG4gICAgdGhpcy5maXQoKTsgLy8gUHJlY29uZGl0aW9uczogbGFiZWwgcm90YXRpb24gYW5kIGxhYmVsIHNpemVzIG11c3QgYmUgY2FsY3VsYXRlZCBiZWZvcmVoYW5kXG4gICAgdGhpcy5hZnRlckZpdCgpO1xuXG4gICAgLy8gSU1QT1JUQU5UOiBhZnRlciB0aGlzIHBvaW50LCB3ZSBjb25zaWRlciB0aGF0IGB0aGlzLnRpY2tzYCB3aWxsIE5FVkVSIGNoYW5nZSFcblxuICAgIHRoaXMuYWZ0ZXJVcGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgbGV0IHJldmVyc2VQaXhlbHMgPSB0aGlzLm9wdGlvbnMucmV2ZXJzZTtcbiAgICBsZXQgc3RhcnRQaXhlbCwgZW5kUGl4ZWw7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgc3RhcnRQaXhlbCA9IHRoaXMubGVmdDtcbiAgICAgIGVuZFBpeGVsID0gdGhpcy5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRQaXhlbCA9IHRoaXMudG9wO1xuICAgICAgZW5kUGl4ZWwgPSB0aGlzLmJvdHRvbTtcbiAgICAgIC8vIGJ5IGRlZmF1bHQgdmVydGljYWwgc2NhbGVzIGFyZSBmcm9tIGJvdHRvbSB0byB0b3AsIHNvIHBpeGVscyBhcmUgcmV2ZXJzZWRcbiAgICAgIHJldmVyc2VQaXhlbHMgPSAhcmV2ZXJzZVBpeGVscztcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRQaXhlbCA9IHN0YXJ0UGl4ZWw7XG4gICAgdGhpcy5fZW5kUGl4ZWwgPSBlbmRQaXhlbDtcbiAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gcmV2ZXJzZVBpeGVscztcbiAgICB0aGlzLl9sZW5ndGggPSBlbmRQaXhlbCAtIHN0YXJ0UGl4ZWw7XG4gICAgdGhpcy5fYWxpZ25Ub1BpeGVscyA9IHRoaXMub3B0aW9ucy5hbGlnblRvUGl4ZWxzO1xuICB9XG5cbiAgYWZ0ZXJVcGRhdGUoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYWZ0ZXJVcGRhdGUsIFt0aGlzXSk7XG4gIH1cblxuICAvL1xuXG4gIGJlZm9yZVNldERpbWVuc2lvbnMoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcbiAgfVxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuICAgICAgdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICB0aGlzLmxlZnQgPSAwO1xuICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG5cbiAgICAgIC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuICAgICAgdGhpcy50b3AgPSAwO1xuICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBwYWRkaW5nXG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nVG9wID0gMDtcbiAgICB0aGlzLnBhZGRpbmdSaWdodCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nQm90dG9tID0gMDtcbiAgfVxuICBhZnRlclNldERpbWVuc2lvbnMoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYWZ0ZXJTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICB9XG5cbiAgX2NhbGxIb29rcyhuYW1lKSB7XG4gICAgdGhpcy5jaGFydC5ub3RpZnlQbHVnaW5zKG5hbWUsIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjYWxsKHRoaXMub3B0aW9uc1tuYW1lXSwgW3RoaXNdKTtcbiAgfVxuXG4gIC8vIERhdGEgbGltaXRzXG4gIGJlZm9yZURhdGFMaW1pdHMoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVEYXRhTGltaXRzJyk7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHt9XG4gIGFmdGVyRGF0YUxpbWl0cygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2FmdGVyRGF0YUxpbWl0cycpO1xuICB9XG5cbiAgLy9cbiAgYmVmb3JlQnVpbGRUaWNrcygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2JlZm9yZUJ1aWxkVGlja3MnKTtcbiAgfVxuICAvKipcblx0ICogQHJldHVybiB7b2JqZWN0W119IHRoZSB0aWNrc1xuXHQgKi9cbiAgYnVpbGRUaWNrcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgYWZ0ZXJCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJCdWlsZFRpY2tzJyk7XG4gIH1cblxuICBiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuICB9XG4gIC8qKlxuXHQgKiBDb252ZXJ0IHRpY2tzIHRvIGxhYmVsIHN0cmluZ3Ncblx0ICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG5cdCAqL1xuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBjb25zdCB0aWNrT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBsZXQgaSwgaWxlbiwgdGljaztcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICB0aWNrLmxhYmVsID0gY2FsbCh0aWNrT3B0cy5jYWxsYmFjaywgW3RpY2sudmFsdWUsIGksIHRpY2tzXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIGFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuICB9XG5cbiAgLy9cblxuICBiZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gIH1cbiAgY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcbiAgICBjb25zdCBudW1UaWNrcyA9IGdldFRpY2tzTGltaXQodGhpcy50aWNrcy5sZW5ndGgsIG9wdGlvbnMudGlja3MubWF4VGlja3NMaW1pdCk7XG4gICAgY29uc3QgbWluUm90YXRpb24gPSB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwO1xuICAgIGNvbnN0IG1heFJvdGF0aW9uID0gdGlja09wdHMubWF4Um90YXRpb247XG4gICAgbGV0IGxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcbiAgICBsZXQgdGlja1dpZHRoLCBtYXhIZWlnaHQsIG1heExhYmVsRGlhZ29uYWw7XG5cbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8ICF0aWNrT3B0cy5kaXNwbGF5IHx8IG1pblJvdGF0aW9uID49IG1heFJvdGF0aW9uIHx8IG51bVRpY2tzIDw9IDEgfHwgIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgbWF4TGFiZWxXaWR0aCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuICAgIGNvbnN0IG1heExhYmVsSGVpZ2h0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodDtcblxuICAgIC8vIEVzdGltYXRlIHRoZSB3aWR0aCBvZiBlYWNoIGdyaWQgYmFzZWQgb24gdGhlIGNhbnZhcyB3aWR0aCwgdGhlIG1heGltdW1cbiAgICAvLyBsYWJlbCB3aWR0aCBhbmQgdGhlIG51bWJlciBvZiB0aWNrIGludGVydmFsc1xuICAgIGNvbnN0IG1heFdpZHRoID0gX2xpbWl0VmFsdWUodGhpcy5jaGFydC53aWR0aCAtIG1heExhYmVsV2lkdGgsIDAsIHRoaXMubWF4V2lkdGgpO1xuICAgIHRpY2tXaWR0aCA9IG9wdGlvbnMub2Zmc2V0ID8gdGhpcy5tYXhXaWR0aCAvIG51bVRpY2tzIDogbWF4V2lkdGggLyAobnVtVGlja3MgLSAxKTtcblxuICAgIC8vIEFsbG93IDMgcGl4ZWxzIHgyIHBhZGRpbmcgZWl0aGVyIHNpZGUgZm9yIGxhYmVsIHJlYWRhYmlsaXR5XG4gICAgaWYgKG1heExhYmVsV2lkdGggKyA2ID4gdGlja1dpZHRoKSB7XG4gICAgICB0aWNrV2lkdGggPSBtYXhXaWR0aCAvIChudW1UaWNrcyAtIChvcHRpb25zLm9mZnNldCA/IDAuNSA6IDEpKTtcbiAgICAgIG1heEhlaWdodCA9IHRoaXMubWF4SGVpZ2h0IC0gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucy5ncmlkKVxuXHRcdFx0XHQtIHRpY2tPcHRzLnBhZGRpbmcgLSBnZXRUaXRsZUhlaWdodChvcHRpb25zLnRpdGxlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMuZm9udCk7XG4gICAgICBtYXhMYWJlbERpYWdvbmFsID0gTWF0aC5zcXJ0KG1heExhYmVsV2lkdGggKiBtYXhMYWJlbFdpZHRoICsgbWF4TGFiZWxIZWlnaHQgKiBtYXhMYWJlbEhlaWdodCk7XG4gICAgICBsYWJlbFJvdGF0aW9uID0gdG9EZWdyZWVzKE1hdGgubWluKFxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUoKGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyA2KSAvIHRpY2tXaWR0aCwgLTEsIDEpKSxcbiAgICAgICAgTWF0aC5hc2luKF9saW1pdFZhbHVlKG1heEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSkgLSBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4TGFiZWxIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsLCAtMSwgMSkpXG4gICAgICApKTtcbiAgICAgIGxhYmVsUm90YXRpb24gPSBNYXRoLm1heChtaW5Sb3RhdGlvbiwgTWF0aC5taW4obWF4Um90YXRpb24sIGxhYmVsUm90YXRpb24pKTtcbiAgICB9XG5cbiAgICB0aGlzLmxhYmVsUm90YXRpb24gPSBsYWJlbFJvdGF0aW9uO1xuICB9XG4gIGFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gIH1cbiAgYWZ0ZXJBdXRvU2tpcCgpIHt9XG5cbiAgLy9cblxuICBiZWZvcmVGaXQoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlRml0LCBbdGhpc10pO1xuICB9XG4gIGZpdCgpIHtcbiAgICAvLyBSZXNldFxuICAgIGNvbnN0IG1pblNpemUgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG5cbiAgICBjb25zdCB7Y2hhcnQsIG9wdGlvbnM6IHt0aWNrczogdGlja09wdHMsIHRpdGxlOiB0aXRsZU9wdHMsIGdyaWQ6IGdyaWRPcHRzfX0gPSB0aGlzO1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLl9pc1Zpc2libGUoKTtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuXG4gICAgaWYgKGRpc3BsYXkpIHtcbiAgICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gZ2V0VGl0bGVIZWlnaHQodGl0bGVPcHRzLCBjaGFydC5vcHRpb25zLmZvbnQpO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBtaW5TaXplLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSBnZXRUaWNrTWFya0xlbmd0aChncmlkT3B0cykgKyB0aXRsZUhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pblNpemUuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7IC8vIGZpbGwgYWxsIHRoZSBoZWlnaHRcbiAgICAgICAgbWluU2l6ZS53aWR0aCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRPcHRzKSArIHRpdGxlSGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCBib3RoZXIgZml0dGluZyB0aGUgdGlja3MgaWYgd2UgYXJlIG5vdCBzaG93aW5nIHRoZSBsYWJlbHNcbiAgICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIHRoaXMudGlja3MubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHtmaXJzdCwgbGFzdCwgd2lkZXN0LCBoaWdoZXN0fSA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICAgICAgY29uc3QgdGlja1BhZGRpbmcgPSB0aWNrT3B0cy5wYWRkaW5nICogMjtcbiAgICAgICAgY29uc3QgYW5nbGVSYWRpYW5zID0gdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlUmFkaWFucyk7XG4gICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlUmFkaWFucyk7XG5cbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAvLyBBIGhvcml6b250YWwgYXhpcyBpcyBtb3JlIGNvbnN0cmFpbmVkIGJ5IHRoZSBoZWlnaHQuXG4gICAgICAgICAgY29uc3QgbGFiZWxIZWlnaHQgPSB0aWNrT3B0cy5taXJyb3IgPyAwIDogc2luICogd2lkZXN0LndpZHRoICsgY29zICogaGlnaGVzdC5oZWlnaHQ7XG4gICAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSBNYXRoLm1pbih0aGlzLm1heEhlaWdodCwgbWluU2l6ZS5oZWlnaHQgKyBsYWJlbEhlaWdodCArIHRpY2tQYWRkaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQSB2ZXJ0aWNhbCBheGlzIGlzIG1vcmUgY29uc3RyYWluZWQgYnkgdGhlIHdpZHRoLiBMYWJlbHMgYXJlIHRoZVxuICAgICAgICAvLyBkb21pbmFudCBmYWN0b3IgaGVyZSwgc28gZ2V0IHRoYXQgbGVuZ3RoIGZpcnN0IGFuZCBhY2NvdW50IGZvciBwYWRkaW5nXG4gICAgICAgICAgY29uc3QgbGFiZWxXaWR0aCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOiBjb3MgKiB3aWRlc3Qud2lkdGggKyBzaW4gKiBoaWdoZXN0LmhlaWdodDtcblxuICAgICAgICAgIG1pblNpemUud2lkdGggPSBNYXRoLm1pbih0aGlzLm1heFdpZHRoLCBtaW5TaXplLndpZHRoICsgbGFiZWxXaWR0aCArIHRpY2tQYWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVQYWRkaW5nKGZpcnN0LCBsYXN0LCBzaW4sIGNvcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5faGFuZGxlTWFyZ2lucygpO1xuXG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuX2xlbmd0aCA9IGNoYXJ0LndpZHRoIC0gdGhpcy5fbWFyZ2lucy5sZWZ0IC0gdGhpcy5fbWFyZ2lucy5yaWdodDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSBtaW5TaXplLndpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLl9sZW5ndGggPSBjaGFydC5oZWlnaHQgLSB0aGlzLl9tYXJnaW5zLnRvcCAtIHRoaXMuX21hcmdpbnMuYm90dG9tO1xuICAgIH1cbiAgfVxuXG4gIF9jYWxjdWxhdGVQYWRkaW5nKGZpcnN0LCBsYXN0LCBzaW4sIGNvcykge1xuICAgIGNvbnN0IHt0aWNrczoge2FsaWduLCBwYWRkaW5nfSwgcG9zaXRpb259ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGlzUm90YXRlZCA9IHRoaXMubGFiZWxSb3RhdGlvbiAhPT0gMDtcbiAgICBjb25zdCBsYWJlbHNCZWxvd1RpY2tzID0gcG9zaXRpb24gIT09ICd0b3AnICYmIHRoaXMuYXhpcyA9PT0gJ3gnO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldExlZnQgPSB0aGlzLmdldFBpeGVsRm9yVGljaygwKSAtIHRoaXMubGVmdDtcbiAgICAgIGNvbnN0IG9mZnNldFJpZ2h0ID0gdGhpcy5yaWdodCAtIHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKHRoaXMudGlja3MubGVuZ3RoIC0gMSk7XG4gICAgICBsZXQgcGFkZGluZ0xlZnQgPSAwO1xuICAgICAgbGV0IHBhZGRpbmdSaWdodCA9IDA7XG5cbiAgICAgIC8vIEVuc3VyZSB0aGF0IG91ciB0aWNrcyBhcmUgYWx3YXlzIGluc2lkZSB0aGUgY2FudmFzLiBXaGVuIHJvdGF0ZWQsIHRpY2tzIGFyZSByaWdodCBhbGlnbmVkXG4gICAgICAvLyB3aGljaCBtZWFucyB0aGF0IHRoZSByaWdodCBwYWRkaW5nIGlzIGRvbWluYXRlZCBieSB0aGUgZm9udCBoZWlnaHRcbiAgICAgIGlmIChpc1JvdGF0ZWQpIHtcbiAgICAgICAgaWYgKGxhYmVsc0JlbG93VGlja3MpIHtcbiAgICAgICAgICBwYWRkaW5nTGVmdCA9IGNvcyAqIGZpcnN0LndpZHRoO1xuICAgICAgICAgIHBhZGRpbmdSaWdodCA9IHNpbiAqIGxhc3QuaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gc2luICogZmlyc3QuaGVpZ2h0O1xuICAgICAgICAgIHBhZGRpbmdSaWdodCA9IGNvcyAqIGxhc3Qud2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgcGFkZGluZ1JpZ2h0ID0gbGFzdC53aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHBhZGRpbmdMZWZ0ID0gZmlyc3Qud2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduICE9PSAnaW5uZXInKSB7XG4gICAgICAgIHBhZGRpbmdMZWZ0ID0gZmlyc3Qud2lkdGggLyAyO1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoIC8gMjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRqdXN0IHBhZGRpbmcgdGFraW5nIGludG8gYWNjb3VudCBjaGFuZ2VzIGluIG9mZnNldHNcbiAgICAgIHRoaXMucGFkZGluZ0xlZnQgPSBNYXRoLm1heCgocGFkZGluZ0xlZnQgLSBvZmZzZXRMZWZ0ICsgcGFkZGluZykgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBvZmZzZXRMZWZ0KSwgMCk7XG4gICAgICB0aGlzLnBhZGRpbmdSaWdodCA9IE1hdGgubWF4KChwYWRkaW5nUmlnaHQgLSBvZmZzZXRSaWdodCArIHBhZGRpbmcpICogdGhpcy53aWR0aCAvICh0aGlzLndpZHRoIC0gb2Zmc2V0UmlnaHQpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhZGRpbmdUb3AgPSBsYXN0LmhlaWdodCAvIDI7XG4gICAgICBsZXQgcGFkZGluZ0JvdHRvbSA9IGZpcnN0LmhlaWdodCAvIDI7XG5cbiAgICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBwYWRkaW5nVG9wID0gMDtcbiAgICAgICAgcGFkZGluZ0JvdHRvbSA9IGZpcnN0LmhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHBhZGRpbmdUb3AgPSBsYXN0LmhlaWdodDtcbiAgICAgICAgcGFkZGluZ0JvdHRvbSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGFkZGluZ1RvcCA9IHBhZGRpbmdUb3AgKyBwYWRkaW5nO1xuICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gcGFkZGluZ0JvdHRvbSArIHBhZGRpbmc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEhhbmRsZSBtYXJnaW5zIGFuZCBwYWRkaW5nIGludGVyYWN0aW9uc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2hhbmRsZU1hcmdpbnMoKSB7XG4gICAgaWYgKHRoaXMuX21hcmdpbnMpIHtcbiAgICAgIHRoaXMuX21hcmdpbnMubGVmdCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0xlZnQsIHRoaXMuX21hcmdpbnMubGVmdCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLnRvcCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ1RvcCwgdGhpcy5fbWFyZ2lucy50b3ApO1xuICAgICAgdGhpcy5fbWFyZ2lucy5yaWdodCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ1JpZ2h0LCB0aGlzLl9tYXJnaW5zLnJpZ2h0KTtcbiAgICAgIHRoaXMuX21hcmdpbnMuYm90dG9tID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nQm90dG9tLCB0aGlzLl9tYXJnaW5zLmJvdHRvbSk7XG4gICAgfVxuICB9XG5cbiAgYWZ0ZXJGaXQoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYWZ0ZXJGaXQsIFt0aGlzXSk7XG4gIH1cblxuICAvLyBTaGFyZWQgTWV0aG9kc1xuICAvKipcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICBjb25zdCB7YXhpcywgcG9zaXRpb259ID0gdGhpcy5vcHRpb25zO1xuICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nIHx8IGF4aXMgPT09ICd4JztcbiAgfVxuICAvKipcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG4gIGlzRnVsbFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mdWxsU2l6ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge1RpY2tbXX0gdGlja3Ncblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb252ZXJ0VGlja3NUb0xhYmVscyh0aWNrcykge1xuICAgIHRoaXMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG5cbiAgICB0aGlzLmdlbmVyYXRlVGlja0xhYmVscyh0aWNrcyk7XG5cbiAgICAvLyBUaWNrcyBzaG91bGQgYmUgc2tpcHBlZCB3aGVuIGNhbGxiYWNrIHJldHVybnMgbnVsbCBvciB1bmRlZiwgc28gbGV0cyByZW1vdmUgdGhvc2UuXG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodGlja3NbaV0ubGFiZWwpKSB7XG4gICAgICAgIHRpY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgaWxlbi0tO1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge3sgZmlyc3Q6IG9iamVjdCwgbGFzdDogb2JqZWN0LCB3aWRlc3Q6IG9iamVjdCwgaGlnaGVzdDogb2JqZWN0LCB3aWR0aHM6IEFycmF5LCBoZWlnaHRzOiBhcnJheSB9fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExhYmVsU2l6ZXMoKSB7XG4gICAgbGV0IGxhYmVsU2l6ZXMgPSB0aGlzLl9sYWJlbFNpemVzO1xuXG4gICAgaWYgKCFsYWJlbFNpemVzKSB7XG4gICAgICBjb25zdCBzYW1wbGVTaXplID0gdGhpcy5vcHRpb25zLnRpY2tzLnNhbXBsZVNpemU7XG4gICAgICBsZXQgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgICAgaWYgKHNhbXBsZVNpemUgPCB0aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgdGlja3MgPSBzYW1wbGUodGlja3MsIHNhbXBsZVNpemUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9sYWJlbFNpemVzID0gbGFiZWxTaXplcyA9IHRoaXMuX2NvbXB1dGVMYWJlbFNpemVzKHRpY2tzLCB0aWNrcy5sZW5ndGgsIHRoaXMub3B0aW9ucy50aWNrcy5tYXhUaWNrc0xpbWl0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGFiZWxTaXplcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHt3aWR0aCwgaGVpZ2h0LCBvZmZzZXR9IG9iamVjdHMgZm9yIHRoZSBmaXJzdCwgbGFzdCwgd2lkZXN0LCBoaWdoZXN0IHRpY2tcblx0ICogbGFiZWxzIHdoZXJlIG9mZnNldCBpbmRpY2F0ZXMgdGhlIGFuY2hvciBwb2ludCBvZmZzZXQgZnJvbSB0aGUgdG9wIGluIHBpeGVscy5cblx0ICogQHJldHVybiB7eyBmaXJzdDogb2JqZWN0LCBsYXN0OiBvYmplY3QsIHdpZGVzdDogb2JqZWN0LCBoaWdoZXN0OiBvYmplY3QsIHdpZHRoczogQXJyYXksIGhlaWdodHM6IGFycmF5IH19XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIGxlbmd0aCwgbWF4VGlja3NMaW1pdCkge1xuICAgIGNvbnN0IHtjdHgsIF9sb25nZXN0VGV4dENhY2hlOiBjYWNoZXN9ID0gdGhpcztcbiAgICBjb25zdCB3aWR0aHMgPSBbXTtcbiAgICBjb25zdCBoZWlnaHRzID0gW107XG4gICAgY29uc3QgaW5jcmVtZW50ID0gTWF0aC5mbG9vcihsZW5ndGggLyBnZXRUaWNrc0xpbWl0KGxlbmd0aCwgbWF4VGlja3NMaW1pdCkpO1xuICAgIGxldCB3aWRlc3RMYWJlbFNpemUgPSAwO1xuICAgIGxldCBoaWdoZXN0TGFiZWxTaXplID0gMDtcbiAgICBsZXQgaSwgaiwgamxlbiwgbGFiZWwsIHRpY2tGb250LCBmb250U3RyaW5nLCBjYWNoZSwgbGluZUhlaWdodCwgd2lkdGgsIGhlaWdodCwgbmVzdGVkTGFiZWw7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IGluY3JlbWVudCkge1xuICAgICAgbGFiZWwgPSB0aWNrc1tpXS5sYWJlbDtcbiAgICAgIHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpKTtcbiAgICAgIGN0eC5mb250ID0gZm9udFN0cmluZyA9IHRpY2tGb250LnN0cmluZztcbiAgICAgIGNhY2hlID0gY2FjaGVzW2ZvbnRTdHJpbmddID0gY2FjaGVzW2ZvbnRTdHJpbmddIHx8IHtkYXRhOiB7fSwgZ2M6IFtdfTtcbiAgICAgIGxpbmVIZWlnaHQgPSB0aWNrRm9udC5saW5lSGVpZ2h0O1xuICAgICAgd2lkdGggPSBoZWlnaHQgPSAwO1xuICAgICAgLy8gVW5kZWZpbmVkIGxhYmVscyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihsYWJlbCkgJiYgIWlzQXJyYXkobGFiZWwpKSB7XG4gICAgICAgIHdpZHRoID0gX21lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBsYWJlbCk7XG4gICAgICAgIGhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkobGFiZWwpKSB7XG4gICAgICAgIC8vIGlmIGl0IGlzIGFuIGFycmF5IGxldCdzIG1lYXN1cmUgZWFjaCBlbGVtZW50XG4gICAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsYWJlbC5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgICBuZXN0ZWRMYWJlbCA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAobGFiZWxbal0pO1xuICAgICAgICAgIC8vIFVuZGVmaW5lZCBsYWJlbHMgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG4gICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKG5lc3RlZExhYmVsKSAmJiAhaXNBcnJheShuZXN0ZWRMYWJlbCkpIHtcbiAgICAgICAgICAgIHdpZHRoID0gX21lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBuZXN0ZWRMYWJlbCk7XG4gICAgICAgICAgICBoZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdpZHRocy5wdXNoKHdpZHRoKTtcbiAgICAgIGhlaWdodHMucHVzaChoZWlnaHQpO1xuICAgICAgd2lkZXN0TGFiZWxTaXplID0gTWF0aC5tYXgod2lkdGgsIHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgICBoaWdoZXN0TGFiZWxTaXplID0gTWF0aC5tYXgoaGVpZ2h0LCBoaWdoZXN0TGFiZWxTaXplKTtcbiAgICB9XG4gICAgZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpO1xuXG4gICAgY29uc3Qgd2lkZXN0ID0gd2lkdGhzLmluZGV4T2Yod2lkZXN0TGFiZWxTaXplKTtcbiAgICBjb25zdCBoaWdoZXN0ID0gaGVpZ2h0cy5pbmRleE9mKGhpZ2hlc3RMYWJlbFNpemUpO1xuXG4gICAgY29uc3QgdmFsdWVBdCA9IChpZHgpID0+ICh7d2lkdGg6IHdpZHRoc1tpZHhdIHx8IDAsIGhlaWdodDogaGVpZ2h0c1tpZHhdIHx8IDB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBmaXJzdDogdmFsdWVBdCgwKSxcbiAgICAgIGxhc3Q6IHZhbHVlQXQobGVuZ3RoIC0gMSksXG4gICAgICB3aWRlc3Q6IHZhbHVlQXQod2lkZXN0KSxcbiAgICAgIGhpZ2hlc3Q6IHZhbHVlQXQoaGlnaGVzdCksXG4gICAgICB3aWR0aHMsXG4gICAgICBoZWlnaHRzLFxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogVXNlZCB0byBnZXQgdGhlIGxhYmVsIHRvIGRpc3BsYXkgaW4gdGhlIHRvb2x0aXAgZm9yIHRoZSBnaXZlbiB2YWx1ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgbG9jYXRpb24gb2YgdGhlIGdpdmVuIGRhdGEgcG9pbnQuIFZhbHVlIGNhbiBlaXRoZXIgYmUgYW4gaW5kZXggb3IgYSBudW1lcmljYWwgdmFsdWVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWVcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF1cblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSwgaW5kZXgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICAvKipcblx0ICogVXNlZCB0byBnZXQgdGhlIGRhdGEgdmFsdWUgZnJvbSBhIGdpdmVuIHBpeGVsLiBUaGlzIGlzIHRoZSBpbnZlcnNlIG9mIGdldFBpeGVsRm9yVmFsdWVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKi9cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsb2NhdGlvbiBvZiB0aGUgdGljayBhdCB0aGUgZ2l2ZW4gaW5kZXhcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRQaXhlbEZvclRpY2soaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XS52YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgcGl4ZWwgbG9jYXRpb24gb2YgYSBwZXJjZW50YWdlIG9mIHNjYWxlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gZGVjaW1hbFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRQaXhlbEZvckRlY2ltYWwoZGVjaW1hbCkge1xuICAgIGlmICh0aGlzLl9yZXZlcnNlUGl4ZWxzKSB7XG4gICAgICBkZWNpbWFsID0gMSAtIGRlY2ltYWw7XG4gICAgfVxuXG4gICAgY29uc3QgcGl4ZWwgPSB0aGlzLl9zdGFydFBpeGVsICsgZGVjaW1hbCAqIHRoaXMuX2xlbmd0aDtcbiAgICByZXR1cm4gX2ludDE2UmFuZ2UodGhpcy5fYWxpZ25Ub1BpeGVscyA/IF9hbGlnblBpeGVsKHRoaXMuY2hhcnQsIHBpeGVsLCAwKSA6IHBpeGVsKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3QgZGVjaW1hbCA9IChwaXhlbCAtIHRoaXMuX3N0YXJ0UGl4ZWwpIC8gdGhpcy5fbGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9yZXZlcnNlUGl4ZWxzID8gMSAtIGRlY2ltYWwgOiBkZWNpbWFsO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHBpeGVsIGZvciB0aGUgbWluaW11bSBjaGFydCB2YWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0QmFzZVBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoKSk7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0QmFzZVZhbHVlKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzO1xuXG4gICAgcmV0dXJuIG1pbiA8IDAgJiYgbWF4IDwgMCA/IG1heCA6XG4gICAgICBtaW4gPiAwICYmIG1heCA+IDAgPyBtaW4gOlxuICAgICAgMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRDb250ZXh0KGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzIHx8IFtdO1xuXG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aWNrcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHRpY2sgPSB0aWNrc1tpbmRleF07XG4gICAgICByZXR1cm4gdGljay4kY29udGV4dCB8fFxuXHRcdFx0XHQodGljay4kY29udGV4dCA9IGNyZWF0ZVRpY2tDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgdGljaykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fFxuXHRcdFx0KHRoaXMuJGNvbnRleHQgPSBjcmVhdGVTY2FsZUNvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdGlja1NpemUoKSB7XG4gICAgY29uc3Qgb3B0aW9uVGlja3MgPSB0aGlzLm9wdGlvbnMudGlja3M7XG5cbiAgICAvLyBDYWxjdWxhdGUgc3BhY2UgbmVlZGVkIGJ5IGxhYmVsIGluIGF4aXMgZGlyZWN0aW9uLlxuICAgIGNvbnN0IHJvdCA9IHRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgIGNvbnN0IGNvcyA9IE1hdGguYWJzKE1hdGguY29zKHJvdCkpO1xuICAgIGNvbnN0IHNpbiA9IE1hdGguYWJzKE1hdGguc2luKHJvdCkpO1xuXG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCBwYWRkaW5nID0gb3B0aW9uVGlja3MuYXV0b1NraXBQYWRkaW5nIHx8IDA7XG4gICAgY29uc3QgdyA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLndpZGVzdC53aWR0aCArIHBhZGRpbmcgOiAwO1xuICAgIGNvbnN0IGggPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIHBhZGRpbmcgOiAwO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHNwYWNlIG5lZWRlZCBmb3IgMSB0aWNrIGluIGF4aXMgZGlyZWN0aW9uLlxuICAgIHJldHVybiB0aGlzLmlzSG9yaXpvbnRhbCgpXG4gICAgICA/IGggKiBjb3MgPiB3ICogc2luID8gdyAvIGNvcyA6IGggLyBzaW5cbiAgICAgIDogaCAqIHNpbiA8IHcgKiBjb3MgPyBoIC8gY29zIDogdyAvIHNpbjtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2lzVmlzaWJsZSgpIHtcbiAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5vcHRpb25zLmRpc3BsYXk7XG5cbiAgICBpZiAoZGlzcGxheSAhPT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gISFkaXNwbGF5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCkubGVuZ3RoID4gMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbXB1dGVHcmlkTGluZUl0ZW1zKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge2dyaWQsIHBvc2l0aW9uLCBib3JkZXJ9ID0gb3B0aW9ucztcbiAgICBjb25zdCBvZmZzZXQgPSBncmlkLm9mZnNldDtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCB0aWNrc0xlbmd0aCA9IHRpY2tzLmxlbmd0aCArIChvZmZzZXQgPyAxIDogMCk7XG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChncmlkKTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuXG4gICAgY29uc3QgYm9yZGVyT3B0cyA9IGJvcmRlci5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBheGlzV2lkdGggPSBib3JkZXJPcHRzLmRpc3BsYXkgPyBib3JkZXJPcHRzLndpZHRoIDogMDtcbiAgICBjb25zdCBheGlzSGFsZldpZHRoID0gYXhpc1dpZHRoIC8gMjtcbiAgICBjb25zdCBhbGlnbkJvcmRlclZhbHVlID0gZnVuY3Rpb24ocGl4ZWwpIHtcbiAgICAgIHJldHVybiBfYWxpZ25QaXhlbChjaGFydCwgcGl4ZWwsIGF4aXNXaWR0aCk7XG4gICAgfTtcbiAgICBsZXQgYm9yZGVyVmFsdWUsIGksIGxpbmVWYWx1ZSwgYWxpZ25lZExpbmVWYWx1ZTtcbiAgICBsZXQgdHgxLCB0eTEsIHR4MiwgdHkyLCB4MSwgeTEsIHgyLCB5MjtcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmJvdHRvbSk7XG4gICAgICB0eTEgPSB0aGlzLmJvdHRvbSAtIHRsO1xuICAgICAgdHkyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgeTEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS50b3ApICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMudG9wKTtcbiAgICAgIHkxID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHkyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEuYm90dG9tKSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTIgPSB0aGlzLnRvcCArIHRsO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMucmlnaHQpO1xuICAgICAgdHgxID0gdGhpcy5yaWdodCAtIHRsO1xuICAgICAgdHgyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgeDEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5sZWZ0KSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB4MiA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5sZWZ0KTtcbiAgICAgIHgxID0gY2hhcnRBcmVhLmxlZnQ7XG4gICAgICB4MiA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnJpZ2h0KSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDIgPSB0aGlzLmxlZnQgKyB0bDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDIgKyAwLjUpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgIH1cblxuICAgICAgeTEgPSBjaGFydEFyZWEudG9wO1xuICAgICAgeTIgPSBjaGFydEFyZWEuYm90dG9tO1xuICAgICAgdHkxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHkyID0gdHkxICsgdGw7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSk7XG4gICAgICB9XG5cbiAgICAgIHR4MSA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MiA9IHR4MSAtIHRsO1xuICAgICAgeDEgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgIHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuICAgIH1cblxuICAgIGNvbnN0IGxpbWl0ID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy50aWNrcy5tYXhUaWNrc0xpbWl0LCB0aWNrc0xlbmd0aCk7XG4gICAgY29uc3Qgc3RlcCA9IE1hdGgubWF4KDEsIE1hdGguY2VpbCh0aWNrc0xlbmd0aCAvIGxpbWl0KSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRpY2tzTGVuZ3RoOyBpICs9IHN0ZXApIHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldENvbnRleHQoaSk7XG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGdyaWQuc2V0Q29udGV4dChjb250ZXh0KTtcbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4Qm9yZGVyID0gYm9yZGVyLnNldENvbnRleHQoY29udGV4dCk7XG5cbiAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IG9wdHNBdEluZGV4LmxpbmVXaWR0aDtcbiAgICAgIGNvbnN0IGxpbmVDb2xvciA9IG9wdHNBdEluZGV4LmNvbG9yO1xuICAgICAgY29uc3QgYm9yZGVyRGFzaCA9IG9wdHNBdEluZGV4Qm9yZGVyLmRhc2ggfHwgW107XG4gICAgICBjb25zdCBib3JkZXJEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXhCb3JkZXIuZGFzaE9mZnNldDtcblxuICAgICAgY29uc3QgdGlja1dpZHRoID0gb3B0c0F0SW5kZXgudGlja1dpZHRoO1xuICAgICAgY29uc3QgdGlja0NvbG9yID0gb3B0c0F0SW5kZXgudGlja0NvbG9yO1xuICAgICAgY29uc3QgdGlja0JvcmRlckRhc2ggPSBvcHRzQXRJbmRleC50aWNrQm9yZGVyRGFzaCB8fCBbXTtcbiAgICAgIGNvbnN0IHRpY2tCb3JkZXJEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXgudGlja0JvcmRlckRhc2hPZmZzZXQ7XG5cbiAgICAgIGxpbmVWYWx1ZSA9IGdldFBpeGVsRm9yR3JpZExpbmUodGhpcywgaSwgb2Zmc2V0KTtcblxuICAgICAgLy8gU2tpcCBpZiB0aGUgcGl4ZWwgaXMgb3V0IG9mIHRoZSByYW5nZVxuICAgICAgaWYgKGxpbmVWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBhbGlnbmVkTGluZVZhbHVlID0gX2FsaWduUGl4ZWwoY2hhcnQsIGxpbmVWYWx1ZSwgbGluZVdpZHRoKTtcblxuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB0eDEgPSB0eDIgPSB4MSA9IHgyID0gYWxpZ25lZExpbmVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5MSA9IHR5MiA9IHkxID0geTIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgdHgxLFxuICAgICAgICB0eTEsXG4gICAgICAgIHR4MixcbiAgICAgICAgdHkyLFxuICAgICAgICB4MSxcbiAgICAgICAgeTEsXG4gICAgICAgIHgyLFxuICAgICAgICB5MixcbiAgICAgICAgd2lkdGg6IGxpbmVXaWR0aCxcbiAgICAgICAgY29sb3I6IGxpbmVDb2xvcixcbiAgICAgICAgYm9yZGVyRGFzaCxcbiAgICAgICAgYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgdGlja1dpZHRoLFxuICAgICAgICB0aWNrQ29sb3IsXG4gICAgICAgIHRpY2tCb3JkZXJEYXNoLFxuICAgICAgICB0aWNrQm9yZGVyRGFzaE9mZnNldCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gdGlja3NMZW5ndGg7XG4gICAgdGhpcy5fYm9yZGVyVmFsdWUgPSBib3JkZXJWYWx1ZTtcblxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzOiBvcHRpb25UaWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IHthbGlnbiwgY3Jvc3NBbGlnbiwgcGFkZGluZywgbWlycm9yfSA9IG9wdGlvblRpY2tzO1xuICAgIGNvbnN0IHRsID0gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucy5ncmlkKTtcbiAgICBjb25zdCB0aWNrQW5kUGFkZGluZyA9IHRsICsgcGFkZGluZztcbiAgICBjb25zdCBoVGlja0FuZFBhZGRpbmcgPSBtaXJyb3IgPyAtcGFkZGluZyA6IHRpY2tBbmRQYWRkaW5nO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gLXRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgbGV0IGksIGlsZW4sIHRpY2ssIGxhYmVsLCB4LCB5LCB0ZXh0QWxpZ24sIHBpeGVsLCBmb250LCBsaW5lSGVpZ2h0LCBsaW5lQ291bnQsIHRleHRPZmZzZXQ7XG4gICAgbGV0IHRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgeSA9IHRoaXMuYm90dG9tIC0gaFRpY2tBbmRQYWRkaW5nO1xuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICB5ID0gdGhpcy50b3AgKyBoVGlja0FuZFBhZGRpbmc7XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBjb25zdCByZXQgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICB4ID0gcmV0Lng7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgY29uc3QgcmV0ID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCk7XG4gICAgICB0ZXh0QWxpZ24gPSByZXQudGV4dEFsaWduO1xuICAgICAgeCA9IHJldC54O1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHkgPSAoKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDIpICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIHkgPSB0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgIH1cbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICB4ID0gKChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyKSAtIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICB4ID0gdGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCkudGV4dEFsaWduO1xuICAgIH1cblxuICAgIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICB0ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgbGFiZWwgPSB0aWNrLmxhYmVsO1xuXG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IG9wdGlvblRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGkpKTtcbiAgICAgIHBpeGVsID0gdGhpcy5nZXRQaXhlbEZvclRpY2soaSkgKyBvcHRpb25UaWNrcy5sYWJlbE9mZnNldDtcbiAgICAgIGZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGkpO1xuICAgICAgbGluZUhlaWdodCA9IGZvbnQubGluZUhlaWdodDtcbiAgICAgIGxpbmVDb3VudCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwubGVuZ3RoIDogMTtcbiAgICAgIGNvbnN0IGhhbGZDb3VudCA9IGxpbmVDb3VudCAvIDI7XG4gICAgICBjb25zdCBjb2xvciA9IG9wdHNBdEluZGV4LmNvbG9yO1xuICAgICAgY29uc3Qgc3Ryb2tlQ29sb3IgPSBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlQ29sb3I7XG4gICAgICBjb25zdCBzdHJva2VXaWR0aCA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VXaWR0aDtcbiAgICAgIGxldCB0aWNrVGV4dEFsaWduID0gdGV4dEFsaWduO1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHggPSBwaXhlbDtcblxuICAgICAgICBpZiAodGV4dEFsaWduID09PSAnaW5uZXInKSB7XG4gICAgICAgICAgaWYgKGkgPT09IGlsZW4gLSAxKSB7XG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gIXRoaXMub3B0aW9ucy5yZXZlcnNlID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAhdGhpcy5vcHRpb25zLnJldmVyc2UgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicgfHwgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGluZUNvdW50ICogbGluZUhlaWdodCArIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAvIDIgLSBoYWxmQ291bnQgKiBsaW5lSGVpZ2h0ICsgbGluZUhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lbHktaWZcbiAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLyAyIC0gaGFsZkNvdW50ICogbGluZUhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLSBsaW5lQ291bnQgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgICAgdGV4dE9mZnNldCAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm90YXRpb24gIT09IDAgJiYgIW9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgICAgeCArPSAobGluZUhlaWdodCAvIDIpICogTWF0aC5zaW4ocm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5ID0gcGl4ZWw7XG4gICAgICAgIHRleHRPZmZzZXQgPSAoMSAtIGxpbmVDb3VudCkgKiBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgIH1cblxuICAgICAgbGV0IGJhY2tkcm9wO1xuXG4gICAgICBpZiAob3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgY29uc3QgbGFiZWxQYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGxhYmVsU2l6ZXMuaGVpZ2h0c1tpXTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBsYWJlbFNpemVzLndpZHRoc1tpXTtcblxuICAgICAgICBsZXQgdG9wID0gdGV4dE9mZnNldCAtIGxhYmVsUGFkZGluZy50b3A7XG4gICAgICAgIGxldCBsZWZ0ID0gMCAtIGxhYmVsUGFkZGluZy5sZWZ0O1xuXG4gICAgICAgIHN3aXRjaCAodGV4dEJhc2VsaW5lKSB7XG4gICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgdG9wIC09IGhlaWdodCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodGV4dEFsaWduKSB7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbm5lcic6XG4gICAgICAgICAgaWYgKGkgPT09IGlsZW4gLSAxKSB7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGggLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGJhY2tkcm9wID0ge1xuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCArIGxhYmVsUGFkZGluZy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCArIGxhYmVsUGFkZGluZy5oZWlnaHQsXG5cbiAgICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguYmFja2Ryb3BDb2xvcixcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgIGxhYmVsLFxuICAgICAgICBmb250LFxuICAgICAgICB0ZXh0T2Zmc2V0LFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgc3Ryb2tlQ29sb3IsXG4gICAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgdGV4dEFsaWduOiB0aWNrVGV4dEFsaWduLFxuICAgICAgICAgIHRleHRCYXNlbGluZSxcbiAgICAgICAgICB0cmFuc2xhdGlvbjogW3gsIHldLFxuICAgICAgICAgIGJhY2tkcm9wLFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICBfZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpIHtcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCByb3RhdGlvbiA9IC10b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcblxuICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfVxuXG4gICAgbGV0IGFsaWduID0gJ2NlbnRlcic7XG5cbiAgICBpZiAodGlja3MuYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgIGFsaWduID0gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICBhbGlnbiA9ICdyaWdodCc7XG4gICAgfSBlbHNlIGlmICh0aWNrcy5hbGlnbiA9PT0gJ2lubmVyJykge1xuICAgICAgYWxpZ24gPSAnaW5uZXInO1xuICAgIH1cblxuICAgIHJldHVybiBhbGlnbjtcbiAgfVxuXG4gIF9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKSB7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrczoge2Nyb3NzQWxpZ24sIG1pcnJvciwgcGFkZGluZ319ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgdGlja0FuZFBhZGRpbmcgPSB0bCArIHBhZGRpbmc7XG4gICAgY29uc3Qgd2lkZXN0ID0gbGFiZWxTaXplcy53aWRlc3Qud2lkdGg7XG5cbiAgICBsZXQgdGV4dEFsaWduO1xuICAgIGxldCB4O1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgeCA9IHRoaXMucmlnaHQgKyBwYWRkaW5nO1xuXG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4ICs9ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgIHggKz0gd2lkZXN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gdGhpcy5yaWdodCAtIHRpY2tBbmRQYWRkaW5nO1xuXG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCAtPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIHggPSB0aGlzLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgIHggPSB0aGlzLmxlZnQgKyBwYWRkaW5nO1xuXG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCAtPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIHggLT0gd2lkZXN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gdGhpcy5sZWZ0ICsgdGlja0FuZFBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggKz0gd2lkZXN0IC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgIHggPSB0aGlzLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHt0ZXh0QWxpZ24sIHh9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUxhYmVsQXJlYSgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRpY2tzLm1pcnJvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICByZXR1cm4ge3RvcDogMCwgbGVmdDogdGhpcy5sZWZ0LCBib3R0b206IGNoYXJ0LmhlaWdodCwgcmlnaHQ6IHRoaXMucmlnaHR9O1xuICAgIH0gaWYgKHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHJldHVybiB7dG9wOiB0aGlzLnRvcCwgbGVmdDogMCwgYm90dG9tOiB0aGlzLmJvdHRvbSwgcmlnaHQ6IGNoYXJ0LndpZHRofTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3Qge2N0eCwgb3B0aW9uczoge2JhY2tncm91bmRDb2xvcn0sIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodH0gPSB0aGlzO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIGdldExpbmVXaWR0aEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgZ3JpZCA9IHRoaXMub3B0aW9ucy5ncmlkO1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIWdyaWQuZGlzcGxheSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCBpbmRleCA9IHRpY2tzLmZpbmRJbmRleCh0ID0+IHQudmFsdWUgPT09IHZhbHVlKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgY29uc3Qgb3B0cyA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICAgIHJldHVybiBvcHRzLmxpbmVXaWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0dyaWQoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgZ3JpZCA9IHRoaXMub3B0aW9ucy5ncmlkO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fZ3JpZExpbmVJdGVtcyB8fCAodGhpcy5fZ3JpZExpbmVJdGVtcyA9IHRoaXMuX2NvbXB1dGVHcmlkTGluZUl0ZW1zKGNoYXJ0QXJlYSkpO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgY29uc3QgZHJhd0xpbmUgPSAocDEsIHAyLCBzdHlsZSkgPT4ge1xuICAgICAgaWYgKCFzdHlsZS53aWR0aCB8fCAhc3R5bGUuY29sb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgY3R4LnNldExpbmVEYXNoKHN0eWxlLmJvcmRlckRhc2ggfHwgW10pO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gc3R5bGUuYm9yZGVyRGFzaE9mZnNldDtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhwMS54LCBwMS55KTtcbiAgICAgIGN0eC5saW5lVG8ocDIueCwgcDIueSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG5cbiAgICBpZiAoZ3JpZC5kaXNwbGF5KSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcblxuICAgICAgICBpZiAoZ3JpZC5kcmF3T25DaGFydEFyZWEpIHtcbiAgICAgICAgICBkcmF3TGluZShcbiAgICAgICAgICAgIHt4OiBpdGVtLngxLCB5OiBpdGVtLnkxfSxcbiAgICAgICAgICAgIHt4OiBpdGVtLngyLCB5OiBpdGVtLnkyfSxcbiAgICAgICAgICAgIGl0ZW1cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdyaWQuZHJhd1RpY2tzKSB7XG4gICAgICAgICAgZHJhd0xpbmUoXG4gICAgICAgICAgICB7eDogaXRlbS50eDEsIHk6IGl0ZW0udHkxfSxcbiAgICAgICAgICAgIHt4OiBpdGVtLnR4MiwgeTogaXRlbS50eTJ9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb2xvcjogaXRlbS50aWNrQ29sb3IsXG4gICAgICAgICAgICAgIHdpZHRoOiBpdGVtLnRpY2tXaWR0aCxcbiAgICAgICAgICAgICAgYm9yZGVyRGFzaDogaXRlbS50aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogaXRlbS50aWNrQm9yZGVyRGFzaE9mZnNldFxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0JvcmRlcigpIHtcbiAgICBjb25zdCB7Y2hhcnQsIGN0eCwgb3B0aW9uczoge2JvcmRlciwgZ3JpZH19ID0gdGhpcztcbiAgICBjb25zdCBib3JkZXJPcHRzID0gYm9yZGVyLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGF4aXNXaWR0aCA9IGJvcmRlci5kaXNwbGF5ID8gYm9yZGVyT3B0cy53aWR0aCA6IDA7XG4gICAgaWYgKCFheGlzV2lkdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFzdExpbmVXaWR0aCA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoMCkpLmxpbmVXaWR0aDtcbiAgICBjb25zdCBib3JkZXJWYWx1ZSA9IHRoaXMuX2JvcmRlclZhbHVlO1xuICAgIGxldCB4MSwgeDIsIHkxLCB5MjtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB4MSA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLmxlZnQsIGF4aXNXaWR0aCkgLSBheGlzV2lkdGggLyAyO1xuICAgICAgeDIgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5yaWdodCwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcbiAgICAgIHkxID0geTIgPSBib3JkZXJWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgeTEgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy50b3AsIGF4aXNXaWR0aCkgLSBheGlzV2lkdGggLyAyO1xuICAgICAgeTIgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5ib3R0b20sIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG4gICAgICB4MSA9IHgyID0gYm9yZGVyVmFsdWU7XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlck9wdHMud2lkdGg7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyT3B0cy5jb2xvcjtcblxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgIGN0eC5zdHJva2UoKTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0xhYmVscyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcblxuICAgIGlmICghb3B0aW9uVGlja3MuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuXG4gICAgY29uc3QgYXJlYSA9IHRoaXMuX2NvbXB1dGVMYWJlbEFyZWEoKTtcbiAgICBpZiAoYXJlYSkge1xuICAgICAgY2xpcEFyZWEoY3R4LCBhcmVhKTtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuZ2V0TGFiZWxJdGVtcyhjaGFydEFyZWEpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgY29uc3QgcmVuZGVyVGV4dE9wdGlvbnMgPSBpdGVtLm9wdGlvbnM7XG4gICAgICBjb25zdCB0aWNrRm9udCA9IGl0ZW0uZm9udDtcbiAgICAgIGNvbnN0IGxhYmVsID0gaXRlbS5sYWJlbDtcbiAgICAgIGNvbnN0IHkgPSBpdGVtLnRleHRPZmZzZXQ7XG4gICAgICByZW5kZXJUZXh0KGN0eCwgbGFiZWwsIDAsIHksIHRpY2tGb250LCByZW5kZXJUZXh0T3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGFyZWEpIHtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd1RpdGxlKCkge1xuICAgIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtwb3NpdGlvbiwgdGl0bGUsIHJldmVyc2V9fSA9IHRoaXM7XG5cbiAgICBpZiAoIXRpdGxlLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBmb250ID0gdG9Gb250KHRpdGxlLmZvbnQpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGUucGFkZGluZyk7XG4gICAgY29uc3QgYWxpZ24gPSB0aXRsZS5hbGlnbjtcbiAgICBsZXQgb2Zmc2V0ID0gZm9udC5saW5lSGVpZ2h0IC8gMjtcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgcG9zaXRpb24gPT09ICdjZW50ZXInIHx8IGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgb2Zmc2V0ICs9IHBhZGRpbmcuYm90dG9tO1xuICAgICAgaWYgKGlzQXJyYXkodGl0bGUudGV4dCkpIHtcbiAgICAgICAgb2Zmc2V0ICs9IGZvbnQubGluZUhlaWdodCAqICh0aXRsZS50ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgKz0gcGFkZGluZy50b3A7XG4gICAgfVxuXG4gICAgY29uc3Qge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259ID0gdGl0bGVBcmdzKHRoaXMsIG9mZnNldCwgcG9zaXRpb24sIGFsaWduKTtcblxuICAgIHJlbmRlclRleHQoY3R4LCB0aXRsZS50ZXh0LCAwLCAwLCBmb250LCB7XG4gICAgICBjb2xvcjogdGl0bGUuY29sb3IsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgdGV4dEFsaWduOiB0aXRsZUFsaWduKGFsaWduLCBwb3NpdGlvbiwgcmV2ZXJzZSksXG4gICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgdHJhbnNsYXRpb246IFt0aXRsZVgsIHRpdGxlWV0sXG4gICAgfSk7XG4gIH1cblxuICBkcmF3KGNoYXJ0QXJlYSkge1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7XG4gICAgdGhpcy5kcmF3R3JpZChjaGFydEFyZWEpO1xuICAgIHRoaXMuZHJhd0JvcmRlcigpO1xuICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgdGhpcy5kcmF3TGFiZWxzKGNoYXJ0QXJlYSk7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7b2JqZWN0W119XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfbGF5ZXJzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdHogPSBvcHRzLnRpY2tzICYmIG9wdHMudGlja3MueiB8fCAwO1xuICAgIGNvbnN0IGd6ID0gdmFsdWVPckRlZmF1bHQob3B0cy5ncmlkICYmIG9wdHMuZ3JpZC56LCAtMSk7XG4gICAgY29uc3QgYnogPSB2YWx1ZU9yRGVmYXVsdChvcHRzLmJvcmRlciAmJiBvcHRzLmJvcmRlci56LCAwKTtcblxuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgdGhpcy5kcmF3ICE9PSBTY2FsZS5wcm90b3R5cGUuZHJhdykge1xuICAgICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eTogZHJhdyBoYXMgYmVlbiBvdmVycmlkZGVuIGJ5IGN1c3RvbSBzY2FsZVxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHo6IHR6LFxuICAgICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgICAgdGhpcy5kcmF3KGNoYXJ0QXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH1cblxuICAgIHJldHVybiBbe1xuICAgICAgejogZ3osXG4gICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcbiAgICAgICAgdGhpcy5kcmF3R3JpZChjaGFydEFyZWEpO1xuICAgICAgICB0aGlzLmRyYXdUaXRsZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IGJ6LFxuICAgICAgZHJhdzogKCkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdCb3JkZXIoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB6OiB0eixcbiAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3TGFiZWxzKGNoYXJ0QXJlYSk7XG4gICAgICB9XG4gICAgfV07XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB2aXNpYmxlIGRhdGFzZXQgbWV0YXMgdGhhdCBhcmUgYXR0YWNoZWQgdG8gdGhpcyBzY2FsZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIC0gaWYgc3BlY2lmaWVkLCBhbHNvIGZpbHRlciBieSBkYXRhc2V0IHR5cGVcblx0ICogQHJldHVybiB7b2JqZWN0W119XG5cdCAqL1xuICBnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKSB7XG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBjb25zdCBheGlzSUQgPSB0aGlzLmF4aXMgKyAnQXhpc0lEJztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBtZXRhc1tpXTtcbiAgICAgIGlmIChtZXRhW2F4aXNJRF0gPT09IHRoaXMuaWQgJiYgKCF0eXBlIHx8IG1ldGEudHlwZSA9PT0gdHlwZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobWV0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEByZXR1cm4ge29iamVjdH1cblx0ICogQHByb3RlY3RlZFxuIFx0ICovXG4gIF9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGluZGV4KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgIHJldHVybiB0b0ZvbnQob3B0cy5mb250KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfbWF4RGlnaXRzKCkge1xuICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKS5saW5lSGVpZ2h0O1xuICAgIHJldHVybiAodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodCkgLyBmb250U2l6ZTtcbiAgfVxufVxuIiwgImltcG9ydCB7bWVyZ2V9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IGRlZmF1bHRzLCB7b3ZlcnJpZGVzfSBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7aWQ6IHN0cmluZywgZGVmYXVsdHM6IGFueSwgb3ZlcnJpZGVzPzogYW55LCBkZWZhdWx0Um91dGVzOiBhbnl9fSBJQ2hhcnRDb21wb25lbnRcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUeXBlZFJlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IodHlwZSwgc2NvcGUsIG92ZXJyaWRlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgdGhpcy5vdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgIHRoaXMuaXRlbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG5cbiAgaXNGb3JUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwodGhpcy50eXBlLnByb3RvdHlwZSwgdHlwZS5wcm90b3R5cGUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SUNoYXJ0Q29tcG9uZW50fSBpdGVtXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzY29wZSB3aGVyZSBpdGVtcyBkZWZhdWx0cyB3ZXJlIHJlZ2lzdGVyZWQgdG8uXG5cdCAqL1xuICByZWdpc3RlcihpdGVtKSB7XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaXRlbSk7XG4gICAgbGV0IHBhcmVudFNjb3BlO1xuXG4gICAgaWYgKGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSkge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwYXJlbnQgaXMgcmVnaXN0ZXJlZCBhbmQgbm90ZSB0aGUgc2NvcGUgd2hlcmUgaXRzIGRlZmF1bHRzIGFyZS5cbiAgICAgIHBhcmVudFNjb3BlID0gdGhpcy5yZWdpc3Rlcihwcm90byk7XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGUgKyAnLicgKyBpZDtcblxuICAgIGlmICghaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xhc3MgZG9lcyBub3QgaGF2ZSBpZDogJyArIGl0ZW0pO1xuICAgIH1cblxuICAgIGlmIChpZCBpbiBpdGVtcykge1xuICAgICAgLy8gYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuXG4gICAgaXRlbXNbaWRdID0gaXRlbTtcbiAgICByZWdpc3RlckRlZmF1bHRzKGl0ZW0sIHNjb3BlLCBwYXJlbnRTY29wZSk7XG4gICAgaWYgKHRoaXMub3ZlcnJpZGUpIHtcbiAgICAgIGRlZmF1bHRzLm92ZXJyaWRlKGl0ZW0uaWQsIGl0ZW0ub3ZlcnJpZGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NvcGU7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqIEByZXR1cm5zIHtvYmplY3Q/fVxuXHQgKi9cbiAgZ2V0KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXNbaWRdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SUNoYXJ0Q29tcG9uZW50fSBpdGVtXG5cdCAqL1xuICB1bnJlZ2lzdGVyKGl0ZW0pIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgY29uc3QgaWQgPSBpdGVtLmlkO1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZTtcblxuICAgIGlmIChpZCBpbiBpdGVtcykge1xuICAgICAgZGVsZXRlIGl0ZW1zW2lkXTtcbiAgICB9XG5cbiAgICBpZiAoc2NvcGUgJiYgaWQgaW4gZGVmYXVsdHNbc2NvcGVdKSB7XG4gICAgICBkZWxldGUgZGVmYXVsdHNbc2NvcGVdW2lkXTtcbiAgICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZWdpc3RlckRlZmF1bHRzKGl0ZW0sIHNjb3BlLCBwYXJlbnRTY29wZSkge1xuICAvLyBJbmhlcml0IHRoZSBwYXJlbnQncyBkZWZhdWx0cyBhbmQga2VlcCBleGlzdGluZyBkZWZhdWx0c1xuICBjb25zdCBpdGVtRGVmYXVsdHMgPSBtZXJnZShPYmplY3QuY3JlYXRlKG51bGwpLCBbXG4gICAgcGFyZW50U2NvcGUgPyBkZWZhdWx0cy5nZXQocGFyZW50U2NvcGUpIDoge30sXG4gICAgZGVmYXVsdHMuZ2V0KHNjb3BlKSxcbiAgICBpdGVtLmRlZmF1bHRzXG4gIF0pO1xuXG4gIGRlZmF1bHRzLnNldChzY29wZSwgaXRlbURlZmF1bHRzKTtcblxuICBpZiAoaXRlbS5kZWZhdWx0Um91dGVzKSB7XG4gICAgcm91dGVEZWZhdWx0cyhzY29wZSwgaXRlbS5kZWZhdWx0Um91dGVzKTtcbiAgfVxuXG4gIGlmIChpdGVtLmRlc2NyaXB0b3JzKSB7XG4gICAgZGVmYXVsdHMuZGVzY3JpYmUoc2NvcGUsIGl0ZW0uZGVzY3JpcHRvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJvdXRlRGVmYXVsdHMoc2NvcGUsIHJvdXRlcykge1xuICBPYmplY3Qua2V5cyhyb3V0ZXMpLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgIGNvbnN0IHByb3BlcnR5UGFydHMgPSBwcm9wZXJ0eS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBwcm9wZXJ0eVBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHNvdXJjZVNjb3BlID0gW3Njb3BlXS5jb25jYXQocHJvcGVydHlQYXJ0cykuam9pbignLicpO1xuICAgIGNvbnN0IHBhcnRzID0gcm91dGVzW3Byb3BlcnR5XS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHRhcmdldE5hbWUgPSBwYXJ0cy5wb3AoKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZSA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgICBkZWZhdWx0cy5yb3V0ZShzb3VyY2VTY29wZSwgc291cmNlTmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pIHtcbiAgcmV0dXJuICdpZCcgaW4gcHJvdG8gJiYgJ2RlZmF1bHRzJyBpbiBwcm90bztcbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCBFbGVtZW50IGZyb20gJy4vY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCBTY2FsZSBmcm9tICcuL2NvcmUuc2NhbGUuanMnO1xuaW1wb3J0IFR5cGVkUmVnaXN0cnkgZnJvbSAnLi9jb3JlLnR5cGVkUmVnaXN0cnkuanMnO1xuaW1wb3J0IHtlYWNoLCBjYWxsYmFjayBhcyBjYWxsLCBfY2FwaXRhbGl6ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIFBsZWFzZSB1c2UgdGhlIG1vZHVsZSdzIGRlZmF1bHQgZXhwb3J0IHdoaWNoIHByb3ZpZGVzIGEgc2luZ2xldG9uIGluc3RhbmNlXG4gKiBOb3RlOiBjbGFzcyBpcyBleHBvcnRlZCBmb3IgdHlwZWRvY1xuICovXG5leHBvcnQgY2xhc3MgUmVnaXN0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXJzID0gbmV3IFR5cGVkUmVnaXN0cnkoRGF0YXNldENvbnRyb2xsZXIsICdkYXRhc2V0cycsIHRydWUpO1xuICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgVHlwZWRSZWdpc3RyeShFbGVtZW50LCAnZWxlbWVudHMnKTtcbiAgICB0aGlzLnBsdWdpbnMgPSBuZXcgVHlwZWRSZWdpc3RyeShPYmplY3QsICdwbHVnaW5zJyk7XG4gICAgdGhpcy5zY2FsZXMgPSBuZXcgVHlwZWRSZWdpc3RyeShTY2FsZSwgJ3NjYWxlcycpO1xuICAgIC8vIE9yZGVyIGlzIGltcG9ydGFudCwgU2NhbGUgaGFzIEVsZW1lbnQgaW4gcHJvdG90eXBlIGNoYWluLFxuICAgIC8vIHNvIFNjYWxlcyBtdXN0IGJlIGJlZm9yZSBFbGVtZW50cy4gUGx1Z2lucyBhcmUgYSBmYWxsYmFjaywgc28gbm90IGxpc3RlZCBoZXJlLlxuICAgIHRoaXMuX3R5cGVkUmVnaXN0cmllcyA9IFt0aGlzLmNvbnRyb2xsZXJzLCB0aGlzLnNjYWxlcywgdGhpcy5lbGVtZW50c107XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4uYW55fSBhcmdzXG5cdCAqL1xuICBhZGQoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncyk7XG4gIH1cblxuICByZW1vdmUoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi50eXBlb2YgRGF0YXNldENvbnRyb2xsZXJ9IGFyZ3Ncblx0ICovXG4gIGFkZENvbnRyb2xsZXJzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBFbGVtZW50fSBhcmdzXG5cdCAqL1xuICBhZGRFbGVtZW50cyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3Ncblx0ICovXG4gIGFkZFBsdWdpbnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5wbHVnaW5zKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi50eXBlb2YgU2NhbGV9IGFyZ3Ncblx0ICovXG4gIGFkZFNjYWxlcyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqIEByZXR1cm5zIHt0eXBlb2YgRGF0YXNldENvbnRyb2xsZXJ9XG5cdCAqL1xuICBnZXRDb250cm9sbGVyKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5jb250cm9sbGVycywgJ2NvbnRyb2xsZXInKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge3R5cGVvZiBFbGVtZW50fVxuXHQgKi9cbiAgZ2V0RWxlbWVudChpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuZWxlbWVudHMsICdlbGVtZW50Jyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9XG5cdCAqL1xuICBnZXRQbHVnaW4oaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLnBsdWdpbnMsICdwbHVnaW4nKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge3R5cGVvZiBTY2FsZX1cblx0ICovXG4gIGdldFNjYWxlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5zY2FsZXMsICdzY2FsZScpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBEYXRhc2V0Q29udHJvbGxlcn0gYXJnc1xuXHQgKi9cbiAgcmVtb3ZlQ29udHJvbGxlcnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLmNvbnRyb2xsZXJzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi50eXBlb2YgRWxlbWVudH0gYXJnc1xuXHQgKi9cbiAgcmVtb3ZlRWxlbWVudHMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3Ncblx0ICovXG4gIHJlbW92ZVBsdWdpbnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnBsdWdpbnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBTY2FsZX0gYXJnc1xuXHQgKi9cbiAgcmVtb3ZlU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5zY2FsZXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZWFjaChtZXRob2QsIGFyZ3MsIHR5cGVkUmVnaXN0cnkpIHtcbiAgICBbLi4uYXJnc10uZm9yRWFjaChhcmcgPT4ge1xuICAgICAgY29uc3QgcmVnID0gdHlwZWRSZWdpc3RyeSB8fCB0aGlzLl9nZXRSZWdpc3RyeUZvclR5cGUoYXJnKTtcbiAgICAgIGlmICh0eXBlZFJlZ2lzdHJ5IHx8IHJlZy5pc0ZvclR5cGUoYXJnKSB8fCAocmVnID09PSB0aGlzLnBsdWdpbnMgJiYgYXJnLmlkKSkge1xuICAgICAgICB0aGlzLl9leGVjKG1ldGhvZCwgcmVnLCBhcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFuZGxlIGxvb3BhYmxlIGFyZ3NcbiAgICAgICAgLy8gVXNlIGNhc2U6XG4gICAgICAgIC8vICBpbXBvcnQgKiBhcyBwbHVnaW5zIGZyb20gJy4vcGx1Z2lucy5qcyc7XG4gICAgICAgIC8vICBDaGFydC5yZWdpc3RlcihwbHVnaW5zKTtcbiAgICAgICAgZWFjaChhcmcsIGl0ZW0gPT4ge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBtaXhlZCB0eXBlcyBpbiB0aGUgbG9vcGFibGUsIG1ha2Ugc3VyZSB0aG9zZSBhcmVcbiAgICAgICAgICAvLyByZWdpc3RlcmVkIGluIGNvcnJlY3QgcmVnaXN0cnlcbiAgICAgICAgICAvLyBVc2UgY2FzZTogKHRyZWVtYXAgZXhwb3J0aW5nIGNvbnRyb2xsZXIsIGVsZW1lbnRzIGV0YylcbiAgICAgICAgICAvLyAgaW1wb3J0ICogYXMgdHJlZW1hcCBmcm9tICdjaGFydGpzLWNoYXJ0LXRyZWVtYXAuanMnO1xuICAgICAgICAgIC8vICBDaGFydC5yZWdpc3Rlcih0cmVlbWFwKTtcblxuICAgICAgICAgIGNvbnN0IGl0ZW1SZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShpdGVtKTtcbiAgICAgICAgICB0aGlzLl9leGVjKG1ldGhvZCwgaXRlbVJlZywgaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZXhlYyhtZXRob2QsIHJlZ2lzdHJ5LCBjb21wb25lbnQpIHtcbiAgICBjb25zdCBjYW1lbE1ldGhvZCA9IF9jYXBpdGFsaXplKG1ldGhvZCk7XG4gICAgY2FsbChjb21wb25lbnRbJ2JlZm9yZScgKyBjYW1lbE1ldGhvZF0sIFtdLCBjb21wb25lbnQpOyAvLyBiZWZvcmVSZWdpc3RlciAvIGJlZm9yZVVucmVnaXN0ZXJcbiAgICByZWdpc3RyeVttZXRob2RdKGNvbXBvbmVudCk7XG4gICAgY2FsbChjb21wb25lbnRbJ2FmdGVyJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7IC8vIGFmdGVyUmVnaXN0ZXIgLyBhZnRlclVucmVnaXN0ZXJcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJlZ2lzdHJ5Rm9yVHlwZSh0eXBlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90eXBlZFJlZ2lzdHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlZyA9IHRoaXMuX3R5cGVkUmVnaXN0cmllc1tpXTtcbiAgICAgIGlmIChyZWcuaXNGb3JUeXBlKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiByZWc7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHBsdWdpbnMgaXMgdGhlIGZhbGxiYWNrIHJlZ2lzdHJ5XG4gICAgcmV0dXJuIHRoaXMucGx1Z2lucztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldChpZCwgdHlwZWRSZWdpc3RyeSwgdHlwZSkge1xuICAgIGNvbnN0IGl0ZW0gPSB0eXBlZFJlZ2lzdHJ5LmdldChpZCk7XG4gICAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBpZCArICdcIiBpcyBub3QgYSByZWdpc3RlcmVkICcgKyB0eXBlICsgJy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxufVxuXG4vLyBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBkZWZhdWx0IC8qICNfX1BVUkVfXyAqLyBuZXcgUmVnaXN0cnkoKTtcbiIsICJpbXBvcnQgcmVnaXN0cnkgZnJvbSAnLi9jb3JlLnJlZ2lzdHJ5LmpzJztcbmltcG9ydCB7Y2FsbGJhY2sgYXMgY2FsbENhbGxiYWNrLCBpc051bGxPclVuZGVmLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9wbHVnaW5zL3BsdWdpbi50b29sdGlwLmpzJykuZGVmYXVsdCB9IFRvb2x0aXBcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBmaWx0ZXJDYWxsYmFja1xuICogQHBhcmFtIHt7cGx1Z2luOiBvYmplY3QsIG9wdGlvbnM6IG9iamVjdH19IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XVxuICogQHBhcmFtIHthcnJheX0gW2FycmF5XVxuICogQHBhcmFtIHtvYmplY3R9IFt0aGlzQXJnXVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBsdWdpblNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pbml0ID0gW107XG4gIH1cblxuICAvKipcblx0ICogQ2FsbHMgZW5hYmxlZCBwbHVnaW5zIGZvciBgY2hhcnRgIG9uIHRoZSBzcGVjaWZpZWQgaG9vayBhbmQgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cblx0ICogVGhpcyBtZXRob2QgaW1tZWRpYXRlbHkgcmV0dXJucyBhcyBzb29uIGFzIGEgcGx1Z2luIGV4cGxpY2l0bHkgcmV0dXJucyBmYWxzZS4gVGhlXG5cdCAqIHJldHVybmVkIHZhbHVlIGNhbiBiZSB1c2VkLCBmb3IgaW5zdGFuY2UsIHRvIGludGVycnVwdCB0aGUgY3VycmVudCBhY3Rpb24uXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlIGZvciB3aGljaCBwbHVnaW5zIHNob3VsZCBiZSBjYWxsZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBob29rIC0gVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiBtZXRob2QgdG8gY2FsbCAoZS5nLiAnYmVmb3JlVXBkYXRlJykuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbYXJnc10gLSBFeHRyYSBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGhvb2sgY2FsbC5cbiAgICogQHBhcmFtIHtmaWx0ZXJDYWxsYmFja30gW2ZpbHRlcl0gLSBGaWx0ZXJpbmcgZnVuY3Rpb24gZm9yIGxpbWl0aW5nIHdoaWNoIHBsdWdpbnMgYXJlIG5vdGlmaWVkXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBmYWxzZSBpZiBhbnkgb2YgdGhlIHBsdWdpbnMgcmV0dXJuIGZhbHNlLCBlbHNlIHJldHVybnMgdHJ1ZS5cblx0ICovXG4gIG5vdGlmeShjaGFydCwgaG9vaywgYXJncywgZmlsdGVyKSB7XG4gICAgaWYgKGhvb2sgPT09ICdiZWZvcmVJbml0Jykge1xuICAgICAgdGhpcy5faW5pdCA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCB0cnVlKTtcbiAgICAgIHRoaXMuX25vdGlmeSh0aGlzLl9pbml0LCBjaGFydCwgJ2luc3RhbGwnKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IGZpbHRlciA/IHRoaXMuX2Rlc2NyaXB0b3JzKGNoYXJ0KS5maWx0ZXIoZmlsdGVyKSA6IHRoaXMuX2Rlc2NyaXB0b3JzKGNoYXJ0KTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCBob29rLCBhcmdzKTtcblxuICAgIGlmIChob29rID09PSAnYWZ0ZXJEZXN0cm95Jykge1xuICAgICAgdGhpcy5fbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgJ3N0b3AnKTtcbiAgICAgIHRoaXMuX25vdGlmeSh0aGlzLl9pbml0LCBjaGFydCwgJ3VuaW5zdGFsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgaG9vaywgYXJncykge1xuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgIGZvciAoY29uc3QgZGVzY3JpcHRvciBvZiBkZXNjcmlwdG9ycykge1xuICAgICAgY29uc3QgcGx1Z2luID0gZGVzY3JpcHRvci5wbHVnaW47XG4gICAgICBjb25zdCBtZXRob2QgPSBwbHVnaW5baG9va107XG4gICAgICBjb25zdCBwYXJhbXMgPSBbY2hhcnQsIGFyZ3MsIGRlc2NyaXB0b3Iub3B0aW9uc107XG4gICAgICBpZiAoY2FsbENhbGxiYWNrKG1ldGhvZCwgcGFyYW1zLCBwbHVnaW4pID09PSBmYWxzZSAmJiBhcmdzLmNhbmNlbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICAvLyBXaGVuIHBsdWdpbnMgYXJlIHJlZ2lzdGVyZWQsIHRoZXJlIGlzIHRoZSBwb3NzaWJpbGl0eSBvZiBhIGRvdWJsZVxuICAgIC8vIGludmFsaWRhdGUgc2l0dWF0aW9uLiBJbiB0aGlzIGNhc2UsIHdlIG9ubHkgd2FudCB0byBpbnZhbGlkYXRlIG9uY2UuXG4gICAgLy8gSWYgd2UgaW52YWxpZGF0ZSBtdWx0aXBsZSB0aW1lcywgdGhlIGBfb2xkQ2FjaGVgIGlzIGxvc3QgYW5kIGFsbCBvZiB0aGVcbiAgICAvLyBwbHVnaW5zIGFyZSByZXN0YXJ0ZWQgd2l0aG91dCBiZWluZyBjb3JyZWN0bHkgc3RvcHBlZC5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzgxNDdcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYodGhpcy5fY2FjaGUpKSB7XG4gICAgICB0aGlzLl9vbGRDYWNoZSA9IHRoaXMuX2NhY2hlO1xuICAgICAgdGhpcy5fY2FjaGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZGVzY3JpcHRvcnMoY2hhcnQpIHtcbiAgICBpZiAodGhpcy5fY2FjaGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZTtcbiAgICB9XG5cbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2NhY2hlID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQpO1xuXG4gICAgdGhpcy5fbm90aWZ5U3RhdGVDaGFuZ2VzKGNoYXJ0KTtcblxuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfVxuXG4gIF9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgYWxsKSB7XG4gICAgY29uc3QgY29uZmlnID0gY2hhcnQgJiYgY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB2YWx1ZU9yRGVmYXVsdChjb25maWcub3B0aW9ucyAmJiBjb25maWcub3B0aW9ucy5wbHVnaW5zLCB7fSk7XG4gICAgY29uc3QgcGx1Z2lucyA9IGFsbFBsdWdpbnMoY29uZmlnKTtcbiAgICAvLyBvcHRpb25zID09PSBmYWxzZSA9PiBhbGwgcGx1Z2lucyBhcmUgZGlzYWJsZWRcbiAgICByZXR1cm4gb3B0aW9ucyA9PT0gZmFsc2UgJiYgIWFsbCA/IFtdIDogY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHBsdWdpbnMsIG9wdGlvbnMsIGFsbCk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpIHtcbiAgICBjb25zdCBwcmV2aW91c0Rlc2NyaXB0b3JzID0gdGhpcy5fb2xkQ2FjaGUgfHwgW107XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZTtcbiAgICBjb25zdCBkaWZmID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuc29tZSh5ID0+IHgucGx1Z2luLmlkID09PSB5LnBsdWdpbi5pZCkpO1xuICAgIHRoaXMuX25vdGlmeShkaWZmKHByZXZpb3VzRGVzY3JpcHRvcnMsIGRlc2NyaXB0b3JzKSwgY2hhcnQsICdzdG9wJyk7XG4gICAgdGhpcy5fbm90aWZ5KGRpZmYoZGVzY3JpcHRvcnMsIHByZXZpb3VzRGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0YXJ0Jyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9jb3JlLmNvbmZpZy5qcycpLmRlZmF1bHR9IGNvbmZpZ1xuICovXG5mdW5jdGlvbiBhbGxQbHVnaW5zKGNvbmZpZykge1xuICBjb25zdCBsb2NhbElkcyA9IHt9O1xuICBjb25zdCBwbHVnaW5zID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhyZWdpc3RyeS5wbHVnaW5zLml0ZW1zKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgcGx1Z2lucy5wdXNoKHJlZ2lzdHJ5LmdldFBsdWdpbihrZXlzW2ldKSk7XG4gIH1cblxuICBjb25zdCBsb2NhbCA9IGNvbmZpZy5wbHVnaW5zIHx8IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGx1Z2luID0gbG9jYWxbaV07XG5cbiAgICBpZiAocGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPT09IC0xKSB7XG4gICAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgIGxvY2FsSWRzW3BsdWdpbi5pZF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7cGx1Z2lucywgbG9jYWxJZHN9O1xufVxuXG5mdW5jdGlvbiBnZXRPcHRzKG9wdGlvbnMsIGFsbCkge1xuICBpZiAoIWFsbCAmJiBvcHRpb25zID09PSBmYWxzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwge3BsdWdpbnMsIGxvY2FsSWRzfSwgb3B0aW9ucywgYWxsKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBjb250ZXh0ID0gY2hhcnQuZ2V0Q29udGV4dCgpO1xuXG4gIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMpIHtcbiAgICBjb25zdCBpZCA9IHBsdWdpbi5pZDtcbiAgICBjb25zdCBvcHRzID0gZ2V0T3B0cyhvcHRpb25zW2lkXSwgYWxsKTtcbiAgICBpZiAob3B0cyA9PT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgIHBsdWdpbixcbiAgICAgIG9wdGlvbnM6IHBsdWdpbk9wdHMoY2hhcnQuY29uZmlnLCB7cGx1Z2luLCBsb2NhbDogbG9jYWxJZHNbaWRdfSwgb3B0cywgY29udGV4dClcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBsdWdpbk9wdHMoY29uZmlnLCB7cGx1Z2luLCBsb2NhbH0sIG9wdHMsIGNvbnRleHQpIHtcbiAgY29uc3Qga2V5cyA9IGNvbmZpZy5wbHVnaW5TY29wZUtleXMocGx1Z2luKTtcbiAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3BlcyhvcHRzLCBrZXlzKTtcbiAgaWYgKGxvY2FsICYmIHBsdWdpbi5kZWZhdWx0cykge1xuICAgIC8vIG1ha2Ugc3VyZSBwbHVnaW4gZGVmYXVsdHMgYXJlIGluIHNjb3BlcyBmb3IgbG9jYWwgKG5vdCByZWdpc3RlcmVkKSBwbHVnaW5zXG4gICAgc2NvcGVzLnB1c2gocGx1Z2luLmRlZmF1bHRzKTtcbiAgfVxuICByZXR1cm4gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgWycnXSwge1xuICAgIC8vIFRoZXNlIGFyZSBqdXN0IGRlZmF1bHRzIHRoYXQgcGx1Z2lucyBjYW4gb3ZlcnJpZGVcbiAgICBzY3JpcHRhYmxlOiBmYWxzZSxcbiAgICBpbmRleGFibGU6IGZhbHNlLFxuICAgIGFsbEtleXM6IHRydWVcbiAgfSk7XG59XG4iLCAiaW1wb3J0IGRlZmF1bHRzLCB7b3ZlcnJpZGVzLCBkZXNjcmlwdG9yc30gZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7bWVyZ2VJZiwgcmVzb2x2ZU9iamVjdEtleSwgaXNBcnJheSwgaXNGdW5jdGlvbiwgdmFsdWVPckRlZmF1bHQsIGlzT2JqZWN0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge19hdHRhY2hDb250ZXh0LCBfY3JlYXRlUmVzb2x2ZXIsIF9kZXNjcmlwdG9yc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbmZpZy5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucykge1xuICBjb25zdCBkYXRhc2V0RGVmYXVsdHMgPSBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXSB8fCB7fTtcbiAgY29uc3QgZGF0YXNldE9wdGlvbnMgPSAob3B0aW9ucy5kYXRhc2V0cyB8fCB7fSlbdHlwZV0gfHwge307XG4gIHJldHVybiBkYXRhc2V0T3B0aW9ucy5pbmRleEF4aXMgfHwgb3B0aW9ucy5pbmRleEF4aXMgfHwgZGF0YXNldERlZmF1bHRzLmluZGV4QXhpcyB8fCAneCc7XG59XG5cbmZ1bmN0aW9uIGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoaWQsIGluZGV4QXhpcykge1xuICBsZXQgYXhpcyA9IGlkO1xuICBpZiAoaWQgPT09ICdfaW5kZXhfJykge1xuICAgIGF4aXMgPSBpbmRleEF4aXM7XG4gIH0gZWxzZSBpZiAoaWQgPT09ICdfdmFsdWVfJykge1xuICAgIGF4aXMgPSBpbmRleEF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcbiAgfVxuICByZXR1cm4gYXhpcztcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBpbmRleEF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09IGluZGV4QXhpcyA/ICdfaW5kZXhfJyA6ICdfdmFsdWVfJztcbn1cblxuZnVuY3Rpb24gaWRNYXRjaGVzQXhpcyhpZCkge1xuICBpZiAoaWQgPT09ICd4JyB8fCBpZCA9PT0gJ3knIHx8IGlkID09PSAncicpIHtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXhpc0Zyb21Qb3NpdGlvbihwb3NpdGlvbikge1xuICBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgIHJldHVybiAneCc7XG4gIH1cbiAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICByZXR1cm4gJ3knO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVBeGlzKGlkLCAuLi5zY2FsZU9wdGlvbnMpIHtcbiAgaWYgKGlkTWF0Y2hlc0F4aXMoaWQpKSB7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIGZvciAoY29uc3Qgb3B0cyBvZiBzY2FsZU9wdGlvbnMpIHtcbiAgICBjb25zdCBheGlzID0gb3B0cy5heGlzXG4gICAgICB8fCBheGlzRnJvbVBvc2l0aW9uKG9wdHMucG9zaXRpb24pXG4gICAgICB8fCBpZC5sZW5ndGggPiAxICYmIGlkTWF0Y2hlc0F4aXMoaWRbMF0udG9Mb3dlckNhc2UoKSk7XG4gICAgaWYgKGF4aXMpIHtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBkZXRlcm1pbmUgdHlwZSBvZiAnJHtpZH0nIGF4aXMuIFBsZWFzZSBwcm92aWRlICdheGlzJyBvciAncG9zaXRpb24nIG9wdGlvbi5gKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXhpc0Zyb21EYXRhc2V0KGlkLCBheGlzLCBkYXRhc2V0KSB7XG4gIGlmIChkYXRhc2V0W2F4aXMgKyAnQXhpc0lEJ10gPT09IGlkKSB7XG4gICAgcmV0dXJuIHtheGlzfTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyaWV2ZUF4aXNGcm9tRGF0YXNldHMoaWQsIGNvbmZpZykge1xuICBpZiAoY29uZmlnLmRhdGEgJiYgY29uZmlnLmRhdGEuZGF0YXNldHMpIHtcbiAgICBjb25zdCBib3VuZERzID0gY29uZmlnLmRhdGEuZGF0YXNldHMuZmlsdGVyKChkKSA9PiBkLnhBeGlzSUQgPT09IGlkIHx8IGQueUF4aXNJRCA9PT0gaWQpO1xuICAgIGlmIChib3VuZERzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGdldEF4aXNGcm9tRGF0YXNldChpZCwgJ3gnLCBib3VuZERzWzBdKSB8fCBnZXRBeGlzRnJvbURhdGFzZXQoaWQsICd5JywgYm91bmREc1swXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hhcnREZWZhdWx0cyA9IG92ZXJyaWRlc1tjb25maWcudHlwZV0gfHwge3NjYWxlczoge319O1xuICBjb25zdCBjb25maWdTY2FsZXMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcbiAgY29uc3QgY2hhcnRJbmRleEF4aXMgPSBnZXRJbmRleEF4aXMoY29uZmlnLnR5cGUsIG9wdGlvbnMpO1xuICBjb25zdCBzY2FsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vIEZpcnN0IGZpZ3VyZSBvdXQgZmlyc3Qgc2NhbGUgaWQncyBwZXIgYXhpcy5cbiAgT2JqZWN0LmtleXMoY29uZmlnU2NhbGVzKS5mb3JFYWNoKGlkID0+IHtcbiAgICBjb25zdCBzY2FsZUNvbmYgPSBjb25maWdTY2FsZXNbaWRdO1xuICAgIGlmICghaXNPYmplY3Qoc2NhbGVDb25mKSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgc2NhbGUgY29uZmlndXJhdGlvbiBmb3Igc2NhbGU6ICR7aWR9YCk7XG4gICAgfVxuICAgIGlmIChzY2FsZUNvbmYuX3Byb3h5KSB7XG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKGBJZ25vcmluZyByZXNvbHZlciBwYXNzZWQgYXMgb3B0aW9ucyBmb3Igc2NhbGU6ICR7aWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZUNvbmYsIHJldHJpZXZlQXhpc0Zyb21EYXRhc2V0cyhpZCwgY29uZmlnKSwgZGVmYXVsdHMuc2NhbGVzW3NjYWxlQ29uZi50eXBlXSk7XG4gICAgY29uc3QgZGVmYXVsdElkID0gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBjaGFydEluZGV4QXhpcyk7XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGNoYXJ0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIHNjYWxlc1tpZF0gPSBtZXJnZUlmKE9iamVjdC5jcmVhdGUobnVsbCksIFt7YXhpc30sIHNjYWxlQ29uZiwgZGVmYXVsdFNjYWxlT3B0aW9uc1theGlzXSwgZGVmYXVsdFNjYWxlT3B0aW9uc1tkZWZhdWx0SWRdXSk7XG4gIH0pO1xuXG4gIC8vIFRoZW4gbWVyZ2UgZGF0YXNldCBkZWZhdWx0cyB0byBzY2FsZSBjb25maWdzXG4gIGNvbmZpZy5kYXRhLmRhdGFzZXRzLmZvckVhY2goZGF0YXNldCA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCBjb25maWcudHlwZTtcbiAgICBjb25zdCBpbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gb3ZlcnJpZGVzW3R5cGVdIHx8IHt9O1xuICAgIGNvbnN0IGRlZmF1bHRTY2FsZU9wdGlvbnMgPSBkYXRhc2V0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKGRlZmF1bHRTY2FsZU9wdGlvbnMpLmZvckVhY2goZGVmYXVsdElEID0+IHtcbiAgICAgIGNvbnN0IGF4aXMgPSBnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEKGRlZmF1bHRJRCwgaW5kZXhBeGlzKTtcbiAgICAgIGNvbnN0IGlkID0gZGF0YXNldFtheGlzICsgJ0F4aXNJRCddIHx8IGF4aXM7XG4gICAgICBzY2FsZXNbaWRdID0gc2NhbGVzW2lkXSB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgbWVyZ2VJZihzY2FsZXNbaWRdLCBbe2F4aXN9LCBjb25maWdTY2FsZXNbaWRdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJRF1dKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gYXBwbHkgc2NhbGUgZGVmYXVsdHMsIGlmIG5vdCBvdmVycmlkZGVuIGJ5IGRhdGFzZXQgZGVmYXVsdHNcbiAgT2JqZWN0LmtleXMoc2NhbGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgY29uc3Qgc2NhbGUgPSBzY2FsZXNba2V5XTtcbiAgICBtZXJnZUlmKHNjYWxlLCBbZGVmYXVsdHMuc2NhbGVzW3NjYWxlLnR5cGVdLCBkZWZhdWx0cy5zY2FsZV0pO1xuICB9KTtcblxuICByZXR1cm4gc2NhbGVzO1xufVxuXG5mdW5jdGlvbiBpbml0T3B0aW9ucyhjb25maWcpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zIHx8IChjb25maWcub3B0aW9ucyA9IHt9KTtcblxuICBvcHRpb25zLnBsdWdpbnMgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnBsdWdpbnMsIHt9KTtcbiAgb3B0aW9ucy5zY2FsZXMgPSBtZXJnZVNjYWxlQ29uZmlnKGNvbmZpZywgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhKGRhdGEpIHtcbiAgZGF0YSA9IGRhdGEgfHwge307XG4gIGRhdGEuZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzIHx8IFtdO1xuICBkYXRhLmxhYmVscyA9IGRhdGEubGFiZWxzIHx8IFtdO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gaW5pdENvbmZpZyhjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICBjb25maWcuZGF0YSA9IGluaXREYXRhKGNvbmZpZy5kYXRhKTtcblxuICBpbml0T3B0aW9ucyhjb25maWcpO1xuXG4gIHJldHVybiBjb25maWc7XG59XG5cbmNvbnN0IGtleUNhY2hlID0gbmV3IE1hcCgpO1xuY29uc3Qga2V5c0NhY2hlZCA9IG5ldyBTZXQoKTtcblxuZnVuY3Rpb24gY2FjaGVkS2V5cyhjYWNoZUtleSwgZ2VuZXJhdGUpIHtcbiAgbGV0IGtleXMgPSBrZXlDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gZ2VuZXJhdGUoKTtcbiAgICBrZXlDYWNoZS5zZXQoY2FjaGVLZXksIGtleXMpO1xuICAgIGtleXNDYWNoZWQuYWRkKGtleXMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuXG5jb25zdCBhZGRJZkZvdW5kID0gKHNldCwgb2JqLCBrZXkpID0+IHtcbiAgY29uc3Qgb3B0cyA9IHJlc29sdmVPYmplY3RLZXkob2JqLCBrZXkpO1xuICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2V0LmFkZChvcHRzKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5fY29uZmlnID0gaW5pdENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcmVzb2x2ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIGdldCBwbGF0Zm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsYXRmb3JtO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy50eXBlO1xuICB9XG5cbiAgc2V0IHR5cGUodHlwZSkge1xuICAgIHRoaXMuX2NvbmZpZy50eXBlID0gdHlwZTtcbiAgfVxuXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcuZGF0YTtcbiAgfVxuXG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICB0aGlzLl9jb25maWcuZGF0YSA9IGluaXREYXRhKGRhdGEpO1xuICB9XG5cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5vcHRpb25zO1xuICB9XG5cbiAgc2V0IG9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuX2NvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIGdldCBwbHVnaW5zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcucGx1Z2lucztcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLl9jb25maWc7XG4gICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgaW5pdE9wdGlvbnMoY29uZmlnKTtcbiAgfVxuXG4gIGNsZWFyQ2FjaGUoKSB7XG4gICAgdGhpcy5fc2NvcGVDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuX3Jlc29sdmVyQ2FjaGUuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb24gc2NvcGUga2V5cyBmb3IgcmVzb2x2aW5nIGRhdGFzZXQgb3B0aW9ucy5cbiAgICogVGhlc2Uga2V5cyBkbyBub3QgaW5jbHVkZSB0aGUgZGF0YXNldCBpdHNlbGYsIGJlY2F1c2UgaXQgaXMgbm90IHVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0VHlwZVxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgZGF0YXNldFNjb3BlS2V5cyhkYXRhc2V0VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGRhdGFzZXRUeXBlLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgJydcbiAgICAgIF1dKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb24gc2NvcGUga2V5cyBmb3IgcmVzb2x2aW5nIGRhdGFzZXQgYW5pbWF0aW9uIG9wdGlvbnMuXG4gICAqIFRoZXNlIGtleXMgZG8gbm90IGluY2x1ZGUgdGhlIGRhdGFzZXQgaXRzZWxmLCBiZWNhdXNlIGl0IGlzIG5vdCB1bmRlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YXNldFR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zaXRpb25cbiAgICogQHJldHVybiB7c3RyaW5nW11bXX1cbiAgICovXG4gIGRhdGFzZXRBbmltYXRpb25TY29wZUtleXMoZGF0YXNldFR5cGUsIHRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbi4ke3RyYW5zaXRpb259YCxcbiAgICAgICgpID0+IFtcbiAgICAgICAgW1xuICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS50cmFuc2l0aW9ucy4ke3RyYW5zaXRpb259YCxcbiAgICAgICAgICBgdHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgIF0sXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlIHVzZWQgZm9yIGxvb2tpbmcgdXAgdGhlIGBhbmltYXRpb25zYCBhbmQgYGFuaW1hdGlvbmAga2V5c1xuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgICAnJ1xuICAgICAgICBdXG4gICAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb25zIHNjb3BlIGtleXMgZm9yIHJlc29sdmluZyBlbGVtZW50IG9wdGlvbnMgdGhhdCBiZWxvbmdcbiAgICogdG8gYW4gZGF0YXNldC4gVGhlc2Uga2V5cyBkbyBub3QgaW5jbHVkZSB0aGUgZGF0YXNldCBpdHNlbGYsIGJlY2F1c2UgaXRcbiAgICogaXMgbm90IHVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0VHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudFR5cGVcbiAgICogQHJldHVybiB7c3RyaW5nW11bXX1cbiAgICovXG4gIGRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKGRhdGFzZXRUeXBlLCBlbGVtZW50VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke2RhdGFzZXRUeXBlfS0ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0uZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICBgZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxuICAgICAgICAnJ1xuICAgICAgXV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbnMgc2NvcGUga2V5cyBmb3IgcmVzb2x2aW5nIHBsdWdpbiBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3tpZDogc3RyaW5nLCBhZGRpdGlvbmFsT3B0aW9uU2NvcGVzPzogc3RyaW5nW119fSBwbHVnaW5cbiAgICogQHJldHVybiB7c3RyaW5nW11bXX1cbiAgICovXG4gIHBsdWdpblNjb3BlS2V5cyhwbHVnaW4pIHtcbiAgICBjb25zdCBpZCA9IHBsdWdpbi5pZDtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlO1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke3R5cGV9LXBsdWdpbi0ke2lkfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgcGx1Z2lucy4ke2lkfWAsXG4gICAgICAgIC4uLnBsdWdpbi5hZGRpdGlvbmFsT3B0aW9uU2NvcGVzIHx8IFtdLFxuICAgICAgXV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IF9zY29wZUNhY2hlID0gdGhpcy5fc2NvcGVDYWNoZTtcbiAgICBsZXQgY2FjaGUgPSBfc2NvcGVDYWNoZS5nZXQobWFpblNjb3BlKTtcbiAgICBpZiAoIWNhY2hlIHx8IHJlc2V0Q2FjaGUpIHtcbiAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgX3Njb3BlQ2FjaGUuc2V0KG1haW5TY29wZSwgY2FjaGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGU7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgdGhlIG9iamVjdHMgZnJvbSBvcHRpb25zIGFuZCBkZWZhdWx0cyBmb3Igb3B0aW9uIHZhbHVlIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtYWluU2NvcGUgLSBUaGUgbWFpbiBzY29wZSBvYmplY3QgZm9yIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmdbXVtdfSBrZXlMaXN0cyAtIFRoZSBhcnJheXMgb2Yga2V5cyBpbiByZXNvbHV0aW9uIG9yZGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc2V0Q2FjaGVdIC0gcmVzZXQgdGhlIGNhY2hlIGZvciB0aGlzIG1haW5TY29wZVxuICAgKi9cbiAgZ2V0T3B0aW9uU2NvcGVzKG1haW5TY29wZSwga2V5TGlzdHMsIHJlc2V0Q2FjaGUpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSk7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleUxpc3RzKTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cblxuICAgIGNvbnN0IHNjb3BlcyA9IG5ldyBTZXQoKTtcblxuICAgIGtleUxpc3RzLmZvckVhY2goa2V5cyA9PiB7XG4gICAgICBpZiAobWFpblNjb3BlKSB7XG4gICAgICAgIHNjb3Blcy5hZGQobWFpblNjb3BlKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgbWFpblNjb3BlLCBrZXkpKTtcbiAgICAgIH1cbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG9wdGlvbnMsIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3Blcywgb3ZlcnJpZGVzW3R5cGVdIHx8IHt9LCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIGRlZmF1bHRzLCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIGRlc2NyaXB0b3JzLCBrZXkpKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGFycmF5ID0gQXJyYXkuZnJvbShzY29wZXMpO1xuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIGFycmF5LnB1c2goT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgfVxuICAgIGlmIChrZXlzQ2FjaGVkLmhhcyhrZXlMaXN0cykpIHtcbiAgICAgIGNhY2hlLnNldChrZXlMaXN0cywgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9uIHNjb3BlcyBmb3IgcmVzb2x2aW5nIGNoYXJ0IG9wdGlvbnNcbiAgICogQHJldHVybiB7b2JqZWN0W119XG4gICAqL1xuICBjaGFydE9wdGlvblNjb3BlcygpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIG9wdGlvbnMsXG4gICAgICBvdmVycmlkZXNbdHlwZV0gfHwge30sXG4gICAgICBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXSB8fCB7fSwgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzg1MzFcbiAgICAgIHt0eXBlfSxcbiAgICAgIGRlZmF1bHRzLFxuICAgICAgZGVzY3JpcHRvcnNcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0W119IHNjb3Blc1xuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBuYW1lc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG9iamVjdH0gY29udGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbcHJlZml4ZXNdXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICovXG4gIHJlc29sdmVOYW1lZE9wdGlvbnMoc2NvcGVzLCBuYW1lcywgY29udGV4dCwgcHJlZml4ZXMgPSBbJyddKSB7XG4gICAgY29uc3QgcmVzdWx0ID0geyRzaGFyZWQ6IHRydWV9O1xuICAgIGNvbnN0IHtyZXNvbHZlciwgc3ViUHJlZml4ZXN9ID0gZ2V0UmVzb2x2ZXIodGhpcy5fcmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgbGV0IG9wdGlvbnMgPSByZXNvbHZlcjtcbiAgICBpZiAobmVlZENvbnRleHQocmVzb2x2ZXIsIG5hbWVzKSkge1xuICAgICAgcmVzdWx0LiRzaGFyZWQgPSBmYWxzZTtcbiAgICAgIGNvbnRleHQgPSBpc0Z1bmN0aW9uKGNvbnRleHQpID8gY29udGV4dCgpIDogY29udGV4dDtcbiAgICAgIC8vIHN1YlJlc29sdmVyIGlzIHBhc3NlZCB0byBzY3JpcHRhYmxlIG9wdGlvbnMuIEl0IHNob3VsZCBub3QgcmVzb2x2ZSB0byBob3ZlciBvcHRpb25zLlxuICAgICAgY29uc3Qgc3ViUmVzb2x2ZXIgPSB0aGlzLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgc3ViUHJlZml4ZXMpO1xuICAgICAgb3B0aW9ucyA9IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCBzdWJSZXNvbHZlcik7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwcm9wIG9mIG5hbWVzKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0W119IHNjb3Blc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFtwcmVmaXhlc11cbiAgICogQHBhcmFtIHt7c2NyaXB0YWJsZTogYm9vbGVhbiwgaW5kZXhhYmxlOiBib29sZWFuLCBhbGxLZXlzPzogYm9vbGVhbn19IFtkZXNjcmlwdG9yRGVmYXVsdHNdXG4gICAqL1xuICBjcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIHByZWZpeGVzID0gWycnXSwgZGVzY3JpcHRvckRlZmF1bHRzKSB7XG4gICAgY29uc3Qge3Jlc29sdmVyfSA9IGdldFJlc29sdmVyKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIHJldHVybiBpc09iamVjdChjb250ZXh0KVxuICAgICAgPyBfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgY29udGV4dCwgdW5kZWZpbmVkLCBkZXNjcmlwdG9yRGVmYXVsdHMpXG4gICAgICA6IHJlc29sdmVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlc29sdmVyKHJlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpIHtcbiAgbGV0IGNhY2hlID0gcmVzb2x2ZXJDYWNoZS5nZXQoc2NvcGVzKTtcbiAgaWYgKCFjYWNoZSkge1xuICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHJlc29sdmVyQ2FjaGUuc2V0KHNjb3BlcywgY2FjaGUpO1xuICB9XG4gIGNvbnN0IGNhY2hlS2V5ID0gcHJlZml4ZXMuam9pbigpO1xuICBsZXQgY2FjaGVkID0gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFjYWNoZWQpIHtcbiAgICBjb25zdCByZXNvbHZlciA9IF9jcmVhdGVSZXNvbHZlcihzY29wZXMsIHByZWZpeGVzKTtcbiAgICBjYWNoZWQgPSB7XG4gICAgICByZXNvbHZlcixcbiAgICAgIHN1YlByZWZpeGVzOiBwcmVmaXhlcy5maWx0ZXIocCA9PiAhcC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdob3ZlcicpKVxuICAgIH07XG4gICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBjYWNoZWQpO1xuICB9XG4gIHJldHVybiBjYWNoZWQ7XG59XG5cbmNvbnN0IGhhc0Z1bmN0aW9uID0gdmFsdWUgPT4gaXNPYmplY3QodmFsdWUpXG4gICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5zb21lKChrZXkpID0+IGlzRnVuY3Rpb24odmFsdWVba2V5XSkpO1xuXG5mdW5jdGlvbiBuZWVkQ29udGV4dChwcm94eSwgbmFtZXMpIHtcbiAgY29uc3Qge2lzU2NyaXB0YWJsZSwgaXNJbmRleGFibGV9ID0gX2Rlc2NyaXB0b3JzKHByb3h5KTtcblxuICBmb3IgKGNvbnN0IHByb3Agb2YgbmFtZXMpIHtcbiAgICBjb25zdCBzY3JpcHRhYmxlID0gaXNTY3JpcHRhYmxlKHByb3ApO1xuICAgIGNvbnN0IGluZGV4YWJsZSA9IGlzSW5kZXhhYmxlKHByb3ApO1xuICAgIGNvbnN0IHZhbHVlID0gKGluZGV4YWJsZSB8fCBzY3JpcHRhYmxlKSAmJiBwcm94eVtwcm9wXTtcbiAgICBpZiAoKHNjcmlwdGFibGUgJiYgKGlzRnVuY3Rpb24odmFsdWUpIHx8IGhhc0Z1bmN0aW9uKHZhbHVlKSkpXG4gICAgICB8fCAoaW5kZXhhYmxlICYmIGlzQXJyYXkodmFsdWUpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsICJpbXBvcnQgYW5pbWF0b3IgZnJvbSAnLi9jb3JlLmFuaW1hdG9yLmpzJztcbmltcG9ydCBkZWZhdWx0cywge292ZXJyaWRlc30gZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiBmcm9tICcuL2NvcmUuaW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IGxheW91dHMgZnJvbSAnLi9jb3JlLmxheW91dHMuanMnO1xuaW1wb3J0IHtfZGV0ZWN0UGxhdGZvcm19IGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcbmltcG9ydCBQbHVnaW5TZXJ2aWNlIGZyb20gJy4vY29yZS5wbHVnaW5zLmpzJztcbmltcG9ydCByZWdpc3RyeSBmcm9tICcuL2NvcmUucmVnaXN0cnkuanMnO1xuaW1wb3J0IENvbmZpZywge2RldGVybWluZUF4aXMsIGdldEluZGV4QXhpc30gZnJvbSAnLi9jb3JlLmNvbmZpZy5qcyc7XG5pbXBvcnQge3JldGluYVNjYWxlLCBfaXNEb21TdXBwb3J0ZWR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5kb20uanMnO1xuaW1wb3J0IHtlYWNoLCBjYWxsYmFjayBhcyBjYWxsQ2FsbGJhY2ssIHVpZCwgdmFsdWVPckRlZmF1bHQsIF9lbGVtZW50c0VxdWFsLCBpc051bGxPclVuZGVmLCBzZXRzRXF1YWwsIGRlZmluZWQsIGlzRnVuY3Rpb24sIF9pc0NsaWNrRXZlbnR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7Y2xlYXJDYW52YXMsIGNsaXBBcmVhLCBjcmVhdGVDb250ZXh0LCB1bmNsaXBBcmVhLCBfaXNQb2ludEluQXJlYX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQge3ZlcnNpb259IGZyb20gJy4uLy4uL3BhY2thZ2UuanNvbic7XG5pbXBvcnQge2RlYm91bmNlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuUG9pbnQgfSBQb2ludFxuICovXG5cbmNvbnN0IEtOT1dOX1BPU0lUSU9OUyA9IFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0JywgJ2NoYXJ0QXJlYSddO1xuZnVuY3Rpb24gcG9zaXRpb25Jc0hvcml6b250YWwocG9zaXRpb24sIGF4aXMpIHtcbiAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgKEtOT1dOX1BPU0lUSU9OUy5pbmRleE9mKHBvc2l0aW9uKSA9PT0gLTEgJiYgYXhpcyA9PT0gJ3gnKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZTJMZXZlbChsMSwgbDIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYVtsMV0gPT09IGJbbDFdXG4gICAgICA/IGFbbDJdIC0gYltsMl1cbiAgICAgIDogYVtsMV0gLSBiW2wxXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25BbmltYXRpb25zQ29tcGxldGUoY29udGV4dCkge1xuICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcblxuICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclJlbmRlcicpO1xuICBjYWxsQ2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uQ29tcGxldGUsIFtjb250ZXh0XSwgY2hhcnQpO1xufVxuXG5mdW5jdGlvbiBvbkFuaW1hdGlvblByb2dyZXNzKGNvbnRleHQpIHtcbiAgY29uc3QgY2hhcnQgPSBjb250ZXh0LmNoYXJ0O1xuICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gY2hhcnQub3B0aW9ucy5hbmltYXRpb247XG4gIGNhbGxDYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Qcm9ncmVzcywgW2NvbnRleHRdLCBjaGFydCk7XG59XG5cbi8qKlxuICogQ2hhcnQuanMgY2FuIHRha2UgYSBzdHJpbmcgaWQgb2YgYSBjYW52YXMgZWxlbWVudCwgYSAyZCBjb250ZXh0LCBvciBhIGNhbnZhcyBlbGVtZW50IGl0c2VsZi5cbiAqIEF0dGVtcHQgdG8gdW53cmFwIHRoZSBpdGVtIHBhc3NlZCBpbnRvIHRoZSBjaGFydCBjb25zdHJ1Y3RvciBzbyB0aGF0IGl0IGlzIGEgY2FudmFzIGVsZW1lbnQgKGlmIHBvc3NpYmxlKS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FudmFzKGl0ZW0pIHtcbiAgaWYgKF9pc0RvbVN1cHBvcnRlZCgpICYmIHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgIGl0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpdGVtKTtcbiAgfSBlbHNlIGlmIChpdGVtICYmIGl0ZW0ubGVuZ3RoKSB7XG4gICAgLy8gU3VwcG9ydCBmb3IgYXJyYXkgYmFzZWQgcXVlcmllcyAoc3VjaCBhcyBqUXVlcnkpXG4gICAgaXRlbSA9IGl0ZW1bMF07XG4gIH1cblxuICBpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xuICAgIC8vIFN1cHBvcnQgZm9yIGFueSBvYmplY3QgYXNzb2NpYXRlZCB0byBhIGNhbnZhcyAoaW5jbHVkaW5nIGEgY29udGV4dDJkKVxuICAgIGl0ZW0gPSBpdGVtLmNhbnZhcztcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cblxuY29uc3QgaW5zdGFuY2VzID0ge307XG5jb25zdCBnZXRDaGFydCA9IChrZXkpID0+IHtcbiAgY29uc3QgY2FudmFzID0gZ2V0Q2FudmFzKGtleSk7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGluc3RhbmNlcykuZmlsdGVyKChjKSA9PiBjLmNhbnZhcyA9PT0gY2FudmFzKS5wb3AoKTtcbn07XG5cbmZ1bmN0aW9uIG1vdmVOdW1lcmljS2V5cyhvYmosIHN0YXJ0LCBtb3ZlKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgY29uc3QgaW50S2V5ID0gK2tleTtcbiAgICBpZiAoaW50S2V5ID49IHN0YXJ0KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgaWYgKG1vdmUgPiAwIHx8IGludEtleSA+IHN0YXJ0KSB7XG4gICAgICAgIG9ialtpbnRLZXkgKyBtb3ZlXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZVxuICogQHBhcmFtIHtDaGFydEV2ZW50fG51bGx9IGxhc3RFdmVudFxuICogQHBhcmFtIHtib29sZWFufSBpbkNoYXJ0QXJlYVxuICogQHBhcmFtIHtib29sZWFufSBpc0NsaWNrXG4gKiBAcmV0dXJucyB7Q2hhcnRFdmVudHxudWxsfVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVMYXN0RXZlbnQoZSwgbGFzdEV2ZW50LCBpbkNoYXJ0QXJlYSwgaXNDbGljaykge1xuICBpZiAoIWluQ2hhcnRBcmVhIHx8IGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpc0NsaWNrKSB7XG4gICAgcmV0dXJuIGxhc3RFdmVudDtcbiAgfVxuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZUZvckFyZWEoc2NhbGUsIGNoYXJ0QXJlYSwgZmllbGQpIHtcbiAgcmV0dXJuIHNjYWxlLm9wdGlvbnMuY2xpcCA/IHNjYWxlW2ZpZWxkXSA6IGNoYXJ0QXJlYVtmaWVsZF07XG59XG5cbmZ1bmN0aW9uIGdldERhdGFzZXRBcmVhKG1ldGEsIGNoYXJ0QXJlYSkge1xuICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgaWYgKHhTY2FsZSAmJiB5U2NhbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogZ2V0U2l6ZUZvckFyZWEoeFNjYWxlLCBjaGFydEFyZWEsICdsZWZ0JyksXG4gICAgICByaWdodDogZ2V0U2l6ZUZvckFyZWEoeFNjYWxlLCBjaGFydEFyZWEsICdyaWdodCcpLFxuICAgICAgdG9wOiBnZXRTaXplRm9yQXJlYSh5U2NhbGUsIGNoYXJ0QXJlYSwgJ3RvcCcpLFxuICAgICAgYm90dG9tOiBnZXRTaXplRm9yQXJlYSh5U2NhbGUsIGNoYXJ0QXJlYSwgJ2JvdHRvbScpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gY2hhcnRBcmVhO1xufVxuXG5jbGFzcyBDaGFydCB7XG5cbiAgc3RhdGljIGRlZmF1bHRzID0gZGVmYXVsdHM7XG4gIHN0YXRpYyBpbnN0YW5jZXMgPSBpbnN0YW5jZXM7XG4gIHN0YXRpYyBvdmVycmlkZXMgPSBvdmVycmlkZXM7XG4gIHN0YXRpYyByZWdpc3RyeSA9IHJlZ2lzdHJ5O1xuICBzdGF0aWMgdmVyc2lvbiA9IHZlcnNpb247XG4gIHN0YXRpYyBnZXRDaGFydCA9IGdldENoYXJ0O1xuXG4gIHN0YXRpYyByZWdpc3RlciguLi5pdGVtcykge1xuICAgIHJlZ2lzdHJ5LmFkZCguLi5pdGVtcyk7XG4gICAgaW52YWxpZGF0ZVBsdWdpbnMoKTtcbiAgfVxuXG4gIHN0YXRpYyB1bnJlZ2lzdGVyKC4uLml0ZW1zKSB7XG4gICAgcmVnaXN0cnkucmVtb3ZlKC4uLml0ZW1zKTtcbiAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzXG4gIGNvbnN0cnVjdG9yKGl0ZW0sIHVzZXJDb25maWcpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZyA9IG5ldyBDb25maWcodXNlckNvbmZpZyk7XG4gICAgY29uc3QgaW5pdGlhbENhbnZhcyA9IGdldENhbnZhcyhpdGVtKTtcbiAgICBjb25zdCBleGlzdGluZ0NoYXJ0ID0gZ2V0Q2hhcnQoaW5pdGlhbENhbnZhcyk7XG4gICAgaWYgKGV4aXN0aW5nQ2hhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0NhbnZhcyBpcyBhbHJlYWR5IGluIHVzZS4gQ2hhcnQgd2l0aCBJRCBcXCcnICsgZXhpc3RpbmdDaGFydC5pZCArICdcXCcnICtcblx0XHRcdFx0JyBtdXN0IGJlIGRlc3Ryb3llZCBiZWZvcmUgdGhlIGNhbnZhcyB3aXRoIElEIFxcJycgKyBleGlzdGluZ0NoYXJ0LmNhbnZhcy5pZCArICdcXCcgY2FuIGJlIHJldXNlZC4nXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoY29uZmlnLmNoYXJ0T3B0aW9uU2NvcGVzKCksIHRoaXMuZ2V0Q29udGV4dCgpKTtcblxuICAgIHRoaXMucGxhdGZvcm0gPSBuZXcgKGNvbmZpZy5wbGF0Zm9ybSB8fCBfZGV0ZWN0UGxhdGZvcm0oaW5pdGlhbENhbnZhcykpKCk7XG4gICAgdGhpcy5wbGF0Zm9ybS51cGRhdGVDb25maWcoY29uZmlnKTtcblxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLnBsYXRmb3JtLmFjcXVpcmVDb250ZXh0KGluaXRpYWxDYW52YXMsIG9wdGlvbnMuYXNwZWN0UmF0aW8pO1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQgJiYgY29udGV4dC5jYW52YXM7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2FudmFzICYmIGNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3Qgd2lkdGggPSBjYW52YXMgJiYgY2FudmFzLndpZHRoO1xuXG4gICAgdGhpcy5pZCA9IHVpZCgpO1xuICAgIHRoaXMuY3R4ID0gY29udGV4dDtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgLy8gU3RvcmUgdGhlIHByZXZpb3VzbHkgdXNlZCBhc3BlY3QgcmF0aW8gdG8gZGV0ZXJtaW5lIGlmIGEgcmVzaXplXG4gICAgLy8gaXMgbmVlZGVkIGR1cmluZyB1cGRhdGVzLiBEbyB0aGlzIGFmdGVyIF9vcHRpb25zIGlzIHNldCBzaW5jZVxuICAgIC8vIGFzcGVjdFJhdGlvIHVzZXMgYSBnZXR0ZXJcbiAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW87XG4gICAgdGhpcy5fbGF5ZXJzID0gW107XG4gICAgdGhpcy5fbWV0YXNldHMgPSBbXTtcbiAgICB0aGlzLl9zdGFja3MgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3hlcyA9IFtdO1xuICAgIHRoaXMuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaGFydEFyZWEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fYWN0aXZlID0gW107XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIC8qKiBAdHlwZSB7P3thdHRhY2g/OiBmdW5jdGlvbiwgZGV0YWNoPzogZnVuY3Rpb24sIHJlc2l6ZT86IGZ1bmN0aW9ufX0gKi9cbiAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NvcnRlZE1ldGFzZXRzID0gW107XG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICB0aGlzLl9wbHVnaW5zID0gbmV3IFBsdWdpblNlcnZpY2UoKTtcbiAgICB0aGlzLiRwcm94aWVzID0ge307XG4gICAgdGhpcy5faGlkZGVuSW5kaWNlcyA9IHt9O1xuICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hbmltYXRpb25zRGlzYWJsZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kb1Jlc2l6ZSA9IGRlYm91bmNlKG1vZGUgPT4gdGhpcy51cGRhdGUobW9kZSksIG9wdGlvbnMucmVzaXplRGVsYXkgfHwgMCk7XG4gICAgdGhpcy5fZGF0YUNoYW5nZXMgPSBbXTtcblxuICAgIC8vIEFkZCB0aGUgY2hhcnQgaW5zdGFuY2UgdG8gdGhlIGdsb2JhbCBuYW1lc3BhY2VcbiAgICBpbnN0YW5jZXNbdGhpcy5pZF0gPSB0aGlzO1xuXG4gICAgaWYgKCFjb250ZXh0IHx8ICFjYW52YXMpIHtcbiAgICAgIC8vIFRoZSBnaXZlbiBpdGVtIGlzIG5vdCBhIGNvbXBhdGlibGUgY29udGV4dDJkIGVsZW1lbnQsIGxldCdzIHJldHVybiBiZWZvcmUgZmluYWxpemluZ1xuICAgICAgLy8gdGhlIGNoYXJ0IGluaXRpYWxpemF0aW9uIGJ1dCBhZnRlciBzZXR0aW5nIGJhc2ljIGNoYXJ0IC8gY29udHJvbGxlciBwcm9wZXJ0aWVzIHRoYXRcbiAgICAgIC8vIGNhbiBoZWxwIHRvIGZpZ3VyZSBvdXQgdGhhdCB0aGUgY2hhcnQgaXMgbm90IHZhbGlkIChlLmcgY2hhcnQuY2FudmFzICE9PSBudWxsKTtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFydDogY2FuJ3QgYWNxdWlyZSBjb250ZXh0IGZyb20gdGhlIGdpdmVuIGl0ZW1cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYW5pbWF0b3IubGlzdGVuKHRoaXMsICdjb21wbGV0ZScsIG9uQW5pbWF0aW9uc0NvbXBsZXRlKTtcbiAgICBhbmltYXRvci5saXN0ZW4odGhpcywgJ3Byb2dyZXNzJywgb25BbmltYXRpb25Qcm9ncmVzcyk7XG5cbiAgICB0aGlzLl9pbml0aWFsaXplKCk7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGFzcGVjdFJhdGlvKCkge1xuICAgIGNvbnN0IHtvcHRpb25zOiB7YXNwZWN0UmF0aW8sIG1haW50YWluQXNwZWN0UmF0aW99LCB3aWR0aCwgaGVpZ2h0LCBfYXNwZWN0UmF0aW99ID0gdGhpcztcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYoYXNwZWN0UmF0aW8pKSB7XG4gICAgICAvLyBJZiBhc3BlY3RSYXRpbyBpcyBkZWZpbmVkIGluIG9wdGlvbnMsIHVzZSB0aGF0LlxuICAgICAgcmV0dXJuIGFzcGVjdFJhdGlvO1xuICAgIH1cblxuICAgIGlmIChtYWludGFpbkFzcGVjdFJhdGlvICYmIF9hc3BlY3RSYXRpbykge1xuICAgICAgLy8gSWYgbWFpbnRhaW5Bc3BlY3RSYXRpbyBpcyB0cnV0aGx5IGFuZCB3ZSBoYWQgcHJldmlvdXNseSBkZXRlcm1pbmVkIF9hc3BlY3RSYXRpbywgdXNlIHRoYXRcbiAgICAgIHJldHVybiBfYXNwZWN0UmF0aW87XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlXG4gICAgcmV0dXJuIGhlaWdodCA/IHdpZHRoIC8gaGVpZ2h0IDogbnVsbDtcbiAgfVxuXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5kYXRhO1xuICB9XG5cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMuY29uZmlnLmRhdGEgPSBkYXRhO1xuICB9XG5cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cblxuICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5jb25maWcub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICBnZXQgcmVnaXN0cnkoKSB7XG4gICAgcmV0dXJuIHJlZ2lzdHJ5O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaW5pdGlhbGl6ZSgpIHtcbiAgICAvLyBCZWZvcmUgaW5pdCBwbHVnaW4gbm90aWZpY2F0aW9uXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVJbml0Jyk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldGluYVNjYWxlKHRoaXMsIHRoaXMub3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICB9XG5cbiAgICB0aGlzLmJpbmRFdmVudHMoKTtcblxuICAgIC8vIEFmdGVyIGluaXQgcGx1Z2luIG5vdGlmaWNhdGlvblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJJbml0Jyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIGNsZWFyQ2FudmFzKHRoaXMuY2FudmFzLCB0aGlzLmN0eCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIGFuaW1hdG9yLnN0b3AodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogUmVzaXplIHRoZSBjaGFydCB0byBpdHMgY29udGFpbmVyIG9yIHRvIGV4cGxpY2l0IGRpbWVuc2lvbnMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XVxuXHQgKi9cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIWFuaW1hdG9yLnJ1bm5pbmcodGhpcykpIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IHt3aWR0aCwgaGVpZ2h0fTtcbiAgICB9XG4gIH1cblxuICBfcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gb3B0aW9ucy5tYWludGFpbkFzcGVjdFJhdGlvICYmIHRoaXMuYXNwZWN0UmF0aW87XG4gICAgY29uc3QgbmV3U2l6ZSA9IHRoaXMucGxhdGZvcm0uZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgbmV3UmF0aW8gPSBvcHRpb25zLmRldmljZVBpeGVsUmF0aW8gfHwgdGhpcy5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgY29uc3QgbW9kZSA9IHRoaXMud2lkdGggPyAncmVzaXplJyA6ICdhdHRhY2gnO1xuXG4gICAgdGhpcy53aWR0aCA9IG5ld1NpemUud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdTaXplLmhlaWdodDtcbiAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW87XG4gICAgaWYgKCFyZXRpbmFTY2FsZSh0aGlzLCBuZXdSYXRpbywgdHJ1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ3Jlc2l6ZScsIHtzaXplOiBuZXdTaXplfSk7XG5cbiAgICBjYWxsQ2FsbGJhY2sob3B0aW9ucy5vblJlc2l6ZSwgW3RoaXMsIG5ld1NpemVdLCB0aGlzKTtcblxuICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICBpZiAodGhpcy5fZG9SZXNpemUobW9kZSkpIHtcbiAgICAgICAgLy8gVGhlIHJlc2l6ZSB1cGRhdGUgaXMgZGVsYXllZCwgb25seSBkcmF3IHdpdGhvdXQgdXBkYXRpbmcuXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZW5zdXJlU2NhbGVzSGF2ZUlEcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNjYWxlc09wdGlvbnMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcblxuICAgIGVhY2goc2NhbGVzT3B0aW9ucywgKGF4aXNPcHRpb25zLCBheGlzSUQpID0+IHtcbiAgICAgIGF4aXNPcHRpb25zLmlkID0gYXhpc0lEO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEJ1aWxkcyBhIG1hcCBvZiBzY2FsZSBJRCB0byBzY2FsZSBvYmplY3QgZm9yIGZ1dHVyZSBsb29rdXAuXG5cdCAqL1xuICBidWlsZE9yVXBkYXRlU2NhbGVzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2NhbGVPcHRzID0gb3B0aW9ucy5zY2FsZXM7XG4gICAgY29uc3Qgc2NhbGVzID0gdGhpcy5zY2FsZXM7XG4gICAgY29uc3QgdXBkYXRlZCA9IE9iamVjdC5rZXlzKHNjYWxlcykucmVkdWNlKChvYmosIGlkKSA9PiB7XG4gICAgICBvYmpbaWRdID0gZmFsc2U7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sIHt9KTtcbiAgICBsZXQgaXRlbXMgPSBbXTtcblxuICAgIGlmIChzY2FsZU9wdHMpIHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KFxuICAgICAgICBPYmplY3Qua2V5cyhzY2FsZU9wdHMpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgICBjb25zdCBzY2FsZU9wdGlvbnMgPSBzY2FsZU9wdHNbaWRdO1xuICAgICAgICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpO1xuICAgICAgICAgIGNvbnN0IGlzUmFkaWFsID0gYXhpcyA9PT0gJ3InO1xuICAgICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGF4aXMgPT09ICd4JztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3B0aW9uczogc2NhbGVPcHRpb25zLFxuICAgICAgICAgICAgZHBvc2l0aW9uOiBpc1JhZGlhbCA/ICdjaGFydEFyZWEnIDogaXNIb3Jpem9udGFsID8gJ2JvdHRvbScgOiAnbGVmdCcsXG4gICAgICAgICAgICBkdHlwZTogaXNSYWRpYWwgPyAncmFkaWFsTGluZWFyJyA6IGlzSG9yaXpvbnRhbCA/ICdjYXRlZ29yeScgOiAnbGluZWFyJ1xuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIGVhY2goaXRlbXMsIChpdGVtKSA9PiB7XG4gICAgICBjb25zdCBzY2FsZU9wdGlvbnMgPSBpdGVtLm9wdGlvbnM7XG4gICAgICBjb25zdCBpZCA9IHNjYWxlT3B0aW9ucy5pZDtcbiAgICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpO1xuICAgICAgY29uc3Qgc2NhbGVUeXBlID0gdmFsdWVPckRlZmF1bHQoc2NhbGVPcHRpb25zLnR5cGUsIGl0ZW0uZHR5cGUpO1xuXG4gICAgICBpZiAoc2NhbGVPcHRpb25zLnBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb25Jc0hvcml6b250YWwoc2NhbGVPcHRpb25zLnBvc2l0aW9uLCBheGlzKSAhPT0gcG9zaXRpb25Jc0hvcml6b250YWwoaXRlbS5kcG9zaXRpb24pKSB7XG4gICAgICAgIHNjYWxlT3B0aW9ucy5wb3NpdGlvbiA9IGl0ZW0uZHBvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVkW2lkXSA9IHRydWU7XG4gICAgICBsZXQgc2NhbGUgPSBudWxsO1xuICAgICAgaWYgKGlkIGluIHNjYWxlcyAmJiBzY2FsZXNbaWRdLnR5cGUgPT09IHNjYWxlVHlwZSkge1xuICAgICAgICBzY2FsZSA9IHNjYWxlc1tpZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzY2FsZUNsYXNzID0gcmVnaXN0cnkuZ2V0U2NhbGUoc2NhbGVUeXBlKTtcbiAgICAgICAgc2NhbGUgPSBuZXcgc2NhbGVDbGFzcyh7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgdHlwZTogc2NhbGVUeXBlLFxuICAgICAgICAgIGN0eDogdGhpcy5jdHgsXG4gICAgICAgICAgY2hhcnQ6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHNjYWxlc1tzY2FsZS5pZF0gPSBzY2FsZTtcbiAgICAgIH1cblxuICAgICAgc2NhbGUuaW5pdChzY2FsZU9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIC8vIGNsZWFyIHVwIGRpc2NhcmRlZCBzY2FsZXNcbiAgICBlYWNoKHVwZGF0ZWQsIChoYXNVcGRhdGVkLCBpZCkgPT4ge1xuICAgICAgaWYgKCFoYXNVcGRhdGVkKSB7XG4gICAgICAgIGRlbGV0ZSBzY2FsZXNbaWRdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZWFjaChzY2FsZXMsIChzY2FsZSkgPT4ge1xuICAgICAgbGF5b3V0cy5jb25maWd1cmUodGhpcywgc2NhbGUsIHNjYWxlLm9wdGlvbnMpO1xuICAgICAgbGF5b3V0cy5hZGRCb3godGhpcywgc2NhbGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlTWV0YXNldHMoKSB7XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9tZXRhc2V0cztcbiAgICBjb25zdCBudW1EYXRhID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBudW1NZXRhID0gbWV0YXNldHMubGVuZ3RoO1xuXG4gICAgbWV0YXNldHMuc29ydCgoYSwgYikgPT4gYS5pbmRleCAtIGIuaW5kZXgpO1xuICAgIGlmIChudW1NZXRhID4gbnVtRGF0YSkge1xuICAgICAgZm9yIChsZXQgaSA9IG51bURhdGE7IGkgPCBudW1NZXRhOyArK2kpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgICAgfVxuICAgICAgbWV0YXNldHMuc3BsaWNlKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcbiAgICB9XG4gICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSBtZXRhc2V0cy5zbGljZSgwKS5zb3J0KGNvbXBhcmUyTGV2ZWwoJ29yZGVyJywgJ2luZGV4JykpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKSB7XG4gICAgY29uc3Qge19tZXRhc2V0czogbWV0YXNldHMsIGRhdGE6IHtkYXRhc2V0c319ID0gdGhpcztcbiAgICBpZiAobWV0YXNldHMubGVuZ3RoID4gZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3RhY2tzO1xuICAgIH1cbiAgICBtZXRhc2V0cy5mb3JFYWNoKChtZXRhLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGRhdGFzZXRzLmZpbHRlcih4ID0+IHggPT09IG1ldGEuX2RhdGFzZXQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCkge1xuICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJzID0gW107XG4gICAgY29uc3QgZGF0YXNldHMgPSB0aGlzLmRhdGEuZGF0YXNldHM7XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICB0aGlzLl9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgY29uc3QgZGF0YXNldCA9IGRhdGFzZXRzW2ldO1xuICAgICAgbGV0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCB0aGlzLmNvbmZpZy50eXBlO1xuXG4gICAgICBpZiAobWV0YS50eXBlICYmIG1ldGEudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICAgIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgfVxuICAgICAgbWV0YS50eXBlID0gdHlwZTtcbiAgICAgIG1ldGEuaW5kZXhBeGlzID0gZGF0YXNldC5pbmRleEF4aXMgfHwgZ2V0SW5kZXhBeGlzKHR5cGUsIHRoaXMub3B0aW9ucyk7XG4gICAgICBtZXRhLm9yZGVyID0gZGF0YXNldC5vcmRlciB8fCAwO1xuICAgICAgbWV0YS5pbmRleCA9IGk7XG4gICAgICBtZXRhLmxhYmVsID0gJycgKyBkYXRhc2V0LmxhYmVsO1xuICAgICAgbWV0YS52aXNpYmxlID0gdGhpcy5pc0RhdGFzZXRWaXNpYmxlKGkpO1xuXG4gICAgICBpZiAobWV0YS5jb250cm9sbGVyKSB7XG4gICAgICAgIG1ldGEuY29udHJvbGxlci51cGRhdGVJbmRleChpKTtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyLmxpbmtTY2FsZXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IENvbnRyb2xsZXJDbGFzcyA9IHJlZ2lzdHJ5LmdldENvbnRyb2xsZXIodHlwZSk7XG4gICAgICAgIGNvbnN0IHtkYXRhc2V0RWxlbWVudFR5cGUsIGRhdGFFbGVtZW50VHlwZX0gPSBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihDb250cm9sbGVyQ2xhc3MsIHtcbiAgICAgICAgICBkYXRhRWxlbWVudFR5cGU6IHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YUVsZW1lbnRUeXBlKSxcbiAgICAgICAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGRhdGFzZXRFbGVtZW50VHlwZSAmJiByZWdpc3RyeS5nZXRFbGVtZW50KGRhdGFzZXRFbGVtZW50VHlwZSlcbiAgICAgICAgfSk7XG4gICAgICAgIG1ldGEuY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyQ2xhc3ModGhpcywgaSk7XG4gICAgICAgIG5ld0NvbnRyb2xsZXJzLnB1c2gobWV0YS5jb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVNZXRhc2V0cygpO1xuICAgIHJldHVybiBuZXdDb250cm9sbGVycztcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXNldCB0aGUgZWxlbWVudHMgb2YgYWxsIGRhdGFzZXRzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzZXRFbGVtZW50cygpIHtcbiAgICBlYWNoKHRoaXMuZGF0YS5kYXRhc2V0cywgKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkgPT4ge1xuICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuXHQqIFJlc2V0cyB0aGUgY2hhcnQgYmFjayB0byBpdHMgc3RhdGUgYmVmb3JlIHRoZSBpbml0aWFsIGFuaW1hdGlvblxuXHQqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRzKCk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdyZXNldCcpO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgIGNvbmZpZy51cGRhdGUoKTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihjb25maWcuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGFuaW1zRGlzYWJsZWQgPSB0aGlzLl9hbmltYXRpb25zRGlzYWJsZWQgPSAhb3B0aW9ucy5hbmltYXRpb247XG5cbiAgICB0aGlzLl91cGRhdGVTY2FsZXMoKTtcbiAgICB0aGlzLl9jaGVja0V2ZW50QmluZGluZ3MoKTtcbiAgICB0aGlzLl91cGRhdGVIaWRkZW5JbmRpY2VzKCk7XG5cbiAgICAvLyBwbHVnaW5zIG9wdGlvbnMgcmVmZXJlbmNlcyBtaWdodCBoYXZlIGNoYW5nZSwgbGV0J3MgaW52YWxpZGF0ZSB0aGUgY2FjaGVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTExMSNpc3N1ZWNvbW1lbnQtMzU1OTM0MTY3XG4gICAgdGhpcy5fcGx1Z2lucy5pbnZhbGlkYXRlKCk7XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVVcGRhdGUnLCB7bW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBkYXRhc2V0IGNvbnRyb2xsZXJzIGFyZSB1cGRhdGVkIGFuZCBuZXcgY29udHJvbGxlcnMgYXJlIHJlc2V0XG4gICAgY29uc3QgbmV3Q29udHJvbGxlcnMgPSB0aGlzLmJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpO1xuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVFbGVtZW50c1VwZGF0ZScpO1xuXG4gICAgLy8gTWFrZSBzdXJlIGFsbCBkYXRhc2V0IGNvbnRyb2xsZXJzIGhhdmUgY29ycmVjdCBtZXRhIGRhdGEgY291bnRzXG4gICAgbGV0IG1pblBhZGRpbmcgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgY29uc3Qge2NvbnRyb2xsZXJ9ID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGNvbnN0IHJlc2V0ID0gIWFuaW1zRGlzYWJsZWQgJiYgbmV3Q29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKSA9PT0gLTE7XG4gICAgICAvLyBOZXcgY29udHJvbGxlcnMgd2lsbCBiZSByZXNldCBhZnRlciB0aGUgbGF5b3V0IHBhc3MsIHNvIHdlIG9ubHkgd2FudCB0byBtb2RpZnlcbiAgICAgIC8vIGVsZW1lbnRzIGFkZGVkIHRvIG5ldyBkYXRhc2V0c1xuICAgICAgY29udHJvbGxlci5idWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXQpO1xuICAgICAgbWluUGFkZGluZyA9IE1hdGgubWF4KCtjb250cm9sbGVyLmdldE1heE92ZXJmbG93KCksIG1pblBhZGRpbmcpO1xuICAgIH1cbiAgICBtaW5QYWRkaW5nID0gdGhpcy5fbWluUGFkZGluZyA9IG9wdGlvbnMubGF5b3V0LmF1dG9QYWRkaW5nID8gbWluUGFkZGluZyA6IDA7XG4gICAgdGhpcy5fdXBkYXRlTGF5b3V0KG1pblBhZGRpbmcpO1xuXG4gICAgLy8gT25seSByZXNldCB0aGUgY29udHJvbGxlcnMgaWYgd2UgaGF2ZSBhbmltYXRpb25zXG4gICAgaWYgKCFhbmltc0Rpc2FibGVkKSB7XG4gICAgICAvLyBDYW4gb25seSByZXNldCB0aGUgbmV3IGNvbnRyb2xsZXJzIGFmdGVyIHRoZSBzY2FsZXMgaGF2ZSBiZWVuIHVwZGF0ZWRcbiAgICAgIC8vIFJlc2V0IGlzIGRvbmUgdG8gZ2V0IHRoZSBzdGFydGluZyBwb2ludCBmb3IgdGhlIGluaXRpYWwgYW5pbWF0aW9uXG4gICAgICBlYWNoKG5ld0NvbnRyb2xsZXJzLCAoY29udHJvbGxlcikgPT4ge1xuICAgICAgICBjb250cm9sbGVyLnJlc2V0KCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVEYXRhc2V0cyhtb2RlKTtcblxuICAgIC8vIERvIHRoaXMgYmVmb3JlIHJlbmRlciBzbyB0aGF0IGFueSBwbHVnaW5zIHRoYXQgbmVlZCBmaW5hbCBzY2FsZSB1cGRhdGVzIGNhbiB1c2UgaXRcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyVXBkYXRlJywge21vZGV9KTtcblxuICAgIHRoaXMuX2xheWVycy5zb3J0KGNvbXBhcmUyTGV2ZWwoJ3onLCAnX2lkeCcpKTtcblxuICAgIC8vIFJlcGxheSBsYXN0IGV2ZW50IGZyb20gYmVmb3JlIHVwZGF0ZSwgb3Igc2V0IGhvdmVyIHN0eWxlcyBvbiBhY3RpdmUgZWxlbWVudHNcbiAgICBjb25zdCB7X2FjdGl2ZSwgX2xhc3RFdmVudH0gPSB0aGlzO1xuICAgIGlmIChfbGFzdEV2ZW50KSB7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIoX2xhc3RFdmVudCwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChfYWN0aXZlLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoX2FjdGl2ZSwgX2FjdGl2ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZVNjYWxlcygpIHtcbiAgICBlYWNoKHRoaXMuc2NhbGVzLCAoc2NhbGUpID0+IHtcbiAgICAgIGxheW91dHMucmVtb3ZlQm94KHRoaXMsIHNjYWxlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZW5zdXJlU2NhbGVzSGF2ZUlEcygpO1xuICAgIHRoaXMuYnVpbGRPclVwZGF0ZVNjYWxlcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tFdmVudEJpbmRpbmdzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZXhpc3RpbmdFdmVudHMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHRoaXMuX2xpc3RlbmVycykpO1xuICAgIGNvbnN0IG5ld0V2ZW50cyA9IG5ldyBTZXQob3B0aW9ucy5ldmVudHMpO1xuXG4gICAgaWYgKCFzZXRzRXF1YWwoZXhpc3RpbmdFdmVudHMsIG5ld0V2ZW50cykgfHwgISF0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzICE9PSBvcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIC8vIFRoZSBjb25maWd1cmVkIGV2ZW50cyBoYXZlIGNoYW5nZWQuIFJlYmluZC5cbiAgICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XG4gICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVIaWRkZW5JbmRpY2VzKCkge1xuICAgIGNvbnN0IHtfaGlkZGVuSW5kaWNlc30gPSB0aGlzO1xuICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLl9nZXRVbmlmb3JtRGF0YUNoYW5nZXMoKSB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IHttZXRob2QsIHN0YXJ0LCBjb3VudH0gb2YgY2hhbmdlcykge1xuICAgICAgY29uc3QgbW92ZSA9IG1ldGhvZCA9PT0gJ19yZW1vdmVFbGVtZW50cycgPyAtY291bnQgOiBjb3VudDtcbiAgICAgIG1vdmVOdW1lcmljS2V5cyhfaGlkZGVuSW5kaWNlcywgc3RhcnQsIG1vdmUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHtcbiAgICBjb25zdCBfZGF0YUNoYW5nZXMgPSB0aGlzLl9kYXRhQ2hhbmdlcztcbiAgICBpZiAoIV9kYXRhQ2hhbmdlcyB8fCAhX2RhdGFDaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2RhdGFDaGFuZ2VzID0gW107XG4gICAgY29uc3QgZGF0YXNldENvdW50ID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBtYWtlU2V0ID0gKGlkeCkgPT4gbmV3IFNldChcbiAgICAgIF9kYXRhQ2hhbmdlc1xuICAgICAgICAuZmlsdGVyKGMgPT4gY1swXSA9PT0gaWR4KVxuICAgICAgICAubWFwKChjLCBpKSA9PiBpICsgJywnICsgYy5zcGxpY2UoMSkuam9pbignLCcpKVxuICAgICk7XG5cbiAgICBjb25zdCBjaGFuZ2VTZXQgPSBtYWtlU2V0KDApO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YXNldENvdW50OyBpKyspIHtcbiAgICAgIGlmICghc2V0c0VxdWFsKGNoYW5nZVNldCwgbWFrZVNldChpKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShjaGFuZ2VTZXQpXG4gICAgICAubWFwKGMgPT4gYy5zcGxpdCgnLCcpKVxuICAgICAgLm1hcChhID0+ICh7bWV0aG9kOiBhWzFdLCBzdGFydDogK2FbMl0sIGNvdW50OiArYVszXX0pKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBjaGFydCBsYXlvdXQgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZUxheW91dGBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyTGF5b3V0YC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVMYXlvdXQobWluUGFkZGluZykge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUxheW91dCcsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGF5b3V0cy51cGRhdGUodGhpcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIG1pblBhZGRpbmcpO1xuXG4gICAgY29uc3QgYXJlYSA9IHRoaXMuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG5vQXJlYSA9IGFyZWEud2lkdGggPD0gMCB8fCBhcmVhLmhlaWdodCA8PSAwO1xuXG4gICAgdGhpcy5fbGF5ZXJzID0gW107XG4gICAgZWFjaCh0aGlzLmJveGVzLCAoYm94KSA9PiB7XG4gICAgICBpZiAobm9BcmVhICYmIGJveC5wb3NpdGlvbiA9PT0gJ2NoYXJ0QXJlYScpIHtcbiAgICAgICAgLy8gU2tpcCBkcmF3aW5nIGFuZCBjb25maWd1cmluZyBjaGFydEFyZWEgYm94ZXMgd2hlbiBjaGFydEFyZWEgaXMgemVybyBvciBuZWdhdGl2ZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbmZpZ3VyZSBpcyBjYWxsZWQgdHdpY2UsIG9uY2UgaW4gY29yZS5zY2FsZS51cGRhdGUgYW5kIG9uY2UgaGVyZS5cbiAgICAgIC8vIEhlcmUgdGhlIGJveGVzIGFyZSBmdWxseSB1cGRhdGVkIGFuZCBhdCB0aGVpciBmaW5hbCBwb3NpdGlvbnMuXG4gICAgICBpZiAoYm94LmNvbmZpZ3VyZSkge1xuICAgICAgICBib3guY29uZmlndXJlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXllcnMucHVzaCguLi5ib3guX2xheWVycygpKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuX2xheWVycy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgaXRlbS5faWR4ID0gaW5kZXg7XG4gICAgfSk7XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyTGF5b3V0Jyk7XG4gIH1cblxuICAvKipcblx0ICogVXBkYXRlcyBhbGwgZGF0YXNldHMgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRzVXBkYXRlYFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0c1VwZGF0ZWAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlRGF0YXNldHMobW9kZSkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzVXBkYXRlJywge21vZGUsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlci5jb25maWd1cmUoKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURhdGFzZXQoaSwgaXNGdW5jdGlvbihtb2RlKSA/IG1vZGUoe2RhdGFzZXRJbmRleDogaX0pIDogbW9kZSk7XG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRzVXBkYXRlJywge21vZGV9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVcGRhdGVzIGRhdGFzZXQgYXQgaW5kZXggdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRVcGRhdGVgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRVcGRhdGVgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZURhdGFzZXQoaW5kZXgsIG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gICAgY29uc3QgYXJncyA9IHttZXRhLCBpbmRleCwgbW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX07XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0VXBkYXRlJywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWV0YS5jb250cm9sbGVyLl91cGRhdGUobW9kZSk7XG5cbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldFVwZGF0ZScsIGFyZ3MpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVJlbmRlcicsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGFuaW1hdG9yLmhhcyh0aGlzKSkge1xuICAgICAgaWYgKHRoaXMuYXR0YWNoZWQgJiYgIWFuaW1hdG9yLnJ1bm5pbmcodGhpcykpIHtcbiAgICAgICAgYW5pbWF0b3Iuc3RhcnQodGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgb25BbmltYXRpb25zQ29tcGxldGUoe2NoYXJ0OiB0aGlzfSk7XG4gICAgfVxuICB9XG5cbiAgZHJhdygpIHtcbiAgICBsZXQgaTtcbiAgICBpZiAodGhpcy5fcmVzaXplQmVmb3JlRHJhdykge1xuICAgICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcy5fcmVzaXplQmVmb3JlRHJhdztcbiAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEcmF3Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBCZWNhdXNlIG9mIHBsdWdpbiBob29rcyAoYmVmb3JlL2FmdGVyRGF0YXNldHNEcmF3KSwgZGF0YXNldHMgY2FuJ3RcbiAgICAvLyBjdXJyZW50bHkgYmUgcGFydCBvZiBsYXllcnMuIEluc3RlYWQsIHdlIGRyYXdcbiAgICAvLyBsYXllcnMgPD0gMCBiZWZvcmUoZGVmYXVsdCwgYmFja3dhcmQgY29tcGF0KSwgYW5kIHRoZSByZXN0IGFmdGVyXG4gICAgY29uc3QgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoICYmIGxheWVyc1tpXS56IDw9IDA7ICsraSkge1xuICAgICAgbGF5ZXJzW2ldLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgIH1cblxuICAgIHRoaXMuX2RyYXdEYXRhc2V0cygpO1xuXG4gICAgLy8gUmVzdCBvZiBsYXllcnNcbiAgICBmb3IgKDsgaSA8IGxheWVycy5sZW5ndGg7ICsraSkge1xuICAgICAgbGF5ZXJzW2ldLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEcmF3Jyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoZmlsdGVyVmlzaWJsZSkge1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fc29ydGVkTWV0YXNldHM7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtZXRhID0gbWV0YXNldHNbaV07XG4gICAgICBpZiAoIWZpbHRlclZpc2libGUgfHwgbWV0YS52aXNpYmxlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogR2V0cyB0aGUgdmlzaWJsZSBkYXRhc2V0IG1ldGFzIGluIGRyYXdpbmcgb3JkZXJcblx0ICogQHJldHVybiB7b2JqZWN0W119XG5cdCAqL1xuICBnZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTb3J0ZWREYXRhc2V0TWV0YXModHJ1ZSk7XG4gIH1cblxuICAvKipcblx0ICogRHJhd3MgYWxsIGRhdGFzZXRzIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0c0RyYXdgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRzRHJhd2AuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZHJhd0RhdGFzZXRzKCkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRoaXMuX2RyYXdEYXRhc2V0KG1ldGFzZXRzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldHNEcmF3Jyk7XG4gIH1cblxuICAvKipcblx0ICogRHJhd3MgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldERyYXdgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXREcmF3YC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3RGF0YXNldChtZXRhKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY2xpcCA9IG1ldGEuX2NsaXA7XG4gICAgY29uc3QgdXNlQ2xpcCA9ICFjbGlwLmRpc2FibGVkO1xuICAgIGNvbnN0IGFyZWEgPSBnZXREYXRhc2V0QXJlYShtZXRhLCB0aGlzLmNoYXJ0QXJlYSk7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIG1ldGEsXG4gICAgICBpbmRleDogbWV0YS5pbmRleCxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldERyYXcnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodXNlQ2xpcCkge1xuICAgICAgY2xpcEFyZWEoY3R4LCB7XG4gICAgICAgIGxlZnQ6IGNsaXAubGVmdCA9PT0gZmFsc2UgPyAwIDogYXJlYS5sZWZ0IC0gY2xpcC5sZWZ0LFxuICAgICAgICByaWdodDogY2xpcC5yaWdodCA9PT0gZmFsc2UgPyB0aGlzLndpZHRoIDogYXJlYS5yaWdodCArIGNsaXAucmlnaHQsXG4gICAgICAgIHRvcDogY2xpcC50b3AgPT09IGZhbHNlID8gMCA6IGFyZWEudG9wIC0gY2xpcC50b3AsXG4gICAgICAgIGJvdHRvbTogY2xpcC5ib3R0b20gPT09IGZhbHNlID8gdGhpcy5oZWlnaHQgOiBhcmVhLmJvdHRvbSArIGNsaXAuYm90dG9tXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXRhLmNvbnRyb2xsZXIuZHJhdygpO1xuXG4gICAgaWYgKHVzZUNsaXApIHtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG5cbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldERyYXcnLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gcG9pbnQgaXMgaW4gdGhlIGNoYXJ0IGFyZWEuXG4gICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXMgKHNlZSwgZS5nLiwgZ2V0UmVsYXRpdmVQb3NpdGlvbilcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1BvaW50SW5BcmVhKHBvaW50KSB7XG4gICAgcmV0dXJuIF9pc1BvaW50SW5BcmVhKHBvaW50LCB0aGlzLmNoYXJ0QXJlYSwgdGhpcy5fbWluUGFkZGluZyk7XG4gIH1cblxuICBnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG1vZGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCBtZXRob2QgPSBJbnRlcmFjdGlvbi5tb2Rlc1ttb2RlXTtcbiAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG1ldGhvZCh0aGlzLCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBnZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9tZXRhc2V0cztcbiAgICBsZXQgbWV0YSA9IG1ldGFzZXRzLmZpbHRlcih4ID0+IHggJiYgeC5fZGF0YXNldCA9PT0gZGF0YXNldCkucG9wKCk7XG5cbiAgICBpZiAoIW1ldGEpIHtcbiAgICAgIG1ldGEgPSB7XG4gICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICBkYXRhc2V0OiBudWxsLFxuICAgICAgICBjb250cm9sbGVyOiBudWxsLFxuICAgICAgICBoaWRkZW46IG51bGwsXHRcdFx0Ly8gU2VlIGlzRGF0YXNldFZpc2libGUoKSBjb21tZW50XG4gICAgICAgIHhBeGlzSUQ6IG51bGwsXG4gICAgICAgIHlBeGlzSUQ6IG51bGwsXG4gICAgICAgIG9yZGVyOiBkYXRhc2V0ICYmIGRhdGFzZXQub3JkZXIgfHwgMCxcbiAgICAgICAgaW5kZXg6IGRhdGFzZXRJbmRleCxcbiAgICAgICAgX2RhdGFzZXQ6IGRhdGFzZXQsXG4gICAgICAgIF9wYXJzZWQ6IFtdLFxuICAgICAgICBfc29ydGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIG1ldGFzZXRzLnB1c2gobWV0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGE7XG4gIH1cblxuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8ICh0aGlzLiRjb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsLCB7Y2hhcnQ6IHRoaXMsIHR5cGU6ICdjaGFydCd9KSk7XG4gIH1cblxuICBnZXRWaXNpYmxlRGF0YXNldENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5sZW5ndGg7XG4gIH1cblxuICBpc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAoIWRhdGFzZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXG4gICAgLy8gbWV0YS5oaWRkZW4gaXMgYSBwZXIgY2hhcnQgZGF0YXNldCBoaWRkZW4gZmxhZyBvdmVycmlkZSB3aXRoIDMgc3RhdGVzOiBpZiB0cnVlIG9yIGZhbHNlLFxuICAgIC8vIHRoZSBkYXRhc2V0LmhpZGRlbiB2YWx1ZSBpcyBpZ25vcmVkLCBlbHNlIGlmIG51bGwsIHRoZSBkYXRhc2V0IGhpZGRlbiBzdGF0ZSBpcyByZXR1cm5lZC5cbiAgICByZXR1cm4gdHlwZW9mIG1ldGEuaGlkZGVuID09PSAnYm9vbGVhbicgPyAhbWV0YS5oaWRkZW4gOiAhZGF0YXNldC5oaWRkZW47XG4gIH1cblxuICBzZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIG1ldGEuaGlkZGVuID0gIXZpc2libGU7XG4gIH1cblxuICB0b2dnbGVEYXRhVmlzaWJpbGl0eShpbmRleCkge1xuICAgIHRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdID0gIXRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdO1xuICB9XG5cbiAgZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcbiAgICByZXR1cm4gIXRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgdmlzaWJsZSkge1xuICAgIGNvbnN0IG1vZGUgPSB2aXNpYmxlID8gJ3Nob3cnIDogJ2hpZGUnO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgY29uc3QgYW5pbXMgPSBtZXRhLmNvbnRyb2xsZXIuX3Jlc29sdmVBbmltYXRpb25zKHVuZGVmaW5lZCwgbW9kZSk7XG5cbiAgICBpZiAoZGVmaW5lZChkYXRhSW5kZXgpKSB7XG4gICAgICBtZXRhLmRhdGFbZGF0YUluZGV4XS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0RGF0YXNldFZpc2liaWxpdHkoZGF0YXNldEluZGV4LCB2aXNpYmxlKTtcbiAgICAgIC8vIEFuaW1hdGUgdmlzaWJsZSBzdGF0ZSwgc28gaGlkZSBhbmltYXRpb24gY2FuIGJlIHNlZW4uIFRoaXMgY291bGQgYmUgaGFuZGxlZCBiZXR0ZXIgaWYgdXBkYXRlIC8gdXBkYXRlRGF0YXNldCByZXR1cm5lZCBhIFByb21pc2UuXG4gICAgICBhbmltcy51cGRhdGUobWV0YSwge3Zpc2libGV9KTtcbiAgICAgIHRoaXMudXBkYXRlKChjdHgpID0+IGN0eC5kYXRhc2V0SW5kZXggPT09IGRhdGFzZXRJbmRleCA/IG1vZGUgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxuXG4gIGhpZGUoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCBmYWxzZSk7XG4gIH1cblxuICBzaG93KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KSB7XG4gICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgdHJ1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kZXN0cm95RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKG1ldGEgJiYgbWV0YS5jb250cm9sbGVyKSB7XG4gICAgICBtZXRhLmNvbnRyb2xsZXIuX2Rlc3Ryb3koKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gIH1cblxuICBfc3RvcCgpIHtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICBhbmltYXRvci5yZW1vdmUodGhpcyk7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEZXN0cm95Jyk7XG4gICAgY29uc3Qge2NhbnZhcywgY3R4fSA9IHRoaXM7XG5cbiAgICB0aGlzLl9zdG9wKCk7XG4gICAgdGhpcy5jb25maWcuY2xlYXJDYWNoZSgpO1xuXG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgIGNsZWFyQ2FudmFzKGNhbnZhcywgY3R4KTtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVsZWFzZUNvbnRleHQoY3R4KTtcbiAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgIHRoaXMuY3R4ID0gbnVsbDtcbiAgICB9XG5cbiAgICBkZWxldGUgaW5zdGFuY2VzW3RoaXMuaWRdO1xuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRlc3Ryb3knKTtcbiAgfVxuXG4gIHRvQmFzZTY0SW1hZ2UoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy50b0RhdGFVUkwoLi4uYXJncyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5iaW5kVXNlckV2ZW50cygpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy5iaW5kUmVzcG9uc2l2ZUV2ZW50cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJpbmRVc2VyRXZlbnRzKCkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG5cbiAgICBjb25zdCBfYWRkID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH07XG5cbiAgICBjb25zdCBsaXN0ZW5lciA9IChlLCB4LCB5KSA9PiB7XG4gICAgICBlLm9mZnNldFggPSB4O1xuICAgICAgZS5vZmZzZXRZID0geTtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihlKTtcbiAgICB9O1xuXG4gICAgZWFjaCh0aGlzLm9wdGlvbnMuZXZlbnRzLCAodHlwZSkgPT4gX2FkZCh0eXBlLCBsaXN0ZW5lcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBiaW5kUmVzcG9uc2l2ZUV2ZW50cygpIHtcbiAgICBpZiAoIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycztcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG5cbiAgICBjb25zdCBfYWRkID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH07XG4gICAgY29uc3QgX3JlbW92ZSA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICBwbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1t0eXBlXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgbGlzdGVuZXIgPSAod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgZGV0YWNoZWQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgY29uc3QgYXR0YWNoZWQgPSAoKSA9PiB7XG4gICAgICBfcmVtb3ZlKCdhdHRhY2gnLCBhdHRhY2hlZCk7XG5cbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgdGhpcy5yZXNpemUoKTtcblxuICAgICAgX2FkZCgncmVzaXplJywgbGlzdGVuZXIpO1xuICAgICAgX2FkZCgnZGV0YWNoJywgZGV0YWNoZWQpO1xuICAgIH07XG5cbiAgICBkZXRhY2hlZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcblxuICAgICAgX3JlbW92ZSgncmVzaXplJywgbGlzdGVuZXIpO1xuXG4gICAgICAvLyBTdG9wIGFuaW1hdGluZyBhbmQgcmVtb3ZlIG1ldGFzZXRzLCBzbyB3aGVuIHJlLWF0dGFjaGVkLCB0aGUgYW5pbWF0aW9ucyBzdGFydCBmcm9tIGJlZ2lubmluZy5cbiAgICAgIHRoaXMuX3N0b3AoKTtcbiAgICAgIHRoaXMuX3Jlc2l6ZSgwLCAwKTtcblxuICAgICAgX2FkZCgnYXR0YWNoJywgYXR0YWNoZWQpO1xuICAgIH07XG5cbiAgICBpZiAocGxhdGZvcm0uaXNBdHRhY2hlZCh0aGlzLmNhbnZhcykpIHtcbiAgICAgIGF0dGFjaGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRldGFjaGVkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICB1bmJpbmRFdmVudHMoKSB7XG4gICAgZWFjaCh0aGlzLl9saXN0ZW5lcnMsIChsaXN0ZW5lciwgdHlwZSkgPT4ge1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcblxuICAgIGVhY2godGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKSA9PiB7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB1cGRhdGVIb3ZlclN0eWxlKGl0ZW1zLCBtb2RlLCBlbmFibGVkKSB7XG4gICAgY29uc3QgcHJlZml4ID0gZW5hYmxlZCA/ICdzZXQnIDogJ3JlbW92ZSc7XG4gICAgbGV0IG1ldGEsIGl0ZW0sIGksIGlsZW47XG5cbiAgICBpZiAobW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtc1swXS5kYXRhc2V0SW5kZXgpO1xuICAgICAgbWV0YS5jb250cm9sbGVyWydfJyArIHByZWZpeCArICdEYXRhc2V0SG92ZXJTdHlsZSddKCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IGl0ZW0gJiYgdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtLmRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXJbcHJlZml4ICsgJ0hvdmVyU3R5bGUnXShpdGVtLmVsZW1lbnQsIGl0ZW0uZGF0YXNldEluZGV4LCBpdGVtLmluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogR2V0IGFjdGl2ZSAoaG92ZXJlZCkgZWxlbWVudHNcblx0ICogQHJldHVybnMgYXJyYXlcblx0ICovXG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cblxuICAvKipcblx0ICogU2V0IGFjdGl2ZSAoaG92ZXJlZCkgZWxlbWVudHNcblx0ICogQHBhcmFtIHthcnJheX0gYWN0aXZlRWxlbWVudHMgTmV3IGFjdGl2ZSBkYXRhIHBvaW50c1xuXHQgKi9cbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMpIHtcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoe2RhdGFzZXRJbmRleCwgaW5kZXh9KSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF0YXNldCBmb3VuZCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICBlbGVtZW50OiBtZXRhLmRhdGFbaW5kZXhdLFxuICAgICAgICBpbmRleCxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpO1xuXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCB1c2UgdGhlIHByZXZpb3VzIG1vdXNlIGV2ZW50IHRvIG92ZXJyaWRlIHRoZSBhY3RpdmUgZWxlbWVudHMgaW4gdXBkYXRlLlxuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIENhbGxzIGVuYWJsZWQgcGx1Z2lucyBvbiB0aGUgc3BlY2lmaWVkIGhvb2sgYW5kIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG5cdCAqIFRoaXMgbWV0aG9kIGltbWVkaWF0ZWx5IHJldHVybnMgYXMgc29vbiBhcyBhIHBsdWdpbiBleHBsaWNpdGx5IHJldHVybnMgZmFsc2UuIFRoZVxuXHQgKiByZXR1cm5lZCB2YWx1ZSBjYW4gYmUgdXNlZCwgZm9yIGluc3RhbmNlLCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgYWN0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaG9vayAtIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gbWV0aG9kIHRvIGNhbGwgKGUuZy4gJ2JlZm9yZVVwZGF0ZScpLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2FyZ3NdIC0gRXh0cmEgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBob29rIGNhbGwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL2NvcmUucGx1Z2lucy5qcycpLmZpbHRlckNhbGxiYWNrfSBbZmlsdGVyXSAtIEZpbHRlcmluZyBmdW5jdGlvbiBmb3IgbGltaXRpbmcgd2hpY2ggcGx1Z2lucyBhcmUgbm90aWZpZWRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIGFueSBvZiB0aGUgcGx1Z2lucyByZXR1cm4gZmFsc2UsIGVsc2UgcmV0dXJucyB0cnVlLlxuXHQgKi9cbiAgbm90aWZ5UGx1Z2lucyhob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1Z2lucy5ub3RpZnkodGhpcywgaG9vaywgYXJncywgZmlsdGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHBsdWdpbiB3aXRoIHRoZSBzcGVjaWZpYyBJRCBpcyByZWdpc3RlcmVkIGFuZCBlbmFibGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwbHVnaW5JZCAtIFRoZSBJRCBvZiB0aGUgcGx1Z2luIG9mIHdoaWNoIHRvIGNoZWNrIGlmIGl0IGlzIGVuYWJsZWRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1BsdWdpbkVuYWJsZWQocGx1Z2luSWQpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1Z2lucy5fY2FjaGUuZmlsdGVyKHAgPT4gcC5wbHVnaW4uaWQgPT09IHBsdWdpbklkKS5sZW5ndGggPT09IDE7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUsIHJlcGxheSkge1xuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICBjb25zdCBkaWZmID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuc29tZSh5ID0+IHguZGF0YXNldEluZGV4ID09PSB5LmRhdGFzZXRJbmRleCAmJiB4LmluZGV4ID09PSB5LmluZGV4KSk7XG4gICAgY29uc3QgZGVhY3RpdmF0ZWQgPSBkaWZmKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgY29uc3QgYWN0aXZhdGVkID0gcmVwbGF5ID8gYWN0aXZlIDogZGlmZihhY3RpdmUsIGxhc3RBY3RpdmUpO1xuXG4gICAgaWYgKGRlYWN0aXZhdGVkLmxlbmd0aCkge1xuICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGRlYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChhY3RpdmF0ZWQubGVuZ3RoICYmIGhvdmVyT3B0aW9ucy5tb2RlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZXZlbnRIYW5kbGVyKGUsIHJlcGxheSkge1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBldmVudDogZSxcbiAgICAgIHJlcGxheSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBpbkNoYXJ0QXJlYTogdGhpcy5pc1BvaW50SW5BcmVhKGUpXG4gICAgfTtcbiAgICBjb25zdCBldmVudEZpbHRlciA9IChwbHVnaW4pID0+IChwbHVnaW4ub3B0aW9ucy5ldmVudHMgfHwgdGhpcy5vcHRpb25zLmV2ZW50cykuaW5jbHVkZXMoZS5uYXRpdmUudHlwZSk7XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5faGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBhcmdzLmluQ2hhcnRBcmVhKTtcblxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKTtcblxuICAgIGlmIChjaGFuZ2VkIHx8IGFyZ3MuY2hhbmdlZCkge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIHRoZSBldmVudCB0byBoYW5kbGVcblx0ICogQHBhcmFtIHtib29sZWFufSBbcmVwbGF5XSAtIHRydWUgaWYgdGhlIGV2ZW50IHdhcyByZXBsYXllZCBieSBgdXBkYXRlYFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbkNoYXJ0QXJlYV0gLSB0cnVlIGlmIHRoZSBldmVudCBpcyBpbnNpZGUgY2hhcnRBcmVhXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGNoYXJ0IG5lZWRzIHRvIHJlLXJlbmRlclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2hhbmRsZUV2ZW50KGUsIHJlcGxheSwgaW5DaGFydEFyZWEpIHtcbiAgICBjb25zdCB7X2FjdGl2ZTogbGFzdEFjdGl2ZSA9IFtdLCBvcHRpb25zfSA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGUgZXZlbnQgaXMgcmVwbGF5ZWQgZnJvbSBgdXBkYXRlYCwgd2Ugc2hvdWxkIGV2YWx1YXRlIHdpdGggdGhlIGZpbmFsIHBvc2l0aW9ucy5cbiAgICAvL1xuICAgIC8vIFRoZSBgcmVwbGF5YDpcbiAgICAvLyBJdCdzIHRoZSBsYXN0IGV2ZW50IChleGNsdWRpbmcgY2xpY2spIHRoYXQgaGFzIG9jY3VycmVkIGJlZm9yZSBgdXBkYXRlYC5cbiAgICAvLyBTbyBtb3VzZSBoYXMgbm90IG1vdmVkLiBJdCdzIGFsc28gb3ZlciB0aGUgY2hhcnQsIGJlY2F1c2UgdGhlcmUgaXMgYSBgcmVwbGF5YC5cbiAgICAvL1xuICAgIC8vIFRoZSB3aHk6XG4gICAgLy8gSWYgYW5pbWF0aW9ucyBhcmUgYWN0aXZlLCB0aGUgZWxlbWVudHMgaGF2ZW4ndCBtb3ZlZCB5ZXQgY29tcGFyZWQgdG8gc3RhdGUgYmVmb3JlIHVwZGF0ZS5cbiAgICAvLyBCdXQgaWYgdGhleSB3aWxsLCB3ZSBhcmUgYWN0aXZhdGluZyB0aGUgZWxlbWVudHMgdGhhdCB3b3VsZCBiZSBhY3RpdmUsIGlmIHRoaXMgY2hlY2tcbiAgICAvLyB3YXMgZG9uZSBhZnRlciB0aGUgYW5pbWF0aW9ucyBoYXZlIGNvbXBsZXRlZC4gPT4gXCJmaW5hbCBwb3NpdGlvbnNcIi5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbmltYXRpb25zLCB0aGUgXCJmaW5hbFwiIGFuZCBcImN1cnJlbnRcIiBwb3NpdGlvbnMgYXJlIGVxdWFsLlxuICAgIC8vIFRoaXMgaXMgZG9uZSBzbyB3ZSBkbyBub3QgaGF2ZSB0byBldmFsdWF0ZSB0aGUgYWN0aXZlIGVsZW1lbnRzIGVhY2ggYW5pbWF0aW9uIGZyYW1lXG4gICAgLy8gLSBpdCB3b3VsZCBiZSBleHBlbnNpdmUuXG4gICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IHJlcGxheTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCBpbkNoYXJ0QXJlYSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgaXNDbGljayA9IF9pc0NsaWNrRXZlbnQoZSk7XG4gICAgY29uc3QgbGFzdEV2ZW50ID0gZGV0ZXJtaW5lTGFzdEV2ZW50KGUsIHRoaXMuX2xhc3RFdmVudCwgaW5DaGFydEFyZWEsIGlzQ2xpY2spO1xuXG4gICAgaWYgKGluQ2hhcnRBcmVhKSB7XG4gICAgICAvLyBTZXQgX2xhc3RFdmVudCB0byBudWxsIHdoaWxlIHdlIGFyZSBwcm9jZXNzaW5nIHRoZSBldmVudCBoYW5kbGVycy5cbiAgICAgIC8vIFRoaXMgcHJldmVudHMgcmVjdXJzaW9uIGlmIHRoZSBoYW5kbGVyIGNhbGxzIGNoYXJ0LnVwZGF0ZSgpXG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuXG4gICAgICAvLyBJbnZva2Ugb25Ib3ZlciBob29rXG4gICAgICBjYWxsQ2FsbGJhY2sob3B0aW9ucy5vbkhvdmVyLCBbZSwgYWN0aXZlLCB0aGlzXSwgdGhpcyk7XG5cbiAgICAgIGlmIChpc0NsaWNrKSB7XG4gICAgICAgIGNhbGxDYWxsYmFjayhvcHRpb25zLm9uQ2xpY2ssIFtlLCBhY3RpdmUsIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGNoYW5nZWQgfHwgcmVwbGF5KSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUsIHJlcGxheSk7XG4gICAgfVxuXG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gbGFzdEV2ZW50O1xuXG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkFjdGl2ZUVsZW1lbnRbXX0gbGFzdEFjdGl2ZSAtIFByZXZpb3VzbHkgYWN0aXZlIGVsZW1lbnRzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5DaGFydEFyZWEgLSBJcyB0aGUgZW52ZW50IGluc2lkZSBjaGFydEFyZWFcbiAgICogQHBhcmFtIHtib29sZWFufSB1c2VGaW5hbFBvc2l0aW9uIC0gU2hvdWxkIHRoZSBldmFsdWF0aW9uIGJlIGRvbmUgd2l0aCBjdXJyZW50IG9yIGZpbmFsIChhZnRlciBhbmltYXRpb24pIGVsZW1lbnQgcG9zaXRpb25zXG4gICAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQWN0aXZlRWxlbWVudFtdfSAtIFRoZSBhY3RpdmUgZWxlbWVudHNcbiAgICogQHByYXZhdGVcbiAgICovXG4gIF9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCBpbkNoYXJ0QXJlYSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAoIWluQ2hhcnRBcmVhKSB7XG4gICAgICAvLyBMZXQgdXNlciBjb250cm9sIHRoZSBhY3RpdmUgZWxlbWVudHMgb3V0c2lkZSBjaGFydEFyZWEuIEVnLiB1c2luZyBMZWdlbmQuXG4gICAgICByZXR1cm4gbGFzdEFjdGl2ZTtcbiAgICB9XG5cbiAgICBjb25zdCBob3Zlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuaG92ZXI7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBob3Zlck9wdGlvbnMubW9kZSwgaG92ZXJPcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxufVxuXG4vLyBAdHMtaWdub3JlXG5mdW5jdGlvbiBpbnZhbGlkYXRlUGx1Z2lucygpIHtcbiAgcmV0dXJuIGVhY2goQ2hhcnQuaW5zdGFuY2VzLCAoY2hhcnQpID0+IGNoYXJ0Ll9wbHVnaW5zLmludmFsaWRhdGUoKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IENoYXJ0O1xuIiwgImltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7X2FuZ2xlQmV0d2VlbiwgZ2V0QW5nbGVGcm9tUG9pbnQsIFRBVSwgSEFMRl9QSSwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtQSSwgX2lzQmV0d2VlbiwgX2xpbWl0VmFsdWV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X3JlYWRWYWx1ZVRvUHJvcHN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcbmltcG9ydCB0eXBlIHtBcmNPcHRpb25zLCBQb2ludH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG5cbmZ1bmN0aW9uIGNsaXBBcmMoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGVsZW1lbnQ6IEFyY0VsZW1lbnQsIGVuZEFuZ2xlOiBudW1iZXIpIHtcbiAgY29uc3Qge3N0YXJ0QW5nbGUsIHBpeGVsTWFyZ2luLCB4LCB5LCBvdXRlclJhZGl1cywgaW5uZXJSYWRpdXN9ID0gZWxlbWVudDtcbiAgbGV0IGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyBvdXRlclJhZGl1cztcblxuICAvLyBEcmF3IGFuIGlubmVyIGJvcmRlciBieSBjbGlwcGluZyB0aGUgYXJjIGFuZCBkcmF3aW5nIGEgZG91YmxlLXdpZHRoIGJvcmRlclxuICAvLyBFbmxhcmdlIHRoZSBjbGlwcGluZyBhcmMgYnkgMC4zMyBwaXhlbHMgdG8gZWxpbWluYXRlIGdsaXRjaGVzIGJldHdlZW4gYm9yZGVyc1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbik7XG4gIGlmIChpbm5lclJhZGl1cyA+IHBpeGVsTWFyZ2luKSB7XG4gICAgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIGlubmVyUmFkaXVzO1xuICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlICsgYW5nbGVNYXJnaW4sIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmFyYyh4LCB5LCBwaXhlbE1hcmdpbiwgZW5kQW5nbGUgKyBIQUxGX1BJLCBzdGFydEFuZ2xlIC0gSEFMRl9QSSk7XG4gIH1cbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguY2xpcCgpO1xufVxuXG5mdW5jdGlvbiB0b1JhZGl1c0Nvcm5lcnModmFsdWUpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBbJ291dGVyU3RhcnQnLCAnb3V0ZXJFbmQnLCAnaW5uZXJTdGFydCcsICdpbm5lckVuZCddKTtcbn1cblxuLyoqXG4gKiBQYXJzZSBib3JkZXIgcmFkaXVzIGZyb20gdGhlIHByb3ZpZGVkIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gcGFyc2VCb3JkZXJSYWRpdXMoYXJjOiBBcmNFbGVtZW50LCBpbm5lclJhZGl1czogbnVtYmVyLCBvdXRlclJhZGl1czogbnVtYmVyLCBhbmdsZURlbHRhOiBudW1iZXIpIHtcbiAgY29uc3QgbyA9IHRvUmFkaXVzQ29ybmVycyhhcmMub3B0aW9ucy5ib3JkZXJSYWRpdXMpO1xuICBjb25zdCBoYWxmVGhpY2tuZXNzID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gMjtcbiAgY29uc3QgaW5uZXJMaW1pdCA9IE1hdGgubWluKGhhbGZUaGlja25lc3MsIGFuZ2xlRGVsdGEgKiBpbm5lclJhZGl1cyAvIDIpO1xuXG4gIC8vIE91dGVyIGxpbWl0cyBhcmUgY29tcGxpY2F0ZWQuIFdlIHdhbnQgdG8gY29tcHV0ZSB0aGUgYXZhaWxhYmxlIGFuZ3VsYXIgZGlzdGFuY2UgYXRcbiAgLy8gYSByYWRpdXMgb2Ygb3V0ZXJSYWRpdXMgLSBib3JkZXJSYWRpdXMgYmVjYXVzZSBmb3Igc21hbGwgYW5ndWxhciBkaXN0YW5jZXMsIHRoaXMgdGVybSBsaW1pdHMuXG4gIC8vIFdlIGNvbXB1dGUgYXQgciA9IG91dGVyUmFkaXVzIC0gYm9yZGVyUmFkaXVzIGJlY2F1c2UgdGhpcyBjaXJjbGUgZGVmaW5lcyB0aGUgY2VudGVyIG9mIHRoZSBib3JkZXIgY29ybmVycy5cbiAgLy9cbiAgLy8gSWYgdGhlIGJvcmRlclJhZGl1cyBpcyBsYXJnZSwgdGhhdCB2YWx1ZSBjYW4gYmVjb21lIG5lZ2F0aXZlLlxuICAvLyBUaGlzIGNhdXNlcyB0aGUgb3V0ZXIgYm9yZGVycyB0byBsb3NlIHRoZWlyIHJhZGl1cyBlbnRpcmVseSwgd2hpY2ggaXMgcmF0aGVyIHVuZXhwZWN0ZWQuIFRvIHNvbHZlIHRoYXQsIGlmIGJvcmRlclJhZGl1cyA+IG91dGVyUmFkaXVzXG4gIC8vIHdlIGtub3cgdGhhdCB0aGUgdGhpY2tuZXNzIHRlcm0gd2lsbCBkb21pbmF0ZSBhbmQgY29tcHV0ZSB0aGUgbGltaXRzIGF0IHRoYXQgcG9pbnRcbiAgY29uc3QgY29tcHV0ZU91dGVyTGltaXQgPSAodmFsKSA9PiB7XG4gICAgY29uc3Qgb3V0ZXJBcmNMaW1pdCA9IChvdXRlclJhZGl1cyAtIE1hdGgubWluKGhhbGZUaGlja25lc3MsIHZhbCkpICogYW5nbGVEZWx0YSAvIDI7XG4gICAgcmV0dXJuIF9saW1pdFZhbHVlKHZhbCwgMCwgTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgb3V0ZXJBcmNMaW1pdCkpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgb3V0ZXJTdGFydDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlclN0YXJ0KSxcbiAgICBvdXRlckVuZDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlckVuZCksXG4gICAgaW5uZXJTdGFydDogX2xpbWl0VmFsdWUoby5pbm5lclN0YXJ0LCAwLCBpbm5lckxpbWl0KSxcbiAgICBpbm5lckVuZDogX2xpbWl0VmFsdWUoby5pbm5lckVuZCwgMCwgaW5uZXJMaW1pdCksXG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydCAociwg8J2cgykgdG8gKHgsIHkpXG4gKi9cbmZ1bmN0aW9uIHJUaGV0YVRvWFkocjogbnVtYmVyLCB0aGV0YTogbnVtYmVyLCB4OiBudW1iZXIsIHk6IG51bWJlcikge1xuICByZXR1cm4ge1xuICAgIHg6IHggKyByICogTWF0aC5jb3ModGhldGEpLFxuICAgIHk6IHkgKyByICogTWF0aC5zaW4odGhldGEpLFxuICB9O1xufVxuXG5cbi8qKlxuICogUGF0aCB0aGUgYXJjLCByZXNwZWN0aW5nIGJvcmRlciByYWRpdXMgYnkgc2VwYXJhdGluZyBpbnRvIGxlZnQgYW5kIHJpZ2h0IGhhbHZlcy5cbiAqXG4gKiAgIFN0YXJ0ICAgICAgRW5kXG4gKlxuICogICAgMS0tLT5hLS0tPjIgICAgT3V0ZXJcbiAqICAgLyAgICAgICAgICAgXFxcbiAqICAgOCAgICAgICAgICAgM1xuICogICB8ICAgICAgICAgICB8XG4gKiAgIHwgICAgICAgICAgIHxcbiAqICAgNyAgICAgICAgICAgNFxuICogICBcXCAgICAgICAgICAgL1xuICogICAgNjwtLS1iPC0tLTUgICAgSW5uZXJcbiAqL1xuZnVuY3Rpb24gcGF0aEFyYyhcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGVsZW1lbnQ6IEFyY0VsZW1lbnQsXG4gIG9mZnNldDogbnVtYmVyLFxuICBzcGFjaW5nOiBudW1iZXIsXG4gIGVuZDogbnVtYmVyLFxuICBjaXJjdWxhcjogYm9vbGVhbixcbikge1xuICBjb25zdCB7eCwgeSwgc3RhcnRBbmdsZTogc3RhcnQsIHBpeGVsTWFyZ2luLCBpbm5lclJhZGl1czogaW5uZXJSfSA9IGVsZW1lbnQ7XG5cbiAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChlbGVtZW50Lm91dGVyUmFkaXVzICsgc3BhY2luZyArIG9mZnNldCAtIHBpeGVsTWFyZ2luLCAwKTtcbiAgY29uc3QgaW5uZXJSYWRpdXMgPSBpbm5lclIgPiAwID8gaW5uZXJSICsgc3BhY2luZyArIG9mZnNldCArIHBpeGVsTWFyZ2luIDogMDtcblxuICBsZXQgc3BhY2luZ09mZnNldCA9IDA7XG4gIGNvbnN0IGFscGhhID0gZW5kIC0gc3RhcnQ7XG5cbiAgaWYgKHNwYWNpbmcpIHtcbiAgICAvLyBXaGVuIHNwYWNpbmcgaXMgcHJlc2VudCwgaXQgaXMgdGhlIHNhbWUgZm9yIGFsbCBpdGVtc1xuICAgIC8vIFNvIHdlIGFkanVzdCB0aGUgc3RhcnQgYW5kIGVuZCBhbmdsZSBvZiB0aGUgYXJjIHN1Y2ggdGhhdFxuICAgIC8vIHRoZSBkaXN0YW5jZSBpcyB0aGUgc2FtZSBhcyBpdCB3b3VsZCBiZSB3aXRob3V0IHRoZSBzcGFjaW5nXG4gICAgY29uc3Qgbm9TcGFjaW5nSW5uZXJSYWRpdXMgPSBpbm5lclIgPiAwID8gaW5uZXJSIC0gc3BhY2luZyA6IDA7XG4gICAgY29uc3Qgbm9TcGFjaW5nT3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyA+IDAgPyBvdXRlclJhZGl1cyAtIHNwYWNpbmcgOiAwO1xuICAgIGNvbnN0IGF2Tm9nU3BhY2luZ1JhZGl1cyA9IChub1NwYWNpbmdJbm5lclJhZGl1cyArIG5vU3BhY2luZ091dGVyUmFkaXVzKSAvIDI7XG4gICAgY29uc3QgYWRqdXN0ZWRBbmdsZSA9IGF2Tm9nU3BhY2luZ1JhZGl1cyAhPT0gMCA/IChhbHBoYSAqIGF2Tm9nU3BhY2luZ1JhZGl1cykgLyAoYXZOb2dTcGFjaW5nUmFkaXVzICsgc3BhY2luZykgOiBhbHBoYTtcbiAgICBzcGFjaW5nT2Zmc2V0ID0gKGFscGhhIC0gYWRqdXN0ZWRBbmdsZSkgLyAyO1xuICB9XG5cbiAgY29uc3QgYmV0YSA9IE1hdGgubWF4KDAuMDAxLCBhbHBoYSAqIG91dGVyUmFkaXVzIC0gb2Zmc2V0IC8gUEkpIC8gb3V0ZXJSYWRpdXM7XG4gIGNvbnN0IGFuZ2xlT2Zmc2V0ID0gKGFscGhhIC0gYmV0YSkgLyAyO1xuICBjb25zdCBzdGFydEFuZ2xlID0gc3RhcnQgKyBhbmdsZU9mZnNldCArIHNwYWNpbmdPZmZzZXQ7XG4gIGNvbnN0IGVuZEFuZ2xlID0gZW5kIC0gYW5nbGVPZmZzZXQgLSBzcGFjaW5nT2Zmc2V0O1xuICBjb25zdCB7b3V0ZXJTdGFydCwgb3V0ZXJFbmQsIGlubmVyU3RhcnQsIGlubmVyRW5kfSA9IHBhcnNlQm9yZGVyUmFkaXVzKGVsZW1lbnQsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcblxuICBjb25zdCBvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMgPSBvdXRlclJhZGl1cyAtIG91dGVyU3RhcnQ7XG4gIGNvbnN0IG91dGVyRW5kQWRqdXN0ZWRSYWRpdXMgPSBvdXRlclJhZGl1cyAtIG91dGVyRW5kO1xuICBjb25zdCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBvdXRlclN0YXJ0IC8gb3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzO1xuICBjb25zdCBvdXRlckVuZEFkanVzdGVkQW5nbGUgPSBlbmRBbmdsZSAtIG91dGVyRW5kIC8gb3V0ZXJFbmRBZGp1c3RlZFJhZGl1cztcblxuICBjb25zdCBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMgPSBpbm5lclJhZGl1cyArIGlubmVyU3RhcnQ7XG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMgPSBpbm5lclJhZGl1cyArIGlubmVyRW5kO1xuICBjb25zdCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBpbm5lclN0YXJ0IC8gaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzO1xuICBjb25zdCBpbm5lckVuZEFkanVzdGVkQW5nbGUgPSBlbmRBbmdsZSAtIGlubmVyRW5kIC8gaW5uZXJFbmRBZGp1c3RlZFJhZGl1cztcblxuICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgaWYgKGNpcmN1bGFyKSB7XG4gICAgLy8gVGhlIGZpcnN0IGFyYyBzZWdtZW50cyBmcm9tIHBvaW50IDEgdG8gcG9pbnQgYSB0byBwb2ludCAyXG4gICAgY29uc3Qgb3V0ZXJNaWRBZGp1c3RlZEFuZ2xlID0gKG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlICsgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKSAvIDI7XG4gICAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUsIG91dGVyTWlkQWRqdXN0ZWRBbmdsZSk7XG4gICAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgb3V0ZXJNaWRBZGp1c3RlZEFuZ2xlLCBvdXRlckVuZEFkanVzdGVkQW5nbGUpO1xuXG4gICAgLy8gVGhlIGNvcm5lciBzZWdtZW50IGZyb20gcG9pbnQgMiB0byBwb2ludCAzXG4gICAgaWYgKG91dGVyRW5kID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJFbmRBZGp1c3RlZFJhZGl1cywgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIG91dGVyRW5kLCBvdXRlckVuZEFkanVzdGVkQW5nbGUsIGVuZEFuZ2xlICsgSEFMRl9QSSk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGxpbmUgZnJvbSBwb2ludCAzIHRvIHBvaW50IDRcbiAgICBjb25zdCBwNCA9IHJUaGV0YVRvWFkoaW5uZXJFbmRBZGp1c3RlZFJhZGl1cywgZW5kQW5nbGUsIHgsIHkpO1xuICAgIGN0eC5saW5lVG8ocDQueCwgcDQueSk7XG5cbiAgICAvLyBUaGUgY29ybmVyIHNlZ21lbnQgZnJvbSBwb2ludCA0IHRvIHBvaW50IDVcbiAgICBpZiAoaW5uZXJFbmQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBpbm5lckVuZEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgaW5uZXJFbmQsIGVuZEFuZ2xlICsgSEFMRl9QSSwgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlICsgTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGlubmVyIGFyYyBmcm9tIHBvaW50IDUgdG8gcG9pbnQgYiB0byBwb2ludCA2XG4gICAgY29uc3QgaW5uZXJNaWRBZGp1c3RlZEFuZ2xlID0gKChlbmRBbmdsZSAtIChpbm5lckVuZCAvIGlubmVyUmFkaXVzKSkgKyAoc3RhcnRBbmdsZSArIChpbm5lclN0YXJ0IC8gaW5uZXJSYWRpdXMpKSkgLyAyO1xuICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlIC0gKGlubmVyRW5kIC8gaW5uZXJSYWRpdXMpLCBpbm5lck1pZEFkanVzdGVkQW5nbGUsIHRydWUpO1xuICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGlubmVyTWlkQWRqdXN0ZWRBbmdsZSwgc3RhcnRBbmdsZSArIChpbm5lclN0YXJ0IC8gaW5uZXJSYWRpdXMpLCB0cnVlKTtcblxuICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDYgdG8gcG9pbnQgN1xuICAgIGlmIChpbm5lclN0YXJ0ID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkoaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzLCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lclN0YXJ0LCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSArIE1hdGguUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgbGluZSBmcm9tIHBvaW50IDcgdG8gcG9pbnQgOFxuICAgIGNvbnN0IHA4ID0gclRoZXRhVG9YWShvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIHN0YXJ0QW5nbGUsIHgsIHkpO1xuICAgIGN0eC5saW5lVG8ocDgueCwgcDgueSk7XG5cbiAgICAvLyBUaGUgY29ybmVyIHNlZ21lbnQgZnJvbSBwb2ludCA4IHRvIHBvaW50IDFcbiAgICBpZiAob3V0ZXJTdGFydCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJTdGFydCwgc3RhcnRBbmdsZSAtIEhBTEZfUEksIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY3R4Lm1vdmVUbyh4LCB5KTtcblxuICAgIGNvbnN0IG91dGVyU3RhcnRYID0gTWF0aC5jb3Mob3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB4O1xuICAgIGNvbnN0IG91dGVyU3RhcnRZID0gTWF0aC5zaW4ob3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB5O1xuICAgIGN0eC5saW5lVG8ob3V0ZXJTdGFydFgsIG91dGVyU3RhcnRZKTtcblxuICAgIGNvbnN0IG91dGVyRW5kWCA9IE1hdGguY29zKG91dGVyRW5kQWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHg7XG4gICAgY29uc3Qgb3V0ZXJFbmRZID0gTWF0aC5zaW4ob3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeTtcbiAgICBjdHgubGluZVRvKG91dGVyRW5kWCwgb3V0ZXJFbmRZKTtcbiAgfVxuXG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cblxuZnVuY3Rpb24gZHJhd0FyYyhcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGVsZW1lbnQ6IEFyY0VsZW1lbnQsXG4gIG9mZnNldDogbnVtYmVyLFxuICBzcGFjaW5nOiBudW1iZXIsXG4gIGNpcmN1bGFyOiBib29sZWFuLFxuKSB7XG4gIGNvbnN0IHtmdWxsQ2lyY2xlcywgc3RhcnRBbmdsZSwgY2lyY3VtZmVyZW5jZX0gPSBlbGVtZW50O1xuICBsZXQgZW5kQW5nbGUgPSBlbGVtZW50LmVuZEFuZ2xlO1xuICBpZiAoZnVsbENpcmNsZXMpIHtcbiAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG4gICAgaWYgKCFpc05hTihjaXJjdW1mZXJlbmNlKSkge1xuICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgKGNpcmN1bWZlcmVuY2UgJSBUQVUgfHwgVEFVKTtcbiAgICB9XG4gIH1cbiAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgY3R4LmZpbGwoKTtcbiAgcmV0dXJuIGVuZEFuZ2xlO1xufVxuXG5mdW5jdGlvbiBkcmF3Qm9yZGVyKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZWxlbWVudDogQXJjRWxlbWVudCxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIHNwYWNpbmc6IG51bWJlcixcbiAgY2lyY3VsYXI6IGJvb2xlYW4sXG4pIHtcbiAgY29uc3Qge2Z1bGxDaXJjbGVzLCBzdGFydEFuZ2xlLCBjaXJjdW1mZXJlbmNlLCBvcHRpb25zfSA9IGVsZW1lbnQ7XG4gIGNvbnN0IHtib3JkZXJXaWR0aCwgYm9yZGVySm9pblN0eWxlLCBib3JkZXJEYXNoLCBib3JkZXJEYXNoT2Zmc2V0fSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlubmVyID0gb3B0aW9ucy5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJztcblxuICBpZiAoIWJvcmRlcldpZHRoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3R4LnNldExpbmVEYXNoKGJvcmRlckRhc2ggfHwgW10pO1xuICBjdHgubGluZURhc2hPZmZzZXQgPSBib3JkZXJEYXNoT2Zmc2V0O1xuXG4gIGlmIChpbm5lcikge1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aCAqIDI7XG4gICAgY3R4LmxpbmVKb2luID0gYm9yZGVySm9pblN0eWxlIHx8ICdyb3VuZCc7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgIGN0eC5saW5lSm9pbiA9IGJvcmRlckpvaW5TdHlsZSB8fCAnYmV2ZWwnO1xuICB9XG5cbiAgbGV0IGVuZEFuZ2xlID0gZWxlbWVudC5lbmRBbmdsZTtcbiAgaWYgKGZ1bGxDaXJjbGVzKSB7XG4gICAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgaWYgKCFpc05hTihjaXJjdW1mZXJlbmNlKSkge1xuICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgKGNpcmN1bWZlcmVuY2UgJSBUQVUgfHwgVEFVKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaW5uZXIpIHtcbiAgICBjbGlwQXJjKGN0eCwgZWxlbWVudCwgZW5kQW5nbGUpO1xuICB9XG5cbiAgaWYgKCFmdWxsQ2lyY2xlcykge1xuICAgIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXJjUHJvcHMgZXh0ZW5kcyBQb2ludCB7XG4gIHN0YXJ0QW5nbGU6IG51bWJlcjtcbiAgZW5kQW5nbGU6IG51bWJlcjtcbiAgaW5uZXJSYWRpdXM6IG51bWJlcjtcbiAgb3V0ZXJSYWRpdXM6IG51bWJlcjtcbiAgY2lyY3VtZmVyZW5jZTogbnVtYmVyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcmNFbGVtZW50IGV4dGVuZHMgRWxlbWVudDxBcmNQcm9wcywgQXJjT3B0aW9ucz4ge1xuXG4gIHN0YXRpYyBpZCA9ICdhcmMnO1xuXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBib3JkZXJBbGlnbjogJ2NlbnRlcicsXG4gICAgYm9yZGVyQ29sb3I6ICcjZmZmJyxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLFxuICAgIGJvcmRlckpvaW5TdHlsZTogdW5kZWZpbmVkLFxuICAgIGJvcmRlclJhZGl1czogMCxcbiAgICBib3JkZXJXaWR0aDogMixcbiAgICBvZmZzZXQ6IDAsXG4gICAgc3BhY2luZzogMCxcbiAgICBhbmdsZTogdW5kZWZpbmVkLFxuICAgIGNpcmN1bGFyOiB0cnVlLFxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcidcbiAgfTtcblxuICBzdGF0aWMgZGVzY3JpcHRvcnMgPSB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdib3JkZXJEYXNoJ1xuICB9O1xuXG4gIGNpcmN1bWZlcmVuY2U6IG51bWJlcjtcbiAgZW5kQW5nbGU6IG51bWJlcjtcbiAgZnVsbENpcmNsZXM6IG51bWJlcjtcbiAgaW5uZXJSYWRpdXM6IG51bWJlcjtcbiAgb3V0ZXJSYWRpdXM6IG51bWJlcjtcbiAgcGl4ZWxNYXJnaW46IG51bWJlcjtcbiAgc3RhcnRBbmdsZTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaXJjdW1mZXJlbmNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RhcnRBbmdsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuZEFuZ2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBpeGVsTWFyZ2luID0gMDtcbiAgICB0aGlzLmZ1bGxDaXJjbGVzID0gMDtcblxuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cblxuICBpblJhbmdlKGNoYXJ0WDogbnVtYmVyLCBjaGFydFk6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbjogYm9vbGVhbikge1xuICAgIGNvbnN0IHBvaW50ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7YW5nbGUsIGRpc3RhbmNlfSA9IGdldEFuZ2xlRnJvbVBvaW50KHBvaW50LCB7eDogY2hhcnRYLCB5OiBjaGFydFl9KTtcbiAgICBjb25zdCB7c3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgY2lyY3VtZmVyZW5jZX0gPSB0aGlzLmdldFByb3BzKFtcbiAgICAgICdzdGFydEFuZ2xlJyxcbiAgICAgICdlbmRBbmdsZScsXG4gICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgJ291dGVyUmFkaXVzJyxcbiAgICAgICdjaXJjdW1mZXJlbmNlJ1xuICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHJBZGp1c3QgPSAodGhpcy5vcHRpb25zLnNwYWNpbmcgKyB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGgpIC8gMjtcbiAgICBjb25zdCBfY2lyY3VtZmVyZW5jZSA9IHZhbHVlT3JEZWZhdWx0KGNpcmN1bWZlcmVuY2UsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgYmV0d2VlbkFuZ2xlcyA9IF9jaXJjdW1mZXJlbmNlID49IFRBVSB8fCBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgY29uc3Qgd2l0aGluUmFkaXVzID0gX2lzQmV0d2VlbihkaXN0YW5jZSwgaW5uZXJSYWRpdXMgKyByQWRqdXN0LCBvdXRlclJhZGl1cyArIHJBZGp1c3QpO1xuXG4gICAgcmV0dXJuIChiZXR3ZWVuQW5nbGVzICYmIHdpdGhpblJhZGl1cyk7XG4gIH1cblxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uOiBib29sZWFuKSB7XG4gICAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXN9ID0gdGhpcy5nZXRQcm9wcyhbXG4gICAgICAneCcsXG4gICAgICAneScsXG4gICAgICAnc3RhcnRBbmdsZScsXG4gICAgICAnZW5kQW5nbGUnLFxuICAgICAgJ2lubmVyUmFkaXVzJyxcbiAgICAgICdvdXRlclJhZGl1cydcbiAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7b2Zmc2V0LCBzcGFjaW5nfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBoYWxmQW5nbGUgPSAoc3RhcnRBbmdsZSArIGVuZEFuZ2xlKSAvIDI7XG4gICAgY29uc3QgaGFsZlJhZGl1cyA9IChpbm5lclJhZGl1cyArIG91dGVyUmFkaXVzICsgc3BhY2luZyArIG9mZnNldCkgLyAyO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4ICsgTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXMsXG4gICAgICB5OiB5ICsgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXNcbiAgICB9O1xuICB9XG5cbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb246IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgY2lyY3VtZmVyZW5jZX0gPSB0aGlzO1xuICAgIGNvbnN0IG9mZnNldCA9IChvcHRpb25zLm9mZnNldCB8fCAwKSAvIDQ7XG4gICAgY29uc3Qgc3BhY2luZyA9IChvcHRpb25zLnNwYWNpbmcgfHwgMCkgLyAyO1xuICAgIGNvbnN0IGNpcmN1bGFyID0gb3B0aW9ucy5jaXJjdWxhcjtcbiAgICB0aGlzLnBpeGVsTWFyZ2luID0gKG9wdGlvbnMuYm9yZGVyQWxpZ24gPT09ICdpbm5lcicpID8gMC4zMyA6IDA7XG4gICAgdGhpcy5mdWxsQ2lyY2xlcyA9IGNpcmN1bWZlcmVuY2UgPiBUQVUgPyBNYXRoLmZsb29yKGNpcmN1bWZlcmVuY2UgLyBUQVUpIDogMDtcblxuICAgIGlmIChjaXJjdW1mZXJlbmNlID09PSAwIHx8IHRoaXMuaW5uZXJSYWRpdXMgPCAwIHx8IHRoaXMub3V0ZXJSYWRpdXMgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4LnNhdmUoKTtcblxuICAgIGNvbnN0IGhhbGZBbmdsZSA9ICh0aGlzLnN0YXJ0QW5nbGUgKyB0aGlzLmVuZEFuZ2xlKSAvIDI7XG4gICAgY3R4LnRyYW5zbGF0ZShNYXRoLmNvcyhoYWxmQW5nbGUpICogb2Zmc2V0LCBNYXRoLnNpbihoYWxmQW5nbGUpICogb2Zmc2V0KTtcbiAgICBjb25zdCBmaXggPSAxIC0gTWF0aC5zaW4oTWF0aC5taW4oUEksIGNpcmN1bWZlcmVuY2UgfHwgMCkpO1xuICAgIGNvbnN0IHJhZGl1c09mZnNldCA9IG9mZnNldCAqIGZpeDtcblxuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuXG4gICAgZHJhd0FyYyhjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZywgY2lyY3VsYXIpO1xuICAgIGRyYXdCb3JkZXIoY3R4LCB0aGlzLCByYWRpdXNPZmZzZXQsIHNwYWNpbmcsIGNpcmN1bGFyKTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge19iZXppZXJJbnRlcnBvbGF0aW9uLCBfcG9pbnRJbkxpbmUsIF9zdGVwcGVkSW50ZXJwb2xhdGlvbn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGVycG9sYXRpb24uanMnO1xuaW1wb3J0IHtfY29tcHV0ZVNlZ21lbnRzLCBfYm91bmRTZWdtZW50c30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLnNlZ21lbnQuanMnO1xuaW1wb3J0IHtfc3RlcHBlZExpbmVUbywgX2JlemllckN1cnZlVG99IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50c30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmN1cnZlLmpzJztcbmltcG9ydCB7dmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzdHlsZSA9IG9wdGlvbnMpIHtcbiAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDYXBTdHlsZSwgb3B0aW9ucy5ib3JkZXJDYXBTdHlsZSk7XG4gIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoLCBvcHRpb25zLmJvcmRlckRhc2gpKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyRGFzaE9mZnNldCwgb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0KTtcbiAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVySm9pblN0eWxlLCBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSk7XG4gIGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckNvbG9yLCBvcHRpb25zLmJvcmRlckNvbG9yKTtcbn1cblxuZnVuY3Rpb24gbGluZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCkge1xuICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG59XG5cbi8qKlxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGluZU1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRMaW5lVG87XG4gIH1cblxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHJldHVybiBfYmV6aWVyQ3VydmVUbztcbiAgfVxuXG4gIHJldHVybiBsaW5lVG87XG59XG5cbmZ1bmN0aW9uIHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zID0ge30pIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7c3RhcnQ6IHBhcmFtc1N0YXJ0ID0gMCwgZW5kOiBwYXJhbXNFbmQgPSBjb3VudCAtIDF9ID0gcGFyYW1zO1xuICBjb25zdCB7c3RhcnQ6IHNlZ21lbnRTdGFydCwgZW5kOiBzZWdtZW50RW5kfSA9IHNlZ21lbnQ7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgocGFyYW1zU3RhcnQsIHNlZ21lbnRTdGFydCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHBhcmFtc0VuZCwgc2VnbWVudEVuZCk7XG4gIGNvbnN0IG91dHNpZGUgPSBwYXJhbXNTdGFydCA8IHNlZ21lbnRTdGFydCAmJiBwYXJhbXNFbmQgPCBzZWdtZW50U3RhcnQgfHwgcGFyYW1zU3RhcnQgPiBzZWdtZW50RW5kICYmIHBhcmFtc0VuZCA+IHNlZ21lbnRFbmQ7XG5cbiAgcmV0dXJuIHtcbiAgICBjb3VudCxcbiAgICBzdGFydCxcbiAgICBsb29wOiBzZWdtZW50Lmxvb3AsXG4gICAgaWxlbjogZW5kIDwgc3RhcnQgJiYgIW91dHNpZGUgPyBjb3VudCArIGVuZCAtIHN0YXJ0IDogZW5kIC0gc3RhcnRcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgcGF0aCBmcm9tIHBvaW50cywgZ3JvdXBpbmcgYnkgdHJ1bmNhdGVkIHgtY29vcmRpbmF0ZVxuICogUG9pbnRzIG5lZWQgdG8gYmUgaW4gb3JkZXIgYnkgeC1jb29yZGluYXRlIGZvciB0aGlzIHRvIHdvcmsgZWZmaWNpZW50bHlcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfFBhdGgyRH0gY3R4IC0gQ29udGV4dFxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMubW92ZSAtIG1vdmUgdG8gc3RhcnRpbmcgcG9pbnQgKHZzIGxpbmUgdG8gaXQpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZXZlcnNlIC0gcGF0aCB0aGUgc2VnbWVudCBmcm9tIGVuZCB0byBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIHN0YXJ0aW5nIGZyb20gYHN0YXJ0YCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5lbmQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBlbmRpbmcgYXQgYHN0YXJ0YCArIGBjb3VudGAgaW5kZXhcbiAqL1xuZnVuY3Rpb24gcGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgY29uc3Qge3BvaW50cywgb3B0aW9uc30gPSBsaW5lO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBsb29wLCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3QgbGluZU1ldGhvZCA9IGdldExpbmVNZXRob2Qob3B0aW9ucyk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XG4gIGxldCBpLCBwb2ludCwgcHJldjtcblxuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzWyhzdGFydCArIChyZXZlcnNlID8gaWxlbiAtIGkgOiBpKSkgJSBjb3VudF07XG5cbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgYSBza2lwcGVkIHBvaW50IGluc2lkZSBhIHNlZ21lbnQsIHNwYW5HYXBzIG11c3QgYmUgdHJ1ZVxuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChtb3ZlKSB7XG4gICAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgbW92ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgfVxuXG4gICAgcHJldiA9IHBvaW50O1xuICB9XG5cbiAgaWYgKGxvb3ApIHtcbiAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gOiAwKSkgJSBjb3VudF07XG4gICAgbGluZU1ldGhvZChjdHgsIHByZXYsIHBvaW50LCByZXZlcnNlLCBvcHRpb25zLnN0ZXBwZWQpO1xuICB9XG5cbiAgcmV0dXJuICEhbG9vcDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgcGF0aCBmcm9tIHBvaW50cywgZ3JvdXBpbmcgYnkgdHJ1bmNhdGVkIHgtY29vcmRpbmF0ZVxuICogUG9pbnRzIG5lZWQgdG8gYmUgaW4gb3JkZXIgYnkgeC1jb29yZGluYXRlIGZvciB0aGlzIHRvIHdvcmsgZWZmaWNpZW50bHlcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfFBhdGgyRH0gY3R4IC0gQ29udGV4dFxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMubW92ZSAtIG1vdmUgdG8gc3RhcnRpbmcgcG9pbnQgKHZzIGxpbmUgdG8gaXQpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZXZlcnNlIC0gcGF0aCB0aGUgc2VnbWVudCBmcm9tIGVuZCB0byBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIHN0YXJ0aW5nIGZyb20gYHN0YXJ0YCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5lbmQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBlbmRpbmcgYXQgYHN0YXJ0YCArIGBjb3VudGAgaW5kZXhcbiAqL1xuZnVuY3Rpb24gZmFzdFBhdGhTZWdtZW50KGN0eCwgbGluZSwgc2VnbWVudCwgcGFyYW1zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3Qge21vdmUgPSB0cnVlLCByZXZlcnNlfSA9IHBhcmFtcyB8fCB7fTtcbiAgbGV0IGF2Z1ggPSAwO1xuICBsZXQgY291bnRYID0gMDtcbiAgbGV0IGksIHBvaW50LCBwcmV2WCwgbWluWSwgbWF4WSwgbGFzdFk7XG5cbiAgY29uc3QgcG9pbnRJbmRleCA9IChpbmRleCkgPT4gKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIC0gaW5kZXggOiBpbmRleCkpICUgY291bnQ7XG4gIGNvbnN0IGRyYXdYID0gKCkgPT4ge1xuICAgIGlmIChtaW5ZICE9PSBtYXhZKSB7XG4gICAgICAvLyBEcmF3IGxpbmUgdG8gbWF4WSBhbmQgbWluWSwgdXNpbmcgdGhlIGF2ZXJhZ2UgeC1jb29yZGluYXRlXG4gICAgICBjdHgubGluZVRvKGF2Z1gsIG1heFkpO1xuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtaW5ZKTtcbiAgICAgIC8vIExpbmUgdG8geS12YWx1ZSBvZiBsYXN0IHBvaW50IGluIGdyb3VwLiBTbyB0aGUgbGluZSBjb250aW51ZXNcbiAgICAgIC8vIGZyb20gY29ycmVjdCBwb3NpdGlvbi4gTm90IHVzaW5nIG1vdmUsIHRvIGhhdmUgc29saWQgcGF0aC5cbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbGFzdFkpO1xuICAgIH1cbiAgfTtcblxuICBpZiAobW92ZSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoMCldO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoaSldO1xuXG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIGEgc2tpcHBlZCBwb2ludCBpbnNpZGUgYSBzZWdtZW50LCBzcGFuR2FwcyBtdXN0IGJlIHRydWVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHggPSBwb2ludC54O1xuICAgIGNvbnN0IHkgPSBwb2ludC55O1xuICAgIGNvbnN0IHRydW5jWCA9IHggfCAwOyAvLyB0cnVuY2F0ZWQgeC1jb29yZGluYXRlXG5cbiAgICBpZiAodHJ1bmNYID09PSBwcmV2WCkge1xuICAgICAgLy8gRGV0ZXJtaW5lIGBtaW5ZYCAvIGBtYXhZYCBhbmQgYGF2Z1hgIHdoaWxlIHdlIHN0YXkgd2l0aGluIHNhbWUgeC1wb3NpdGlvblxuICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgIG1pblkgPSB5O1xuICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICBtYXhZID0geTtcbiAgICAgIH1cbiAgICAgIC8vIEZvciBmaXJzdCBwb2ludCBpbiBncm91cCwgY291bnRYIGlzIGAwYCwgc28gYXZlcmFnZSB3aWxsIGJlIGB4YCAvIDEuXG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyB4KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICBkcmF3WCgpO1xuICAgICAgLy8gRHJhdyBsaW5lIHRvIG5leHQgeC1wb3NpdGlvbiwgdXNpbmcgdGhlIGZpcnN0IChvciBvbmx5KVxuICAgICAgLy8geS12YWx1ZSBpbiB0aGF0IGdyb3VwXG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuXG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgfVxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxhc3QgeS12YWx1ZSBpbiBncm91cFxuICAgIGxhc3RZID0geTtcbiAgfVxuICBkcmF3WCgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmUgLSB0aGUgbGluZVxuICogQHJldHVybnMge2Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dldFNlZ21lbnRNZXRob2QobGluZSkge1xuICBjb25zdCBvcHRzID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBib3JkZXJEYXNoID0gb3B0cy5ib3JkZXJEYXNoICYmIG9wdHMuYm9yZGVyRGFzaC5sZW5ndGg7XG4gIGNvbnN0IHVzZUZhc3RQYXRoID0gIWxpbmUuX2RlY2ltYXRlZCAmJiAhbGluZS5fbG9vcCAmJiAhb3B0cy50ZW5zaW9uICYmIG9wdHMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSAhPT0gJ21vbm90b25lJyAmJiAhb3B0cy5zdGVwcGVkICYmICFib3JkZXJEYXNoO1xuICByZXR1cm4gdXNlRmFzdFBhdGggPyBmYXN0UGF0aFNlZ21lbnQgOiBwYXRoU2VnbWVudDtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICByZXR1cm4gX2JlemllckludGVycG9sYXRpb247XG4gIH1cblxuICByZXR1cm4gX3BvaW50SW5MaW5lO1xufVxuXG5mdW5jdGlvbiBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGxldCBwYXRoID0gbGluZS5fcGF0aDtcbiAgaWYgKCFwYXRoKSB7XG4gICAgcGF0aCA9IGxpbmUuX3BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgaWYgKGxpbmUucGF0aChwYXRoLCBzdGFydCwgY291bnQpKSB7XG4gICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuICBzZXRTdHlsZShjdHgsIGxpbmUub3B0aW9ucyk7XG4gIGN0eC5zdHJva2UocGF0aCk7XG59XG5cbmZ1bmN0aW9uIHN0cm9rZVBhdGhEaXJlY3QoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3Qge3NlZ21lbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKTtcblxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHNlZ21lbnQuc3R5bGUpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBpZiAoc2VnbWVudE1ldGhvZChjdHgsIGxpbmUsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pKSB7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG5jb25zdCB1c2VQYXRoMkQgPSB0eXBlb2YgUGF0aDJEID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBkcmF3KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGlmICh1c2VQYXRoMkQgJiYgIWxpbmUub3B0aW9ucy5zZWdtZW50KSB7XG4gICAgc3Ryb2tlUGF0aFdpdGhDYWNoZShjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCk7XG4gIH0gZWxzZSB7XG4gICAgc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcblxuICBzdGF0aWMgaWQgPSAnbGluZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgYm9yZGVyQ2FwU3R5bGU6ICdidXR0JyxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLFxuICAgIGJvcmRlckpvaW5TdHlsZTogJ21pdGVyJyxcbiAgICBib3JkZXJXaWR0aDogMyxcbiAgICBjYXBCZXppZXJQb2ludHM6IHRydWUsXG4gICAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogJ2RlZmF1bHQnLFxuICAgIGZpbGw6IGZhbHNlLFxuICAgIHNwYW5HYXBzOiBmYWxzZSxcbiAgICBzdGVwcGVkOiBmYWxzZSxcbiAgICB0ZW5zaW9uOiAwLFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xuICB9O1xuXG5cbiAgc3RhdGljIGRlc2NyaXB0b3JzID0ge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2ZpbGwnLFxuICB9O1xuXG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuYW5pbWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jaGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9sb29wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2Z1bGxMb29wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcG9pbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NlZ21lbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RlY2ltYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhc2V0SW5kZXggPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ29udHJvbFBvaW50cyhjaGFydEFyZWEsIGluZGV4QXhpcykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSAmJiAhb3B0aW9ucy5zdGVwcGVkICYmICF0aGlzLl9wb2ludHNVcGRhdGVkKSB7XG4gICAgICBjb25zdCBsb29wID0gb3B0aW9ucy5zcGFuR2FwcyA/IHRoaXMuX2xvb3AgOiB0aGlzLl9mdWxsTG9vcDtcbiAgICAgIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKHRoaXMuX3BvaW50cywgb3B0aW9ucywgY2hhcnRBcmVhLCBsb29wLCBpbmRleEF4aXMpO1xuICAgICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgc2V0IHBvaW50cyhwb2ludHMpIHtcbiAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XG4gICAgZGVsZXRlIHRoaXMuX3NlZ21lbnRzO1xuICAgIGRlbGV0ZSB0aGlzLl9wYXRoO1xuICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGdldCBwb2ludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50cztcbiAgfVxuXG4gIGdldCBzZWdtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudHMgfHwgKHRoaXMuX3NlZ21lbnRzID0gX2NvbXB1dGVTZWdtZW50cyh0aGlzLCB0aGlzLm9wdGlvbnMuc2VnbWVudCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEZpcnN0IG5vbi1za2lwcGVkIHBvaW50IG9uIHRoaXMgbGluZVxuXHQgKiBAcmV0dXJucyB7UG9pbnRFbGVtZW50fHVuZGVmaW5lZH1cblx0ICovXG4gIGZpcnN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoICYmIHBvaW50c1tzZWdtZW50c1swXS5zdGFydF07XG4gIH1cblxuICAvKipcblx0ICogTGFzdCBub24tc2tpcHBlZCBwb2ludCBvbiB0aGlzIGxpbmVcblx0ICogQHJldHVybnMge1BvaW50RWxlbWVudHx1bmRlZmluZWR9XG5cdCAqL1xuICBsYXN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBjb3VudCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gY291bnQgJiYgcG9pbnRzW3NlZ21lbnRzW2NvdW50IC0gMV0uZW5kXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBJbnRlcnBvbGF0ZSBhIHBvaW50IGluIHRoaXMgbGluZSBhdCB0aGUgc2FtZSB2YWx1ZSBvbiBgcHJvcGVydHlgIGFzXG5cdCAqIHRoZSByZWZlcmVuY2UgYHBvaW50YCBwcm92aWRlZFxuXHQgKiBAcGFyYW0ge1BvaW50RWxlbWVudH0gcG9pbnQgLSB0aGUgcmVmZXJlbmNlIHBvaW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBwcm9wZXJ0eSB0byBtYXRjaCBvblxuXHQgKiBAcmV0dXJucyB7UG9pbnRFbGVtZW50fHVuZGVmaW5lZH1cblx0ICovXG4gIGludGVycG9sYXRlKHBvaW50LCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBfYm91bmRTZWdtZW50cyh0aGlzLCB7cHJvcGVydHksIHN0YXJ0OiB2YWx1ZSwgZW5kOiB2YWx1ZX0pO1xuXG4gICAgaWYgKCFzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBfaW50ZXJwb2xhdGUgPSBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50c1tpXTtcbiAgICAgIGNvbnN0IHAxID0gcG9pbnRzW3N0YXJ0XTtcbiAgICAgIGNvbnN0IHAyID0gcG9pbnRzW2VuZF07XG4gICAgICBpZiAocDEgPT09IHAyKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHAxKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0ID0gTWF0aC5hYnMoKHZhbHVlIC0gcDFbcHJvcGVydHldKSAvIChwMltwcm9wZXJ0eV0gLSBwMVtwcm9wZXJ0eV0pKTtcbiAgICAgIGNvbnN0IGludGVycG9sYXRlZCA9IF9pbnRlcnBvbGF0ZShwMSwgcDIsIHQsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgICBpbnRlcnBvbGF0ZWRbcHJvcGVydHldID0gcG9pbnRbcHJvcGVydHldO1xuICAgICAgcmVzdWx0LnB1c2goaW50ZXJwb2xhdGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IDEgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogQXBwZW5kIGEgc2VnbWVudCBvZiB0aGlzIGxpbmUgdG8gY3VycmVudCBwYXRoLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBzZWdtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gXHQgKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuXHQgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLm1vdmUgLSBtb3ZlIHRvIHN0YXJ0aW5nIHBvaW50ICh2cyBsaW5lIHRvIGl0KVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZXZlcnNlIC0gcGF0aCB0aGUgc2VnbWVudCBmcm9tIGVuZCB0byBzdGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0YXJ0IC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgc3RhcnRpbmcgZnJvbSBgc3RhcnRgIGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZW5kIC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgZW5kaW5nIGF0IGBzdGFydGAgKyBgY291bnRgIGluZGV4XG5cdCAqIEByZXR1cm5zIHt1bmRlZmluZWR8Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSBzZWdtZW50IGlzIGEgZnVsbCBsb29wIChwYXRoIHNob3VsZCBiZSBjbG9zZWQpXG5cdCAqL1xuICBwYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHBhcmFtcykge1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICByZXR1cm4gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcblx0ICogQXBwZW5kIGFsbCBzZWdtZW50cyBvZiB0aGlzIGxpbmUgdG8gY3VycmVudCBwYXRoLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxQYXRoMkR9IGN0eFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2NvdW50XVxuXHQgKiBAcmV0dXJucyB7dW5kZWZpbmVkfGJvb2xlYW59IC0gdHJ1ZSBpZiBsaW5lIGlzIGEgZnVsbCBsb29wIChwYXRoIHNob3VsZCBiZSBjbG9zZWQpXG5cdCAqL1xuICBwYXRoKGN0eCwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICBsZXQgbG9vcCA9IHRoaXMuX2xvb3A7XG5cbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgY291bnQgPSBjb3VudCB8fCAodGhpcy5wb2ludHMubGVuZ3RoIC0gc3RhcnQpO1xuXG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICBsb29wICY9IHNlZ21lbnRNZXRob2QoY3R4LCB0aGlzLCBzZWdtZW50LCB7c3RhcnQsIGVuZDogc3RhcnQgKyBjb3VudCAtIDF9KTtcbiAgICB9XG4gICAgcmV0dXJuICEhbG9vcDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHBhcmFtIHtvYmplY3R9IGNoYXJ0QXJlYVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2NvdW50XVxuXHQgKi9cbiAgZHJhdyhjdHgsIGNoYXJ0QXJlYSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cyB8fCBbXTtcblxuICAgIGlmIChwb2ludHMubGVuZ3RoICYmIG9wdGlvbnMuYm9yZGVyV2lkdGgpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgIGRyYXcoY3R4LCB0aGlzLCBzdGFydCwgY291bnQpO1xuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFuaW1hdGVkKSB7XG4gICAgICAvLyBXaGVuIGxpbmUgaXMgYW5pbWF0ZWQsIHRoZSBjb250cm9sIHBvaW50cyBhbmQgcGF0aCBhcmUgbm90IGNhY2hlZC5cbiAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtkcmF3UG9pbnQsIF9pc1BvaW50SW5BcmVhfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB0eXBlIHtcbiAgQ2FydGVzaWFuUGFyc2VkRGF0YSxcbiAgQ2hhcnRBcmVhLFxuICBQb2ludCxcbiAgUG9pbnRIb3Zlck9wdGlvbnMsXG4gIFBvaW50T3B0aW9ucyxcbn0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG5mdW5jdGlvbiBpblJhbmdlKGVsOiBQb2ludEVsZW1lbnQsIHBvczogbnVtYmVyLCBheGlzOiAneCcgfCAneScsIHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBlbC5vcHRpb25zO1xuICBjb25zdCB7W2F4aXNdOiB2YWx1ZX0gPSBlbC5nZXRQcm9wcyhbYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pO1xuXG4gIHJldHVybiAoTWF0aC5hYnMocG9zIC0gdmFsdWUpIDwgb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhpdFJhZGl1cyk7XG59XG5cbmV4cG9ydCB0eXBlIFBvaW50UHJvcHMgPSBQb2ludFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2ludEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PFBvaW50UHJvcHMsIFBvaW50T3B0aW9ucyAmIFBvaW50SG92ZXJPcHRpb25zPiB7XG5cbiAgc3RhdGljIGlkID0gJ3BvaW50JztcblxuICBwYXJzZWQ6IENhcnRlc2lhblBhcnNlZERhdGE7XG4gIHNraXA/OiBib29sZWFuO1xuICBzdG9wPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBib3JkZXJXaWR0aDogMSxcbiAgICBoaXRSYWRpdXM6IDEsXG4gICAgaG92ZXJCb3JkZXJXaWR0aDogMSxcbiAgICBob3ZlclJhZGl1czogNCxcbiAgICBwb2ludFN0eWxlOiAnY2lyY2xlJyxcbiAgICByYWRpdXM6IDMsXG4gICAgcm90YXRpb246IDBcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gICAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFyc2VkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2tpcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0b3AgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG5cbiAgaW5SYW5nZShtb3VzZVg6IG51bWJlciwgbW91c2VZOiBudW1iZXIsIHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiAoKE1hdGgucG93KG1vdXNlWCAtIHgsIDIpICsgTWF0aC5wb3cobW91c2VZIC0geSwgMikpIDwgTWF0aC5wb3cob3B0aW9ucy5oaXRSYWRpdXMgKyBvcHRpb25zLnJhZGl1cywgMikpO1xuICB9XG5cbiAgaW5YUmFuZ2UobW91c2VYOiBudW1iZXIsIHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCAneCcsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgaW5ZUmFuZ2UobW91c2VZOiBudW1iZXIsIHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VZLCAneScsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7eCwgeX07XG4gIH1cblxuICBzaXplKG9wdGlvbnM/OiBQYXJ0aWFsPFBvaW50T3B0aW9ucyAmIFBvaW50SG92ZXJPcHRpb25zPikge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgMDtcbiAgICByYWRpdXMgPSBNYXRoLm1heChyYWRpdXMsIHJhZGl1cyAmJiBvcHRpb25zLmhvdmVyUmFkaXVzIHx8IDApO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gcmFkaXVzICYmIG9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICByZXR1cm4gKHJhZGl1cyArIGJvcmRlcldpZHRoKSAqIDI7XG4gIH1cblxuICBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBhcmVhOiBDaGFydEFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKHRoaXMuc2tpcCB8fCBvcHRpb25zLnJhZGl1cyA8IDAuMSB8fCAhX2lzUG9pbnRJbkFyZWEodGhpcywgYXJlYSwgdGhpcy5zaXplKG9wdGlvbnMpIC8gMikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBkcmF3UG9pbnQoY3R4LCBvcHRpb25zLCB0aGlzLngsIHRoaXMueSk7XG4gIH1cblxuICBnZXRSYW5nZSgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgRmFsbGJhY2tzIHNob3VsZCBuZXZlciBiZSBoaXQgaW4gcHJhY3RpY2VcbiAgICByZXR1cm4gb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhpdFJhZGl1cztcbiAgfVxufVxuIiwgImltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7aXNPYmplY3QsIF9pc0JldHdlZW4sIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7YWRkUm91bmRlZFJlY3RQYXRofSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7dG9UUkJMLCB0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5cbi8qKiBAdHlwZWRlZiB7eyB4OiBudW1iZXIsIHk6IG51bWJlciwgYmFzZTogbnVtYmVyLCBob3Jpem9udGFsOiBib29sZWFuLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9fSBCYXJQcm9wcyAqL1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGJvdW5kcyBvZiB0aGUgYmFyIHJlZ2FyZGxlc3Mgb2YgdGhlIG9yaWVudGF0aW9uXG4gKiBAcGFyYW0ge0JhckVsZW1lbnR9IGJhciB0aGUgYmFyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXVxuICogQHJldHVybiB7b2JqZWN0fSBib3VuZHMgb2YgdGhlIGJhclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0QmFyQm91bmRzKGJhciwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCB7eCwgeSwgYmFzZSwgd2lkdGgsIGhlaWdodH0gPSAvKiogQHR5cGUge0JhclByb3BzfSAqLyAoYmFyLmdldFByb3BzKFsneCcsICd5JywgJ2Jhc2UnLCAnd2lkdGgnLCAnaGVpZ2h0J10sIHVzZUZpbmFsUG9zaXRpb24pKTtcblxuICBsZXQgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBoYWxmO1xuXG4gIGlmIChiYXIuaG9yaXpvbnRhbCkge1xuICAgIGhhbGYgPSBoZWlnaHQgLyAyO1xuICAgIGxlZnQgPSBNYXRoLm1pbih4LCBiYXNlKTtcbiAgICByaWdodCA9IE1hdGgubWF4KHgsIGJhc2UpO1xuICAgIHRvcCA9IHkgLSBoYWxmO1xuICAgIGJvdHRvbSA9IHkgKyBoYWxmO1xuICB9IGVsc2Uge1xuICAgIGhhbGYgPSB3aWR0aCAvIDI7XG4gICAgbGVmdCA9IHggLSBoYWxmO1xuICAgIHJpZ2h0ID0geCArIGhhbGY7XG4gICAgdG9wID0gTWF0aC5taW4oeSwgYmFzZSk7XG4gICAgYm90dG9tID0gTWF0aC5tYXgoeSwgYmFzZSk7XG4gIH1cblxuICByZXR1cm4ge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX07XG59XG5cbmZ1bmN0aW9uIHNraXBPckxpbWl0KHNraXAsIHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gc2tpcCA/IDAgOiBfbGltaXRWYWx1ZSh2YWx1ZSwgbWluLCBtYXgpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUJvcmRlcldpZHRoKGJhciwgbWF4VywgbWF4SCkge1xuICBjb25zdCB2YWx1ZSA9IGJhci5vcHRpb25zLmJvcmRlcldpZHRoO1xuICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IG8gPSB0b1RSQkwodmFsdWUpO1xuXG4gIHJldHVybiB7XG4gICAgdDogc2tpcE9yTGltaXQoc2tpcC50b3AsIG8udG9wLCAwLCBtYXhIKSxcbiAgICByOiBza2lwT3JMaW1pdChza2lwLnJpZ2h0LCBvLnJpZ2h0LCAwLCBtYXhXKSxcbiAgICBiOiBza2lwT3JMaW1pdChza2lwLmJvdHRvbSwgby5ib3R0b20sIDAsIG1heEgpLFxuICAgIGw6IHNraXBPckxpbWl0KHNraXAubGVmdCwgby5sZWZ0LCAwLCBtYXhXKVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyhiYXIsIG1heFcsIG1heEgpIHtcbiAgY29uc3Qge2VuYWJsZUJvcmRlclJhZGl1c30gPSBiYXIuZ2V0UHJvcHMoWydlbmFibGVCb3JkZXJSYWRpdXMnXSk7XG4gIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyUmFkaXVzO1xuICBjb25zdCBvID0gdG9UUkJMQ29ybmVycyh2YWx1ZSk7XG4gIGNvbnN0IG1heFIgPSBNYXRoLm1pbihtYXhXLCBtYXhIKTtcbiAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xuXG4gIC8vIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QsIGFzc3VtZSB0aGUgdXNlciBrbm93cyB3aGF0IHRoZXkgYXJlIGRvaW5nXG4gIC8vIGFuZCBhcHBseSBhcyBkaXJlY3RlZC5cbiAgY29uc3QgZW5hYmxlQm9yZGVyID0gZW5hYmxlQm9yZGVyUmFkaXVzIHx8IGlzT2JqZWN0KHZhbHVlKTtcblxuICByZXR1cm4ge1xuICAgIHRvcExlZnQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC50b3AgfHwgc2tpcC5sZWZ0LCBvLnRvcExlZnQsIDAsIG1heFIpLFxuICAgIHRvcFJpZ2h0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAucmlnaHQsIG8udG9wUmlnaHQsIDAsIG1heFIpLFxuICAgIGJvdHRvbUxlZnQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5sZWZ0LCBvLmJvdHRvbUxlZnQsIDAsIG1heFIpLFxuICAgIGJvdHRvbVJpZ2h0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAuYm90dG9tIHx8IHNraXAucmlnaHQsIG8uYm90dG9tUmlnaHQsIDAsIG1heFIpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJvdW5kaW5nUmVjdHMoYmFyKSB7XG4gIGNvbnN0IGJvdW5kcyA9IGdldEJhckJvdW5kcyhiYXIpO1xuICBjb25zdCB3aWR0aCA9IGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0O1xuICBjb25zdCBoZWlnaHQgPSBib3VuZHMuYm90dG9tIC0gYm91bmRzLnRvcDtcbiAgY29uc3QgYm9yZGVyID0gcGFyc2VCb3JkZXJXaWR0aChiYXIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gIGNvbnN0IHJhZGl1cyA9IHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcblxuICByZXR1cm4ge1xuICAgIG91dGVyOiB7XG4gICAgICB4OiBib3VuZHMubGVmdCxcbiAgICAgIHk6IGJvdW5kcy50b3AsXG4gICAgICB3OiB3aWR0aCxcbiAgICAgIGg6IGhlaWdodCxcbiAgICAgIHJhZGl1c1xuICAgIH0sXG4gICAgaW5uZXI6IHtcbiAgICAgIHg6IGJvdW5kcy5sZWZ0ICsgYm9yZGVyLmwsXG4gICAgICB5OiBib3VuZHMudG9wICsgYm9yZGVyLnQsXG4gICAgICB3OiB3aWR0aCAtIGJvcmRlci5sIC0gYm9yZGVyLnIsXG4gICAgICBoOiBoZWlnaHQgLSBib3JkZXIudCAtIGJvcmRlci5iLFxuICAgICAgcmFkaXVzOiB7XG4gICAgICAgIHRvcExlZnQ6IE1hdGgubWF4KDAsIHJhZGl1cy50b3BMZWZ0IC0gTWF0aC5tYXgoYm9yZGVyLnQsIGJvcmRlci5sKSksXG4gICAgICAgIHRvcFJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wUmlnaHQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLnIpKSxcbiAgICAgICAgYm90dG9tTGVmdDogTWF0aC5tYXgoMCwgcmFkaXVzLmJvdHRvbUxlZnQgLSBNYXRoLm1heChib3JkZXIuYiwgYm9yZGVyLmwpKSxcbiAgICAgICAgYm90dG9tUmlnaHQ6IE1hdGgubWF4KDAsIHJhZGl1cy5ib3R0b21SaWdodCAtIE1hdGgubWF4KGJvcmRlci5iLCBib3JkZXIucikpLFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5SYW5nZShiYXIsIHgsIHksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qgc2tpcFggPSB4ID09PSBudWxsO1xuICBjb25zdCBza2lwWSA9IHkgPT09IG51bGw7XG4gIGNvbnN0IHNraXBCb3RoID0gc2tpcFggJiYgc2tpcFk7XG4gIGNvbnN0IGJvdW5kcyA9IGJhciAmJiAhc2tpcEJvdGggJiYgZ2V0QmFyQm91bmRzKGJhciwgdXNlRmluYWxQb3NpdGlvbik7XG5cbiAgcmV0dXJuIGJvdW5kc1xuXHRcdCYmIChza2lwWCB8fCBfaXNCZXR3ZWVuKHgsIGJvdW5kcy5sZWZ0LCBib3VuZHMucmlnaHQpKVxuXHRcdCYmIChza2lwWSB8fCBfaXNCZXR3ZWVuKHksIGJvdW5kcy50b3AsIGJvdW5kcy5ib3R0b20pKTtcbn1cblxuZnVuY3Rpb24gaGFzUmFkaXVzKHJhZGl1cykge1xuICByZXR1cm4gcmFkaXVzLnRvcExlZnQgfHwgcmFkaXVzLnRvcFJpZ2h0IHx8IHJhZGl1cy5ib3R0b21MZWZ0IHx8IHJhZGl1cy5ib3R0b21SaWdodDtcbn1cblxuLyoqXG4gKiBBZGQgYSBwYXRoIG9mIGEgcmVjdGFuZ2xlIHRvIHRoZSBjdXJyZW50IHN1Yi1wYXRoXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHRcbiAqIEBwYXJhbSB7Kn0gcmVjdCBCb3VuZGluZyByZWN0XG4gKi9cbmZ1bmN0aW9uIGFkZE5vcm1hbFJlY3RQYXRoKGN0eCwgcmVjdCkge1xuICBjdHgucmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53LCByZWN0LmgpO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVjdChyZWN0LCBhbW91bnQsIHJlZlJlY3QgPSB7fSkge1xuICBjb25zdCB4ID0gcmVjdC54ICE9PSByZWZSZWN0LnggPyAtYW1vdW50IDogMDtcbiAgY29uc3QgeSA9IHJlY3QueSAhPT0gcmVmUmVjdC55ID8gLWFtb3VudCA6IDA7XG4gIGNvbnN0IHcgPSAocmVjdC54ICsgcmVjdC53ICE9PSByZWZSZWN0LnggKyByZWZSZWN0LncgPyBhbW91bnQgOiAwKSAtIHg7XG4gIGNvbnN0IGggPSAocmVjdC55ICsgcmVjdC5oICE9PSByZWZSZWN0LnkgKyByZWZSZWN0LmggPyBhbW91bnQgOiAwKSAtIHk7XG4gIHJldHVybiB7XG4gICAgeDogcmVjdC54ICsgeCxcbiAgICB5OiByZWN0LnkgKyB5LFxuICAgIHc6IHJlY3QudyArIHcsXG4gICAgaDogcmVjdC5oICsgaCxcbiAgICByYWRpdXM6IHJlY3QucmFkaXVzXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcblxuICBzdGF0aWMgaWQgPSAnYmFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBib3JkZXJTa2lwcGVkOiAnc3RhcnQnLFxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIGJvcmRlclJhZGl1czogMCxcbiAgICBpbmZsYXRlQW1vdW50OiAnYXV0bycsXG4gICAgcG9pbnRTdHlsZTogdW5kZWZpbmVkXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICAgIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhvcml6b250YWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYXNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbmZsYXRlQW1vdW50ID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuXG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qge2luZmxhdGVBbW91bnQsIG9wdGlvbnM6IHtib3JkZXJDb2xvciwgYmFja2dyb3VuZENvbG9yfX0gPSB0aGlzO1xuICAgIGNvbnN0IHtpbm5lciwgb3V0ZXJ9ID0gYm91bmRpbmdSZWN0cyh0aGlzKTtcbiAgICBjb25zdCBhZGRSZWN0UGF0aCA9IGhhc1JhZGl1cyhvdXRlci5yYWRpdXMpID8gYWRkUm91bmRlZFJlY3RQYXRoIDogYWRkTm9ybWFsUmVjdFBhdGg7XG5cbiAgICBjdHguc2F2ZSgpO1xuXG4gICAgaWYgKG91dGVyLncgIT09IGlubmVyLncgfHwgb3V0ZXIuaCAhPT0gaW5uZXIuaCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChvdXRlciwgaW5mbGF0ZUFtb3VudCwgaW5uZXIpKTtcbiAgICAgIGN0eC5jbGlwKCk7XG4gICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KGlubmVyLCAtaW5mbGF0ZUFtb3VudCwgb3V0ZXIpKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsKCdldmVub2RkJyk7XG4gICAgfVxuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIGluZmxhdGVBbW91bnQpKTtcbiAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5maWxsKCk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGluWFJhbmdlKG1vdXNlWCwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgbnVsbCwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBpbllSYW5nZShtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBudWxsLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5LCBiYXNlLCBob3Jpem9udGFsfSA9IC8qKiBAdHlwZSB7QmFyUHJvcHN9ICovICh0aGlzLmdldFByb3BzKFsneCcsICd5JywgJ2Jhc2UnLCAnaG9yaXpvbnRhbCddLCB1c2VGaW5hbFBvc2l0aW9uKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGhvcml6b250YWwgPyAoeCArIGJhc2UpIC8gMiA6IHgsXG4gICAgICB5OiBob3Jpem9udGFsID8geSA6ICh5ICsgYmFzZSkgLyAyXG4gICAgfTtcbiAgfVxuXG4gIGdldFJhbmdlKGF4aXMpIHtcbiAgICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gdGhpcy53aWR0aCAvIDIgOiB0aGlzLmhlaWdodCAvIDI7XG4gIH1cbn1cbiIsICJpbXBvcnQge0RvdWdobnV0Q29udHJvbGxlciwgUG9sYXJBcmVhQ29udHJvbGxlcn0gZnJvbSAnLi4vaW5kZXguanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0LCBDaGFydERhdGFzZXR9IGZyb20gJy4uL3R5cGVzLmpzJztcblxuZXhwb3J0IGludGVyZmFjZSBDb2xvcnNQbHVnaW5PcHRpb25zIHtcbiAgZW5hYmxlZD86IGJvb2xlYW47XG4gIGZvcmNlT3ZlcnJpZGU/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgQ29sb3JzRGVzY3JpcHRvciB7XG4gIGJhY2tncm91bmRDb2xvcj86IHVua25vd247XG4gIGJvcmRlckNvbG9yPzogdW5rbm93bjtcbn1cblxuY29uc3QgQk9SREVSX0NPTE9SUyA9IFtcbiAgJ3JnYig1NCwgMTYyLCAyMzUpJywgLy8gYmx1ZVxuICAncmdiKDI1NSwgOTksIDEzMiknLCAvLyByZWRcbiAgJ3JnYigyNTUsIDE1OSwgNjQpJywgLy8gb3JhbmdlXG4gICdyZ2IoMjU1LCAyMDUsIDg2KScsIC8vIHllbGxvd1xuICAncmdiKDc1LCAxOTIsIDE5MiknLCAvLyBncmVlblxuICAncmdiKDE1MywgMTAyLCAyNTUpJywgLy8gcHVycGxlXG4gICdyZ2IoMjAxLCAyMDMsIDIwNyknIC8vIGdyZXlcbl07XG5cbi8vIEJvcmRlciBjb2xvcnMgd2l0aCA1MCUgdHJhbnNwYXJlbmN5XG5jb25zdCBCQUNLR1JPVU5EX0NPTE9SUyA9IC8qICNfX1BVUkVfXyAqLyBCT1JERVJfQ09MT1JTLm1hcChjb2xvciA9PiBjb2xvci5yZXBsYWNlKCdyZ2IoJywgJ3JnYmEoJykucmVwbGFjZSgnKScsICcsIDAuNSknKSk7XG5cbmZ1bmN0aW9uIGdldEJvcmRlckNvbG9yKGk6IG51bWJlcikge1xuICByZXR1cm4gQk9SREVSX0NPTE9SU1tpICUgQk9SREVSX0NPTE9SUy5sZW5ndGhdO1xufVxuXG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kQ29sb3IoaTogbnVtYmVyKSB7XG4gIHJldHVybiBCQUNLR1JPVU5EX0NPTE9SU1tpICUgQkFDS0dST1VORF9DT0xPUlMubGVuZ3RoXTtcbn1cblxuZnVuY3Rpb24gY29sb3JpemVEZWZhdWx0RGF0YXNldChkYXRhc2V0OiBDaGFydERhdGFzZXQsIGk6IG51bWJlcikge1xuICBkYXRhc2V0LmJvcmRlckNvbG9yID0gZ2V0Qm9yZGVyQ29sb3IoaSk7XG4gIGRhdGFzZXQuYmFja2dyb3VuZENvbG9yID0gZ2V0QmFja2dyb3VuZENvbG9yKGkpO1xuXG4gIHJldHVybiArK2k7XG59XG5cbmZ1bmN0aW9uIGNvbG9yaXplRG91Z2hudXREYXRhc2V0KGRhdGFzZXQ6IENoYXJ0RGF0YXNldCwgaTogbnVtYmVyKSB7XG4gIGRhdGFzZXQuYmFja2dyb3VuZENvbG9yID0gZGF0YXNldC5kYXRhLm1hcCgoKSA9PiBnZXRCb3JkZXJDb2xvcihpKyspKTtcblxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gY29sb3JpemVQb2xhckFyZWFEYXRhc2V0KGRhdGFzZXQ6IENoYXJ0RGF0YXNldCwgaTogbnVtYmVyKSB7XG4gIGRhdGFzZXQuYmFja2dyb3VuZENvbG9yID0gZGF0YXNldC5kYXRhLm1hcCgoKSA9PiBnZXRCYWNrZ3JvdW5kQ29sb3IoaSsrKSk7XG5cbiAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIGdldENvbG9yaXplcihjaGFydDogQ2hhcnQpIHtcbiAgbGV0IGkgPSAwO1xuXG4gIHJldHVybiAoZGF0YXNldDogQ2hhcnREYXRhc2V0LCBkYXRhc2V0SW5kZXg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG5cbiAgICBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIERvdWdobnV0Q29udHJvbGxlcikge1xuICAgICAgaSA9IGNvbG9yaXplRG91Z2hudXREYXRhc2V0KGRhdGFzZXQsIGkpO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIFBvbGFyQXJlYUNvbnRyb2xsZXIpIHtcbiAgICAgIGkgPSBjb2xvcml6ZVBvbGFyQXJlYURhdGFzZXQoZGF0YXNldCwgaSk7XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVyKSB7XG4gICAgICBpID0gY29sb3JpemVEZWZhdWx0RGF0YXNldChkYXRhc2V0LCBpKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbnMoXG4gIGRlc2NyaXB0b3JzOiBDb2xvcnNEZXNjcmlwdG9yW10gfCBSZWNvcmQ8c3RyaW5nLCBDb2xvcnNEZXNjcmlwdG9yPlxuKSB7XG4gIGxldCBrOiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgZm9yIChrIGluIGRlc2NyaXB0b3JzKSB7XG4gICAgaWYgKGRlc2NyaXB0b3JzW2tdLmJvcmRlckNvbG9yIHx8IGRlc2NyaXB0b3JzW2tdLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb250YWluc0NvbG9yc0RlZmluaXRpb24oXG4gIGRlc2NyaXB0b3I6IENvbG9yc0Rlc2NyaXB0b3Jcbikge1xuICByZXR1cm4gZGVzY3JpcHRvciAmJiAoZGVzY3JpcHRvci5ib3JkZXJDb2xvciB8fCBkZXNjcmlwdG9yLmJhY2tncm91bmRDb2xvcik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICdjb2xvcnMnLFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmb3JjZU92ZXJyaWRlOiBmYWxzZVxuICB9IGFzIENvbG9yc1BsdWdpbk9wdGlvbnMsXG5cbiAgYmVmb3JlTGF5b3V0KGNoYXJ0OiBDaGFydCwgX2FyZ3MsIG9wdGlvbnM6IENvbG9yc1BsdWdpbk9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHtkYXRhc2V0c30sXG4gICAgICBvcHRpb25zOiBjaGFydE9wdGlvbnNcbiAgICB9ID0gY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHtlbGVtZW50c30gPSBjaGFydE9wdGlvbnM7XG5cbiAgICBpZiAoIW9wdGlvbnMuZm9yY2VPdmVycmlkZSAmJiAoY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhkYXRhc2V0cykgfHwgY29udGFpbnNDb2xvcnNEZWZpbml0aW9uKGNoYXJ0T3B0aW9ucykgfHwgKGVsZW1lbnRzICYmIGNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbnMoZWxlbWVudHMpKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb2xvcml6ZXIgPSBnZXRDb2xvcml6ZXIoY2hhcnQpO1xuXG4gICAgZGF0YXNldHMuZm9yRWFjaChjb2xvcml6ZXIpO1xuICB9XG59O1xuIiwgImltcG9ydCB7X2xpbWl0VmFsdWUsIF9sb29rdXBCeUtleSwgaXNOdWxsT3JVbmRlZiwgcmVzb2x2ZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmZ1bmN0aW9uIGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpIHtcbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBMYXJnZXN0IFRyaWFuZ2xlIFRocmVlIEJ1Y2tldHMgYWxnb3JpdGhtLlxuICAgKlxuICAgKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBieSBTdmVpbm4gU3RlaW5hcnNzb25cbiAgICogaW4gaHR0cHM6Ly9naXRodWIuY29tL3N2ZWlubi1zdGVpbmFyc3Nvbi9mbG90LWRvd25zYW1wbGUvYmxvYi9tYXN0ZXIvanF1ZXJ5LmZsb3QuZG93bnNhbXBsZS5qc1xuICAgKlxuICAgKiBUaGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb24gaXMgTUlUIGxpY2Vuc2VkLlxuICAgKi9cbiAgY29uc3Qgc2FtcGxlcyA9IG9wdGlvbnMuc2FtcGxlcyB8fCBhdmFpbGFibGVXaWR0aDtcbiAgLy8gVGhlcmUgYXJlIGxlc3MgcG9pbnRzIHRoYW4gdGhlIHRocmVzaG9sZCwgcmV0dXJuaW5nIHRoZSB3aG9sZSBhcnJheVxuICBpZiAoc2FtcGxlcyA+PSBjb3VudCkge1xuICAgIHJldHVybiBkYXRhLnNsaWNlKHN0YXJ0LCBzdGFydCArIGNvdW50KTtcbiAgfVxuXG4gIGNvbnN0IGRlY2ltYXRlZCA9IFtdO1xuXG4gIGNvbnN0IGJ1Y2tldFdpZHRoID0gKGNvdW50IC0gMikgLyAoc2FtcGxlcyAtIDIpO1xuICBsZXQgc2FtcGxlZEluZGV4ID0gMDtcbiAgY29uc3QgZW5kSW5kZXggPSBzdGFydCArIGNvdW50IC0gMTtcbiAgLy8gU3RhcnRpbmcgZnJvbSBvZmZzZXRcbiAgbGV0IGEgPSBzdGFydDtcbiAgbGV0IGksIG1heEFyZWFQb2ludCwgbWF4QXJlYSwgYXJlYSwgbmV4dEE7XG5cbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbYV07XG5cbiAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMgLSAyOyBpKyspIHtcbiAgICBsZXQgYXZnWCA9IDA7XG4gICAgbGV0IGF2Z1kgPSAwO1xuICAgIGxldCBqO1xuXG4gICAgLy8gQWRkaW5nIG9mZnNldFxuICAgIGNvbnN0IGF2Z1JhbmdlU3RhcnQgPSBNYXRoLmZsb29yKChpICsgMSkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgYXZnUmFuZ2VFbmQgPSBNYXRoLm1pbihNYXRoLmZsb29yKChpICsgMikgKiBidWNrZXRXaWR0aCkgKyAxLCBjb3VudCkgKyBzdGFydDtcbiAgICBjb25zdCBhdmdSYW5nZUxlbmd0aCA9IGF2Z1JhbmdlRW5kIC0gYXZnUmFuZ2VTdGFydDtcblxuICAgIGZvciAoaiA9IGF2Z1JhbmdlU3RhcnQ7IGogPCBhdmdSYW5nZUVuZDsgaisrKSB7XG4gICAgICBhdmdYICs9IGRhdGFbal0ueDtcbiAgICAgIGF2Z1kgKz0gZGF0YVtqXS55O1xuICAgIH1cblxuICAgIGF2Z1ggLz0gYXZnUmFuZ2VMZW5ndGg7XG4gICAgYXZnWSAvPSBhdmdSYW5nZUxlbmd0aDtcblxuICAgIC8vIEFkZGluZyBvZmZzZXRcbiAgICBjb25zdCByYW5nZU9mZnMgPSBNYXRoLmZsb29yKGkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgcmFuZ2VUbyA9IE1hdGgubWluKE1hdGguZmxvb3IoKGkgKyAxKSAqIGJ1Y2tldFdpZHRoKSArIDEsIGNvdW50KSArIHN0YXJ0O1xuICAgIGNvbnN0IHt4OiBwb2ludEF4LCB5OiBwb2ludEF5fSA9IGRhdGFbYV07XG5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBpcyBjaGFuZ2VkIGZyb20gdGhlIG9yaWdpbmFsIGFsZ29yaXRobSB3aGljaCBpbml0aWFsaXplcyB0aGVzZVxuICAgIC8vIHZhbHVlcyB0byAxLiBUaGUgcmVhc29uIGZvciB0aGlzIGNoYW5nZSBpcyB0aGF0IGlmIHRoZSBhcmVhIGlzIHNtYWxsLCBuZXh0QVxuICAgIC8vIHdvdWxkIG5ldmVyIGJlIHNldCBhbmQgdGh1cyBhIGNyYXNoIHdvdWxkIG9jY3VyIGluIHRoZSBuZXh0IGxvb3AgYXMgYGFgIHdvdWxkIGJlY29tZVxuICAgIC8vIGB1bmRlZmluZWRgLiBTaW5jZSB0aGUgYXJlYSBpcyBhbHdheXMgcG9zaXRpdmUsIGJ1dCBjb3VsZCBiZSAwIGluIHRoZSBjYXNlIG9mIGEgZmxhdCB0cmFjZSxcbiAgICAvLyBpbml0aWFsaXppbmcgd2l0aCBhIG5lZ2F0aXZlIG51bWJlciBpcyB0aGUgY29ycmVjdCBzb2x1dGlvbi5cbiAgICBtYXhBcmVhID0gYXJlYSA9IC0xO1xuXG4gICAgZm9yIChqID0gcmFuZ2VPZmZzOyBqIDwgcmFuZ2VUbzsgaisrKSB7XG4gICAgICBhcmVhID0gMC41ICogTWF0aC5hYnMoXG4gICAgICAgIChwb2ludEF4IC0gYXZnWCkgKiAoZGF0YVtqXS55IC0gcG9pbnRBeSkgLVxuICAgICAgICAocG9pbnRBeCAtIGRhdGFbal0ueCkgKiAoYXZnWSAtIHBvaW50QXkpXG4gICAgICApO1xuXG4gICAgICBpZiAoYXJlYSA+IG1heEFyZWEpIHtcbiAgICAgICAgbWF4QXJlYSA9IGFyZWE7XG4gICAgICAgIG1heEFyZWFQb2ludCA9IGRhdGFbal07XG4gICAgICAgIG5leHRBID0gajtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gbWF4QXJlYVBvaW50O1xuICAgIGEgPSBuZXh0QTtcbiAgfVxuXG4gIC8vIEluY2x1ZGUgdGhlIGxhc3QgcG9pbnRcbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbZW5kSW5kZXhdO1xuXG4gIHJldHVybiBkZWNpbWF0ZWQ7XG59XG5cbmZ1bmN0aW9uIG1pbk1heERlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCkge1xuICBsZXQgYXZnWCA9IDA7XG4gIGxldCBjb3VudFggPSAwO1xuICBsZXQgaSwgcG9pbnQsIHgsIHksIHByZXZYLCBtaW5JbmRleCwgbWF4SW5kZXgsIHN0YXJ0SW5kZXgsIG1pblksIG1heFk7XG4gIGNvbnN0IGRlY2ltYXRlZCA9IFtdO1xuICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuXG4gIGNvbnN0IHhNaW4gPSBkYXRhW3N0YXJ0XS54O1xuICBjb25zdCB4TWF4ID0gZGF0YVtlbmRJbmRleF0ueDtcbiAgY29uc3QgZHggPSB4TWF4IC0geE1pbjtcblxuICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgIHBvaW50ID0gZGF0YVtpXTtcbiAgICB4ID0gKHBvaW50LnggLSB4TWluKSAvIGR4ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7XG5cbiAgICBpZiAodHJ1bmNYID09PSBwcmV2WCkge1xuICAgICAgLy8gRGV0ZXJtaW5lIGBtaW5ZYCAvIGBtYXhZYCBhbmQgYGF2Z1hgIHdoaWxlIHdlIHN0YXkgd2l0aGluIHNhbWUgeC1wb3NpdGlvblxuICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgIG1pblkgPSB5O1xuICAgICAgICBtaW5JbmRleCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgIG1heFkgPSB5O1xuICAgICAgICBtYXhJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICAvLyBGb3IgZmlyc3QgcG9pbnQgaW4gZ3JvdXAsIGNvdW50WCBpcyBgMGAsIHNvIGF2ZXJhZ2Ugd2lsbCBiZSBgeGAgLyAxLlxuICAgICAgLy8gVXNlIHBvaW50LnggaGVyZSBiZWNhdXNlIHdlJ3JlIGNvbXB1dGluZyB0aGUgYXZlcmFnZSBkYXRhIGB4YCB2YWx1ZVxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgcG9pbnQueCkgLyArK2NvdW50WDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUHVzaCB1cCB0byA0IHBvaW50cywgMyBmb3IgdGhlIGxhc3QgaW50ZXJ2YWwgYW5kIHRoZSBmaXJzdCBwb2ludCBmb3IgdGhpcyBpbnRlcnZhbFxuICAgICAgY29uc3QgbGFzdEluZGV4ID0gaSAtIDE7XG5cbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihtaW5JbmRleCkgJiYgIWlzTnVsbE9yVW5kZWYobWF4SW5kZXgpKSB7XG4gICAgICAgIC8vIFRoZSBpbnRlcnZhbCBpcyBkZWZpbmVkIGJ5IDQgcG9pbnRzOiBzdGFydCwgbWluLCBtYXgsIGVuZC5cbiAgICAgICAgLy8gVGhlIHN0YXJ0aW5nIHBvaW50IGlzIGFscmVhZHkgY29uc2lkZXJlZCBhdCB0aGlzIHBvaW50LCBzbyB3ZSBuZWVkIHRvIGRldGVybWluZSB3aGljaFxuICAgICAgICAvLyBvZiB0aGUgb3RoZXIgcG9pbnRzIHRvIGFkZC4gV2UgbmVlZCB0byBzb3J0IHRoZXNlIHBvaW50cyB0byBlbnN1cmUgdGhlIGRlY2ltYXRlZCBkYXRhXG4gICAgICAgIC8vIGlzIHN0aWxsIHNvcnRlZCBhbmQgdGhlbiBlbnN1cmUgdGhlcmUgYXJlIG5vIGR1cGxpY2F0ZXMuXG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUluZGV4MSA9IE1hdGgubWluKG1pbkluZGV4LCBtYXhJbmRleCk7XG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUluZGV4MiA9IE1hdGgubWF4KG1pbkluZGV4LCBtYXhJbmRleCk7XG5cbiAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MSAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDEgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgxXSxcbiAgICAgICAgICAgIHg6IGF2Z1gsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MiAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDIgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgyXSxcbiAgICAgICAgICAgIHg6IGF2Z1hcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBsYXN0SW5kZXggPT09IHN0YXJ0SW5kZXggd2lsbCBvY2N1ciB3aGVuIGEgcmFuZ2UgaGFzIG9ubHkgMSBwb2ludCB3aGljaCBjb3VsZFxuICAgICAgLy8gaGFwcGVuIHdpdGggdmVyeSB1bmV2ZW4gZGF0YVxuICAgICAgaWYgKGkgPiAwICYmIGxhc3RJbmRleCAhPT0gc3RhcnRJbmRleCkge1xuICAgICAgICAvLyBMYXN0IHBvaW50IGluIHRoZSBwcmV2aW91cyBpbnRlcnZhbFxuICAgICAgICBkZWNpbWF0ZWQucHVzaChkYXRhW2xhc3RJbmRleF0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTdGFydCBvZiB0aGUgbmV3IGludGVydmFsXG4gICAgICBkZWNpbWF0ZWQucHVzaChwb2ludCk7XG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgICBtaW5JbmRleCA9IG1heEluZGV4ID0gc3RhcnRJbmRleCA9IGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlY2ltYXRlZDtcbn1cblxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpIHtcbiAgaWYgKGRhdGFzZXQuX2RlY2ltYXRlZCkge1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0Ll9kYXRhO1xuICAgIGRlbGV0ZSBkYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RhdGE7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGRhdGEsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KSB7XG4gIGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCkgPT4ge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkKG1ldGEsIHBvaW50cykge1xuICBjb25zdCBwb2ludENvdW50ID0gcG9pbnRzLmxlbmd0aDtcblxuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQ7XG5cbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcblxuICBpZiAobWluRGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoX2xvb2t1cEJ5S2V5KHBvaW50cywgaVNjYWxlLmF4aXMsIG1pbikubG8sIDAsIHBvaW50Q291bnQgLSAxKTtcbiAgfVxuICBpZiAobWF4RGVmaW5lZCkge1xuICAgIGNvdW50ID0gX2xpbWl0VmFsdWUoX2xvb2t1cEJ5S2V5KHBvaW50cywgaVNjYWxlLmF4aXMsIG1heCkuaGkgKyAxLCBzdGFydCwgcG9pbnRDb3VudCkgLSBzdGFydDtcbiAgfSBlbHNlIHtcbiAgICBjb3VudCA9IHBvaW50Q291bnQgLSBzdGFydDtcbiAgfVxuXG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ2RlY2ltYXRpb24nLFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxnb3JpdGhtOiAnbWluLW1heCcsXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gIH0sXG5cbiAgYmVmb3JlRWxlbWVudHNVcGRhdGU6IChjaGFydCwgYXJncywgb3B0aW9ucykgPT4ge1xuICAgIGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICAvLyBUaGUgZGVjaW1hdGlvbiBwbHVnaW4gbWF5IGhhdmUgYmVlbiBwcmV2aW91c2x5IGVuYWJsZWQuIE5lZWQgdG8gcmVtb3ZlIG9sZCBgZGF0YXNldC5fZGF0YWAgaGFuZGxlcnNcbiAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQXNzdW1lIHRoZSBlbnRpcmUgY2hhcnQgaXMgYXZhaWxhYmxlIHRvIHNob3cgYSBmZXcgbW9yZSBwb2ludHMgdGhhbiBuZWVkZWRcbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IGNoYXJ0LndpZHRoO1xuXG4gICAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHtfZGF0YSwgaW5kZXhBeGlzfSA9IGRhdGFzZXQ7XG4gICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBfZGF0YSB8fCBkYXRhc2V0LmRhdGE7XG5cbiAgICAgIGlmIChyZXNvbHZlKFtpbmRleEF4aXMsIGNoYXJ0Lm9wdGlvbnMuaW5kZXhBeGlzXSkgPT09ICd5Jykge1xuICAgICAgICAvLyBEZWNpbWF0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBsaW5lcyB0aGF0IGhhdmUgYW4gWCBpbmRleEF4aXNcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW1ldGEuY29udHJvbGxlci5zdXBwb3J0c0RlY2ltYXRpb24pIHtcbiAgICAgICAgLy8gT25seSBsaW5lIGRhdGFzZXRzIGFyZSBzdXBwb3J0ZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB4QXhpcyA9IGNoYXJ0LnNjYWxlc1ttZXRhLnhBeGlzSURdO1xuICAgICAgaWYgKHhBeGlzLnR5cGUgIT09ICdsaW5lYXInICYmIHhBeGlzLnR5cGUgIT09ICd0aW1lJykge1xuICAgICAgICAvLyBPbmx5IGxpbmVhciBpbnRlcnBvbGF0aW9uIGlzIHN1cHBvcnRlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFydC5vcHRpb25zLnBhcnNpbmcpIHtcbiAgICAgICAgLy8gUGx1Z2luIG9ubHkgc3VwcG9ydHMgZGF0YSB0aGF0IGRvZXMgbm90IG5lZWQgcGFyc2luZ1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkKG1ldGEsIGRhdGEpO1xuICAgICAgY29uc3QgdGhyZXNob2xkID0gb3B0aW9ucy50aHJlc2hvbGQgfHwgNCAqIGF2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKGNvdW50IDw9IHRocmVzaG9sZCkge1xuICAgICAgICAvLyBObyBkZWNpbWF0aW9uIGlzIHJlcXVpcmVkIHVudGlsIHdlIGFyZSBhYm92ZSB0aGlzIHRocmVzaG9sZFxuICAgICAgICBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYoX2RhdGEpKSB7XG4gICAgICAgIC8vIEZpcnN0IHRpbWUgd2UgYXJlIHNlZWluZyB0aGlzIGRhdGFzZXRcbiAgICAgICAgLy8gV2Ugb3ZlcnJpZGUgdGhlICdkYXRhJyBwcm9wZXJ0eSB3aXRoIGEgc2V0dGVyIHRoYXQgc3RvcmVzIHRoZVxuICAgICAgICAvLyByYXcgZGF0YSBpbiBfZGF0YSwgYnV0IHJlYWRzIHRoZSBkZWNpbWF0ZWQgZGF0YSBmcm9tIF9kZWNpbWF0ZWRcbiAgICAgICAgZGF0YXNldC5fZGF0YSA9IGRhdGE7XG4gICAgICAgIGRlbGV0ZSBkYXRhc2V0LmRhdGE7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhc2V0LCAnZGF0YScsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY2ltYXRlZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gUG9pbnQgdGhlIGNoYXJ0IHRvIHRoZSBkZWNpbWF0ZWQgZGF0YVxuICAgICAgbGV0IGRlY2ltYXRlZDtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5hbGdvcml0aG0pIHtcbiAgICAgIGNhc2UgJ2x0dGInOlxuICAgICAgICBkZWNpbWF0ZWQgPSBsdHRiRGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoLCBvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaW4tbWF4JzpcbiAgICAgICAgZGVjaW1hdGVkID0gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlY2ltYXRpb24gYWxnb3JpdGhtICcke29wdGlvbnMuYWxnb3JpdGhtfSdgKTtcbiAgICAgIH1cblxuICAgICAgZGF0YXNldC5fZGVjaW1hdGVkID0gZGVjaW1hdGVkO1xuICAgIH0pO1xuICB9LFxuXG4gIGRlc3Ryb3koY2hhcnQpIHtcbiAgICBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpO1xuICB9XG59O1xuIiwgImltcG9ydCB7X2JvdW5kU2VnbWVudCwgX2JvdW5kU2VnbWVudHMsIF9ub3JtYWxpemVBbmdsZX0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBfc2VnbWVudHMobGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCB0cG9pbnRzID0gdGFyZ2V0LnBvaW50cztcbiAgY29uc3QgcGFydHMgPSBbXTtcblxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBsZXQge3N0YXJ0LCBlbmR9ID0gc2VnbWVudDtcbiAgICBlbmQgPSBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKTtcblxuICAgIGNvbnN0IGJvdW5kcyA9IF9nZXRCb3VuZHMocHJvcGVydHksIHBvaW50c1tzdGFydF0sIHBvaW50c1tlbmRdLCBzZWdtZW50Lmxvb3ApO1xuXG4gICAgaWYgKCF0YXJnZXQuc2VnbWVudHMpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYm91bmRhcnkgbm90IHN1cHBvcnRpbmcgYHNlZ21lbnRzYCAoc2ltcGxlQXJjKVxuICAgICAgLy8gQm91bmRzIGFyZSBwcm92aWRlZCBhcyBgdGFyZ2V0YCBmb3IgcGFydGlhbCBjaXJjbGUsIG9yIHVuZGVmaW5lZCBmb3IgZnVsbCBjaXJjbGVcbiAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICBzb3VyY2U6IHNlZ21lbnQsXG4gICAgICAgIHRhcmdldDogYm91bmRzLFxuICAgICAgICBzdGFydDogcG9pbnRzW3N0YXJ0XSxcbiAgICAgICAgZW5kOiBwb2ludHNbZW5kXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBHZXQgYWxsIHNlZ21lbnRzIGZyb20gYHRhcmdldGAgdGhhdCBpbnRlcnNlY3QgdGhlIGJvdW5kcyBvZiBjdXJyZW50IHNlZ21lbnQgb2YgYGxpbmVgXG4gICAgY29uc3QgdGFyZ2V0U2VnbWVudHMgPSBfYm91bmRTZWdtZW50cyh0YXJnZXQsIGJvdW5kcyk7XG5cbiAgICBmb3IgKGNvbnN0IHRndCBvZiB0YXJnZXRTZWdtZW50cykge1xuICAgICAgY29uc3Qgc3ViQm91bmRzID0gX2dldEJvdW5kcyhwcm9wZXJ0eSwgdHBvaW50c1t0Z3Quc3RhcnRdLCB0cG9pbnRzW3RndC5lbmRdLCB0Z3QubG9vcCk7XG4gICAgICBjb25zdCBmaWxsU291cmNlcyA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBzdWJCb3VuZHMpO1xuXG4gICAgICBmb3IgKGNvbnN0IGZpbGxTb3VyY2Ugb2YgZmlsbFNvdXJjZXMpIHtcbiAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgc291cmNlOiBmaWxsU291cmNlLFxuICAgICAgICAgIHRhcmdldDogdGd0LFxuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICBbcHJvcGVydHldOiBfZ2V0RWRnZShib3VuZHMsIHN1YkJvdW5kcywgJ3N0YXJ0JywgTWF0aC5tYXgpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgIFtwcm9wZXJ0eV06IF9nZXRFZGdlKGJvdW5kcywgc3ViQm91bmRzLCAnZW5kJywgTWF0aC5taW4pXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2dldEJvdW5kcyhwcm9wZXJ0eSwgZmlyc3QsIGxhc3QsIGxvb3ApIHtcbiAgaWYgKGxvb3ApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHN0YXJ0ID0gZmlyc3RbcHJvcGVydHldO1xuICBsZXQgZW5kID0gbGFzdFtwcm9wZXJ0eV07XG5cbiAgaWYgKHByb3BlcnR5ID09PSAnYW5nbGUnKSB7XG4gICAgc3RhcnQgPSBfbm9ybWFsaXplQW5nbGUoc3RhcnQpO1xuICAgIGVuZCA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICB9XG4gIHJldHVybiB7cHJvcGVydHksIHN0YXJ0LCBlbmR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX3BvaW50c0Zyb21TZWdtZW50cyhib3VuZGFyeSwgbGluZSkge1xuICBjb25zdCB7eCA9IG51bGwsIHkgPSBudWxsfSA9IGJvdW5kYXJ5IHx8IHt9O1xuICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHBvaW50cyA9IFtdO1xuICBsaW5lLnNlZ21lbnRzLmZvckVhY2goKHtzdGFydCwgZW5kfSkgPT4ge1xuICAgIGVuZCA9IF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBsaW5lUG9pbnRzKTtcbiAgICBjb25zdCBmaXJzdCA9IGxpbmVQb2ludHNbc3RhcnRdO1xuICAgIGNvbnN0IGxhc3QgPSBsaW5lUG9pbnRzW2VuZF07XG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHBvaW50cy5wdXNoKHt4OiBmaXJzdC54LCB5fSk7XG4gICAgICBwb2ludHMucHVzaCh7eDogbGFzdC54LCB5fSk7XG4gICAgfSBlbHNlIGlmICh4ICE9PSBudWxsKSB7XG4gICAgICBwb2ludHMucHVzaCh7eCwgeTogZmlyc3QueX0pO1xuICAgICAgcG9pbnRzLnB1c2goe3gsIHk6IGxhc3QueX0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwb2ludHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKSB7XG4gIGZvciAoO2VuZCA+IHN0YXJ0OyBlbmQtLSkge1xuICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2VuZF07XG4gICAgaWYgKCFpc05hTihwb2ludC54KSAmJiAhaXNOYU4ocG9pbnQueSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5kO1xufVxuXG5mdW5jdGlvbiBfZ2V0RWRnZShhLCBiLCBwcm9wLCBmbikge1xuICBpZiAoYSAmJiBiKSB7XG4gICAgcmV0dXJuIGZuKGFbcHJvcF0sIGJbcHJvcF0pO1xuICB9XG4gIHJldHVybiBhID8gYVtwcm9wXSA6IGIgPyBiW3Byb3BdIDogMDtcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuaW1wb3J0IHtMaW5lRWxlbWVudH0gZnJvbSAnLi4vLi4vZWxlbWVudHMvaW5kZXguanMnO1xuaW1wb3J0IHtpc0FycmF5fSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X3BvaW50c0Zyb21TZWdtZW50c30gZnJvbSAnLi9maWxsZXIuc2VnbWVudC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXSB8IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IH19IGJvdW5kYXJ5XG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcmV0dXJuIHtMaW5lRWxlbWVudD99XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY3JlYXRlQm91bmRhcnlMaW5lKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGxldCBwb2ludHMgPSBbXTtcbiAgbGV0IF9sb29wID0gZmFsc2U7XG5cbiAgaWYgKGlzQXJyYXkoYm91bmRhcnkpKSB7XG4gICAgX2xvb3AgPSB0cnVlO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBwb2ludHMgPSBib3VuZGFyeTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSBfcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHMubGVuZ3RoID8gbmV3IExpbmVFbGVtZW50KHtcbiAgICBwb2ludHMsXG4gICAgb3B0aW9uczoge3RlbnNpb246IDB9LFxuICAgIF9sb29wLFxuICAgIF9mdWxsTG9vcDogX2xvb3BcbiAgfSkgOiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpIHtcbiAgcmV0dXJuIHNvdXJjZSAmJiBzb3VyY2UuZmlsbCAhPT0gZmFsc2U7XG59XG4iLCAiaW1wb3J0IHtpc09iamVjdCwgaXNGaW5pdGUsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi8uLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQubGluZS5qcycpLmRlZmF1bHQgfSBMaW5lRWxlbWVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL3R5cGVzL2luZGV4LmpzJykuRmlsbFRhcmdldCB9IEZpbGxUYXJnZXRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi90eXBlcy9pbmRleC5qcycpLkNvbXBsZXhGaWxsVGFyZ2V0IH0gQ29tcGxleEZpbGxUYXJnZXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gX3Jlc29sdmVUYXJnZXQoc291cmNlcywgaW5kZXgsIHByb3BhZ2F0ZSkge1xuICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgbGV0IGZpbGwgPSBzb3VyY2UuZmlsbDtcbiAgY29uc3QgdmlzaXRlZCA9IFtpbmRleF07XG4gIGxldCB0YXJnZXQ7XG5cbiAgaWYgKCFwcm9wYWdhdGUpIHtcbiAgICByZXR1cm4gZmlsbDtcbiAgfVxuXG4gIHdoaWxlIChmaWxsICE9PSBmYWxzZSAmJiB2aXNpdGVkLmluZGV4T2YoZmlsbCkgPT09IC0xKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShmaWxsKSkge1xuICAgICAgcmV0dXJuIGZpbGw7XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gc291cmNlc1tmaWxsXTtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQudmlzaWJsZSkge1xuICAgICAgcmV0dXJuIGZpbGw7XG4gICAgfVxuXG4gICAgdmlzaXRlZC5wdXNoKGZpbGwpO1xuICAgIGZpbGwgPSB0YXJnZXQuZmlsbDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICovXG5leHBvcnQgZnVuY3Rpb24gX2RlY29kZUZpbGwobGluZSwgaW5kZXgsIGNvdW50KSB7XG4gIC8qKiBAdHlwZSB7c3RyaW5nIHwge3ZhbHVlOiBudW1iZXJ9fSAqL1xuICBjb25zdCBmaWxsID0gcGFyc2VGaWxsT3B0aW9uKGxpbmUpO1xuXG4gIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIHJldHVybiBpc05hTihmaWxsLnZhbHVlKSA/IGZhbHNlIDogZmlsbDtcbiAgfVxuXG4gIGxldCB0YXJnZXQgPSBwYXJzZUZsb2F0KGZpbGwpO1xuXG4gIGlmIChpc0Zpbml0ZSh0YXJnZXQpICYmIE1hdGguZmxvb3IodGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGRlY29kZVRhcmdldEluZGV4KGZpbGxbMF0sIGluZGV4LCB0YXJnZXQsIGNvdW50KTtcbiAgfVxuXG4gIHJldHVybiBbJ29yaWdpbicsICdzdGFydCcsICdlbmQnLCAnc3RhY2snLCAnc2hhcGUnXS5pbmRleE9mKGZpbGwpID49IDAgJiYgZmlsbDtcbn1cblxuZnVuY3Rpb24gZGVjb2RlVGFyZ2V0SW5kZXgoZmlyc3RDaCwgaW5kZXgsIHRhcmdldCwgY291bnQpIHtcbiAgaWYgKGZpcnN0Q2ggPT09ICctJyB8fCBmaXJzdENoID09PSAnKycpIHtcbiAgICB0YXJnZXQgPSBpbmRleCArIHRhcmdldDtcbiAgfVxuXG4gIGlmICh0YXJnZXQgPT09IGluZGV4IHx8IHRhcmdldCA8IDAgfHwgdGFyZ2V0ID49IGNvdW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZpbGxUYXJnZXQgfCBDb21wbGV4RmlsbFRhcmdldH0gZmlsbFxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGVcbiAqIEByZXR1cm5zIHtudW1iZXIgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldFRhcmdldFBpeGVsKGZpbGwsIHNjYWxlKSB7XG4gIGxldCBwaXhlbCA9IG51bGw7XG4gIGlmIChmaWxsID09PSAnc3RhcnQnKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS5ib3R0b207XG4gIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcbiAgICBwaXhlbCA9IHNjYWxlLnRvcDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBwaXhlbCA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUoZmlsbC52YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBpeGVsKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgfVxuICByZXR1cm4gcGl4ZWw7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGaWxsVGFyZ2V0IHwgQ29tcGxleEZpbGxUYXJnZXR9IGZpbGxcbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRWYWx1ZVxuICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9nZXRUYXJnZXRWYWx1ZShmaWxsLCBzY2FsZSwgc3RhcnRWYWx1ZSkge1xuICBsZXQgdmFsdWU7XG5cbiAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICB2YWx1ZSA9IHN0YXJ0VmFsdWU7XG4gIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcbiAgICB2YWx1ZSA9IHNjYWxlLm9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1pbiA6IHNjYWxlLm1heDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB2YWx1ZSA9IGZpbGwudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBzY2FsZS5nZXRCYXNlVmFsdWUoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICovXG5mdW5jdGlvbiBwYXJzZUZpbGxPcHRpb24obGluZSkge1xuICBjb25zdCBvcHRpb25zID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBmaWxsT3B0aW9uID0gb3B0aW9ucy5maWxsO1xuICBsZXQgZmlsbCA9IHZhbHVlT3JEZWZhdWx0KGZpbGxPcHRpb24gJiYgZmlsbE9wdGlvbi50YXJnZXQsIGZpbGxPcHRpb24pO1xuXG4gIGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcbiAgICBmaWxsID0gISFvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgfVxuXG4gIGlmIChmaWxsID09PSBmYWxzZSB8fCBmaWxsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09IHRydWUpIHtcbiAgICByZXR1cm4gJ29yaWdpbic7XG4gIH1cbiAgcmV0dXJuIGZpbGw7XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0IH0gU2NhbGVcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9lbGVtZW50cy9lbGVtZW50LnBvaW50LmpzJykuZGVmYXVsdCB9IFBvaW50RWxlbWVudFxuICovXG5cbmltcG9ydCB7TGluZUVsZW1lbnR9IGZyb20gJy4uLy4uL2VsZW1lbnRzL2luZGV4LmpzJztcbmltcG9ydCB7X2lzQmV0d2Vlbn0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge19jcmVhdGVCb3VuZGFyeUxpbmV9IGZyb20gJy4vZmlsbGVyLmhlbHBlci5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHt7IGNoYXJ0OiBDaGFydDsgc2NhbGU6IFNjYWxlOyBpbmRleDogbnVtYmVyOyBsaW5lOiBMaW5lRWxlbWVudDsgfX0gc291cmNlXG4gKiBAcmV0dXJuIHtMaW5lRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9idWlsZFN0YWNrTGluZShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlLCBpbmRleCwgbGluZX0gPSBzb3VyY2U7XG4gIGNvbnN0IHBvaW50cyA9IFtdO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IHNvdXJjZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBsaW5lc0JlbG93ID0gZ2V0TGluZXNCZWxvdyhzY2FsZSwgaW5kZXgpO1xuICBsaW5lc0JlbG93LnB1c2goX2NyZWF0ZUJvdW5kYXJ5TGluZSh7eDogbnVsbCwgeTogc2NhbGUuYm90dG9tfSwgbGluZSkpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgZm9yIChsZXQgaiA9IHNlZ21lbnQuc3RhcnQ7IGogPD0gc2VnbWVudC5lbmQ7IGorKykge1xuICAgICAgYWRkUG9pbnRzQmVsb3cocG9pbnRzLCBzb3VyY2VQb2ludHNbal0sIGxpbmVzQmVsb3cpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IExpbmVFbGVtZW50KHtwb2ludHMsIG9wdGlvbnM6IHt9fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7TGluZUVsZW1lbnRbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGluZXNCZWxvdyhzY2FsZSwgaW5kZXgpIHtcbiAgY29uc3QgYmVsb3cgPSBbXTtcbiAgY29uc3QgbWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygnbGluZScpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWV0YXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtZXRhID0gbWV0YXNbaV07XG4gICAgaWYgKG1ldGEuaW5kZXggPT09IGluZGV4KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKCFtZXRhLmhpZGRlbikge1xuICAgICAgYmVsb3cudW5zaGlmdChtZXRhLmRhdGFzZXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmVsb3c7XG59XG5cbi8qKlxuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXX0gcG9pbnRzXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudH0gc291cmNlUG9pbnRcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnRbXX0gbGluZXNCZWxvd1xuICovXG5mdW5jdGlvbiBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50LCBsaW5lc0JlbG93KSB7XG4gIGNvbnN0IHBvc3Rwb25lZCA9IFtdO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmVzQmVsb3cubGVuZ3RoOyBqKyspIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNCZWxvd1tqXTtcbiAgICBjb25zdCB7Zmlyc3QsIGxhc3QsIHBvaW50fSA9IGZpbmRQb2ludChsaW5lLCBzb3VyY2VQb2ludCwgJ3gnKTtcblxuICAgIGlmICghcG9pbnQgfHwgKGZpcnN0ICYmIGxhc3QpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICAvLyBGaXJzdCBwb2ludCBvZiBhbiBzZWdtZW50IC0+IG5lZWQgdG8gYWRkIGFub3RoZXIgcG9pbnQgYmVmb3JlIHRoaXMsXG4gICAgICAvLyBmcm9tIG5leHQgbGluZSBiZWxvdy5cbiAgICAgIHBvc3Rwb25lZC51bnNoaWZ0KHBvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIC8vIEluIHRoZSBtaWRkbGUgb2YgYW4gc2VnbWVudCwgbm8gbmVlZCB0byBhZGQgbW9yZSBwb2ludHMuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwb2ludHMucHVzaCguLi5wb3N0cG9uZWQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50fSBzb3VyY2VQb2ludFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7e3BvaW50PzogUG9pbnRFbGVtZW50LCBmaXJzdD86IGJvb2xlYW4sIGxhc3Q/OiBib29sZWFufX1cbiAqL1xuZnVuY3Rpb24gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCBwb2ludCA9IGxpbmUuaW50ZXJwb2xhdGUoc291cmNlUG9pbnQsIHByb3BlcnR5KTtcbiAgaWYgKCFwb2ludCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGNvbnN0IHBvaW50VmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3QgbGluZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBsZXQgZmlyc3QgPSBmYWxzZTtcbiAgbGV0IGxhc3QgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBjb25zdCBmaXJzdFZhbHVlID0gbGluZVBvaW50c1tzZWdtZW50LnN0YXJ0XVtwcm9wZXJ0eV07XG4gICAgY29uc3QgbGFzdFZhbHVlID0gbGluZVBvaW50c1tzZWdtZW50LmVuZF1bcHJvcGVydHldO1xuICAgIGlmIChfaXNCZXR3ZWVuKHBvaW50VmFsdWUsIGZpcnN0VmFsdWUsIGxhc3RWYWx1ZSkpIHtcbiAgICAgIGZpcnN0ID0gcG9pbnRWYWx1ZSA9PT0gZmlyc3RWYWx1ZTtcbiAgICAgIGxhc3QgPSBwb2ludFZhbHVlID09PSBsYXN0VmFsdWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtmaXJzdCwgbGFzdCwgcG9pbnR9O1xufVxuIiwgImltcG9ydCB7VEFVfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcblxuLy8gVE9ETzogdXNlIGVsZW1lbnRzLkFyY0VsZW1lbnQgaW5zdGVhZFxuZXhwb3J0IGNsYXNzIHNpbXBsZUFyYyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLnggPSBvcHRzLng7XG4gICAgdGhpcy55ID0gb3B0cy55O1xuICAgIHRoaXMucmFkaXVzID0gb3B0cy5yYWRpdXM7XG4gIH1cblxuICBwYXRoU2VnbWVudChjdHgsIGJvdW5kcywgb3B0cykge1xuICAgIGNvbnN0IHt4LCB5LCByYWRpdXN9ID0gdGhpcztcbiAgICBib3VuZHMgPSBib3VuZHMgfHwge3N0YXJ0OiAwLCBlbmQ6IFRBVX07XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIGJvdW5kcy5lbmQsIGJvdW5kcy5zdGFydCwgdHJ1ZSk7XG4gICAgcmV0dXJuICFvcHRzLmJvdW5kcztcbiAgfVxuXG4gIGludGVycG9sYXRlKHBvaW50KSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGNvbnN0IGFuZ2xlID0gcG9pbnQuYW5nbGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMsXG4gICAgICB5OiB5ICsgTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG59XG4iLCAiaW1wb3J0IHtpc0Zpbml0ZX0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge19jcmVhdGVCb3VuZGFyeUxpbmV9IGZyb20gJy4vZmlsbGVyLmhlbHBlci5qcyc7XG5pbXBvcnQge19nZXRUYXJnZXRQaXhlbCwgX2dldFRhcmdldFZhbHVlfSBmcm9tICcuL2ZpbGxlci5vcHRpb25zLmpzJztcbmltcG9ydCB7X2J1aWxkU3RhY2tMaW5lfSBmcm9tICcuL2ZpbGxlci50YXJnZXQuc3RhY2suanMnO1xuaW1wb3J0IHtzaW1wbGVBcmN9IGZyb20gJy4vc2ltcGxlQXJjLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0IH0gU2NhbGVcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9lbGVtZW50cy9lbGVtZW50LnBvaW50LmpzJykuZGVmYXVsdCB9IFBvaW50RWxlbWVudFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0VGFyZ2V0KHNvdXJjZSkge1xuICBjb25zdCB7Y2hhcnQsIGZpbGwsIGxpbmV9ID0gc291cmNlO1xuXG4gIGlmIChpc0Zpbml0ZShmaWxsKSkge1xuICAgIHJldHVybiBnZXRMaW5lQnlJbmRleChjaGFydCwgZmlsbCk7XG4gIH1cblxuICBpZiAoZmlsbCA9PT0gJ3N0YWNrJykge1xuICAgIHJldHVybiBfYnVpbGRTdGFja0xpbmUoc291cmNlKTtcbiAgfVxuXG4gIGlmIChmaWxsID09PSAnc2hhcGUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBib3VuZGFyeSA9IGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpO1xuXG4gIGlmIChib3VuZGFyeSBpbnN0YW5jZW9mIHNpbXBsZUFyYykge1xuICAgIHJldHVybiBib3VuZGFyeTtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQm91bmRhcnlMaW5lKGJvdW5kYXJ5LCBsaW5lKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKi9cbmZ1bmN0aW9uIGdldExpbmVCeUluZGV4KGNoYXJ0LCBpbmRleCkge1xuICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuICBjb25zdCB2aXNpYmxlID0gbWV0YSAmJiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGluZGV4KTtcbiAgcmV0dXJuIHZpc2libGUgPyBtZXRhLmRhdGFzZXQgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHNjYWxlID0gc291cmNlLnNjYWxlIHx8IHt9O1xuXG4gIGlmIChzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUpIHtcbiAgICByZXR1cm4gY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkoc291cmNlKTtcbiAgfVxuICByZXR1cm4gY29tcHV0ZUxpbmVhckJvdW5kYXJ5KHNvdXJjZSk7XG59XG5cblxuZnVuY3Rpb24gY29tcHV0ZUxpbmVhckJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUgPSB7fSwgZmlsbH0gPSBzb3VyY2U7XG4gIGNvbnN0IHBpeGVsID0gX2dldFRhcmdldFBpeGVsKGZpbGwsIHNjYWxlKTtcblxuICBpZiAoaXNGaW5pdGUocGl4ZWwpKSB7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGhvcml6b250YWwgPyBwaXhlbCA6IG51bGwsXG4gICAgICB5OiBob3Jpem9udGFsID8gbnVsbCA6IHBpeGVsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlLCBmaWxsfSA9IHNvdXJjZTtcbiAgY29uc3Qgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnM7XG4gIGNvbnN0IGxlbmd0aCA9IHNjYWxlLmdldExhYmVscygpLmxlbmd0aDtcbiAgY29uc3Qgc3RhcnQgPSBvcHRpb25zLnJldmVyc2UgPyBzY2FsZS5tYXggOiBzY2FsZS5taW47XG4gIGNvbnN0IHZhbHVlID0gX2dldFRhcmdldFZhbHVlKGZpbGwsIHNjYWxlLCBzdGFydCk7XG4gIGNvbnN0IHRhcmdldCA9IFtdO1xuXG4gIGlmIChvcHRpb25zLmdyaWQuY2lyY3VsYXIpIHtcbiAgICBjb25zdCBjZW50ZXIgPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoMCwgc3RhcnQpO1xuICAgIHJldHVybiBuZXcgc2ltcGxlQXJjKHtcbiAgICAgIHg6IGNlbnRlci54LFxuICAgICAgeTogY2VudGVyLnksXG4gICAgICByYWRpdXM6IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKVxuICAgIH0pO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHRhcmdldC5wdXNoKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCB2YWx1ZSkpO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbiIsICJpbXBvcnQge2NsaXBBcmVhLCB1bmNsaXBBcmVhfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X2ZpbmRTZWdtZW50RW5kLCBfZ2V0Qm91bmRzLCBfc2VnbWVudHN9IGZyb20gJy4vZmlsbGVyLnNlZ21lbnQuanMnO1xuaW1wb3J0IHtfZ2V0VGFyZ2V0fSBmcm9tICcuL2ZpbGxlci50YXJnZXQuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gX2RyYXdmaWxsKGN0eCwgc291cmNlLCBhcmVhKSB7XG4gIGNvbnN0IHRhcmdldCA9IF9nZXRUYXJnZXQoc291cmNlKTtcbiAgY29uc3Qge2xpbmUsIHNjYWxlLCBheGlzfSA9IHNvdXJjZTtcbiAgY29uc3QgbGluZU9wdHMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGZpbGxPcHRpb24gPSBsaW5lT3B0cy5maWxsO1xuICBjb25zdCBjb2xvciA9IGxpbmVPcHRzLmJhY2tncm91bmRDb2xvcjtcbiAgY29uc3Qge2Fib3ZlID0gY29sb3IsIGJlbG93ID0gY29sb3J9ID0gZmlsbE9wdGlvbiB8fCB7fTtcbiAgaWYgKHRhcmdldCAmJiBsaW5lLnBvaW50cy5sZW5ndGgpIHtcbiAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgIGRvRmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGFib3ZlLCBiZWxvdywgYXJlYSwgc2NhbGUsIGF4aXN9KTtcbiAgICB1bmNsaXBBcmVhKGN0eCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZG9GaWxsKGN0eCwgY2ZnKSB7XG4gIGNvbnN0IHtsaW5lLCB0YXJnZXQsIGFib3ZlLCBiZWxvdywgYXJlYSwgc2NhbGV9ID0gY2ZnO1xuICBjb25zdCBwcm9wZXJ0eSA9IGxpbmUuX2xvb3AgPyAnYW5nbGUnIDogY2ZnLmF4aXM7XG5cbiAgY3R4LnNhdmUoKTtcblxuICBpZiAocHJvcGVydHkgPT09ICd4JyAmJiBiZWxvdyAhPT0gYWJvdmUpIHtcbiAgICBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGFyZWEudG9wKTtcbiAgICBmaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGFib3ZlLCBzY2FsZSwgcHJvcGVydHl9KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBhcmVhLmJvdHRvbSk7XG4gIH1cbiAgZmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGNvbG9yOiBiZWxvdywgc2NhbGUsIHByb3BlcnR5fSk7XG5cbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuZnVuY3Rpb24gY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBjbGlwWSkge1xuICBjb25zdCB7c2VnbWVudHMsIHBvaW50c30gPSB0YXJnZXQ7XG4gIGxldCBmaXJzdCA9IHRydWU7XG4gIGxldCBsaW5lTG9vcCA9IGZhbHNlO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gc2VnbWVudDtcbiAgICBjb25zdCBmaXJzdFBvaW50ID0gcG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBwb2ludHNbX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cyldO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgY3R4Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgY2xpcFkpO1xuICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgfVxuICAgIGxpbmVMb29wID0gISF0YXJnZXQucGF0aFNlZ21lbnQoY3R4LCBzZWdtZW50LCB7bW92ZTogbGluZUxvb3B9KTtcbiAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVUbyhsYXN0UG9pbnQueCwgY2xpcFkpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5saW5lVG8odGFyZ2V0LmZpcnN0KCkueCwgY2xpcFkpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5cbmZ1bmN0aW9uIGZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgcHJvcGVydHksIGNvbG9yLCBzY2FsZX0gPSBjZmc7XG4gIGNvbnN0IHNlZ21lbnRzID0gX3NlZ21lbnRzKGxpbmUsIHRhcmdldCwgcHJvcGVydHkpO1xuXG4gIGZvciAoY29uc3Qge3NvdXJjZTogc3JjLCB0YXJnZXQ6IHRndCwgc3RhcnQsIGVuZH0gb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCB7c3R5bGU6IHtiYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcn0gPSB7fX0gPSBzcmM7XG4gICAgY29uc3Qgbm90U2hhcGUgPSB0YXJnZXQgIT09IHRydWU7XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIG5vdFNoYXBlICYmIF9nZXRCb3VuZHMocHJvcGVydHksIHN0YXJ0LCBlbmQpKTtcblxuICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgIGNvbnN0IGxpbmVMb29wID0gISFsaW5lLnBhdGhTZWdtZW50KGN0eCwgc3JjKTtcblxuICAgIGxldCBsb29wO1xuICAgIGlmIChub3RTaGFwZSkge1xuICAgICAgaWYgKGxpbmVMb29wKSB7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgZW5kLCBwcm9wZXJ0eSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhcmdldExvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHRndCwge21vdmU6IGxpbmVMb29wLCByZXZlcnNlOiB0cnVlfSk7XG4gICAgICBsb29wID0gbGluZUxvb3AgJiYgdGFyZ2V0TG9vcDtcbiAgICAgIGlmICghbG9vcCkge1xuICAgICAgICBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIHN0YXJ0LCBwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKGxvb3AgPyAnZXZlbm9kZCcgOiAnbm9uemVybycpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIGJvdW5kcykge1xuICBjb25zdCB7dG9wLCBib3R0b219ID0gc2NhbGUuY2hhcnQuY2hhcnRBcmVhO1xuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0LCBlbmR9ID0gYm91bmRzIHx8IHt9O1xuICBpZiAocHJvcGVydHkgPT09ICd4Jykge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgucmVjdChzdGFydCwgdG9wLCBlbmQgLSBzdGFydCwgYm90dG9tIC0gdG9wKTtcbiAgICBjdHguY2xpcCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgcG9pbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGludGVycG9sYXRlZFBvaW50ID0gdGFyZ2V0LmludGVycG9sYXRlKHBvaW50LCBwcm9wZXJ0eSk7XG4gIGlmIChpbnRlcnBvbGF0ZWRQb2ludCkge1xuICAgIGN0eC5saW5lVG8oaW50ZXJwb2xhdGVkUG9pbnQueCwgaW50ZXJwb2xhdGVkUG9pbnQueSk7XG4gIH1cbn1cblxuIiwgIi8qKlxuICogUGx1Z2luIGJhc2VkIG9uIGRpc2N1c3Npb24gZnJvbSB0aGUgZm9sbG93aW5nIENoYXJ0LmpzIGlzc3VlczpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzIzODAjaXNzdWVjb21tZW50LTI3OTk2MTU2OVxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjQ0MCNpc3N1ZWNvbW1lbnQtMjU2NDYxODk3XG4gKi9cblxuaW1wb3J0IExpbmVFbGVtZW50IGZyb20gJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQubGluZS5qcyc7XG5pbXBvcnQge19kcmF3ZmlsbH0gZnJvbSAnLi9maWxsZXIuZHJhd2luZy5qcyc7XG5pbXBvcnQge19zaG91bGRBcHBseUZpbGx9IGZyb20gJy4vZmlsbGVyLmhlbHBlci5qcyc7XG5pbXBvcnQge19kZWNvZGVGaWxsLCBfcmVzb2x2ZVRhcmdldH0gZnJvbSAnLi9maWxsZXIub3B0aW9ucy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICdmaWxsZXInLFxuXG4gIGFmdGVyRGF0YXNldHNVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY291bnQgPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoO1xuICAgIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgICBsZXQgbWV0YSwgaSwgbGluZSwgc291cmNlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgICBzb3VyY2UgPSBudWxsO1xuXG4gICAgICBpZiAobGluZSAmJiBsaW5lLm9wdGlvbnMgJiYgbGluZSBpbnN0YW5jZW9mIExpbmVFbGVtZW50KSB7XG4gICAgICAgIHNvdXJjZSA9IHtcbiAgICAgICAgICB2aXNpYmxlOiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIGZpbGw6IF9kZWNvZGVGaWxsKGxpbmUsIGksIGNvdW50KSxcbiAgICAgICAgICBjaGFydCxcbiAgICAgICAgICBheGlzOiBtZXRhLmNvbnRyb2xsZXIub3B0aW9ucy5pbmRleEF4aXMsXG4gICAgICAgICAgc2NhbGU6IG1ldGEudlNjYWxlLFxuICAgICAgICAgIGxpbmUsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG1ldGEuJGZpbGxlciA9IHNvdXJjZTtcbiAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgaWYgKCFzb3VyY2UgfHwgc291cmNlLmZpbGwgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UuZmlsbCA9IF9yZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGksIG9wdGlvbnMucHJvcGFnYXRlKTtcbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkcmF3ID0gb3B0aW9ucy5kcmF3VGltZSA9PT0gJ2JlZm9yZURyYXcnO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZS5saW5lLnVwZGF0ZUNvbnRyb2xQb2ludHMoYXJlYSwgc291cmNlLmF4aXMpO1xuICAgICAgaWYgKGRyYXcgJiYgc291cmNlLmZpbGwpIHtcbiAgICAgICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlRGF0YXNldHNEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldHNEcmF3Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcblxuICAgICAgaWYgKF9zaG91bGRBcHBseUZpbGwoc291cmNlKSkge1xuICAgICAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZURhdGFzZXREcmF3KGNoYXJ0LCBhcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc291cmNlID0gYXJncy5tZXRhLiRmaWxsZXI7XG5cbiAgICBpZiAoIV9zaG91bGRBcHBseUZpbGwoc291cmNlKSB8fCBvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldERyYXcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBjaGFydC5jaGFydEFyZWEpO1xuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgcHJvcGFnYXRlOiB0cnVlLFxuICAgIGRyYXdUaW1lOiAnYmVmb3JlRGF0YXNldERyYXcnXG4gIH1cbn07XG4iLCAiaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2NvcmUvY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQgbGF5b3V0cyBmcm9tICcuLi9jb3JlL2NvcmUubGF5b3V0cy5qcyc7XG5pbXBvcnQge2FkZFJvdW5kZWRSZWN0UGF0aCwgZHJhd1BvaW50TGVnZW5kLCByZW5kZXJUZXh0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7XG4gIF9pc0JldHdlZW4sXG4gIGNhbGxiYWNrIGFzIGNhbGwsXG4gIGNsaXBBcmVhLFxuICBnZXRSdGxBZGFwdGVyLFxuICBvdmVycmlkZVRleHREaXJlY3Rpb24sXG4gIHJlc3RvcmVUZXh0RGlyZWN0aW9uLFxuICB0b0ZvbnQsXG4gIHRvUGFkZGluZyxcbiAgdW5jbGlwQXJlYSxcbiAgdmFsdWVPckRlZmF1bHQsXG59IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfYWxpZ25TdGFydEVuZCwgX3RleHRYLCBfdG9MZWZ0UmlnaHRDZW50ZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuaW1wb3J0IHt0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqL1xuXG5jb25zdCBnZXRCb3hTaXplID0gKGxhYmVsT3B0cywgZm9udFNpemUpID0+IHtcbiAgbGV0IHtib3hIZWlnaHQgPSBmb250U2l6ZSwgYm94V2lkdGggPSBmb250U2l6ZX0gPSBsYWJlbE9wdHM7XG5cbiAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG4gICAgYm94SGVpZ2h0ID0gTWF0aC5taW4oYm94SGVpZ2h0LCBmb250U2l6ZSk7XG4gICAgYm94V2lkdGggPSBsYWJlbE9wdHMucG9pbnRTdHlsZVdpZHRoIHx8IE1hdGgubWluKGJveFdpZHRoLCBmb250U2l6ZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJveFdpZHRoLFxuICAgIGJveEhlaWdodCxcbiAgICBpdGVtSGVpZ2h0OiBNYXRoLm1heChmb250U2l6ZSwgYm94SGVpZ2h0KVxuICB9O1xufTtcblxuY29uc3QgaXRlbXNFcXVhbCA9IChhLCBiKSA9PiBhICE9PSBudWxsICYmIGIgIT09IG51bGwgJiYgYS5kYXRhc2V0SW5kZXggPT09IGIuZGF0YXNldEluZGV4ICYmIGEuaW5kZXggPT09IGIuaW5kZXg7XG5cbmV4cG9ydCBjbGFzcyBMZWdlbmQgZXh0ZW5kcyBFbGVtZW50IHtcblxuICAvKipcblx0ICogQHBhcmFtIHt7IGN0eDogYW55OyBvcHRpb25zOiBhbnk7IGNoYXJ0OiBhbnk7IH19IGNvbmZpZ1xuXHQgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2FkZGVkID0gZmFsc2U7XG5cbiAgICAvLyBDb250YWlucyBoaXQgYm94ZXMgZm9yIGVhY2ggZGF0YXNldCAoaW4gZGF0YXNldCBvcmRlcilcbiAgICB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG5cbiAgICAvKipcbiBcdFx0ICogQHByaXZhdGVcbiBcdFx0ICovXG4gICAgdGhpcy5faG92ZXJlZEl0ZW0gPSBudWxsO1xuXG4gICAgLy8gQXJlIHdlIGluIGRvdWdobnV0IG1vZGUgd2hpY2ggaGFzIGEgZGlmZmVyZW50IGRhdGEgdHlwZVxuICAgIHRoaXMuZG91Z2hudXRNb2RlID0gZmFsc2U7XG5cbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29sdW1uU2l6ZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5saW5lV2lkdGhzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4V2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mdWxsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgIHRoaXMuX21hcmdpbnMgPSBtYXJnaW5zO1xuXG4gICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5idWlsZExhYmVscygpO1xuICAgIHRoaXMuZml0KCk7XG4gIH1cblxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIHRoaXMubGVmdCA9IHRoaXMuX21hcmdpbnMubGVmdDtcbiAgICAgIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgdGhpcy50b3AgPSB0aGlzLl9tYXJnaW5zLnRvcDtcbiAgICAgIHRoaXMuYm90dG9tID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuICB9XG5cbiAgYnVpbGRMYWJlbHMoKSB7XG4gICAgY29uc3QgbGFiZWxPcHRzID0gdGhpcy5vcHRpb25zLmxhYmVscyB8fCB7fTtcbiAgICBsZXQgbGVnZW5kSXRlbXMgPSBjYWxsKGxhYmVsT3B0cy5nZW5lcmF0ZUxhYmVscywgW3RoaXMuY2hhcnRdLCB0aGlzKSB8fCBbXTtcblxuICAgIGlmIChsYWJlbE9wdHMuZmlsdGVyKSB7XG4gICAgICBsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gbGFiZWxPcHRzLmZpbHRlcihpdGVtLCB0aGlzLmNoYXJ0LmRhdGEpKTtcbiAgICB9XG5cbiAgICBpZiAobGFiZWxPcHRzLnNvcnQpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuc29ydCgoYSwgYikgPT4gbGFiZWxPcHRzLnNvcnQoYSwgYiwgdGhpcy5jaGFydC5kYXRhKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICBsZWdlbmRJdGVtcy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5sZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zO1xuICB9XG5cbiAgZml0KCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCBjdHh9ID0gdGhpcztcblxuICAgIC8vIFRoZSBsZWdlbmQgbWF5IG5vdCBiZSBkaXNwbGF5ZWQgZm9yIGEgdmFyaWV0eSBvZiByZWFzb25zIGluY2x1ZGluZ1xuICAgIC8vIHRoZSBmYWN0IHRoYXQgdGhlIGRlZmF1bHRzIGdvdCBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyBXaGVuIHRoZSBsZWdlbmQgaXMgbm90IGRpc3BsYXllZCwgdGhlcmUgYXJlIG5vIGd1YXJhbnRlZXMgdGhhdCB0aGUgb3B0aW9uc1xuICAgIC8vIGFyZSBjb3JyZWN0bHkgZm9ybWF0dGVkIHNvIHdlIG5lZWQgdG8gYmFpbCBvdXQgYXMgZWFybHkgYXMgcG9zc2libGUuXG4gICAgaWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxPcHRzID0gb3B0aW9ucy5sYWJlbHM7XG4gICAgY29uc3QgbGFiZWxGb250ID0gdG9Gb250KGxhYmVsT3B0cy5mb250KTtcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2JveFdpZHRoLCBpdGVtSGVpZ2h0fSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcblxuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB3aWR0aCA9IHRoaXMubWF4V2lkdGg7IC8vIGZpbGwgYWxsIHRoZSB3aWR0aFxuICAgICAgaGVpZ2h0ID0gdGhpcy5fZml0Um93cyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSArIDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSB0aGlzLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuICAgICAgd2lkdGggPSB0aGlzLl9maXRDb2xzKHRpdGxlSGVpZ2h0LCBsYWJlbEZvbnQsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSArIDEwO1xuICAgIH1cblxuICAgIHRoaXMud2lkdGggPSBNYXRoLm1pbih3aWR0aCwgb3B0aW9ucy5tYXhXaWR0aCB8fCB0aGlzLm1heFdpZHRoKTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWluKGhlaWdodCwgb3B0aW9ucy5tYXhIZWlnaHQgfHwgdGhpcy5tYXhIZWlnaHQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZml0Um93cyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSB7XG4gICAgY29uc3Qge2N0eCwgbWF4V2lkdGgsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gdGhpcztcbiAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICAvLyBXaWR0aCBvZiBlYWNoIGxpbmUgb2YgbGVnZW5kIGJveGVzLiBMYWJlbHMgd3JhcCBvbnRvIG11bHRpcGxlIGxpbmVzIHdoZW4gdGhlcmUgYXJlIHRvbyBtYW55IHRvIGZpdCBvbiBvbmVcbiAgICBjb25zdCBsaW5lV2lkdGhzID0gdGhpcy5saW5lV2lkdGhzID0gWzBdO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICBsZXQgdG90YWxIZWlnaHQgPSB0aXRsZUhlaWdodDtcblxuICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgbGV0IHJvdyA9IC0xO1xuICAgIGxldCB0b3AgPSAtbGluZUhlaWdodDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1XaWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcblxuICAgICAgaWYgKGkgPT09IDAgfHwgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICsgaXRlbVdpZHRoICsgMiAqIHBhZGRpbmcgPiBtYXhXaWR0aCkge1xuICAgICAgICB0b3RhbEhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gKGkgPiAwID8gMCA6IDEpXSA9IDA7XG4gICAgICAgIHRvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICByb3crKztcbiAgICAgIH1cblxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdDogMCwgdG9wLCByb3csIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG5cbiAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArPSBpdGVtV2lkdGggKyBwYWRkaW5nO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRvdGFsSGVpZ2h0O1xuICB9XG5cbiAgX2ZpdENvbHModGl0bGVIZWlnaHQsIGxhYmVsRm9udCwgYm94V2lkdGgsIF9pdGVtSGVpZ2h0KSB7XG4gICAgY29uc3Qge2N0eCwgbWF4SGVpZ2h0LCBvcHRpb25zOiB7bGFiZWxzOiB7cGFkZGluZ319fSA9IHRoaXM7XG4gICAgY29uc3QgaGl0Ym94ZXMgPSB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG4gICAgY29uc3QgY29sdW1uU2l6ZXMgPSB0aGlzLmNvbHVtblNpemVzID0gW107XG4gICAgY29uc3QgaGVpZ2h0TGltaXQgPSBtYXhIZWlnaHQgLSB0aXRsZUhlaWdodDtcblxuICAgIGxldCB0b3RhbFdpZHRoID0gcGFkZGluZztcbiAgICBsZXQgY3VycmVudENvbFdpZHRoID0gMDtcbiAgICBsZXQgY3VycmVudENvbEhlaWdodCA9IDA7XG5cbiAgICBsZXQgbGVmdCA9IDA7XG4gICAgbGV0IGNvbCA9IDA7XG5cbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IHtpdGVtV2lkdGgsIGl0ZW1IZWlnaHR9ID0gY2FsY3VsYXRlSXRlbVNpemUoYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4LCBsZWdlbmRJdGVtLCBfaXRlbUhlaWdodCk7XG5cbiAgICAgIC8vIElmIHRvbyB0YWxsLCBnbyB0byBuZXcgY29sdW1uXG4gICAgICBpZiAoaSA+IDAgJiYgY3VycmVudENvbEhlaWdodCArIGl0ZW1IZWlnaHQgKyAyICogcGFkZGluZyA+IGhlaWdodExpbWl0KSB7XG4gICAgICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sdW1uU2l6ZXMucHVzaCh7d2lkdGg6IGN1cnJlbnRDb2xXaWR0aCwgaGVpZ2h0OiBjdXJyZW50Q29sSGVpZ2h0fSk7IC8vIHByZXZpb3VzIGNvbHVtbiBzaXplXG4gICAgICAgIGxlZnQgKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sKys7XG4gICAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBTdG9yZSB0aGUgaGl0Ym94IHdpZHRoIGFuZCBoZWlnaHQgaGVyZS4gRmluYWwgcG9zaXRpb24gd2lsbCBiZSB1cGRhdGVkIGluIGBkcmF3YFxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdCwgdG9wOiBjdXJyZW50Q29sSGVpZ2h0LCBjb2wsIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG5cbiAgICAgIC8vIEdldCBtYXggd2lkdGhcbiAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IE1hdGgubWF4KGN1cnJlbnRDb2xXaWR0aCwgaXRlbVdpZHRoKTtcbiAgICAgIGN1cnJlbnRDb2xIZWlnaHQgKz0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgfSk7XG5cbiAgICB0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aDtcbiAgICBjb2x1bW5TaXplcy5wdXNoKHt3aWR0aDogY3VycmVudENvbFdpZHRoLCBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHR9KTsgLy8gcHJldmlvdXMgY29sdW1uIHNpemVcblxuICAgIHJldHVybiB0b3RhbFdpZHRoO1xuICB9XG5cbiAgYWRqdXN0SGl0Qm94ZXMoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGNvbnN0IHtsZWdlbmRIaXRCb3hlczogaGl0Ym94ZXMsIG9wdGlvbnM6IHthbGlnbiwgbGFiZWxzOiB7cGFkZGluZ30sIHJ0bH19ID0gdGhpcztcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKHJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgbGV0IHJvdyA9IDA7XG4gICAgICBsZXQgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gdGhpcy5saW5lV2lkdGhzW3Jvd10pO1xuICAgICAgZm9yIChjb25zdCBoaXRib3ggb2YgaGl0Ym94ZXMpIHtcbiAgICAgICAgaWYgKHJvdyAhPT0gaGl0Ym94LnJvdykge1xuICAgICAgICAgIHJvdyA9IGhpdGJveC5yb3c7XG4gICAgICAgICAgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gdGhpcy5saW5lV2lkdGhzW3Jvd10pO1xuICAgICAgICB9XG4gICAgICAgIGhpdGJveC50b3AgKz0gdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmc7XG4gICAgICAgIGhpdGJveC5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLngobGVmdCksIGhpdGJveC53aWR0aCk7XG4gICAgICAgIGxlZnQgKz0gaGl0Ym94LndpZHRoICsgcGFkZGluZztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNvbCA9IDA7XG4gICAgICBsZXQgdG9wID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIHRoaXMuY29sdW1uU2l6ZXNbY29sXS5oZWlnaHQpO1xuICAgICAgZm9yIChjb25zdCBoaXRib3ggb2YgaGl0Ym94ZXMpIHtcbiAgICAgICAgaWYgKGhpdGJveC5jb2wgIT09IGNvbCkge1xuICAgICAgICAgIGNvbCA9IGhpdGJveC5jb2w7XG4gICAgICAgICAgdG9wID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIHRoaXMuY29sdW1uU2l6ZXNbY29sXS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGhpdGJveC50b3AgPSB0b3A7XG4gICAgICAgIGhpdGJveC5sZWZ0ICs9IHRoaXMubGVmdCArIHBhZGRpbmc7XG4gICAgICAgIGhpdGJveC5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLngoaGl0Ym94LmxlZnQpLCBoaXRib3gud2lkdGgpO1xuICAgICAgICB0b3AgKz0gaGl0Ym94LmhlaWdodCArIHBhZGRpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICd0b3AnIHx8IHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjbGlwQXJlYShjdHgsIHRoaXMpO1xuXG4gICAgICB0aGlzLl9kcmF3KCk7XG5cbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3KCkge1xuICAgIGNvbnN0IHtvcHRpb25zOiBvcHRzLCBjb2x1bW5TaXplcywgbGluZVdpZHRocywgY3R4fSA9IHRoaXM7XG4gICAgY29uc3Qge2FsaWduLCBsYWJlbHM6IGxhYmVsT3B0c30gPSBvcHRzO1xuICAgIGNvbnN0IGRlZmF1bHRDb2xvciA9IGRlZmF1bHRzLmNvbG9yO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgbGFiZWxGb250ID0gdG9Gb250KGxhYmVsT3B0cy5mb250KTtcbiAgICBjb25zdCB7cGFkZGluZ30gPSBsYWJlbE9wdHM7XG4gICAgY29uc3QgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcbiAgICBjb25zdCBoYWxmRm9udFNpemUgPSBmb250U2l6ZSAvIDI7XG4gICAgbGV0IGN1cnNvcjtcblxuICAgIHRoaXMuZHJhd1RpdGxlKCk7XG5cbiAgICAvLyBDYW52YXMgc2V0dXBcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbignbGVmdCcpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHgubGluZVdpZHRoID0gMC41O1xuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcblxuICAgIGNvbnN0IHtib3hXaWR0aCwgYm94SGVpZ2h0LCBpdGVtSGVpZ2h0fSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cbiAgICAvLyBjdXJyZW50IHBvc2l0aW9uXG4gICAgY29uc3QgZHJhd0xlZ2VuZEJveCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0pIHtcbiAgICAgIGlmIChpc05hTihib3hXaWR0aCkgfHwgYm94V2lkdGggPD0gMCB8fCBpc05hTihib3hIZWlnaHQpIHx8IGJveEhlaWdodCA8IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGhlIGN0eCBmb3IgdGhlIGJveFxuICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgY29uc3QgbGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lV2lkdGgsIDEpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uZmlsbFN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuICAgICAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVDYXAsICdidXR0Jyk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoT2Zmc2V0LCAwKTtcbiAgICAgIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUpvaW4sICdtaXRlcicpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uc3Ryb2tlU3R5bGUsIGRlZmF1bHRDb2xvcik7XG5cbiAgICAgIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoLCBbXSkpO1xuXG4gICAgICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgICAgLy8gUmVjYWxjdWxhdGUgeCBhbmQgeSBmb3IgZHJhd1BvaW50KCkgYmVjYXVzZSBpdHMgZXhwZWN0aW5nXG4gICAgICAgIC8vIHggYW5kIHkgdG8gYmUgY2VudGVyIG9mIGZpZ3VyZSAoaW5zdGVhZCBvZiB0b3AgbGVmdClcbiAgICAgICAgY29uc3QgZHJhd09wdGlvbnMgPSB7XG4gICAgICAgICAgcmFkaXVzOiBib3hIZWlnaHQgKiBNYXRoLlNRUlQyIC8gMixcbiAgICAgICAgICBwb2ludFN0eWxlOiBsZWdlbmRJdGVtLnBvaW50U3R5bGUsXG4gICAgICAgICAgcm90YXRpb246IGxlZ2VuZEl0ZW0ucm90YXRpb24sXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IGxpbmVXaWR0aFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLnhQbHVzKHgsIGJveFdpZHRoIC8gMik7XG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSB5ICsgaGFsZkZvbnRTaXplO1xuXG4gICAgICAgIC8vIERyYXcgcG9pbnRTdHlsZSBhcyBsZWdlbmQgc3ltYm9sXG4gICAgICAgIGRyYXdQb2ludExlZ2VuZChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZLCBsYWJlbE9wdHMucG9pbnRTdHlsZVdpZHRoICYmIGJveFdpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERyYXcgYm94IGFzIGxlZ2VuZCBzeW1ib2xcbiAgICAgICAgLy8gQWRqdXN0IHBvc2l0aW9uIHdoZW4gYm94SGVpZ2h0IDwgZm9udFNpemUgKHdhbnQgaXQgY2VudGVyZWQpXG4gICAgICAgIGNvbnN0IHlCb3hUb3AgPSB5ICsgTWF0aC5tYXgoKGZvbnRTaXplIC0gYm94SGVpZ2h0KSAvIDIsIDApO1xuICAgICAgICBjb25zdCB4Qm94TGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHgsIGJveFdpZHRoKTtcbiAgICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsZWdlbmRJdGVtLmJvcmRlclJhZGl1cyk7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgICAgeDogeEJveExlZnQsXG4gICAgICAgICAgICB5OiB5Qm94VG9wLFxuICAgICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgucmVjdCh4Qm94TGVmdCwgeUJveFRvcCwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBpZiAobGluZVdpZHRoICE9PSAwKSB7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGZpbGxUZXh0ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgcmVuZGVyVGV4dChjdHgsIGxlZ2VuZEl0ZW0udGV4dCwgeCwgeSArIChpdGVtSGVpZ2h0IC8gMiksIGxhYmVsRm9udCwge1xuICAgICAgICBzdHJpa2V0aHJvdWdoOiBsZWdlbmRJdGVtLmhpZGRlbixcbiAgICAgICAgdGV4dEFsaWduOiBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduKVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEhvcml6b250YWxcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgY3Vyc29yID0ge1xuICAgICAgICB4OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbMF0pLFxuICAgICAgICB5OiB0aGlzLnRvcCArIHBhZGRpbmcgKyB0aXRsZUhlaWdodCxcbiAgICAgICAgbGluZTogMFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3Vyc29yID0ge1xuICAgICAgICB4OiB0aGlzLmxlZnQgKyBwYWRkaW5nLFxuICAgICAgICB5OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbMF0uaGVpZ2h0KSxcbiAgICAgICAgbGluZTogMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBvdmVycmlkZVRleHREaXJlY3Rpb24odGhpcy5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XG5cbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvcjsgLy8gZm9yIHN0cmlrZXRocm91Z2ggZWZmZWN0XG4gICAgICBjdHguZmlsbFN0eWxlID0gbGVnZW5kSXRlbS5mb250Q29sb3I7IC8vIHJlbmRlciBpbiBjb3JyZWN0IGNvbG91clxuXG4gICAgICBjb25zdCB0ZXh0V2lkdGggPSBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcbiAgICAgIGNvbnN0IHRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24gfHwgKGxlZ2VuZEl0ZW0udGV4dEFsaWduID0gbGFiZWxPcHRzLnRleHRBbGlnbikpO1xuICAgICAgY29uc3Qgd2lkdGggPSBib3hXaWR0aCArIGhhbGZGb250U2l6ZSArIHRleHRXaWR0aDtcbiAgICAgIGxldCB4ID0gY3Vyc29yLng7XG4gICAgICBsZXQgeSA9IGN1cnNvci55O1xuXG4gICAgICBydGxIZWxwZXIuc2V0V2lkdGgodGhpcy53aWR0aCk7XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgaWYgKGkgPiAwICYmIHggKyB3aWR0aCArIHBhZGRpbmcgPiB0aGlzLnJpZ2h0KSB7XG4gICAgICAgICAgeSA9IGN1cnNvci55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgY3Vyc29yLmxpbmUrKztcbiAgICAgICAgICB4ID0gY3Vyc29yLnggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbY3Vyc29yLmxpbmVdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpID4gMCAmJiB5ICsgbGluZUhlaWdodCA+IHRoaXMuYm90dG9tKSB7XG4gICAgICAgIHggPSBjdXJzb3IueCA9IHggKyBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0ud2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICB5ID0gY3Vyc29yLnkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbY3Vyc29yLmxpbmVdLmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlYWxYID0gcnRsSGVscGVyLngoeCk7XG5cbiAgICAgIGRyYXdMZWdlbmRCb3gocmVhbFgsIHksIGxlZ2VuZEl0ZW0pO1xuXG4gICAgICB4ID0gX3RleHRYKHRleHRBbGlnbiwgeCArIGJveFdpZHRoICsgaGFsZkZvbnRTaXplLCBpc0hvcml6b250YWwgPyB4ICsgd2lkdGggOiB0aGlzLnJpZ2h0LCBvcHRzLnJ0bCk7XG5cbiAgICAgIC8vIEZpbGwgdGhlIGFjdHVhbCBsYWJlbFxuICAgICAgZmlsbFRleHQocnRsSGVscGVyLngoeCksIHksIGxlZ2VuZEl0ZW0pO1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIGN1cnNvci54ICs9IHdpZHRoICsgcGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxlZ2VuZEl0ZW0udGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgZm9udExpbmVIZWlnaHQgPSBsYWJlbEZvbnQubGluZUhlaWdodDtcbiAgICAgICAgY3Vyc29yLnkgKz0gY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodChsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCkgKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlc3RvcmVUZXh0RGlyZWN0aW9uKHRoaXMuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdUaXRsZSgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpdGxlT3B0cyA9IG9wdHMudGl0bGU7XG4gICAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KHRpdGxlT3B0cy5mb250KTtcbiAgICBjb25zdCB0aXRsZVBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGVPcHRzLnBhZGRpbmcpO1xuXG4gICAgaWYgKCF0aXRsZU9wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aXRsZU9wdHMucG9zaXRpb247XG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gdGl0bGVGb250LnNpemUgLyAyO1xuICAgIGNvbnN0IHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplID0gdGl0bGVQYWRkaW5nLnRvcCArIGhhbGZGb250U2l6ZTtcbiAgICBsZXQgeTtcblxuICAgIC8vIFRoZXNlIGRlZmF1bHRzIGFyZSB1c2VkIHdoZW4gdGhlIGxlZ2VuZCBpcyB2ZXJ0aWNhbC5cbiAgICAvLyBXaGVuIGhvcml6b250YWwsIHRoZXkgYXJlIGNvbXB1dGVkIGJlbG93LlxuICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0O1xuICAgIGxldCBtYXhXaWR0aCA9IHRoaXMud2lkdGg7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgLy8gTW92ZSBsZWZ0IC8gcmlnaHQgc28gdGhhdCB0aGUgdGl0bGUgaXMgYWJvdmUgdGhlIGxlZ2VuZCBsaW5lc1xuICAgICAgbWF4V2lkdGggPSBNYXRoLm1heCguLi50aGlzLmxpbmVXaWR0aHMpO1xuICAgICAgeSA9IHRoaXMudG9wICsgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemU7XG4gICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQob3B0cy5hbGlnbiwgbGVmdCwgdGhpcy5yaWdodCAtIG1heFdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92ZSBkb3duIHNvIHRoYXQgdGhlIHRpdGxlIGlzIGFib3ZlIHRoZSBsZWdlbmQgc3RhY2sgaW4gZXZlcnkgYWxpZ25tZW50XG4gICAgICBjb25zdCBtYXhIZWlnaHQgPSB0aGlzLmNvbHVtblNpemVzLnJlZHVjZSgoYWNjLCBzaXplKSA9PiBNYXRoLm1heChhY2MsIHNpemUuaGVpZ2h0KSwgMCk7XG4gICAgICB5ID0gdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgKyBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCB0aGlzLnRvcCwgdGhpcy5ib3R0b20gLSBtYXhIZWlnaHQgLSBvcHRzLmxhYmVscy5wYWRkaW5nIC0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCkpO1xuICAgIH1cblxuICAgIC8vIE5vdyB0aGF0IHdlIGtub3cgdGhlIGxlZnQgZWRnZSBvZiB0aGUgaW5uZXIgbGVnZW5kIGJveCwgY29tcHV0ZSB0aGUgY29ycmVjdFxuICAgIC8vIFggY29vcmRpbmF0ZSBmcm9tIHRoZSB0aXRsZSBhbGlnbm1lbnRcbiAgICBjb25zdCB4ID0gX2FsaWduU3RhcnRFbmQocG9zaXRpb24sIGxlZnQsIGxlZnQgKyBtYXhXaWR0aCk7XG5cbiAgICAvLyBDYW52YXMgc2V0dXBcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihfdG9MZWZ0UmlnaHRDZW50ZXIocG9zaXRpb24pKTtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGl0bGVPcHRzLmNvbG9yO1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuXG4gICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlT3B0cy50ZXh0LCB4LCB5LCB0aXRsZUZvbnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZVRpdGxlSGVpZ2h0KCkge1xuICAgIGNvbnN0IHRpdGxlT3B0cyA9IHRoaXMub3B0aW9ucy50aXRsZTtcbiAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG4gICAgcmV0dXJuIHRpdGxlT3B0cy5kaXNwbGF5ID8gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVBhZGRpbmcuaGVpZ2h0IDogMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExlZ2VuZEl0ZW1BdCh4LCB5KSB7XG4gICAgbGV0IGksIGhpdEJveCwgbGg7XG5cbiAgICBpZiAoX2lzQmV0d2Vlbih4LCB0aGlzLmxlZnQsIHRoaXMucmlnaHQpXG4gICAgICAmJiBfaXNCZXR3ZWVuKHksIHRoaXMudG9wLCB0aGlzLmJvdHRvbSkpIHtcbiAgICAgIC8vIFNlZSBpZiB3ZSBhcmUgdG91Y2hpbmcgb25lIG9mIHRoZSBkYXRhc2V0IGJveGVzXG4gICAgICBsaCA9IHRoaXMubGVnZW5kSGl0Qm94ZXM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaGl0Qm94ID0gbGhbaV07XG5cbiAgICAgICAgaWYgKF9pc0JldHdlZW4oeCwgaGl0Qm94LmxlZnQsIGhpdEJveC5sZWZ0ICsgaGl0Qm94LndpZHRoKVxuICAgICAgICAgICYmIF9pc0JldHdlZW4oeSwgaGl0Qm94LnRvcCwgaGl0Qm94LnRvcCArIGhpdEJveC5oZWlnaHQpKSB7XG4gICAgICAgICAgLy8gVG91Y2hpbmcgYW4gZWxlbWVudFxuICAgICAgICAgIHJldHVybiB0aGlzLmxlZ2VuZEl0ZW1zW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcblx0ICogSGFuZGxlIGFuIGV2ZW50XG5cdCAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSAtIFRoZSBldmVudCB0byBoYW5kbGVcblx0ICovXG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghaXNMaXN0ZW5lZChlLnR5cGUsIG9wdHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hhcnQgZXZlbnQgYWxyZWFkeSBoYXMgcmVsYXRpdmUgcG9zaXRpb24gaW4gaXRcbiAgICBjb25zdCBob3ZlcmVkSXRlbSA9IHRoaXMuX2dldExlZ2VuZEl0ZW1BdChlLngsIGUueSk7XG5cbiAgICBpZiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJyB8fCBlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5faG92ZXJlZEl0ZW07XG4gICAgICBjb25zdCBzYW1lSXRlbSA9IGl0ZW1zRXF1YWwocHJldmlvdXMsIGhvdmVyZWRJdGVtKTtcbiAgICAgIGlmIChwcmV2aW91cyAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbChvcHRzLm9uTGVhdmUsIFtlLCBwcmV2aW91cywgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ob3ZlcmVkSXRlbSA9IGhvdmVyZWRJdGVtO1xuXG4gICAgICBpZiAoaG92ZXJlZEl0ZW0gJiYgIXNhbWVJdGVtKSB7XG4gICAgICAgIGNhbGwob3B0cy5vbkhvdmVyLCBbZSwgaG92ZXJlZEl0ZW0sIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhvdmVyZWRJdGVtKSB7XG4gICAgICBjYWxsKG9wdHMub25DbGljaywgW2UsIGhvdmVyZWRJdGVtLCB0aGlzXSwgdGhpcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUl0ZW1TaXplKGJveFdpZHRoLCBsYWJlbEZvbnQsIGN0eCwgbGVnZW5kSXRlbSwgX2l0ZW1IZWlnaHQpIHtcbiAgY29uc3QgaXRlbVdpZHRoID0gY2FsY3VsYXRlSXRlbVdpZHRoKGxlZ2VuZEl0ZW0sIGJveFdpZHRoLCBsYWJlbEZvbnQsIGN0eCk7XG4gIGNvbnN0IGl0ZW1IZWlnaHQgPSBjYWxjdWxhdGVJdGVtSGVpZ2h0KF9pdGVtSGVpZ2h0LCBsZWdlbmRJdGVtLCBsYWJlbEZvbnQubGluZUhlaWdodCk7XG4gIHJldHVybiB7aXRlbVdpZHRoLCBpdGVtSGVpZ2h0fTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlSXRlbVdpZHRoKGxlZ2VuZEl0ZW0sIGJveFdpZHRoLCBsYWJlbEZvbnQsIGN0eCkge1xuICBsZXQgbGVnZW5kSXRlbVRleHQgPSBsZWdlbmRJdGVtLnRleHQ7XG4gIGlmIChsZWdlbmRJdGVtVGV4dCAmJiB0eXBlb2YgbGVnZW5kSXRlbVRleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgbGVnZW5kSXRlbVRleHQgPSBsZWdlbmRJdGVtVGV4dC5yZWR1Y2UoKGEsIGIpID0+IGEubGVuZ3RoID4gYi5sZW5ndGggPyBhIDogYik7XG4gIH1cbiAgcmV0dXJuIGJveFdpZHRoICsgKGxhYmVsRm9udC5zaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbVRleHQpLndpZHRoO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVJdGVtSGVpZ2h0KF9pdGVtSGVpZ2h0LCBsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCkge1xuICBsZXQgaXRlbUhlaWdodCA9IF9pdGVtSGVpZ2h0O1xuICBpZiAodHlwZW9mIGxlZ2VuZEl0ZW0udGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICBpdGVtSGVpZ2h0ID0gY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodChsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCk7XG4gIH1cbiAgcmV0dXJuIGl0ZW1IZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUxlZ2VuZEl0ZW1IZWlnaHQobGVnZW5kSXRlbSwgZm9udExpbmVIZWlnaHQpIHtcbiAgY29uc3QgbGFiZWxIZWlnaHQgPSBsZWdlbmRJdGVtLnRleHQgPyBsZWdlbmRJdGVtLnRleHQubGVuZ3RoIDogMDtcbiAgcmV0dXJuIGZvbnRMaW5lSGVpZ2h0ICogbGFiZWxIZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGlzTGlzdGVuZWQodHlwZSwgb3B0cykge1xuICBpZiAoKHR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IHR5cGUgPT09ICdtb3VzZW91dCcpICYmIChvcHRzLm9uSG92ZXIgfHwgb3B0cy5vbkxlYXZlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChvcHRzLm9uQ2xpY2sgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ21vdXNldXAnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ2xlZ2VuZCcsXG5cbiAgLyoqXG5cdCAqIEZvciB0ZXN0c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2VsZW1lbnQ6IExlZ2VuZCxcblxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQgPSBuZXcgTGVnZW5kKHtjdHg6IGNoYXJ0LmN0eCwgb3B0aW9ucywgY2hhcnR9KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBvcHRpb25zKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgbGVnZW5kKTtcbiAgfSxcblxuICBzdG9wKGNoYXJ0KSB7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIGNoYXJ0LmxlZ2VuZCk7XG4gICAgZGVsZXRlIGNoYXJ0LmxlZ2VuZDtcbiAgfSxcblxuICAvLyBEdXJpbmcgdGhlIGJlZm9yZVVwZGF0ZSBzdGVwLCB0aGUgbGF5b3V0IGNvbmZpZ3VyYXRpb24gbmVlZHMgdG8gcnVuXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0IGlmIHRoZSBsZWdlbmQgcG9zaXRpb24gY2hhbmdlcyAodmlhIGFuIG9wdGlvbiB1cGRhdGUpXG4gIC8vIHRoZSBsYXlvdXQgc3lzdGVtIHJlc3BlY3RzIHRoZSBjaGFuZ2UuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNzUyN1xuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIG9wdGlvbnMpO1xuICAgIGxlZ2VuZC5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcblxuICAvLyBUaGUgbGFiZWxzIG5lZWQgdG8gYmUgYnVpbHQgYWZ0ZXIgZGF0YXNldHMgYXJlIHVwZGF0ZWQgdG8gZW5zdXJlIHRoYXQgY29sb3JzXG4gIC8vIGFuZCBvdGhlciBzdHlsaW5nIGFyZSBjb3JyZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzY5NjhcbiAgYWZ0ZXJVcGRhdGUoY2hhcnQpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGVnZW5kLmJ1aWxkTGFiZWxzKCk7XG4gICAgbGVnZW5kLmFkanVzdEhpdEJveGVzKCk7XG4gIH0sXG5cblxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XG4gICAgaWYgKCFhcmdzLnJlcGxheSkge1xuICAgICAgY2hhcnQubGVnZW5kLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQpO1xuICAgIH1cbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICByZXZlcnNlOiBmYWxzZSxcbiAgICB3ZWlnaHQ6IDEwMDAsXG5cbiAgICAvLyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBoYW5kbGVcbiAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgY29uc3QgaW5kZXggPSBsZWdlbmRJdGVtLmRhdGFzZXRJbmRleDtcbiAgICAgIGNvbnN0IGNpID0gbGVnZW5kLmNoYXJ0O1xuICAgICAgaWYgKGNpLmlzRGF0YXNldFZpc2libGUoaW5kZXgpKSB7XG4gICAgICAgIGNpLmhpZGUoaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaS5zaG93KGluZGV4KTtcbiAgICAgICAgbGVnZW5kSXRlbS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb25Ib3ZlcjogbnVsbCxcbiAgICBvbkxlYXZlOiBudWxsLFxuXG4gICAgbGFiZWxzOiB7XG4gICAgICBjb2xvcjogKGN0eCkgPT4gY3R4LmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICBib3hXaWR0aDogNDAsXG4gICAgICBwYWRkaW5nOiAxMCxcbiAgICAgIC8vIEdlbmVyYXRlcyBsYWJlbHMgc2hvd24gaW4gdGhlIGxlZ2VuZFxuICAgICAgLy8gVmFsaWQgcHJvcGVydGllcyB0byByZXR1cm46XG4gICAgICAvLyB0ZXh0IDogdGV4dCB0byBkaXNwbGF5XG4gICAgICAvLyBmaWxsU3R5bGUgOiBmaWxsIG9mIGNvbG91cmVkIGJveFxuICAgICAgLy8gc3Ryb2tlU3R5bGU6IHN0cm9rZSBvZiBjb2xvdXJlZCBib3hcbiAgICAgIC8vIGhpZGRlbiA6IGlmIHRoaXMgbGVnZW5kIGl0ZW0gcmVmZXJzIHRvIGEgaGlkZGVuIGl0ZW1cbiAgICAgIC8vIGxpbmVDYXAgOiBjYXAgc3R5bGUgZm9yIGxpbmVcbiAgICAgIC8vIGxpbmVEYXNoXG4gICAgICAvLyBsaW5lRGFzaE9mZnNldCA6XG4gICAgICAvLyBsaW5lSm9pbiA6XG4gICAgICAvLyBsaW5lV2lkdGggOlxuICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgY29uc3QgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuICAgICAgICBjb25zdCB7bGFiZWxzOiB7dXNlUG9pbnRTdHlsZSwgcG9pbnRTdHlsZSwgdGV4dEFsaWduLCBjb2xvciwgdXNlQm9yZGVyUmFkaXVzLCBib3JkZXJSYWRpdXN9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuXG4gICAgICAgIHJldHVybiBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKCkubWFwKChtZXRhKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodXNlUG9pbnRTdHlsZSA/IDAgOiB1bmRlZmluZWQpO1xuICAgICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gdG9QYWRkaW5nKHN0eWxlLmJvcmRlcldpZHRoKTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBkYXRhc2V0c1ttZXRhLmluZGV4XS5sYWJlbCxcbiAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZm9udENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIGhpZGRlbjogIW1ldGEudmlzaWJsZSxcbiAgICAgICAgICAgIGxpbmVDYXA6IHN0eWxlLmJvcmRlckNhcFN0eWxlLFxuICAgICAgICAgICAgbGluZURhc2g6IHN0eWxlLmJvcmRlckRhc2gsXG4gICAgICAgICAgICBsaW5lRGFzaE9mZnNldDogc3R5bGUuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgICAgIGxpbmVKb2luOiBzdHlsZS5ib3JkZXJKb2luU3R5bGUsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IChib3JkZXJXaWR0aC53aWR0aCArIGJvcmRlcldpZHRoLmhlaWdodCkgLyA0LFxuICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSB8fCBzdHlsZS5wb2ludFN0eWxlLFxuICAgICAgICAgICAgcm90YXRpb246IHN0eWxlLnJvdGF0aW9uLFxuICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24gfHwgc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiB1c2VCb3JkZXJSYWRpdXMgJiYgKGJvcmRlclJhZGl1cyB8fCBzdHlsZS5ib3JkZXJSYWRpdXMpLFxuXG4gICAgICAgICAgICAvLyBCZWxvdyBpcyBleHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBkYXRhc2V0c1xuICAgICAgICAgICAgZGF0YXNldEluZGV4OiBtZXRhLmluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHRpdGxlOiB7XG4gICAgICBjb2xvcjogKGN0eCkgPT4gY3R4LmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgIHBvc2l0aW9uOiAnY2VudGVyJyxcbiAgICAgIHRleHQ6ICcnLFxuICAgIH1cbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgICBsYWJlbHM6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIVsnZ2VuZXJhdGVMYWJlbHMnLCAnZmlsdGVyJywgJ3NvcnQnXS5pbmNsdWRlcyhuYW1lKSxcbiAgICB9XG4gIH0sXG59O1xuIiwgImltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCBsYXlvdXRzIGZyb20gJy4uL2NvcmUvY29yZS5sYXlvdXRzLmpzJztcbmltcG9ydCB7UEksIGlzQXJyYXksIHRvUGFkZGluZywgdG9Gb250fSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X3RvTGVmdFJpZ2h0Q2VudGVyLCBfYWxpZ25TdGFydEVuZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5pbXBvcnQge3JlbmRlclRleHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuXG5leHBvcnQgY2xhc3MgVGl0bGUgZXh0ZW5kcyBFbGVtZW50IHtcbiAgLyoqXG5cdCAqIEBwYXJhbSB7eyBjdHg6IGFueTsgb3B0aW9uczogYW55OyBjaGFydDogYW55OyB9fSBjb25maWdcblx0ICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICB0aGlzLl9wYWRkaW5nID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZ1bGxTaXplID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgdGhpcy5sZWZ0ID0gMDtcbiAgICB0aGlzLnRvcCA9IDA7XG5cbiAgICBpZiAoIW9wdHMuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5yaWdodCA9IHRoaXMuYm90dG9tID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLndpZHRoID0gdGhpcy5yaWdodCA9IG1heFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5ib3R0b20gPSBtYXhIZWlnaHQ7XG5cbiAgICBjb25zdCBsaW5lQ291bnQgPSBpc0FycmF5KG9wdHMudGV4dCkgPyBvcHRzLnRleHQubGVuZ3RoIDogMTtcbiAgICB0aGlzLl9wYWRkaW5nID0gdG9QYWRkaW5nKG9wdHMucGFkZGluZyk7XG4gICAgY29uc3QgdGV4dFNpemUgPSBsaW5lQ291bnQgKiB0b0ZvbnQob3B0cy5mb250KS5saW5lSGVpZ2h0ICsgdGhpcy5fcGFkZGluZy5oZWlnaHQ7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0ZXh0U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHRleHRTaXplO1xuICAgIH1cbiAgfVxuXG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG4gICAgcmV0dXJuIHBvcyA9PT0gJ3RvcCcgfHwgcG9zID09PSAnYm90dG9tJztcbiAgfVxuXG4gIF9kcmF3QXJncyhvZmZzZXQpIHtcbiAgICBjb25zdCB7dG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgYWxpZ24gPSBvcHRpb25zLmFsaWduO1xuICAgIGxldCByb3RhdGlvbiA9IDA7XG4gICAgbGV0IG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aXRsZVggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbGVmdCwgcmlnaHQpO1xuICAgICAgdGl0bGVZID0gdG9wICsgb2Zmc2V0O1xuICAgICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgdGl0bGVYID0gbGVmdCArIG9mZnNldDtcbiAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGJvdHRvbSwgdG9wKTtcbiAgICAgICAgcm90YXRpb24gPSBQSSAqIC0wLjU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aXRsZVggPSByaWdodCAtIG9mZnNldDtcbiAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRvcCwgYm90dG9tKTtcbiAgICAgICAgcm90YXRpb24gPSBQSSAqIDAuNTtcbiAgICAgIH1cbiAgICAgIG1heFdpZHRoID0gYm90dG9tIC0gdG9wO1xuICAgIH1cbiAgICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xuICB9XG5cbiAgZHJhdygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKCFvcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBmb250T3B0cyA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBmb250T3B0cy5saW5lSGVpZ2h0O1xuICAgIGNvbnN0IG9mZnNldCA9IGxpbmVIZWlnaHQgLyAyICsgdGhpcy5fcGFkZGluZy50b3A7XG4gICAgY29uc3Qge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259ID0gdGhpcy5fZHJhd0FyZ3Mob2Zmc2V0KTtcblxuICAgIHJlbmRlclRleHQoY3R4LCBvcHRzLnRleHQsIDAsIDAsIGZvbnRPcHRzLCB7XG4gICAgICBjb2xvcjogb3B0cy5jb2xvcixcbiAgICAgIG1heFdpZHRoLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ246IF90b0xlZnRSaWdodENlbnRlcihvcHRzLmFsaWduKSxcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICB0cmFuc2xhdGlvbjogW3RpdGxlWCwgdGl0bGVZXSxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUaXRsZShjaGFydCwgdGl0bGVPcHRzKSB7XG4gIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICBjdHg6IGNoYXJ0LmN0eCxcbiAgICBvcHRpb25zOiB0aXRsZU9wdHMsXG4gICAgY2hhcnRcbiAgfSk7XG5cbiAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCB0aXRsZU9wdHMpO1xuICBsYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuICBjaGFydC50aXRsZUJsb2NrID0gdGl0bGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICd0aXRsZScsXG5cbiAgLyoqXG5cdCAqIEZvciB0ZXN0c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2VsZW1lbnQ6IFRpdGxlLFxuXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNyZWF0ZVRpdGxlKGNoYXJ0LCBvcHRpb25zKTtcbiAgfSxcblxuICBzdG9wKGNoYXJ0KSB7XG4gICAgY29uc3QgdGl0bGVCbG9jayA9IGNoYXJ0LnRpdGxlQmxvY2s7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIHRpdGxlQmxvY2spO1xuICAgIGRlbGV0ZSBjaGFydC50aXRsZUJsb2NrO1xuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IGNoYXJ0LnRpdGxlQmxvY2s7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICB0aXRsZS5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHBhZGRpbmc6IDEwLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICB0ZXh0OiAnJyxcbiAgICB3ZWlnaHQ6IDIwMDAgICAgICAgICAvLyBieSBkZWZhdWx0IGdyZWF0ZXIgdGhhbiBsZWdlbmQgKDEwMDApIHRvIGJlIGFib3ZlXG4gIH0sXG5cbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiAnY29sb3InXG4gIH0sXG5cbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfSxcbn07XG4iLCAiaW1wb3J0IHtUaXRsZX0gZnJvbSAnLi9wbHVnaW4udGl0bGUuanMnO1xuaW1wb3J0IGxheW91dHMgZnJvbSAnLi4vY29yZS9jb3JlLmxheW91dHMuanMnO1xuXG5jb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnc3VidGl0bGUnLFxuXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICAgIGN0eDogY2hhcnQuY3R4LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGNoYXJ0XG4gICAgfSk7XG5cbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gICAgbWFwLnNldChjaGFydCwgdGl0bGUpO1xuICB9LFxuXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgbWFwLmdldChjaGFydCkpO1xuICAgIG1hcC5kZWxldGUoY2hhcnQpO1xuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IG1hcC5nZXQoY2hhcnQpO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgZm9udDoge1xuICAgICAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgICB9LFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIHRleHQ6ICcnLFxuICAgIHdlaWdodDogMTUwMCAgICAgICAgIC8vIGJ5IGRlZmF1bHQgZ3JlYXRlciB0aGFuIGxlZ2VuZCAoMTAwMCkgYW5kIHNtYWxsZXIgdGhhbiB0aXRsZSAoMjAwMClcbiAgfSxcblxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgY29sb3I6ICdjb2xvcidcbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcbiIsICJpbXBvcnQgQW5pbWF0aW9ucyBmcm9tICcuLi9jb3JlL2NvcmUuYW5pbWF0aW9ucy5qcyc7XG5pbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge2FkZFJvdW5kZWRSZWN0UGF0aH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge2VhY2gsIG5vb3AsIGlzTnVsbE9yVW5kZWYsIGlzQXJyYXksIF9lbGVtZW50c0VxdWFsLCBpc09iamVjdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b0ZvbnQsIHRvUGFkZGluZywgdG9UUkJMQ29ybmVyc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtnZXRSdGxBZGFwdGVyLCBvdmVycmlkZVRleHREaXJlY3Rpb24sIHJlc3RvcmVUZXh0RGlyZWN0aW9ufSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMucnRsLmpzJztcbmltcG9ydCB7ZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCBkcmF3UG9pbnR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9wbGF0Zm9ybS9wbGF0Zm9ybS5iYXNlLmpzJykuQ2hhcnQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkFjdGl2ZUVsZW1lbnQgfSBBY3RpdmVFbGVtZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmludGVyYWN0aW9uLmpzJykuSW50ZXJhY3Rpb25JdGVtIH0gSW50ZXJhY3Rpb25JdGVtXG4gKi9cblxuY29uc3QgcG9zaXRpb25lcnMgPSB7XG4gIC8qKlxuXHQgKiBBdmVyYWdlIG1vZGUgcGxhY2VzIHRoZSB0b29sdGlwIGF0IHRoZSBhdmVyYWdlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50cyBzaG93blxuXHQgKi9cbiAgYXZlcmFnZShpdGVtcykge1xuICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGksIGxlbjtcbiAgICBsZXQgeFNldCA9IG5ldyBTZXQoKTtcbiAgICBsZXQgeSA9IDA7XG4gICAgbGV0IGNvdW50ID0gMDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBwb3MgPSBlbC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgICAgeFNldC5hZGQocG9zLngpO1xuICAgICAgICB5ICs9IHBvcy55O1xuICAgICAgICArK2NvdW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHhBdmVyYWdlID0gWy4uLnhTZXRdLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8geFNldC5zaXplO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHhBdmVyYWdlLFxuICAgICAgeTogeSAvIGNvdW50XG4gICAgfTtcbiAgfSxcblxuICAvKipcblx0ICogR2V0cyB0aGUgdG9vbHRpcCBwb3NpdGlvbiBuZWFyZXN0IG9mIHRoZSBpdGVtIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uXG5cdCAqL1xuICBuZWFyZXN0KGl0ZW1zLCBldmVudFBvc2l0aW9uKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgeCA9IGV2ZW50UG9zaXRpb24ueDtcbiAgICBsZXQgeSA9IGV2ZW50UG9zaXRpb24ueTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IGksIGxlbiwgbmVhcmVzdEVsZW1lbnQ7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3QgZWwgPSBpdGVtc1tpXS5lbGVtZW50O1xuICAgICAgaWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gZWwuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgICAgY29uc3QgZCA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhldmVudFBvc2l0aW9uLCBjZW50ZXIpO1xuXG4gICAgICAgIGlmIChkIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICBtaW5EaXN0YW5jZSA9IGQ7XG4gICAgICAgICAgbmVhcmVzdEVsZW1lbnQgPSBlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZWFyZXN0RWxlbWVudCkge1xuICAgICAgY29uc3QgdHAgPSBuZWFyZXN0RWxlbWVudC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgIHggPSB0cC54O1xuICAgICAgeSA9IHRwLnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfVxufTtcblxuLy8gSGVscGVyIHRvIHB1c2ggb3IgY29uY2F0IGJhc2VkIG9uIGlmIHRoZSAybmQgcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9yIG5vdFxuZnVuY3Rpb24gcHVzaE9yQ29uY2F0KGJhc2UsIHRvUHVzaCkge1xuICBpZiAodG9QdXNoKSB7XG4gICAgaWYgKGlzQXJyYXkodG9QdXNoKSkge1xuICAgICAgLy8gYmFzZSA9IGJhc2UuY29uY2F0KHRvUHVzaCk7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShiYXNlLCB0b1B1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlLnB1c2godG9QdXNoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFycmF5IG9mIHN0cmluZ3Mgc3BsaXQgYnkgbmV3bGluZVxuICogQHBhcmFtIHsqfSBzdHIgLSBUaGUgdmFsdWUgdG8gc3BsaXQgYnkgbmV3bGluZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3RyaW5nW119IHZhbHVlIGlmIG5ld2xpbmUgcHJlc2VudCAtIFJldHVybmVkIGZyb20gU3RyaW5nIHNwbGl0KCkgbWV0aG9kXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gc3BsaXROZXdsaW5lcyhzdHIpIHtcbiAgaWYgKCh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpICYmIHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnXFxuJyk7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuXG4vKipcbiAqIFByaXZhdGUgaGVscGVyIHRvIGNyZWF0ZSBhIHRvb2x0aXAgaXRlbSBtb2RlbFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnRcbiAqIEBwYXJhbSB7QWN0aXZlRWxlbWVudH0gaXRlbSAtIHtlbGVtZW50LCBpbmRleCwgZGF0YXNldEluZGV4fSB0byBjcmVhdGUgdGhlIHRvb2x0aXAgaXRlbSBmb3JcbiAqIEByZXR1cm4gbmV3IHRvb2x0aXAgaXRlbVxuICovXG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwSXRlbShjaGFydCwgaXRlbSkge1xuICBjb25zdCB7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0gPSBpdGVtO1xuICBjb25zdCBjb250cm9sbGVyID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuICBjb25zdCB7bGFiZWwsIHZhbHVlfSA9IGNvbnRyb2xsZXIuZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCk7XG5cbiAgcmV0dXJuIHtcbiAgICBjaGFydCxcbiAgICBsYWJlbCxcbiAgICBwYXJzZWQ6IGNvbnRyb2xsZXIuZ2V0UGFyc2VkKGluZGV4KSxcbiAgICByYXc6IGNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSxcbiAgICBmb3JtYXR0ZWRWYWx1ZTogdmFsdWUsXG4gICAgZGF0YXNldDogY29udHJvbGxlci5nZXREYXRhc2V0KCksXG4gICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICBkYXRhc2V0SW5kZXgsXG4gICAgZWxlbWVudFxuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgdG9vbHRpcFxuICovXG5mdW5jdGlvbiBnZXRUb29sdGlwU2l6ZSh0b29sdGlwLCBvcHRpb25zKSB7XG4gIGNvbnN0IGN0eCA9IHRvb2x0aXAuY2hhcnQuY3R4O1xuICBjb25zdCB7Ym9keSwgZm9vdGVyLCB0aXRsZX0gPSB0b29sdGlwO1xuICBjb25zdCB7Ym94V2lkdGgsIGJveEhlaWdodH0gPSBvcHRpb25zO1xuICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgY29uc3QgZm9vdGVyRm9udCA9IHRvRm9udChvcHRpb25zLmZvb3RlckZvbnQpO1xuICBjb25zdCB0aXRsZUxpbmVDb3VudCA9IHRpdGxlLmxlbmd0aDtcbiAgY29uc3QgZm9vdGVyTGluZUNvdW50ID0gZm9vdGVyLmxlbmd0aDtcbiAgY29uc3QgYm9keUxpbmVJdGVtQ291bnQgPSBib2R5Lmxlbmd0aDtcblxuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIGxldCBoZWlnaHQgPSBwYWRkaW5nLmhlaWdodDtcbiAgbGV0IHdpZHRoID0gMDtcblxuICAvLyBDb3VudCBvZiBhbGwgbGluZXMgaW4gdGhlIGJvZHlcbiAgbGV0IGNvbWJpbmVkQm9keUxlbmd0aCA9IGJvZHkucmVkdWNlKChjb3VudCwgYm9keUl0ZW0pID0+IGNvdW50ICsgYm9keUl0ZW0uYmVmb3JlLmxlbmd0aCArIGJvZHlJdGVtLmxpbmVzLmxlbmd0aCArIGJvZHlJdGVtLmFmdGVyLmxlbmd0aCwgMCk7XG4gIGNvbWJpbmVkQm9keUxlbmd0aCArPSB0b29sdGlwLmJlZm9yZUJvZHkubGVuZ3RoICsgdG9vbHRpcC5hZnRlckJvZHkubGVuZ3RoO1xuXG4gIGlmICh0aXRsZUxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCAqIHRpdGxlRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrICh0aXRsZUxpbmVDb3VudCAtIDEpICogb3B0aW9ucy50aXRsZVNwYWNpbmdcblx0XHRcdCsgb3B0aW9ucy50aXRsZU1hcmdpbkJvdHRvbTtcbiAgfVxuICBpZiAoY29tYmluZWRCb2R5TGVuZ3RoKSB7XG4gICAgLy8gQm9keSBsaW5lcyBtYXkgaW5jbHVkZSBzb21lIGV4dHJhIGhlaWdodCBkZXBlbmRpbmcgb24gYm94SGVpZ2h0XG4gICAgY29uc3QgYm9keUxpbmVIZWlnaHQgPSBvcHRpb25zLmRpc3BsYXlDb2xvcnMgPyBNYXRoLm1heChib3hIZWlnaHQsIGJvZHlGb250LmxpbmVIZWlnaHQpIDogYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBoZWlnaHQgKz0gYm9keUxpbmVJdGVtQ291bnQgKiBib2R5TGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gYm9keUxpbmVJdGVtQ291bnQpICogYm9keUZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gMSkgKiBvcHRpb25zLmJvZHlTcGFjaW5nO1xuICB9XG4gIGlmIChmb290ZXJMaW5lQ291bnQpIHtcbiAgICBoZWlnaHQgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3Bcblx0XHRcdCsgZm9vdGVyTGluZUNvdW50ICogZm9vdGVyRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG9wdGlvbnMuZm9vdGVyU3BhY2luZztcbiAgfVxuXG4gIC8vIFRpdGxlIHdpZHRoXG4gIGxldCB3aWR0aFBhZGRpbmcgPSAwO1xuICBjb25zdCBtYXhMaW5lV2lkdGggPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmUpLndpZHRoICsgd2lkdGhQYWRkaW5nKTtcbiAgfTtcblxuICBjdHguc2F2ZSgpO1xuXG4gIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLnRpdGxlLCBtYXhMaW5lV2lkdGgpO1xuXG4gIC8vIEJvZHkgd2lkdGhcbiAgY3R4LmZvbnQgPSBib2R5Rm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5iZWZvcmVCb2R5LmNvbmNhdCh0b29sdGlwLmFmdGVyQm9keSksIG1heExpbmVXaWR0aCk7XG5cbiAgLy8gQm9keSBsaW5lcyBtYXkgaW5jbHVkZSBzb21lIGV4dHJhIHdpZHRoIGR1ZSB0byB0aGUgY29sb3IgYm94XG4gIHdpZHRoUGFkZGluZyA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IChib3hXaWR0aCArIDIgKyBvcHRpb25zLmJveFBhZGRpbmcpIDogMDtcbiAgZWFjaChib2R5LCAoYm9keUl0ZW0pID0+IHtcbiAgICBlYWNoKGJvZHlJdGVtLmJlZm9yZSwgbWF4TGluZVdpZHRoKTtcbiAgICBlYWNoKGJvZHlJdGVtLmxpbmVzLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIG1heExpbmVXaWR0aCk7XG4gIH0pO1xuXG4gIC8vIFJlc2V0IGJhY2sgdG8gMFxuICB3aWR0aFBhZGRpbmcgPSAwO1xuXG4gIC8vIEZvb3RlciB3aWR0aFxuICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAuZm9vdGVyLCBtYXhMaW5lV2lkdGgpO1xuXG4gIGN0eC5yZXN0b3JlKCk7XG5cbiAgLy8gQWRkIHBhZGRpbmdcbiAgd2lkdGggKz0gcGFkZGluZy53aWR0aDtcblxuICByZXR1cm4ge3dpZHRoLCBoZWlnaHR9O1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpIHtcbiAgY29uc3Qge3ksIGhlaWdodH0gPSBzaXplO1xuXG4gIGlmICh5IDwgaGVpZ2h0IC8gMikge1xuICAgIHJldHVybiAndG9wJztcbiAgfSBlbHNlIGlmICh5ID4gKGNoYXJ0LmhlaWdodCAtIGhlaWdodCAvIDIpKSB7XG4gICAgcmV0dXJuICdib3R0b20nO1xuICB9XG4gIHJldHVybiAnY2VudGVyJztcbn1cblxuZnVuY3Rpb24gZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XG4gIGNvbnN0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBjb25zdCBjYXJldCA9IG9wdGlvbnMuY2FyZXRTaXplICsgb3B0aW9ucy5jYXJldFBhZGRpbmc7XG4gIGlmICh4QWxpZ24gPT09ICdsZWZ0JyAmJiB4ICsgd2lkdGggKyBjYXJldCA+IGNoYXJ0LndpZHRoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoeEFsaWduID09PSAncmlnaHQnICYmIHggLSB3aWR0aCAtIGNhcmV0IDwgMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSB7XG4gIGNvbnN0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBjb25zdCB7d2lkdGg6IGNoYXJ0V2lkdGgsIGNoYXJ0QXJlYToge2xlZnQsIHJpZ2h0fX0gPSBjaGFydDtcbiAgbGV0IHhBbGlnbiA9ICdjZW50ZXInO1xuXG4gIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeEFsaWduID0geCA8PSAobGVmdCArIHJpZ2h0KSAvIDIgPyAnbGVmdCcgOiAncmlnaHQnO1xuICB9IGVsc2UgaWYgKHggPD0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ2xlZnQnO1xuICB9IGVsc2UgaWYgKHggPj0gY2hhcnRXaWR0aCAtIHdpZHRoIC8gMikge1xuICAgIHhBbGlnbiA9ICdyaWdodCc7XG4gIH1cblxuICBpZiAoZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSkge1xuICAgIHhBbGlnbiA9ICdjZW50ZXInO1xuICB9XG5cbiAgcmV0dXJuIHhBbGlnbjtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBhbGlnbm1lbnQgb2YgYSB0b29sdGlwIGdpdmVuIHRoZSBzaXplXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZUFsaWdubWVudChjaGFydCwgb3B0aW9ucywgc2l6ZSkge1xuICBjb25zdCB5QWxpZ24gPSBzaXplLnlBbGlnbiB8fCBvcHRpb25zLnlBbGlnbiB8fCBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpO1xuXG4gIHJldHVybiB7XG4gICAgeEFsaWduOiBzaXplLnhBbGlnbiB8fCBvcHRpb25zLnhBbGlnbiB8fCBkZXRlcm1pbmVYQWxpZ24oY2hhcnQsIG9wdGlvbnMsIHNpemUsIHlBbGlnbiksXG4gICAgeUFsaWduXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFsaWduWChzaXplLCB4QWxpZ24pIHtcbiAgbGV0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3aWR0aDtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCAtPSAod2lkdGggLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24gYWxpZ25ZKHNpemUsIHlBbGlnbiwgcGFkZGluZ0FuZFNpemUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge3ksIGhlaWdodH0gPSBzaXplO1xuICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgIHkgKz0gcGFkZGluZ0FuZFNpemU7XG4gIH0gZWxzZSBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgIHkgLT0gaGVpZ2h0ICsgcGFkZGluZ0FuZFNpemU7XG4gIH0gZWxzZSB7XG4gICAgeSAtPSAoaGVpZ2h0IC8gMik7XG4gIH1cbiAgcmV0dXJuIHk7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGdldCB0aGUgbG9jYXRpb24gYSB0b29sdGlwIG5lZWRzIHRvIGJlIHBsYWNlZCBhdCBnaXZlbiB0aGUgaW5pdGlhbCBwb3NpdGlvbiAodmlhIHRoZSB2bSkgYW5kIHRoZSBzaXplIGFuZCBhbGlnbm1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHNpemUsIGFsaWdubWVudCwgY2hhcnQpIHtcbiAgY29uc3Qge2NhcmV0U2l6ZSwgY2FyZXRQYWRkaW5nLCBjb3JuZXJSYWRpdXN9ID0gb3B0aW9ucztcbiAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IGFsaWdubWVudDtcbiAgY29uc3QgcGFkZGluZ0FuZFNpemUgPSBjYXJldFNpemUgKyBjYXJldFBhZGRpbmc7XG4gIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhjb3JuZXJSYWRpdXMpO1xuXG4gIGxldCB4ID0gYWxpZ25YKHNpemUsIHhBbGlnbik7XG4gIGNvbnN0IHkgPSBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSk7XG5cbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHggKz0gcGFkZGluZ0FuZFNpemU7XG4gICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgIHggLT0gcGFkZGluZ0FuZFNpemU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgeCAtPSBNYXRoLm1heCh0b3BMZWZ0LCBib3R0b21MZWZ0KSArIGNhcmV0U2l6ZTtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4ICs9IE1hdGgubWF4KHRvcFJpZ2h0LCBib3R0b21SaWdodCkgKyBjYXJldFNpemU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IF9saW1pdFZhbHVlKHgsIDAsIGNoYXJ0LndpZHRoIC0gc2l6ZS53aWR0aCksXG4gICAgeTogX2xpbWl0VmFsdWUoeSwgMCwgY2hhcnQuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEFsaWduZWRYKHRvb2x0aXAsIGFsaWduLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcblxuICByZXR1cm4gYWxpZ24gPT09ICdjZW50ZXInXG4gICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC8gMlxuICAgIDogYWxpZ24gPT09ICdyaWdodCdcbiAgICAgID8gdG9vbHRpcC54ICsgdG9vbHRpcC53aWR0aCAtIHBhZGRpbmcucmlnaHRcbiAgICAgIDogdG9vbHRpcC54ICsgcGFkZGluZy5sZWZ0O1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBidWlsZCBiZWZvcmUgYW5kIGFmdGVyIGJvZHkgbGluZXNcbiAqL1xuZnVuY3Rpb24gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoY2FsbGJhY2spIHtcbiAgcmV0dXJuIHB1c2hPckNvbmNhdChbXSwgc3BsaXROZXdsaW5lcyhjYWxsYmFjaykpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwQ29udGV4dChwYXJlbnQsIHRvb2x0aXAsIHRvb2x0aXBJdGVtcykge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICB0b29sdGlwLFxuICAgIHRvb2x0aXBJdGVtcyxcbiAgICB0eXBlOiAndG9vbHRpcCdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCkge1xuICBjb25zdCBvdmVycmlkZSA9IGNvbnRleHQgJiYgY29udGV4dC5kYXRhc2V0ICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwLmNhbGxiYWNrcztcbiAgcmV0dXJuIG92ZXJyaWRlID8gY2FsbGJhY2tzLm92ZXJyaWRlKG92ZXJyaWRlKSA6IGNhbGxiYWNrcztcbn1cblxuY29uc3QgZGVmYXVsdENhbGxiYWNrcyA9IHtcbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGJlZm9yZVRpdGxlOiBub29wLFxuICB0aXRsZSh0b29sdGlwSXRlbXMpIHtcbiAgICBpZiAodG9vbHRpcEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0b29sdGlwSXRlbXNbMF07XG4gICAgICBjb25zdCBsYWJlbHMgPSBpdGVtLmNoYXJ0LmRhdGEubGFiZWxzO1xuICAgICAgY29uc3QgbGFiZWxDb3VudCA9IGxhYmVscyA/IGxhYmVscy5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgICByZXR1cm4gaXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLmxhYmVsKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmxhYmVsO1xuICAgICAgfSBlbHNlIGlmIChsYWJlbENvdW50ID4gMCAmJiBpdGVtLmRhdGFJbmRleCA8IGxhYmVsQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIGxhYmVsc1tpdGVtLmRhdGFJbmRleF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9LFxuICBhZnRlclRpdGxlOiBub29wLFxuXG4gIC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuICBiZWZvcmVCb2R5OiBub29wLFxuXG4gIC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG4gIGJlZm9yZUxhYmVsOiBub29wLFxuICBsYWJlbCh0b29sdGlwSXRlbSkge1xuICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICByZXR1cm4gdG9vbHRpcEl0ZW0ubGFiZWwgKyAnOiAnICsgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWUgfHwgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgfVxuXG4gICAgbGV0IGxhYmVsID0gdG9vbHRpcEl0ZW0uZGF0YXNldC5sYWJlbCB8fCAnJztcblxuICAgIGlmIChsYWJlbCkge1xuICAgICAgbGFiZWwgKz0gJzogJztcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICBsYWJlbCArPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsO1xuICB9LFxuICBsYWJlbENvbG9yKHRvb2x0aXBJdGVtKSB7XG4gICAgY29uc3QgbWV0YSA9IHRvb2x0aXBJdGVtLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcbiAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICB9O1xuICB9LFxuICBsYWJlbFRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmJvZHlDb2xvcjtcbiAgfSxcbiAgbGFiZWxQb2ludFN0eWxlKHRvb2x0aXBJdGVtKSB7XG4gICAgY29uc3QgbWV0YSA9IHRvb2x0aXBJdGVtLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG4gICAgICByb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcbiAgICB9O1xuICB9LFxuICBhZnRlckxhYmVsOiBub29wLFxuXG4gIC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuICBhZnRlckJvZHk6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGJlZm9yZUZvb3Rlcjogbm9vcCxcbiAgZm9vdGVyOiBub29wLFxuICBhZnRlckZvb3Rlcjogbm9vcFxufTtcblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgZnJvbSBvYmplY3Qgd2l0aCBjb250ZXh0IGFuZCBhcmd1bWVudHMuXG4gKiBJZiBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgLCB0aGVuIHdpbGwgYmUgaW52b2tlZCBkZWZhdWx0IGNhbGxiYWNrLlxuICogQHBhcmFtIHtSZWNvcmQ8a2V5b2YgdHlwZW9mIGRlZmF1bHRDYWxsYmFja3MsIEZ1bmN0aW9uPn0gY2FsbGJhY2tzXG4gKiBAcGFyYW0ge2tleW9mIHR5cGVvZiBkZWZhdWx0Q2FsbGJhY2tzfSBuYW1lXG4gKiBAcGFyYW0geyp9IGN0eFxuICogQHBhcmFtIHsqfSBhcmdcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgbmFtZSwgY3R4LCBhcmcpIHtcbiAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2tzW25hbWVdLmNhbGwoY3R4LCBhcmcpO1xuXG4gIGlmICh0eXBlb2YgcmVzdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBkZWZhdWx0Q2FsbGJhY2tzW25hbWVdLmNhbGwoY3R4LCBhcmcpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBFbGVtZW50IHtcblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBDaGFydC5Ub29sdGlwLnBvc2l0aW9uZXJzXG4gICAqL1xuICBzdGF0aWMgcG9zaXRpb25lcnMgPSBwb3NpdGlvbmVycztcblxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vcGFjaXR5ID0gMDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NpemUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSBbXTtcbiAgICB0aGlzLiRhbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aXRsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJlZm9yZUJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm9vdGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueEFsaWduID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueUFsaWduID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhcmV0WCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhcmV0WSA9IHVuZGVmaW5lZDtcbiAgICAvLyBUT0RPOiBWNCwgbWFrZSB0aGlzIHByaXZhdGUsIHJlbmFtZSB0byBgX2xhYmVsU3R5bGVzYCwgYW5kIGNvbWJpbmUgd2l0aCBgbGFiZWxQb2ludFN0eWxlc2BcbiAgICAvLyBhbmQgYGxhYmVsVGV4dENvbG9yc2AgdG8gY3JlYXRlIGEgc2luZ2xlIHZhcmlhYmxlXG4gICAgdGhpcy5sYWJlbENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsUG9pbnRTdHlsZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpbml0aWFsaXplKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc29sdmVBbmltYXRpb25zKCkge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuX2NhY2hlZEFuaW1hdGlvbnM7XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zLmVuYWJsZWQgJiYgY2hhcnQub3B0aW9ucy5hbmltYXRpb24gJiYgb3B0aW9ucy5hbmltYXRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyh0aGlzLmNoYXJ0LCBvcHRzKTtcbiAgICBpZiAob3B0cy5fY2FjaGVhYmxlKSB7XG4gICAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XG5cdFx0XHQodGhpcy4kY29udGV4dCA9IGNyZWF0ZVRvb2x0aXBDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLCB0aGlzLl90b29sdGlwSXRlbXMpKTtcbiAgfVxuXG4gIGdldFRpdGxlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBiZWZvcmVUaXRsZSA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2JlZm9yZVRpdGxlJywgdGhpcywgY29udGV4dCk7XG4gICAgY29uc3QgdGl0bGUgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICd0aXRsZScsIHRoaXMsIGNvbnRleHQpO1xuICAgIGNvbnN0IGFmdGVyVGl0bGUgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdhZnRlclRpdGxlJywgdGhpcywgY29udGV4dCk7XG5cbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVUaXRsZSkpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKHRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJUaXRsZSkpO1xuXG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG5cbiAgZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoXG4gICAgICBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhvcHRpb25zLmNhbGxiYWNrcywgJ2JlZm9yZUJvZHknLCB0aGlzLCB0b29sdGlwSXRlbXMpXG4gICAgKTtcbiAgfVxuXG4gIGdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlJdGVtcyA9IFtdO1xuXG4gICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBib2R5SXRlbSA9IHtcbiAgICAgICAgYmVmb3JlOiBbXSxcbiAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICBhZnRlcjogW11cbiAgICAgIH07XG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhjYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmJlZm9yZSwgc3BsaXROZXdsaW5lcyhpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdiZWZvcmVMYWJlbCcsIHRoaXMsIGNvbnRleHQpKSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0ubGluZXMsIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsJywgdGhpcywgY29udGV4dCkpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmFmdGVyLCBzcGxpdE5ld2xpbmVzKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2FmdGVyTGFiZWwnLCB0aGlzLCBjb250ZXh0KSkpO1xuXG4gICAgICBib2R5SXRlbXMucHVzaChib2R5SXRlbSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYm9keUl0ZW1zO1xuICB9XG5cbiAgZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhcbiAgICAgIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKG9wdGlvbnMuY2FsbGJhY2tzLCAnYWZ0ZXJCb2R5JywgdGhpcywgdG9vbHRpcEl0ZW1zKVxuICAgICk7XG4gIH1cblxuICAvLyBHZXQgdGhlIGZvb3RlciBhbmQgYmVmb3JlRm9vdGVyIGFuZCBhZnRlckZvb3RlciBsaW5lc1xuICBnZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuXG4gICAgY29uc3QgYmVmb3JlRm9vdGVyID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYmVmb3JlRm9vdGVyJywgdGhpcywgdG9vbHRpcEl0ZW1zKTtcbiAgICBjb25zdCBmb290ZXIgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdmb290ZXInLCB0aGlzLCB0b29sdGlwSXRlbXMpO1xuICAgIGNvbnN0IGFmdGVyRm9vdGVyID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYWZ0ZXJGb290ZXInLCB0aGlzLCB0b29sdGlwSXRlbXMpO1xuXG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlRm9vdGVyKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoZm9vdGVyKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJGb290ZXIpKTtcblxuICAgIHJldHVybiBsaW5lcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICBjb25zdCBsYWJlbENvbG9ycyA9IFtdO1xuICAgIGNvbnN0IGxhYmVsUG9pbnRTdHlsZXMgPSBbXTtcbiAgICBjb25zdCBsYWJlbFRleHRDb2xvcnMgPSBbXTtcbiAgICBsZXQgdG9vbHRpcEl0ZW1zID0gW107XG4gICAgbGV0IGksIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGFjdGl2ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdG9vbHRpcEl0ZW1zLnB1c2goY3JlYXRlVG9vbHRpcEl0ZW0odGhpcy5jaGFydCwgYWN0aXZlW2ldKSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBmaWx0ZXIgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcbiAgICBpZiAob3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5maWx0ZXIoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gb3B0aW9ucy5maWx0ZXIoZWxlbWVudCwgaW5kZXgsIGFycmF5LCBkYXRhKSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBzb3J0aW5nIGZ1bmN0aW9uLCB1c2UgaXQgdG8gbW9kaWZ5IHRoZSB0b29sdGlwIGl0ZW1zXG4gICAgaWYgKG9wdGlvbnMuaXRlbVNvcnQpIHtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5zb3J0KChhLCBiKSA9PiBvcHRpb25zLml0ZW1Tb3J0KGEsIGIsIGRhdGEpKTtcbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgY29sb3JzIGZvciBib3hlc1xuICAgIGVhY2godG9vbHRpcEl0ZW1zLCAoY29udGV4dCkgPT4ge1xuICAgICAgY29uc3Qgc2NvcGVkID0gb3ZlcnJpZGVDYWxsYmFja3Mob3B0aW9ucy5jYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgbGFiZWxDb2xvcnMucHVzaChpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdsYWJlbENvbG9yJywgdGhpcywgY29udGV4dCkpO1xuICAgICAgbGFiZWxQb2ludFN0eWxlcy5wdXNoKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsUG9pbnRTdHlsZScsIHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIGxhYmVsVGV4dENvbG9ycy5wdXNoKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsVGV4dENvbG9yJywgdGhpcywgY29udGV4dCkpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5sYWJlbENvbG9ycyA9IGxhYmVsQ29sb3JzO1xuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IGxhYmVsUG9pbnRTdHlsZXM7XG4gICAgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSBsYWJlbFRleHRDb2xvcnM7XG4gICAgdGhpcy5kYXRhUG9pbnRzID0gdG9vbHRpcEl0ZW1zO1xuICAgIHJldHVybiB0b29sdGlwSXRlbXM7XG4gIH1cblxuICB1cGRhdGUoY2hhbmdlZCwgcmVwbGF5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgbGV0IHByb3BlcnRpZXM7XG4gICAgbGV0IHRvb2x0aXBJdGVtcyA9IFtdO1xuXG4gICAgaWYgKCFhY3RpdmUubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5vcGFjaXR5ICE9PSAwKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgYWN0aXZlLCB0aGlzLl9ldmVudFBvc2l0aW9uKTtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRoaXMuX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLnRpdGxlID0gdGhpcy5nZXRUaXRsZSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5iZWZvcmVCb2R5ID0gdGhpcy5nZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmJvZHkgPSB0aGlzLmdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdGhpcy5nZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuZm9vdGVyID0gdGhpcy5nZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcblxuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NpemUgPSBnZXRUb29sdGlwU2l6ZSh0aGlzLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQW5kU2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBvc2l0aW9uLCBzaXplKTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudCh0aGlzLmNoYXJ0LCBvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUpO1xuICAgICAgY29uc3QgYmFja2dyb3VuZFBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSwgYWxpZ25tZW50LCB0aGlzLmNoYXJ0KTtcblxuICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgdGhpcy55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuXG4gICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICB4OiBiYWNrZ3JvdW5kUG9pbnQueCxcbiAgICAgICAgeTogYmFja2dyb3VuZFBvaW50LnksXG4gICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuICAgICAgICBjYXJldFg6IHBvc2l0aW9uLngsXG4gICAgICAgIGNhcmV0WTogcG9zaXRpb24ueVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXM7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucygpLnVwZGF0ZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlZCAmJiBvcHRpb25zLmV4dGVybmFsKSB7XG4gICAgICBvcHRpb25zLmV4dGVybmFsLmNhbGwodGhpcywge2NoYXJ0OiB0aGlzLmNoYXJ0LCB0b29sdGlwOiB0aGlzLCByZXBsYXl9KTtcbiAgICB9XG4gIH1cblxuICBkcmF3Q2FyZXQodG9vbHRpcFBvaW50LCBjdHgsIHNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYXJldFBvc2l0aW9uID0gdGhpcy5nZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgb3B0aW9ucyk7XG5cbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDEsIGNhcmV0UG9zaXRpb24ueTEpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MiwgY2FyZXRQb3NpdGlvbi55Mik7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngzLCBjYXJldFBvc2l0aW9uLnkzKTtcbiAgfVxuXG4gIGdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IHRoaXM7XG4gICAgY29uc3Qge2NhcmV0U2l6ZSwgY29ybmVyUmFkaXVzfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKGNvcm5lclJhZGl1cyk7XG4gICAgY29uc3Qge3g6IHB0WCwgeTogcHRZfSA9IHRvb2x0aXBQb2ludDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBzaXplO1xuICAgIGxldCB4MSwgeDIsIHgzLCB5MSwgeTIsIHkzO1xuXG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHkyID0gcHRZICsgKGhlaWdodCAvIDIpO1xuXG4gICAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeDEgPSBwdFg7XG4gICAgICAgIHgyID0geDEgLSBjYXJldFNpemU7XG5cbiAgICAgICAgLy8gTGVmdCBkcmF3cyBib3R0b20gLT4gdG9wLCB0aGlzIHkxIGlzIG9uIHRoZSBib3R0b21cbiAgICAgICAgeTEgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgeTMgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgxID0gcHRYICsgd2lkdGg7XG4gICAgICAgIHgyID0geDEgKyBjYXJldFNpemU7XG5cbiAgICAgICAgLy8gUmlnaHQgZHJhd3MgdG9wIC0+IGJvdHRvbSwgdGh1cyB5MSBpcyBvbiB0aGUgdG9wXG4gICAgICAgIHkxID0geTIgLSBjYXJldFNpemU7XG4gICAgICAgIHkzID0geTIgKyBjYXJldFNpemU7XG4gICAgICB9XG5cbiAgICAgIHgzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4MiA9IHB0WCArIE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgKGNhcmV0U2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB4MiA9IHB0WCArIHdpZHRoIC0gTWF0aC5tYXgodG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSAtIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyID0gdGhpcy5jYXJldFg7XG4gICAgICB9XG5cbiAgICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgIHkxID0gcHRZO1xuICAgICAgICB5MiA9IHkxIC0gY2FyZXRTaXplO1xuXG4gICAgICAgIC8vIFRvcCBkcmF3cyBsZWZ0IC0+IHJpZ2h0LCB0aHVzIHgxIGlzIG9uIHRoZSBsZWZ0XG4gICAgICAgIHgxID0geDIgLSBjYXJldFNpemU7XG4gICAgICAgIHgzID0geDIgKyBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5MSA9IHB0WSArIGhlaWdodDtcbiAgICAgICAgeTIgPSB5MSArIGNhcmV0U2l6ZTtcblxuICAgICAgICAvLyBCb3R0b20gZHJhd3MgcmlnaHQgLT4gbGVmdCwgdGh1cyB4MSBpcyBvbiB0aGUgcmlnaHRcbiAgICAgICAgeDEgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgeDMgPSB4MiAtIGNhcmV0U2l6ZTtcbiAgICAgIH1cbiAgICAgIHkzID0geTE7XG4gICAgfVxuICAgIHJldHVybiB7eDEsIHgyLCB4MywgeTEsIHkyLCB5M307XG4gIH1cblxuICBkcmF3VGl0bGUocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gdGhpcy50aXRsZTtcbiAgICBjb25zdCBsZW5ndGggPSB0aXRsZS5sZW5ndGg7XG4gICAgbGV0IHRpdGxlRm9udCwgdGl0bGVTcGFjaW5nLCBpO1xuXG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcblxuICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIG9wdGlvbnMudGl0bGVBbGlnbiwgb3B0aW9ucyk7XG5cbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMudGl0bGVBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICAgIHRpdGxlRm9udCA9IHRvRm9udChvcHRpb25zLnRpdGxlRm9udCk7XG4gICAgICB0aXRsZVNwYWNpbmcgPSBvcHRpb25zLnRpdGxlU3BhY2luZztcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMudGl0bGVDb2xvcjtcbiAgICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dCh0aXRsZVtpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyB0aXRsZUZvbnQubGluZUhlaWdodCAvIDIpO1xuICAgICAgICBwdC55ICs9IHRpdGxlRm9udC5saW5lSGVpZ2h0ICsgdGl0bGVTcGFjaW5nOyAvLyBMaW5lIEhlaWdodCBhbmQgc3BhY2luZ1xuXG4gICAgICAgIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgcHQueSArPSBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tIC0gdGl0bGVTcGFjaW5nOyAvLyBJZiBMYXN0LCBhZGQgbWFyZ2luLCByZW1vdmUgc3BhY2luZ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZHJhd0NvbG9yQm94KGN0eCwgcHQsIGksIHJ0bEhlbHBlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxhYmVsQ29sb3IgPSB0aGlzLmxhYmVsQ29sb3JzW2ldO1xuICAgIGNvbnN0IGxhYmVsUG9pbnRTdHlsZSA9IHRoaXMubGFiZWxQb2ludFN0eWxlc1tpXTtcbiAgICBjb25zdCB7Ym94SGVpZ2h0LCBib3hXaWR0aH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgIGNvbnN0IGNvbG9yWCA9IGdldEFsaWduZWRYKHRoaXMsICdsZWZ0Jywgb3B0aW9ucyk7XG4gICAgY29uc3QgcnRsQ29sb3JYID0gcnRsSGVscGVyLngoY29sb3JYKTtcbiAgICBjb25zdCB5T2ZmU2V0ID0gYm94SGVpZ2h0IDwgYm9keUZvbnQubGluZUhlaWdodCA/IChib2R5Rm9udC5saW5lSGVpZ2h0IC0gYm94SGVpZ2h0KSAvIDIgOiAwO1xuICAgIGNvbnN0IGNvbG9yWSA9IHB0LnkgKyB5T2ZmU2V0O1xuXG4gICAgaWYgKG9wdGlvbnMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgY29uc3QgZHJhd09wdGlvbnMgPSB7XG4gICAgICAgIHJhZGl1czogTWF0aC5taW4oYm94V2lkdGgsIGJveEhlaWdodCkgLyAyLCAvLyBmaXQgdGhlIGNpcmNsZSBpbiB0aGUgYm94XG4gICAgICAgIHBvaW50U3R5bGU6IGxhYmVsUG9pbnRTdHlsZS5wb2ludFN0eWxlLFxuICAgICAgICByb3RhdGlvbjogbGFiZWxQb2ludFN0eWxlLnJvdGF0aW9uLFxuICAgICAgICBib3JkZXJXaWR0aDogMVxuICAgICAgfTtcbiAgICAgIC8vIFJlY2FsY3VsYXRlIHggYW5kIHkgZm9yIGRyYXdQb2ludCgpIGJlY2F1c2UgaXRzIGV4cGVjdGluZ1xuICAgICAgLy8geCBhbmQgeSB0byBiZSBjZW50ZXIgb2YgZmlndXJlIChpbnN0ZWFkIG9mIHRvcCBsZWZ0KVxuICAgICAgY29uc3QgY2VudGVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm94V2lkdGgpICsgYm94V2lkdGggLyAyO1xuICAgICAgY29uc3QgY2VudGVyWSA9IGNvbG9yWSArIGJveEhlaWdodCAvIDI7XG5cbiAgICAgIC8vIEZpbGwgdGhlIHBvaW50IHdpdGggd2hpdGUgc28gdGhhdCBjb2xvdXJzIG1lcmdlIG5pY2VseSBpZiB0aGUgb3BhY2l0eSBpcyA8IDFcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuXG4gICAgICAvLyBEcmF3IHRoZSBwb2ludFxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvci5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9yLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIGRyYXdQb2ludChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQm9yZGVyXG4gICAgICBjdHgubGluZVdpZHRoID0gaXNPYmplY3QobGFiZWxDb2xvci5ib3JkZXJXaWR0aCkgPyBNYXRoLm1heCguLi5PYmplY3QudmFsdWVzKGxhYmVsQ29sb3IuYm9yZGVyV2lkdGgpKSA6IChsYWJlbENvbG9yLmJvcmRlcldpZHRoIHx8IDEpOyAvLyBUT0RPLCB2NCByZW1vdmUgZmFsbGJhY2tcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3IuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2gobGFiZWxDb2xvci5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxhYmVsQ29sb3IuYm9yZGVyRGFzaE9mZnNldCB8fCAwO1xuXG4gICAgICAvLyBGaWxsIGEgd2hpdGUgcmVjdCBzbyB0aGF0IGNvbG91cnMgbWVyZ2UgbmljZWx5IGlmIHRoZSBvcGFjaXR5IGlzIDwgMVxuICAgICAgY29uc3Qgb3V0ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCk7XG4gICAgICBjb25zdCBpbm5lclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueFBsdXMocnRsQ29sb3JYLCAxKSwgYm94V2lkdGggLSAyKTtcbiAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGFiZWxDb2xvci5ib3JkZXJSYWRpdXMpO1xuXG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IG91dGVyWCxcbiAgICAgICAgICB5OiBjb2xvclksXG4gICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgaDogYm94SGVpZ2h0LFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIC8vIElubmVyIHNxdWFyZVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvci5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IGlubmVyWCxcbiAgICAgICAgICB5OiBjb2xvclkgKyAxLFxuICAgICAgICAgIHc6IGJveFdpZHRoIC0gMixcbiAgICAgICAgICBoOiBib3hIZWlnaHQgLSAyLFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vcm1hbCByZWN0XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgY3R4LmZpbGxSZWN0KG91dGVyWCwgY29sb3JZLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICAvLyBJbm5lciBzcXVhcmVcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3IuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguZmlsbFJlY3QoaW5uZXJYLCBjb2xvclkgKyAxLCBib3hXaWR0aCAtIDIsIGJveEhlaWdodCAtIDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlc3RvcmUgZmlsbFN0eWxlXG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMubGFiZWxUZXh0Q29sb3JzW2ldO1xuICB9XG5cbiAgZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtib2R5fSA9IHRoaXM7XG4gICAgY29uc3Qge2JvZHlTcGFjaW5nLCBib2R5QWxpZ24sIGRpc3BsYXlDb2xvcnMsIGJveEhlaWdodCwgYm94V2lkdGgsIGJveFBhZGRpbmd9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgICBsZXQgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGxldCB4TGluZVBhZGRpbmcgPSAwO1xuXG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcblxuICAgIGNvbnN0IGZpbGxMaW5lT2ZUZXh0ID0gZnVuY3Rpb24obGluZSkge1xuICAgICAgY3R4LmZpbGxUZXh0KGxpbmUsIHJ0bEhlbHBlci54KHB0LnggKyB4TGluZVBhZGRpbmcpLCBwdC55ICsgYm9keUxpbmVIZWlnaHQgLyAyKTtcbiAgICAgIHB0LnkgKz0gYm9keUxpbmVIZWlnaHQgKyBib2R5U3BhY2luZztcbiAgICB9O1xuXG4gICAgY29uc3QgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gPSBydGxIZWxwZXIudGV4dEFsaWduKGJvZHlBbGlnbik7XG4gICAgbGV0IGJvZHlJdGVtLCB0ZXh0Q29sb3IsIGxpbmVzLCBpLCBqLCBpbGVuLCBqbGVuO1xuXG4gICAgY3R4LnRleHRBbGlnbiA9IGJvZHlBbGlnbjtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LmZvbnQgPSBib2R5Rm9udC5zdHJpbmc7XG5cbiAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24sIG9wdGlvbnMpO1xuXG4gICAgLy8gQmVmb3JlIGJvZHkgbGluZXNcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5ib2R5Q29sb3I7XG4gICAgZWFjaCh0aGlzLmJlZm9yZUJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcblxuICAgIHhMaW5lUGFkZGluZyA9IGRpc3BsYXlDb2xvcnMgJiYgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gIT09ICdyaWdodCdcbiAgICAgID8gYm9keUFsaWduID09PSAnY2VudGVyJyA/IChib3hXaWR0aCAvIDIgKyBib3hQYWRkaW5nKSA6IChib3hXaWR0aCArIDIgKyBib3hQYWRkaW5nKVxuICAgICAgOiAwO1xuXG4gICAgLy8gRHJhdyBib2R5IGxpbmVzIG5vd1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBib2R5Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgYm9keUl0ZW0gPSBib2R5W2ldO1xuICAgICAgdGV4dENvbG9yID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG4gICAgICBlYWNoKGJvZHlJdGVtLmJlZm9yZSwgZmlsbExpbmVPZlRleHQpO1xuXG4gICAgICBsaW5lcyA9IGJvZHlJdGVtLmxpbmVzO1xuICAgICAgLy8gRHJhdyBMZWdlbmQtbGlrZSBib3hlcyBpZiBuZWVkZWRcbiAgICAgIGlmIChkaXNwbGF5Q29sb3JzICYmIGxpbmVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKTtcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBNYXRoLm1heChib2R5Rm9udC5saW5lSGVpZ2h0LCBib3hIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGogPSAwLCBqbGVuID0gbGluZXMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgIGZpbGxMaW5lT2ZUZXh0KGxpbmVzW2pdKTtcbiAgICAgICAgLy8gUmVzZXQgZm9yIGFueSBsaW5lcyB0aGF0IGRvbid0IGluY2x1ZGUgY29sb3Jib3hcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBlYWNoKGJvZHlJdGVtLmFmdGVyLCBmaWxsTGluZU9mVGV4dCk7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgYmFjayB0byAwIGZvciBhZnRlciBib2R5XG4gICAgeExpbmVQYWRkaW5nID0gMDtcbiAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG5cbiAgICAvLyBBZnRlciBib2R5IGxpbmVzXG4gICAgZWFjaCh0aGlzLmFmdGVyQm9keSwgZmlsbExpbmVPZlRleHQpO1xuICAgIHB0LnkgLT0gYm9keVNwYWNpbmc7IC8vIFJlbW92ZSBsYXN0IGJvZHkgc3BhY2luZ1xuICB9XG5cbiAgZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZm9vdGVyID0gdGhpcy5mb290ZXI7XG4gICAgY29uc3QgbGVuZ3RoID0gZm9vdGVyLmxlbmd0aDtcbiAgICBsZXQgZm9vdGVyRm9udCwgaTtcblxuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG5cbiAgICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBvcHRpb25zLmZvb3RlckFsaWduLCBvcHRpb25zKTtcbiAgICAgIHB0LnkgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3A7XG5cbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMuZm9vdGVyQWxpZ24pO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgICBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZvb3RlckNvbG9yO1xuICAgICAgY3R4LmZvbnQgPSBmb290ZXJGb250LnN0cmluZztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChmb290ZXJbaV0sIHJ0bEhlbHBlci54KHB0LngpLCBwdC55ICsgZm9vdGVyRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgIHB0LnkgKz0gZm9vdGVyRm9udC5saW5lSGVpZ2h0ICsgb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRyYXdCYWNrZ3JvdW5kKHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IHRoaXM7XG4gICAgY29uc3Qge3gsIHl9ID0gcHQ7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdG9vbHRpcFNpemU7XG4gICAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKG9wdGlvbnMuY29ybmVyUmFkaXVzKTtcblxuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHRvcExlZnQsIHkpO1xuICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gdG9wUmlnaHQsIHkpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgdG9wUmlnaHQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIGJvdHRvbVJpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIGJvdHRvbVJpZ2h0LCB5ICsgaGVpZ2h0KTtcbiAgICBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyBib3R0b21MZWZ0LCB5ICsgaGVpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gYm90dG9tTGVmdCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4LCB5ICsgdG9wTGVmdCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHRvcExlZnQsIHkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgIGN0eC5maWxsKCk7XG5cbiAgICBpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogVXBkYXRlIHgveSBhbmltYXRpb24gdGFyZ2V0cyB3aGVuIF9hY3RpdmUgZWxlbWVudHMgYXJlIGFuaW1hdGluZyB0b29cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucykge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbVggPSBhbmltcyAmJiBhbmltcy54O1xuICAgIGNvbnN0IGFuaW1ZID0gYW5pbXMgJiYgYW5pbXMueTtcbiAgICBpZiAoYW5pbVggfHwgYW5pbVkpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCB0aGlzLl9hY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHRoaXMuX3NpemUpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUpO1xuICAgICAgY29uc3QgcG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgcG9zaXRpb25BbmRTaXplLCBhbGlnbm1lbnQsIGNoYXJ0KTtcbiAgICAgIGlmIChhbmltWC5fdG8gIT09IHBvaW50LnggfHwgYW5pbVkuX3RvICE9PSBwb2ludC55KSB7XG4gICAgICAgIHRoaXMueEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcbiAgICAgICAgdGhpcy55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuICAgICAgICB0aGlzLndpZHRoID0gc2l6ZS53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgdGhpcy5jYXJldFggPSBwb3NpdGlvbi54O1xuICAgICAgICB0aGlzLmNhcmV0WSA9IHBvc2l0aW9uLnk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHBvaW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSB0b29sdGlwIHdpbGwgZHJhdyBhbnl0aGluZ1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdG9vbHRpcCB3aWxsIHJlbmRlclxuICAgKi9cbiAgX3dpbGxSZW5kZXIoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5vcGFjaXR5O1xuICB9XG5cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGxldCBvcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuXG4gICAgaWYgKCFvcGFjaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlQW5pbWF0aW9uVGFyZ2V0KG9wdGlvbnMpO1xuXG4gICAgY29uc3QgdG9vbHRpcFNpemUgPSB7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IHB0ID0ge1xuICAgICAgeDogdGhpcy54LFxuICAgICAgeTogdGhpcy55XG4gICAgfTtcblxuICAgIC8vIElFMTEvRWRnZSBkb2VzIG5vdCBsaWtlIHZlcnkgc21hbGwgb3BhY2l0aWVzLCBzbyBzbmFwIHRvIDBcbiAgICBvcGFjaXR5ID0gTWF0aC5hYnMob3BhY2l0eSkgPCAxZS0zID8gMCA6IG9wYWNpdHk7XG5cbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG5cbiAgICAvLyBUcnV0aHkvZmFsc2V5IHZhbHVlIGZvciBlbXB0eSB0b29sdGlwXG4gICAgY29uc3QgaGFzVG9vbHRpcENvbnRlbnQgPSB0aGlzLnRpdGxlLmxlbmd0aCB8fCB0aGlzLmJlZm9yZUJvZHkubGVuZ3RoIHx8IHRoaXMuYm9keS5sZW5ndGggfHwgdGhpcy5hZnRlckJvZHkubGVuZ3RoIHx8IHRoaXMuZm9vdGVyLmxlbmd0aDtcblxuICAgIGlmIChvcHRpb25zLmVuYWJsZWQgJiYgaGFzVG9vbHRpcENvbnRlbnQpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuXG4gICAgICAvLyBEcmF3IEJhY2tncm91bmRcbiAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuXG4gICAgICBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuXG4gICAgICBwdC55ICs9IHBhZGRpbmcudG9wO1xuXG4gICAgICAvLyBUaXRsZXNcbiAgICAgIHRoaXMuZHJhd1RpdGxlKHB0LCBjdHgsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBCb2R5XG4gICAgICB0aGlzLmRyYXdCb2R5KHB0LCBjdHgsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBGb290ZXJcbiAgICAgIHRoaXMuZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKTtcblxuICAgICAgcmVzdG9yZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgYWN0aXZlIGVsZW1lbnRzIGluIHRoZSB0b29sdGlwXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgYWN0aXZlIGluIHRoZSB0b29sdGlwXG5cdCAqL1xuICBnZXRBY3RpdmVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldCBhY3RpdmUgZWxlbWVudHMgaW4gdGhlIHRvb2x0aXBcblx0ICogQHBhcmFtIHthcnJheX0gYWN0aXZlRWxlbWVudHMgQXJyYXkgb2YgYWN0aXZlIGRhdGFzZXRJbmRleC9pbmRleCBwYWlycy5cblx0ICogQHBhcmFtIHtvYmplY3R9IGV2ZW50UG9zaXRpb24gU3ludGhldGljIGV2ZW50IHBvc2l0aW9uIHVzZWQgaW4gcG9zaXRpb25pbmdcblx0ICovXG4gIHNldEFjdGl2ZUVsZW1lbnRzKGFjdGl2ZUVsZW1lbnRzLCBldmVudFBvc2l0aW9uKSB7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50cy5tYXAoKHtkYXRhc2V0SW5kZXgsIGluZGV4fSkgPT4ge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblxuICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgYSBkYXRhc2V0IGF0IGluZGV4ICcgKyBkYXRhc2V0SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgIGluZGV4LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZXZlbnRQb3NpdGlvbik7XG5cbiAgICBpZiAoY2hhbmdlZCB8fCBwb3NpdGlvbkNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSBldmVudFBvc2l0aW9uO1xuICAgICAgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzID0gdHJ1ZTtcbiAgICAgIHRoaXMudXBkYXRlKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXBsYXldIC0gVGhpcyBpcyBhIHJlcGxheWVkIGV2ZW50IChmcm9tIHVwZGF0ZSlcblx0ICogQHBhcmFtIHtib29sZWFufSBbaW5DaGFydEFyZWFdIC0gVGhlIGV2ZW50IGlzIGluc2lkZSBjaGFydEFyZWFcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHRvb2x0aXAgY2hhbmdlZFxuXHQgKi9cbiAgaGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSA9IHRydWUpIHtcbiAgICBpZiAocmVwbGF5ICYmIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSBmYWxzZTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCByZXBsYXksIGluQ2hhcnRBcmVhKTtcblxuICAgIC8vIFdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGl0ZW1zIHNob3duLCBidXQgdGhlIHRvb2x0aXAgcG9zaXRpb24gaXMgbmVhcmVzdCBtb2RlXG4gICAgLy8gYW4gdXBkYXRlIG1heSBuZWVkIHRvIGJlIG1hZGUgYmVjYXVzZSBvdXIgcG9zaXRpb24gbWF5IGhhdmUgY2hhbmdlZCBldmVuIHRob3VnaFxuICAgIC8vIHRoZSBpdGVtcyBhcmUgdGhlIHNhbWUgYXMgYmVmb3JlLlxuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGUpO1xuXG4gICAgLy8gUmVtZW1iZXIgTGFzdCBBY3RpdmVzXG4gICAgY29uc3QgY2hhbmdlZCA9IHJlcGxheSB8fCAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKSB8fCBwb3NpdGlvbkNoYW5nZWQ7XG5cbiAgICAvLyBPbmx5IGhhbmRsZSB0YXJnZXQgZXZlbnQgb24gdG9vbHRpcCBjaGFuZ2VcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuXG4gICAgICBpZiAob3B0aW9ucy5lbmFibGVkIHx8IG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiBlLngsXG4gICAgICAgICAgeTogZS55XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51cGRhdGUodHJ1ZSwgcmVwbGF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBIZWxwZXIgZm9yIGRldGVybWluaW5nIHRoZSBhY3RpdmUgZWxlbWVudHMgZm9yIGV2ZW50XG5cdCAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSAtIFRoZSBldmVudCB0byBoYW5kbGVcblx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbkl0ZW1bXX0gbGFzdEFjdGl2ZSAtIFByZXZpb3VzbHkgYWN0aXZlIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcGxheV0gLSBUaGlzIGlzIGEgcmVwbGF5ZWQgZXZlbnQgKGZyb20gdXBkYXRlKVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbkNoYXJ0QXJlYV0gLSBUaGUgZXZlbnQgaXMgaW5zaWRlIGNoYXJ0QXJlYVxuXHQgKiBAcmV0dXJucyB7SW50ZXJhY3Rpb25JdGVtW119IC0gQWN0aXZlIGVsZW1lbnRzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKCFpbkNoYXJ0QXJlYSkge1xuICAgICAgLy8gTGV0IHVzZXIgY29udHJvbCB0aGUgYWN0aXZlIGVsZW1lbnRzIG91dHNpZGUgY2hhcnRBcmVhLiBFZy4gdXNpbmcgTGVnZW5kLlxuICAgICAgLy8gQnV0IG1ha2Ugc3VyZSB0aGF0IGFjdGl2ZSBlbGVtZW50cyBhcmUgc3RpbGwgdmFsaWQuXG4gICAgICByZXR1cm4gbGFzdEFjdGl2ZS5maWx0ZXIoaSA9PlxuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbaS5kYXRhc2V0SW5kZXhdICYmXG4gICAgICAgIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaS5kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIuZ2V0UGFyc2VkKGkuaW5kZXgpICE9PSB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRmluZCBBY3RpdmUgRWxlbWVudHMgZm9yIHRvb2x0aXBzXG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5jaGFydC5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG9wdGlvbnMubW9kZSwgb3B0aW9ucywgcmVwbGF5KTtcblxuICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIGFjdGl2ZS5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGl2ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgdGhlIGFjdGl2ZSBlbGVtZW50cyArIGV2ZW50IGNvbWJpbmF0aW9uIGNoYW5nZXMgdGhlXG5cdCAqIHRvb2x0aXAgcG9zaXRpb25cblx0ICogQHBhcmFtIHthcnJheX0gYWN0aXZlIC0gQWN0aXZlIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSAtIEV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSBwb3NpdGlvbiBjaGFuZ2Vcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBvc2l0aW9uIGhhcyBjaGFuZ2VkXG5cdCAqL1xuICBfcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSkge1xuICAgIGNvbnN0IHtjYXJldFgsIGNhcmV0WSwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIGUpO1xuICAgIHJldHVybiBwb3NpdGlvbiAhPT0gZmFsc2UgJiYgKGNhcmV0WCAhPT0gcG9zaXRpb24ueCB8fCBjYXJldFkgIT09IHBvc2l0aW9uLnkpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICd0b29sdGlwJyxcbiAgX2VsZW1lbnQ6IFRvb2x0aXAsXG4gIHBvc2l0aW9uZXJzLFxuXG4gIGFmdGVySW5pdChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgY2hhcnQudG9vbHRpcCA9IG5ldyBUb29sdGlwKHtjaGFydCwgb3B0aW9uc30pO1xuICAgIH1cbiAgfSxcblxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVzZXQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9XG4gIH0sXG5cbiAgYWZ0ZXJEcmF3KGNoYXJ0KSB7XG4gICAgY29uc3QgdG9vbHRpcCA9IGNoYXJ0LnRvb2x0aXA7XG5cbiAgICBpZiAodG9vbHRpcCAmJiB0b29sdGlwLl93aWxsUmVuZGVyKCkpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICAgIHRvb2x0aXBcbiAgICAgIH07XG5cbiAgICAgIGlmIChjaGFydC5ub3RpZnlQbHVnaW5zKCdiZWZvcmVUb29sdGlwRHJhdycsIHsuLi5hcmdzLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdG9vbHRpcC5kcmF3KGNoYXJ0LmN0eCk7XG5cbiAgICAgIGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2FmdGVyVG9vbHRpcERyYXcnLCBhcmdzKTtcbiAgICB9XG4gIH0sXG5cbiAgYWZ0ZXJFdmVudChjaGFydCwgYXJncykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICAvLyBJZiB0aGUgZXZlbnQgaXMgcmVwbGF5ZWQgZnJvbSBgdXBkYXRlYCwgd2Ugc2hvdWxkIGV2YWx1YXRlIHdpdGggdGhlIGZpbmFsIHBvc2l0aW9ucy5cbiAgICAgIGNvbnN0IHVzZUZpbmFsUG9zaXRpb24gPSBhcmdzLnJlcGxheTtcbiAgICAgIGlmIChjaGFydC50b29sdGlwLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQsIHVzZUZpbmFsUG9zaXRpb24sIGFyZ3MuaW5DaGFydEFyZWEpKSB7XG4gICAgICAgIC8vIG5vdGlmeSBjaGFydCBhYm91dCB0aGUgY2hhbmdlLCBzbyBpdCB3aWxsIHJlbmRlclxuICAgICAgICBhcmdzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZXh0ZXJuYWw6IG51bGwsXG4gICAgcG9zaXRpb246ICdhdmVyYWdlJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuICAgIHRpdGxlQ29sb3I6ICcjZmZmJyxcbiAgICB0aXRsZUZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgdGl0bGVTcGFjaW5nOiAyLFxuICAgIHRpdGxlTWFyZ2luQm90dG9tOiA2LFxuICAgIHRpdGxlQWxpZ246ICdsZWZ0JyxcbiAgICBib2R5Q29sb3I6ICcjZmZmJyxcbiAgICBib2R5U3BhY2luZzogMixcbiAgICBib2R5Rm9udDoge1xuICAgIH0sXG4gICAgYm9keUFsaWduOiAnbGVmdCcsXG4gICAgZm9vdGVyQ29sb3I6ICcjZmZmJyxcbiAgICBmb290ZXJTcGFjaW5nOiAyLFxuICAgIGZvb3Rlck1hcmdpblRvcDogNixcbiAgICBmb290ZXJGb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIGZvb3RlckFsaWduOiAnbGVmdCcsXG4gICAgcGFkZGluZzogNixcbiAgICBjYXJldFBhZGRpbmc6IDIsXG4gICAgY2FyZXRTaXplOiA1LFxuICAgIGNvcm5lclJhZGl1czogNixcbiAgICBib3hIZWlnaHQ6IChjdHgsIG9wdHMpID0+IG9wdHMuYm9keUZvbnQuc2l6ZSxcbiAgICBib3hXaWR0aDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIG11bHRpS2V5QmFja2dyb3VuZDogJyNmZmYnLFxuICAgIGRpc3BsYXlDb2xvcnM6IHRydWUsXG4gICAgYm94UGFkZGluZzogMCxcbiAgICBib3JkZXJDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDQwMCxcbiAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnLCAnY2FyZXRYJywgJ2NhcmV0WSddLFxuICAgICAgfSxcbiAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgZHVyYXRpb246IDIwMFxuICAgICAgfVxuICAgIH0sXG4gICAgY2FsbGJhY2tzOiBkZWZhdWx0Q2FsbGJhY2tzXG4gIH0sXG5cbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGJvZHlGb250OiAnZm9udCcsXG4gICAgZm9vdGVyRm9udDogJ2ZvbnQnLFxuICAgIHRpdGxlRm9udDogJ2ZvbnQnXG4gIH0sXG5cbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdmaWx0ZXInICYmIG5hbWUgIT09ICdpdGVtU29ydCcgJiYgbmFtZSAhPT0gJ2V4dGVybmFsJyxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBjYWxsYmFja3M6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcbiAgICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBfZmFsbGJhY2s6IGZhbHNlXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBfZmFsbGJhY2s6ICdhbmltYXRpb24nXG4gICAgfVxuICB9LFxuXG4gIC8vIFJlc29sdmUgYWRkaXRpb25hbGx5IGZyb20gYGludGVyYWN0aW9uYCBvcHRpb25zIGFuZCBkZWZhdWx0cy5cbiAgYWRkaXRpb25hbE9wdGlvblNjb3BlczogWydpbnRlcmFjdGlvbiddXG59O1xuIiwgImltcG9ydCBTY2FsZSBmcm9tICcuLi9jb3JlL2NvcmUuc2NhbGUuanMnO1xuaW1wb3J0IHtpc051bGxPclVuZGVmLCB2YWx1ZU9yRGVmYXVsdCwgX2xpbWl0VmFsdWV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5jb25zdCBhZGRJZlN0cmluZyA9IChsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKSA9PiB7XG4gIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgIGluZGV4ID0gbGFiZWxzLnB1c2gocmF3KSAtIDE7XG4gICAgYWRkZWRMYWJlbHMudW5zaGlmdCh7aW5kZXgsIGxhYmVsOiByYXd9KTtcbiAgfSBlbHNlIGlmIChpc05hTihyYXcpKSB7XG4gICAgaW5kZXggPSBudWxsO1xuICB9XG4gIHJldHVybiBpbmRleDtcbn07XG5cbmZ1bmN0aW9uIGZpbmRPckFkZExhYmVsKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpIHtcbiAgY29uc3QgZmlyc3QgPSBsYWJlbHMuaW5kZXhPZihyYXcpO1xuICBpZiAoZmlyc3QgPT09IC0xKSB7XG4gICAgcmV0dXJuIGFkZElmU3RyaW5nKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpO1xuICB9XG4gIGNvbnN0IGxhc3QgPSBsYWJlbHMubGFzdEluZGV4T2YocmF3KTtcbiAgcmV0dXJuIGZpcnN0ICE9PSBsYXN0ID8gaW5kZXggOiBmaXJzdDtcbn1cblxuY29uc3QgdmFsaWRJbmRleCA9IChpbmRleCwgbWF4KSA9PiBpbmRleCA9PT0gbnVsbCA/IG51bGwgOiBfbGltaXRWYWx1ZShNYXRoLnJvdW5kKGluZGV4KSwgMCwgbWF4KTtcblxuZnVuY3Rpb24gX2dldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcblxuICBpZiAodmFsdWUgPj0gMCAmJiB2YWx1ZSA8IGxhYmVscy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbGFiZWxzW3ZhbHVlXTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhdGVnb3J5U2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG5cbiAgc3RhdGljIGlkID0gJ2NhdGVnb3J5JztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICB0aWNrczoge1xuICAgICAgY2FsbGJhY2s6IF9nZXRMYWJlbEZvclZhbHVlXG4gICAgfVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gIH1cblxuICBpbml0KHNjYWxlT3B0aW9ucykge1xuICAgIGNvbnN0IGFkZGVkID0gdGhpcy5fYWRkZWRMYWJlbHM7XG4gICAgaWYgKGFkZGVkLmxlbmd0aCkge1xuICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICAgIGZvciAoY29uc3Qge2luZGV4LCBsYWJlbH0gb2YgYWRkZWQpIHtcbiAgICAgICAgaWYgKGxhYmVsc1tpbmRleF0gPT09IGxhYmVsKSB7XG4gICAgICAgICAgbGFiZWxzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gICAgfVxuICAgIHN1cGVyLmluaXQoc2NhbGVPcHRpb25zKTtcbiAgfVxuXG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBpbmRleCA9IGlzRmluaXRlKGluZGV4KSAmJiBsYWJlbHNbaW5kZXhdID09PSByYXcgPyBpbmRleFxuICAgICAgOiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgdmFsdWVPckRlZmF1bHQoaW5kZXgsIHJhdyksIHRoaXMuX2FkZGVkTGFiZWxzKTtcbiAgICByZXR1cm4gdmFsaWRJbmRleChpbmRleCwgbGFiZWxzLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIGlmICghbWluRGVmaW5lZCkge1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XG4gICAgICAgIG1heCA9IHRoaXMuZ2V0TGFiZWxzKCkubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vcHRpb25zLm9mZnNldDtcbiAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgIGxldCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuXG4gICAgLy8gSWYgd2UgYXJlIHZpZXdpbmcgc29tZSBzdWJzZXQgb2YgbGFiZWxzLCBzbGljZSB0aGUgb3JpZ2luYWwgYXJyYXlcbiAgICBsYWJlbHMgPSAobWluID09PSAwICYmIG1heCA9PT0gbGFiZWxzLmxlbmd0aCAtIDEpID8gbGFiZWxzIDogbGFiZWxzLnNsaWNlKG1pbiwgbWF4ICsgMSk7XG5cbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gTWF0aC5tYXgobGFiZWxzLmxlbmd0aCAtIChvZmZzZXQgPyAwIDogMSksIDEpO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB0aGlzLm1pbiAtIChvZmZzZXQgPyAwLjUgOiAwKTtcblxuICAgIGZvciAobGV0IHZhbHVlID0gbWluOyB2YWx1ZSA8PSBtYXg7IHZhbHVlKyspIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlfSk7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gX2dldExhYmVsRm9yVmFsdWUuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29uZmlndXJlKCkge1xuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuXG4gICAgaWYgKCF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdmVydGljYWwgY2F0ZWdvcnkgc2NhbGUgcmV2ZXJzZSBpcyBpbnZlcnRlZC5cbiAgICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSAhdGhpcy5fcmV2ZXJzZVBpeGVscztcbiAgICB9XG4gIH1cblxuICAvLyBVc2VkIHRvIGdldCBkYXRhIHZhbHVlIGxvY2F0aW9ucy4gVmFsdWUgY2FuIGVpdGhlciBiZSBhbiBpbmRleCBvciBhIG51bWVyaWNhbCB2YWx1ZVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuXG4gIC8vIE11c3Qgb3ZlcnJpZGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBiZWNhdXNlIGl0IGNhbGxzIGdldFBpeGVsRm9yVmFsdWVcbiAgLy8gYW5kIGNhdGVnb3J5IHNjYWxlIGNhbiBoYXZlIGR1cGxpY2F0ZSB2YWx1ZXNcbiAgZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0udmFsdWUpO1xuICB9XG5cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMuX3N0YXJ0VmFsdWUgKyB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuXG4gIGdldEJhc2VQaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3R0b207XG4gIH1cbn1cbiIsICJpbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7YWxtb3N0RXF1YWxzLCBhbG1vc3RXaG9sZSwgbmljZU51bSwgX2RlY2ltYWxQbGFjZXMsIF9zZXRNaW5BbmRNYXhCeUtleSwgc2lnbiwgdG9SYWRpYW5zfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQgU2NhbGUgZnJvbSAnLi4vY29yZS9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCB7Zm9ybWF0TnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50bC5qcyc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzZXQgb2YgbGluZWFyIHRpY2tzIGZvciBhbiBheGlzXG4gKiAxLiBJZiBnZW5lcmF0aW9uT3B0aW9ucy5taW4sIGdlbmVyYXRpb25PcHRpb25zLm1heCwgYW5kIGdlbmVyYXRpb25PcHRpb25zLnN0ZXAgYXJlIGRlZmluZWQ6XG4gKiAgICBpZiAobWF4IC0gbWluKSAvIHN0ZXAgaXMgYW4gaW50ZWdlciwgdGlja3MgYXJlIGdlbmVyYXRlZCBhcyBbbWluLCBtaW4gKyBzdGVwLCAuLi4sIG1heF1cbiAqICAgIE5vdGUgdGhhdCB0aGUgZ2VuZXJhdGlvbk9wdGlvbnMubWF4Q291bnQgc2V0dGluZyBpcyByZXNwZWN0ZWQgaW4gdGhpcyBzY2VuYXJpb1xuICpcbiAqIDIuIElmIGdlbmVyYXRpb25PcHRpb25zLm1pbiwgZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCBhbmQgZ2VuZXJhdGlvbk9wdGlvbnMuY291bnQgaXMgZGVmaW5lZFxuICogICAgc3BhY2luZyA9IChtYXggLSBtaW4pIC8gY291bnRcbiAqICAgIFRpY2tzIGFyZSBnZW5lcmF0ZWQgYXMgW21pbiwgbWluICsgc3BhY2luZywgLi4uLCBtYXhdXG4gKlxuICogMy4gSWYgZ2VuZXJhdGlvbk9wdGlvbnMuY291bnQgaXMgZGVmaW5lZFxuICogICAgc3BhY2luZyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBjb3VudFxuICpcbiAqIDQuIENvbXB1dGUgb3B0aW1hbCBzcGFjaW5nIG9mIHRpY2tzIHVzaW5nIG5pY2VOdW0gYWxnb3JpdGhtXG4gKlxuICogQHBhcmFtIGdlbmVyYXRpb25PcHRpb25zIHRoZSBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpY2tzXG4gKiBAcGFyYW0gZGF0YVJhbmdlIHRoZSByYW5nZSBvZiB0aGUgZGF0YVxuICogQHJldHVybnMge29iamVjdFtdfSBhcnJheSBvZiB0aWNrIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIC8vIFRvIGdldCBhIFwibmljZVwiIHZhbHVlIGZvciB0aGUgdGljayBzcGFjaW5nLCB3ZSB3aWxsIHVzZSB0aGUgYXBwcm9wcmlhdGVseSBuYW1lZFxuICAvLyBcIm5pY2UgbnVtYmVyXCIgYWxnb3JpdGhtLiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODUwNjg4MS9uaWNlLWxhYmVsLWFsZ29yaXRobS1mb3ItY2hhcnRzLXdpdGgtbWluaW11bS10aWNrc1xuICAvLyBmb3IgZGV0YWlscy5cblxuICBjb25zdCBNSU5fU1BBQ0lORyA9IDFlLTE0O1xuICBjb25zdCB7Ym91bmRzLCBzdGVwLCBtaW4sIG1heCwgcHJlY2lzaW9uLCBjb3VudCwgbWF4VGlja3MsIG1heERpZ2l0cywgaW5jbHVkZUJvdW5kc30gPSBnZW5lcmF0aW9uT3B0aW9ucztcbiAgY29uc3QgdW5pdCA9IHN0ZXAgfHwgMTtcbiAgY29uc3QgbWF4U3BhY2VzID0gbWF4VGlja3MgLSAxO1xuICBjb25zdCB7bWluOiBybWluLCBtYXg6IHJtYXh9ID0gZGF0YVJhbmdlO1xuICBjb25zdCBtaW5EZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWluKTtcbiAgY29uc3QgbWF4RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKG1heCk7XG4gIGNvbnN0IGNvdW50RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKGNvdW50KTtcbiAgY29uc3QgbWluU3BhY2luZyA9IChybWF4IC0gcm1pbikgLyAobWF4RGlnaXRzICsgMSk7XG4gIGxldCBzcGFjaW5nID0gbmljZU51bSgocm1heCAtIHJtaW4pIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuICBsZXQgZmFjdG9yLCBuaWNlTWluLCBuaWNlTWF4LCBudW1TcGFjZXM7XG5cbiAgLy8gQmV5b25kIE1JTl9TUEFDSU5HIGZsb2F0aW5nIHBvaW50IG51bWJlcnMgYmVpbmcgdG8gbG9zZSBwcmVjaXNpb25cbiAgLy8gc3VjaCB0aGF0IHdlIGNhbid0IGRvIHRoZSBtYXRoIG5lY2Vzc2FyeSB0byBnZW5lcmF0ZSB0aWNrc1xuICBpZiAoc3BhY2luZyA8IE1JTl9TUEFDSU5HICYmICFtaW5EZWZpbmVkICYmICFtYXhEZWZpbmVkKSB7XG4gICAgcmV0dXJuIFt7dmFsdWU6IHJtaW59LCB7dmFsdWU6IHJtYXh9XTtcbiAgfVxuXG4gIG51bVNwYWNlcyA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgLSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKTtcbiAgaWYgKG51bVNwYWNlcyA+IG1heFNwYWNlcykge1xuICAgIC8vIElmIHRoZSBjYWxjdWxhdGVkIG51bSBvZiBzcGFjZXMgZXhjZWVkcyBtYXhOdW1TcGFjZXMsIHJlY2FsY3VsYXRlIGl0XG4gICAgc3BhY2luZyA9IG5pY2VOdW0obnVtU3BhY2VzICogc3BhY2luZyAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcbiAgfVxuXG4gIGlmICghaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pKSB7XG4gICAgLy8gSWYgdGhlIHVzZXIgc3BlY2lmaWVkIGEgcHJlY2lzaW9uLCByb3VuZCB0byB0aGF0IG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICAgIGZhY3RvciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIH1cblxuICBpZiAoYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgbmljZU1pbiA9IE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcbiAgICBuaWNlTWF4ID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gIH0gZWxzZSB7XG4gICAgbmljZU1pbiA9IHJtaW47XG4gICAgbmljZU1heCA9IHJtYXg7XG4gIH1cblxuICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkICYmIHN0ZXAgJiYgYWxtb3N0V2hvbGUoKG1heCAtIG1pbikgLyBzdGVwLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICAvLyBDYXNlIDE6IElmIG1pbiwgbWF4IGFuZCBzdGVwU2l6ZSBhcmUgc2V0IGFuZCB0aGV5IG1ha2UgYW4gZXZlbmx5IHNwYWNlZCBzY2FsZSB1c2UgaXQuXG4gICAgLy8gc3BhY2luZyA9IHN0ZXA7XG4gICAgLy8gbnVtU3BhY2VzID0gKG1heCAtIG1pbikgLyBzcGFjaW5nO1xuICAgIC8vIE5vdGUgdGhhdCB3ZSByb3VuZCBoZXJlIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhbG1vc3RXaG9sZSB0cmFuc2xhdGVkIGFuIEZQIGVycm9yXG4gICAgbnVtU3BhY2VzID0gTWF0aC5yb3VuZChNYXRoLm1pbigobWF4IC0gbWluKSAvIHNwYWNpbmcsIG1heFRpY2tzKSk7XG4gICAgc3BhY2luZyA9IChtYXggLSBtaW4pIC8gbnVtU3BhY2VzO1xuICAgIG5pY2VNaW4gPSBtaW47XG4gICAgbmljZU1heCA9IG1heDtcbiAgfSBlbHNlIGlmIChjb3VudERlZmluZWQpIHtcbiAgICAvLyBDYXNlcyAyICYgMywgd2UgaGF2ZSBhIGNvdW50IHNwZWNpZmllZC4gSGFuZGxlIG9wdGlvbmFsIHVzZXIgZGVmaW5lZCBlZGdlcyB0byB0aGUgcmFuZ2UuXG4gICAgLy8gU29tZXRpbWVzIHRoZXNlIGFyZSBuby1vcHMsIGJ1dCBpdCBtYWtlcyB0aGUgY29kZSBhIGxvdCBjbGVhcmVyXG4gICAgLy8gYW5kIHdoZW4gYSB1c2VyIGRlZmluZWQgcmFuZ2UgaXMgc3BlY2lmaWVkLCB3ZSB3YW50IHRoZSBjb3JyZWN0IHRpY2tzXG4gICAgbmljZU1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiBuaWNlTWluO1xuICAgIG5pY2VNYXggPSBtYXhEZWZpbmVkID8gbWF4IDogbmljZU1heDtcbiAgICBudW1TcGFjZXMgPSBjb3VudCAtIDE7XG4gICAgc3BhY2luZyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBudW1TcGFjZXM7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FzZSA0XG4gICAgbnVtU3BhY2VzID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIHNwYWNpbmc7XG5cbiAgICAvLyBJZiB2ZXJ5IGNsb3NlIHRvIG91ciByb3VuZGVkIHZhbHVlLCB1c2UgaXQuXG4gICAgaWYgKGFsbW9zdEVxdWFscyhudW1TcGFjZXMsIE1hdGgucm91bmQobnVtU3BhY2VzKSwgc3BhY2luZyAvIDEwMDApKSB7XG4gICAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKG51bVNwYWNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bVNwYWNlcyA9IE1hdGguY2VpbChudW1TcGFjZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoZSBzcGFjaW5nIHdpbGwgaGF2ZSBjaGFuZ2VkIGluIGNhc2VzIDEsIDIsIGFuZCAzIHNvIHRoZSBmYWN0b3IgY2Fubm90IGJlIGNvbXB1dGVkXG4gIC8vIHVudGlsIHRoaXMgcG9pbnRcbiAgY29uc3QgZGVjaW1hbFBsYWNlcyA9IE1hdGgubWF4KFxuICAgIF9kZWNpbWFsUGxhY2VzKHNwYWNpbmcpLFxuICAgIF9kZWNpbWFsUGxhY2VzKG5pY2VNaW4pXG4gICk7XG4gIGZhY3RvciA9IE1hdGgucG93KDEwLCBpc051bGxPclVuZGVmKHByZWNpc2lvbikgPyBkZWNpbWFsUGxhY2VzIDogcHJlY2lzaW9uKTtcbiAgbmljZU1pbiA9IE1hdGgucm91bmQobmljZU1pbiAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIG5pY2VNYXggPSBNYXRoLnJvdW5kKG5pY2VNYXggKiBmYWN0b3IpIC8gZmFjdG9yO1xuXG4gIGxldCBqID0gMDtcbiAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICBpZiAoaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWluICE9PSBtaW4pIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtaW59KTtcblxuICAgICAgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgICAgaisrOyAvLyBTa2lwIG5pY2VNaW5cbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBuZXh0IG5pY2UgdGljayBpcyBjbG9zZSB0byBtaW4sIHNraXAgaXRcbiAgICAgIGlmIChhbG1vc3RFcXVhbHMoTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3IsIG1pbiwgcmVsYXRpdmVMYWJlbFNpemUobWluLCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgIGorKztcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG51bVNwYWNlczsgKytqKSB7XG4gICAgY29uc3QgdGlja1ZhbHVlID0gTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3I7XG4gICAgaWYgKG1heERlZmluZWQgJiYgdGlja1ZhbHVlID4gbWF4KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IHRpY2tWYWx1ZX0pO1xuICB9XG5cbiAgaWYgKG1heERlZmluZWQgJiYgaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWF4ICE9PSBtYXgpIHtcbiAgICAvLyBJZiB0aGUgcHJldmlvdXMgdGljayBpcyB0b28gY2xvc2UgdG8gbWF4LCByZXBsYWNlIGl0IHdpdGggbWF4LCBlbHNlIGFkZCBtYXhcbiAgICBpZiAodGlja3MubGVuZ3RoICYmIGFsbW9zdEVxdWFscyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSwgbWF4LCByZWxhdGl2ZUxhYmVsU2l6ZShtYXgsIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgIHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlID0gbWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbWF4fSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFtYXhEZWZpbmVkIHx8IG5pY2VNYXggPT09IG1heCkge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBuaWNlTWF4fSk7XG4gIH1cblxuICByZXR1cm4gdGlja3M7XG59XG5cbmZ1bmN0aW9uIHJlbGF0aXZlTGFiZWxTaXplKHZhbHVlLCBtaW5TcGFjaW5nLCB7aG9yaXpvbnRhbCwgbWluUm90YXRpb259KSB7XG4gIGNvbnN0IHJhZCA9IHRvUmFkaWFucyhtaW5Sb3RhdGlvbik7XG4gIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihyYWQpIDogTWF0aC5jb3MocmFkKSkgfHwgMC4wMDE7XG4gIGNvbnN0IGxlbmd0aCA9IDAuNzUgKiBtaW5TcGFjaW5nICogKCcnICsgdmFsdWUpLmxlbmd0aDtcbiAgcmV0dXJuIE1hdGgubWluKG1pblNwYWNpbmcgLyByYXRpbywgbGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZWFyU2NhbGVCYXNlIGV4dGVuZHMgU2NhbGUge1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fZW5kVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cblxuICBwYXJzZShyYXcsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCh0eXBlb2YgcmF3ID09PSAnbnVtYmVyJyB8fCByYXcgaW5zdGFuY2VvZiBOdW1iZXIpICYmICFpc0Zpbml0ZSgrcmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuICtyYXc7XG4gIH1cblxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IHtiZWdpbkF0WmVyb30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHttaW4sIG1heH0gPSB0aGlzO1xuXG4gICAgY29uc3Qgc2V0TWluID0gdiA9PiAobWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHYpO1xuICAgIGNvbnN0IHNldE1heCA9IHYgPT4gKG1heCA9IG1heERlZmluZWQgPyBtYXggOiB2KTtcblxuICAgIGlmIChiZWdpbkF0WmVybykge1xuICAgICAgY29uc3QgbWluU2lnbiA9IHNpZ24obWluKTtcbiAgICAgIGNvbnN0IG1heFNpZ24gPSBzaWduKG1heCk7XG5cbiAgICAgIGlmIChtaW5TaWduIDwgMCAmJiBtYXhTaWduIDwgMCkge1xuICAgICAgICBzZXRNYXgoMCk7XG4gICAgICB9IGVsc2UgaWYgKG1pblNpZ24gPiAwICYmIG1heFNpZ24gPiAwKSB7XG4gICAgICAgIHNldE1pbigwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIGxldCBvZmZzZXQgPSBtYXggPT09IDAgPyAxIDogTWF0aC5hYnMobWF4ICogMC4wNSk7XG5cbiAgICAgIHNldE1heChtYXggKyBvZmZzZXQpO1xuXG4gICAgICBpZiAoIWJlZ2luQXRaZXJvKSB7XG4gICAgICAgIHNldE1pbihtaW4gLSBvZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuXG4gIGdldFRpY2tMaW1pdCgpIHtcbiAgICBjb25zdCB0aWNrT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgbGV0IHttYXhUaWNrc0xpbWl0LCBzdGVwU2l6ZX0gPSB0aWNrT3B0cztcbiAgICBsZXQgbWF4VGlja3M7XG5cbiAgICBpZiAoc3RlcFNpemUpIHtcbiAgICAgIG1heFRpY2tzID0gTWF0aC5jZWlsKHRoaXMubWF4IC8gc3RlcFNpemUpIC0gTWF0aC5mbG9vcih0aGlzLm1pbiAvIHN0ZXBTaXplKSArIDE7XG4gICAgICBpZiAobWF4VGlja3MgPiAxMDAwKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihgc2NhbGVzLiR7dGhpcy5pZH0udGlja3Muc3RlcFNpemU6ICR7c3RlcFNpemV9IHdvdWxkIHJlc3VsdCBnZW5lcmF0aW5nIHVwIHRvICR7bWF4VGlja3N9IHRpY2tzLiBMaW1pdGluZyB0byAxMDAwLmApO1xuICAgICAgICBtYXhUaWNrcyA9IDEwMDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heFRpY2tzID0gdGhpcy5jb21wdXRlVGlja0xpbWl0KCk7XG4gICAgICBtYXhUaWNrc0xpbWl0ID0gbWF4VGlja3NMaW1pdCB8fCAxMTtcbiAgICB9XG5cbiAgICBpZiAobWF4VGlja3NMaW1pdCkge1xuICAgICAgbWF4VGlja3MgPSBNYXRoLm1pbihtYXhUaWNrc0xpbWl0LCBtYXhUaWNrcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heFRpY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgfVxuXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cbiAgICAvLyBGaWd1cmUgb3V0IHdoYXQgdGhlIG1heCBudW1iZXIgb2YgdGlja3Mgd2UgY2FuIHN1cHBvcnQgaXQgaXMgYmFzZWQgb24gdGhlIHNpemUgb2ZcbiAgICAvLyB0aGUgYXhpcyBhcmVhLiBGb3Igbm93LCB3ZSBzYXkgdGhhdCB0aGUgbWluaW11bSB0aWNrIHNwYWNpbmcgaW4gcGl4ZWxzIG11c3QgYmUgNDBcbiAgICAvLyBXZSBhbHNvIGxpbWl0IHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyB0byAxMSB3aGljaCBnaXZlcyBhIG5pY2UgMTAgc3F1YXJlcyBvblxuICAgIC8vIHRoZSBncmFwaC4gTWFrZSBzdXJlIHdlIGFsd2F5cyBoYXZlIGF0IGxlYXN0IDIgdGlja3NcbiAgICBsZXQgbWF4VGlja3MgPSB0aGlzLmdldFRpY2tMaW1pdCgpO1xuICAgIG1heFRpY2tzID0gTWF0aC5tYXgoMiwgbWF4VGlja3MpO1xuXG4gICAgY29uc3QgbnVtZXJpY0dlbmVyYXRvck9wdGlvbnMgPSB7XG4gICAgICBtYXhUaWNrcyxcbiAgICAgIGJvdW5kczogb3B0cy5ib3VuZHMsXG4gICAgICBtaW46IG9wdHMubWluLFxuICAgICAgbWF4OiBvcHRzLm1heCxcbiAgICAgIHByZWNpc2lvbjogdGlja09wdHMucHJlY2lzaW9uLFxuICAgICAgc3RlcDogdGlja09wdHMuc3RlcFNpemUsXG4gICAgICBjb3VudDogdGlja09wdHMuY291bnQsXG4gICAgICBtYXhEaWdpdHM6IHRoaXMuX21heERpZ2l0cygpLFxuICAgICAgaG9yaXpvbnRhbDogdGhpcy5pc0hvcml6b250YWwoKSxcbiAgICAgIG1pblJvdGF0aW9uOiB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwLFxuICAgICAgaW5jbHVkZUJvdW5kczogdGlja09wdHMuaW5jbHVkZUJvdW5kcyAhPT0gZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGRhdGFSYW5nZSA9IHRoaXMuX3JhbmdlIHx8IHRoaXM7XG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzKG51bWVyaWNHZW5lcmF0b3JPcHRpb25zLCBkYXRhUmFuZ2UpO1xuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB1cGRhdGUgb3VyIG1heCBhbmQgbWluIGdpdmVuIHRoZSB0aWNrIHZhbHVlcyxcbiAgICAvLyBzaW5jZSB3ZSBwcm9iYWJseSBoYXZlIGV4cGFuZGVkIHRoZSByYW5nZSBvZiB0aGUgc2NhbGVcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgdGhpcywgJ3ZhbHVlJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuXG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgIH1cblxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGxldCBzdGFydCA9IHRoaXMubWluO1xuICAgIGxldCBlbmQgPSB0aGlzLm1heDtcblxuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGlja3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSAoZW5kIC0gc3RhcnQpIC8gTWF0aC5tYXgodGlja3MubGVuZ3RoIC0gMSwgMSkgLyAyO1xuICAgICAgc3RhcnQgLT0gb2Zmc2V0O1xuICAgICAgZW5kICs9IG9mZnNldDtcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHN0YXJ0O1xuICAgIHRoaXMuX2VuZFZhbHVlID0gZW5kO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBlbmQgLSBzdGFydDtcbiAgfVxuXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgfVxufVxuIiwgImltcG9ydCB7aXNGaW5pdGV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCBMaW5lYXJTY2FsZUJhc2UgZnJvbSAnLi9zY2FsZS5saW5lYXJiYXNlLmpzJztcbmltcG9ydCBUaWNrcyBmcm9tICcuLi9jb3JlL2NvcmUudGlja3MuanMnO1xuaW1wb3J0IHt0b1JhZGlhbnN9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XG5cbiAgc3RhdGljIGlkID0gJ2xpbmVhcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgdGlja3M6IHtcbiAgICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgICB9XG4gIH07XG5cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcblxuICAgIHRoaXMubWluID0gaXNGaW5pdGUobWluKSA/IG1pbiA6IDA7XG4gICAgdGhpcy5tYXggPSBpc0Zpbml0ZShtYXgpID8gbWF4IDogMTtcblxuICAgIC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSBtaW4sIG1heCwgYmVnaW5BdFplcm9cbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyBiYXNlZCBvbiB0aGUgc2NhbGUgZGltZW5zaW9uXG5cdCAqIEBwcm90ZWN0ZWRcbiBcdCAqL1xuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGhvcml6b250YWwgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluUm90YXRpb24gPSB0b1JhZGlhbnModGhpcy5vcHRpb25zLnRpY2tzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4obWluUm90YXRpb24pIDogTWF0aC5jb3MobWluUm90YXRpb24pKSB8fCAwLjAwMTtcbiAgICBjb25zdCB0aWNrRm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCk7XG4gICAgcmV0dXJuIE1hdGguY2VpbChsZW5ndGggLyBNYXRoLm1pbig0MCwgdGlja0ZvbnQubGluZUhlaWdodCAvIHJhdGlvKSk7XG4gIH1cblxuICAvLyBVdGlsc1xuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2U7XG4gIH1cbn1cbiIsICJpbXBvcnQge2Zpbml0ZU9yRGVmYXVsdCwgaXNGaW5pdGV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7Zm9ybWF0TnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50bC5qcyc7XG5pbXBvcnQge19zZXRNaW5BbmRNYXhCeUtleSwgbG9nMTB9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCBTY2FsZSBmcm9tICcuLi9jb3JlL2NvcmUuc2NhbGUuanMnO1xuaW1wb3J0IExpbmVhclNjYWxlQmFzZSBmcm9tICcuL3NjYWxlLmxpbmVhcmJhc2UuanMnO1xuaW1wb3J0IFRpY2tzIGZyb20gJy4uL2NvcmUvY29yZS50aWNrcy5qcyc7XG5cbmNvbnN0IGxvZzEwRmxvb3IgPSB2ID0+IE1hdGguZmxvb3IobG9nMTAodikpO1xuY29uc3QgY2hhbmdlRXhwb25lbnQgPSAodiwgbSkgPT4gTWF0aC5wb3coMTAsIGxvZzEwRmxvb3IodikgKyBtKTtcblxuZnVuY3Rpb24gaXNNYWpvcih0aWNrVmFsKSB7XG4gIGNvbnN0IHJlbWFpbiA9IHRpY2tWYWwgLyAoTWF0aC5wb3coMTAsIGxvZzEwRmxvb3IodGlja1ZhbCkpKTtcbiAgcmV0dXJuIHJlbWFpbiA9PT0gMTtcbn1cblxuZnVuY3Rpb24gc3RlcHMobWluLCBtYXgsIHJhbmdlRXhwKSB7XG4gIGNvbnN0IHJhbmdlU3RlcCA9IE1hdGgucG93KDEwLCByYW5nZUV4cCk7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5mbG9vcihtaW4gLyByYW5nZVN0ZXApO1xuICBjb25zdCBlbmQgPSBNYXRoLmNlaWwobWF4IC8gcmFuZ2VTdGVwKTtcbiAgcmV0dXJuIGVuZCAtIHN0YXJ0O1xufVxuXG5mdW5jdGlvbiBzdGFydEV4cChtaW4sIG1heCkge1xuICBjb25zdCByYW5nZSA9IG1heCAtIG1pbjtcbiAgbGV0IHJhbmdlRXhwID0gbG9nMTBGbG9vcihyYW5nZSk7XG4gIHdoaWxlIChzdGVwcyhtaW4sIG1heCwgcmFuZ2VFeHApID4gMTApIHtcbiAgICByYW5nZUV4cCsrO1xuICB9XG4gIHdoaWxlIChzdGVwcyhtaW4sIG1heCwgcmFuZ2VFeHApIDwgMTApIHtcbiAgICByYW5nZUV4cC0tO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihyYW5nZUV4cCwgbG9nMTBGbG9vcihtaW4pKTtcbn1cblxuXG4vKipcbiAqIEdlbmVyYXRlIGEgc2V0IG9mIGxvZ2FyaXRobWljIHRpY2tzXG4gKiBAcGFyYW0gZ2VuZXJhdGlvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGlja3NcbiAqIEBwYXJhbSBkYXRhUmFuZ2UgdGhlIHJhbmdlIG9mIHRoZSBkYXRhXG4gKiBAcmV0dXJucyB7b2JqZWN0W119IGFycmF5IG9mIHRpY2sgb2JqZWN0c1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCB7bWluLCBtYXh9KSB7XG4gIG1pbiA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5taW4sIG1pbik7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGNvbnN0IG1pbkV4cCA9IGxvZzEwRmxvb3IobWluKTtcbiAgbGV0IGV4cCA9IHN0YXJ0RXhwKG1pbiwgbWF4KTtcbiAgbGV0IHByZWNpc2lvbiA9IGV4cCA8IDAgPyBNYXRoLnBvdygxMCwgTWF0aC5hYnMoZXhwKSkgOiAxO1xuICBjb25zdCBzdGVwU2l6ZSA9IE1hdGgucG93KDEwLCBleHApO1xuICBjb25zdCBiYXNlID0gbWluRXhwID4gZXhwID8gTWF0aC5wb3coMTAsIG1pbkV4cCkgOiAwO1xuICBjb25zdCBzdGFydCA9IE1hdGgucm91bmQoKG1pbiAtIGJhc2UpICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5mbG9vcigobWluIC0gYmFzZSkgLyBzdGVwU2l6ZSAvIDEwKSAqIHN0ZXBTaXplICogMTA7XG4gIGxldCBzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IoKHN0YXJ0IC0gb2Zmc2V0KSAvIE1hdGgucG93KDEwLCBleHApKTtcbiAgbGV0IHZhbHVlID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1pbiwgTWF0aC5yb3VuZCgoYmFzZSArIG9mZnNldCArIHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCkpICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbik7XG4gIHdoaWxlICh2YWx1ZSA8IG1heCkge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlLCBtYWpvcjogaXNNYWpvcih2YWx1ZSksIHNpZ25pZmljYW5kfSk7XG4gICAgaWYgKHNpZ25pZmljYW5kID49IDEwKSB7XG4gICAgICBzaWduaWZpY2FuZCA9IHNpZ25pZmljYW5kIDwgMTUgPyAxNSA6IDIwO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaWduaWZpY2FuZCsrO1xuICAgIH1cbiAgICBpZiAoc2lnbmlmaWNhbmQgPj0gMjApIHtcbiAgICAgIGV4cCsrO1xuICAgICAgc2lnbmlmaWNhbmQgPSAyO1xuICAgICAgcHJlY2lzaW9uID0gZXhwID49IDAgPyAxIDogcHJlY2lzaW9uO1xuICAgIH1cbiAgICB2YWx1ZSA9IE1hdGgucm91bmQoKGJhc2UgKyBvZmZzZXQgKyBzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gIH1cbiAgY29uc3QgbGFzdFRpY2sgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCB2YWx1ZSk7XG4gIHRpY2tzLnB1c2goe3ZhbHVlOiBsYXN0VGljaywgbWFqb3I6IGlzTWFqb3IobGFzdFRpY2spLCBzaWduaWZpY2FuZH0pO1xuXG4gIHJldHVybiB0aWNrcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9nYXJpdGhtaWNTY2FsZSBleHRlbmRzIFNjYWxlIHtcblxuICBzdGF0aWMgaWQgPSAnbG9nYXJpdGhtaWMnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIHRpY2tzOiB7XG4gICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5sb2dhcml0aG1pYyxcbiAgICAgIG1ham9yOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmVuZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICB9XG5cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGNvbnN0IHZhbHVlID0gTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5wYXJzZS5hcHBseSh0aGlzLCBbcmF3LCBpbmRleF0pO1xuICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgdGhpcy5femVybyA9IHRydWU7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpICYmIHZhbHVlID4gMCA/IHZhbHVlIDogbnVsbDtcbiAgfVxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuXG4gICAgdGhpcy5taW4gPSBpc0Zpbml0ZShtaW4pID8gTWF0aC5tYXgoMCwgbWluKSA6IG51bGw7XG4gICAgdGhpcy5tYXggPSBpc0Zpbml0ZShtYXgpID8gTWF0aC5tYXgoMCwgbWF4KSA6IG51bGw7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmJlZ2luQXRaZXJvKSB7XG4gICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBpZiBkYXRhIGhhcyBgMGAgaW4gaXQgb3IgYGJlZ2luQXRaZXJvYCBpcyB0cnVlLCBtaW4gKG5vbiB6ZXJvKSB2YWx1ZSBpcyBhdCBib3R0b21cbiAgICAvLyBvZiBzY2FsZSwgYW5kIGl0IGRvZXMgbm90IGVxdWFsIHN1Z2dlc3RlZE1pbiwgbG93ZXIgdGhlIG1pbiBib3VuZCBieSBvbmUgZXhwLlxuICAgIGlmICh0aGlzLl96ZXJvICYmIHRoaXMubWluICE9PSB0aGlzLl9zdWdnZXN0ZWRNaW4gJiYgIWlzRmluaXRlKHRoaXMuX3VzZXJNaW4pKSB7XG4gICAgICB0aGlzLm1pbiA9IG1pbiA9PT0gY2hhbmdlRXhwb25lbnQodGhpcy5taW4sIDApID8gY2hhbmdlRXhwb25lbnQodGhpcy5taW4sIC0xKSA6IGNoYW5nZUV4cG9uZW50KHRoaXMubWluLCAwKTtcbiAgICB9XG5cbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuXG4gIGhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKSB7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IG1pbiA9IHRoaXMubWluO1xuICAgIGxldCBtYXggPSB0aGlzLm1heDtcblxuICAgIGNvbnN0IHNldE1pbiA9IHYgPT4gKG1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiB2KTtcbiAgICBjb25zdCBzZXRNYXggPSB2ID0+IChtYXggPSBtYXhEZWZpbmVkID8gbWF4IDogdik7XG5cbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIGlmIChtaW4gPD0gMCkgeyAvLyBpbmNsdWRlcyBudWxsXG4gICAgICAgIHNldE1pbigxKTtcbiAgICAgICAgc2V0TWF4KDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldE1pbihjaGFuZ2VFeHBvbmVudChtaW4sIC0xKSk7XG4gICAgICAgIHNldE1heChjaGFuZ2VFeHBvbmVudChtYXgsICsxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaW4gPD0gMCkge1xuICAgICAgc2V0TWluKGNoYW5nZUV4cG9uZW50KG1heCwgLTEpKTtcbiAgICB9XG4gICAgaWYgKG1heCA8PSAwKSB7XG5cbiAgICAgIHNldE1heChjaGFuZ2VFeHBvbmVudChtaW4sICsxKSk7XG4gICAgfVxuXG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cblxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBjb25zdCBnZW5lcmF0aW9uT3B0aW9ucyA9IHtcbiAgICAgIG1pbjogdGhpcy5fdXNlck1pbixcbiAgICAgIG1heDogdGhpcy5fdXNlck1heFxuICAgIH07XG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCB0aGlzKTtcblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIG5lZWQgdG8gdXBkYXRlIG91ciBtYXggYW5kIG1pbiBnaXZlbiB0aGUgdGljayB2YWx1ZXMsXG4gICAgLy8gc2luY2Ugd2UgcHJvYmFibHkgaGF2ZSBleHBhbmRlZCB0aGUgcmFuZ2Ugb2YgdGhlIHNjYWxlXG4gICAgaWYgKG9wdHMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBfc2V0TWluQW5kTWF4QnlLZXkodGlja3MsIHRoaXMsICd2YWx1ZScpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcblxuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWF4O1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWluO1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1heDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgPyAnMCdcbiAgICAgIDogZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLm1pbjtcblxuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuXG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IGxvZzEwKHN0YXJ0KTtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gbG9nMTAodGhpcy5tYXgpIC0gbG9nMTAoc3RhcnQpO1xuICB9XG5cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMubWluO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwodmFsdWUgPT09IHRoaXMubWluXG4gICAgICA/IDBcbiAgICAgIDogKGxvZzEwKHZhbHVlKSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cblxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3QgZGVjaW1hbCA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKTtcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIHRoaXMuX3N0YXJ0VmFsdWUgKyBkZWNpbWFsICogdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vY29yZS9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7X2xvbmdlc3RUZXh0LCBhZGRSb3VuZGVkUmVjdFBhdGgsIHJlbmRlclRleHQsIF9pc1BvaW50SW5BcmVhfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7SEFMRl9QSSwgVEFVLCB0b0RlZ3JlZXMsIHRvUmFkaWFucywgX25vcm1hbGl6ZUFuZ2xlLCBQSX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IExpbmVhclNjYWxlQmFzZSBmcm9tICcuL3NjYWxlLmxpbmVhcmJhc2UuanMnO1xuaW1wb3J0IFRpY2tzIGZyb20gJy4uL2NvcmUvY29yZS50aWNrcy5qcyc7XG5pbXBvcnQge3ZhbHVlT3JEZWZhdWx0LCBpc0FycmF5LCBpc0Zpbml0ZSwgY2FsbGJhY2sgYXMgY2FsbENhbGxiYWNrLCBpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHQsIHRvRm9udCwgdG9QYWRkaW5nLCB0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5cbmZ1bmN0aW9uIGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuICBpZiAodGlja09wdHMuZGlzcGxheSAmJiBvcHRzLmRpc3BsYXkpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZyk7XG4gICAgcmV0dXJuIHZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLmZvbnQgJiYgdGlja09wdHMuZm9udC5zaXplLCBkZWZhdWx0cy5mb250LnNpemUpICsgcGFkZGluZy5oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIG1lYXN1cmVMYWJlbFNpemUoY3R4LCBmb250LCBsYWJlbCkge1xuICBsYWJlbCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwgOiBbbGFiZWxdO1xuICByZXR1cm4ge1xuICAgIHc6IF9sb25nZXN0VGV4dChjdHgsIGZvbnQuc3RyaW5nLCBsYWJlbCksXG4gICAgaDogbGFiZWwubGVuZ3RoICogZm9udC5saW5lSGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9zLCBzaXplLCBtaW4sIG1heCkge1xuICBpZiAoYW5nbGUgPT09IG1pbiB8fCBhbmdsZSA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwb3MgLSAoc2l6ZSAvIDIpLFxuICAgICAgZW5kOiBwb3MgKyAoc2l6ZSAvIDIpXG4gICAgfTtcbiAgfSBlbHNlIGlmIChhbmdsZSA8IG1pbiB8fCBhbmdsZSA+IG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogcG9zIC0gc2l6ZSxcbiAgICAgIGVuZDogcG9zXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHBvcyxcbiAgICBlbmQ6IHBvcyArIHNpemVcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZml0IGEgcmFkaWFsIGxpbmVhciBzY2FsZSB3aXRoIHBvaW50IGxhYmVsc1xuICovXG5mdW5jdGlvbiBmaXRXaXRoUG9pbnRMYWJlbHMoc2NhbGUpIHtcblxuICAvLyBSaWdodCwgdGhpcyBpcyByZWFsbHkgY29uZnVzaW5nIGFuZCB0aGVyZSBpcyBhIGxvdCBvZiBtYXRocyBnb2luZyBvbiBoZXJlXG4gIC8vIFRoZSBnaXN0IG9mIHRoZSBwcm9ibGVtIGlzIGhlcmU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL25ubmljay82OTZjYzljNTVmNGIwYmViOGZlOVxuICAvL1xuICAvLyBSZWFjdGlvbjogaHR0cHM6Ly9kbC5kcm9wYm94dXNlcmNvbnRlbnQuY29tL3UvMzQ2MDEzNjMvdG9vbXVjaHNjaWVuY2UuZ2lmXG4gIC8vXG4gIC8vIFNvbHV0aW9uOlxuICAvL1xuICAvLyBXZSBhc3N1bWUgdGhlIHJhZGl1cyBvZiB0aGUgcG9seWdvbiBpcyBoYWxmIHRoZSBzaXplIG9mIHRoZSBjYW52YXMgYXQgZmlyc3RcbiAgLy8gYXQgZWFjaCBpbmRleCB3ZSBjaGVjayBpZiB0aGUgdGV4dCBvdmVybGFwcy5cbiAgLy9cbiAgLy8gV2hlcmUgaXQgZG9lcywgd2Ugc3RvcmUgdGhhdCBhbmdsZSBhbmQgdGhhdCBpbmRleC5cbiAgLy9cbiAgLy8gQWZ0ZXIgZmluZGluZyB0aGUgbGFyZ2VzdCBpbmRleCBhbmQgYW5nbGUgd2UgY2FsY3VsYXRlIGhvdyBtdWNoIHdlIG5lZWQgdG8gcmVtb3ZlXG4gIC8vIGZyb20gdGhlIHNoYXBlIHJhZGl1cyB0byBtb3ZlIHRoZSBwb2ludCBpbndhcmRzIGJ5IHRoYXQgeC5cbiAgLy9cbiAgLy8gV2UgYXZlcmFnZSB0aGUgbGVmdCBhbmQgcmlnaHQgZGlzdGFuY2VzIHRvIGdldCB0aGUgbWF4aW11bSBzaGFwZSByYWRpdXMgdGhhdCBjYW4gZml0IGluIHRoZSBib3hcbiAgLy8gYWxvbmcgd2l0aCBsYWJlbHMuXG4gIC8vXG4gIC8vIE9uY2Ugd2UgaGF2ZSB0aGF0LCB3ZSBjYW4gZmluZCB0aGUgY2VudHJlIHBvaW50IGZvciB0aGUgY2hhcnQsIGJ5IHRha2luZyB0aGUgeCB0ZXh0IHByb3RydXNpb25cbiAgLy8gb24gZWFjaCBzaWRlLCByZW1vdmluZyB0aGF0IGZyb20gdGhlIHNpemUsIGhhbHZpbmcgaXQgYW5kIGFkZGluZyB0aGUgbGVmdCB4IHByb3RydXNpb24gd2lkdGguXG4gIC8vXG4gIC8vIFRoaXMgd2lsbCBtZWFuIHdlIGhhdmUgYSBzaGFwZSBmaXR0ZWQgdG8gdGhlIGNhbnZhcywgYXMgbGFyZ2UgYXMgaXQgY2FuIGJlIHdpdGggdGhlIGxhYmVsc1xuICAvLyBhbmQgcG9zaXRpb24gaXQgaW4gdGhlIG1vc3Qgc3BhY2UgZWZmaWNpZW50IG1hbm5lclxuICAvL1xuICAvLyBodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8zNDYwMTM2My95ZWFoc2NpZW5jZS5naWZcblxuICAvLyBHZXQgbWF4aW11bSByYWRpdXMgb2YgdGhlIHBvbHlnb24uIEVpdGhlciBoYWxmIHRoZSBoZWlnaHQgKG1pbnVzIHRoZSB0ZXh0IHdpZHRoKSBvciBoYWxmIHRoZSB3aWR0aC5cbiAgLy8gVXNlIHRoaXMgdG8gY2FsY3VsYXRlIHRoZSBvZmZzZXQgKyBjaGFuZ2UuIC0gTWFrZSBzdXJlIEwvUiBwcm90cnVzaW9uIGlzIGF0IGxlYXN0IDAgdG8gc3RvcCBpc3N1ZXMgd2l0aCBjZW50cmUgcG9pbnRzXG4gIGNvbnN0IG9yaWcgPSB7XG4gICAgbDogc2NhbGUubGVmdCArIHNjYWxlLl9wYWRkaW5nLmxlZnQsXG4gICAgcjogc2NhbGUucmlnaHQgLSBzY2FsZS5fcGFkZGluZy5yaWdodCxcbiAgICB0OiBzY2FsZS50b3AgKyBzY2FsZS5fcGFkZGluZy50b3AsXG4gICAgYjogc2NhbGUuYm90dG9tIC0gc2NhbGUuX3BhZGRpbmcuYm90dG9tXG4gIH07XG4gIGNvbnN0IGxpbWl0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWcpO1xuICBjb25zdCBsYWJlbFNpemVzID0gW107XG4gIGNvbnN0IHBhZGRpbmcgPSBbXTtcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XG4gIGNvbnN0IHBvaW50TGFiZWxPcHRzID0gc2NhbGUub3B0aW9ucy5wb2ludExhYmVscztcbiAgY29uc3QgYWRkaXRpb25hbEFuZ2xlID0gcG9pbnRMYWJlbE9wdHMuY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgY29uc3Qgb3B0cyA9IHBvaW50TGFiZWxPcHRzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgIHBhZGRpbmdbaV0gPSBvcHRzLnBhZGRpbmc7XG4gICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgc2NhbGUuZHJhd2luZ0FyZWEgKyBwYWRkaW5nW2ldLCBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbWVhc3VyZUxhYmVsU2l6ZShzY2FsZS5jdHgsIHBsRm9udCwgc2NhbGUuX3BvaW50TGFiZWxzW2ldKTtcbiAgICBsYWJlbFNpemVzW2ldID0gdGV4dFNpemU7XG5cbiAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSBfbm9ybWFsaXplQW5nbGUoc2NhbGUuZ2V0SW5kZXhBbmdsZShpKSArIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhhbmdsZVJhZGlhbnMpKTtcbiAgICBjb25zdCBoTGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLngsIHRleHRTaXplLncsIDAsIDE4MCk7XG4gICAgY29uc3QgdkxpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi55LCB0ZXh0U2l6ZS5oLCA5MCwgMjcwKTtcbiAgICB1cGRhdGVMaW1pdHMobGltaXRzLCBvcmlnLCBhbmdsZVJhZGlhbnMsIGhMaW1pdHMsIHZMaW1pdHMpO1xuICB9XG5cbiAgc2NhbGUuc2V0Q2VudGVyUG9pbnQoXG4gICAgb3JpZy5sIC0gbGltaXRzLmwsXG4gICAgbGltaXRzLnIgLSBvcmlnLnIsXG4gICAgb3JpZy50IC0gbGltaXRzLnQsXG4gICAgbGltaXRzLmIgLSBvcmlnLmJcbiAgKTtcblxuICAvLyBOb3cgdGhhdCB0ZXh0IHNpemUgaXMgZGV0ZXJtaW5lZCwgY29tcHV0ZSB0aGUgZnVsbCBwb3NpdGlvbnNcbiAgc2NhbGUuX3BvaW50TGFiZWxJdGVtcyA9IGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGltaXRzKGxpbWl0cywgb3JpZywgYW5nbGUsIGhMaW1pdHMsIHZMaW1pdHMpIHtcbiAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4oYW5nbGUpKTtcbiAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGUpKTtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmIChoTGltaXRzLnN0YXJ0IDwgb3JpZy5sKSB7XG4gICAgeCA9IChvcmlnLmwgLSBoTGltaXRzLnN0YXJ0KSAvIHNpbjtcbiAgICBsaW1pdHMubCA9IE1hdGgubWluKGxpbWl0cy5sLCBvcmlnLmwgLSB4KTtcbiAgfSBlbHNlIGlmIChoTGltaXRzLmVuZCA+IG9yaWcucikge1xuICAgIHggPSAoaExpbWl0cy5lbmQgLSBvcmlnLnIpIC8gc2luO1xuICAgIGxpbWl0cy5yID0gTWF0aC5tYXgobGltaXRzLnIsIG9yaWcuciArIHgpO1xuICB9XG4gIGlmICh2TGltaXRzLnN0YXJ0IDwgb3JpZy50KSB7XG4gICAgeSA9IChvcmlnLnQgLSB2TGltaXRzLnN0YXJ0KSAvIGNvcztcbiAgICBsaW1pdHMudCA9IE1hdGgubWluKGxpbWl0cy50LCBvcmlnLnQgLSB5KTtcbiAgfSBlbHNlIGlmICh2TGltaXRzLmVuZCA+IG9yaWcuYikge1xuICAgIHkgPSAodkxpbWl0cy5lbmQgLSBvcmlnLmIpIC8gY29zO1xuICAgIGxpbWl0cy5iID0gTWF0aC5tYXgobGltaXRzLmIsIG9yaWcuYiArIHkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50TGFiZWxJdGVtKHNjYWxlLCBpbmRleCwgaXRlbU9wdHMpIHtcbiAgY29uc3Qgb3V0ZXJEaXN0YW5jZSA9IHNjYWxlLmRyYXdpbmdBcmVhO1xuICBjb25zdCB7ZXh0cmEsIGFkZGl0aW9uYWxBbmdsZSwgcGFkZGluZywgc2l6ZX0gPSBpdGVtT3B0cztcbiAgY29uc3QgcG9pbnRMYWJlbFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgb3V0ZXJEaXN0YW5jZSArIGV4dHJhICsgcGFkZGluZywgYWRkaXRpb25hbEFuZ2xlKTtcbiAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhfbm9ybWFsaXplQW5nbGUocG9pbnRMYWJlbFBvc2l0aW9uLmFuZ2xlICsgSEFMRl9QSSkpKTtcbiAgY29uc3QgeSA9IHlGb3JBbmdsZShwb2ludExhYmVsUG9zaXRpb24ueSwgc2l6ZS5oLCBhbmdsZSk7XG4gIGNvbnN0IHRleHRBbGlnbiA9IGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKTtcbiAgY29uc3QgbGVmdCA9IGxlZnRGb3JUZXh0QWxpZ24ocG9pbnRMYWJlbFBvc2l0aW9uLngsIHNpemUudywgdGV4dEFsaWduKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBpZiB0byBkcmF3IG9yIG92ZXJsYXBwZWRcbiAgICB2aXNpYmxlOiB0cnVlLFxuXG4gICAgLy8gVGV4dCBwb3NpdGlvblxuICAgIHg6IHBvaW50TGFiZWxQb3NpdGlvbi54LFxuICAgIHksXG5cbiAgICAvLyBUZXh0IHJlbmRlcmluZyBkYXRhXG4gICAgdGV4dEFsaWduLFxuXG4gICAgLy8gQm91bmRpbmcgYm94XG4gICAgbGVmdCxcbiAgICB0b3A6IHksXG4gICAgcmlnaHQ6IGxlZnQgKyBzaXplLncsXG4gICAgYm90dG9tOiB5ICsgc2l6ZS5oXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzTm90T3ZlcmxhcHBlZChpdGVtLCBhcmVhKSB7XG4gIGlmICghYXJlYSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gaXRlbTtcbiAgY29uc3QgYXBleGVzSW5BcmVhID0gX2lzUG9pbnRJbkFyZWEoe3g6IGxlZnQsIHk6IHRvcH0sIGFyZWEpIHx8IF9pc1BvaW50SW5BcmVhKHt4OiBsZWZ0LCB5OiBib3R0b219LCBhcmVhKSB8fFxuICAgIF9pc1BvaW50SW5BcmVhKHt4OiByaWdodCwgeTogdG9wfSwgYXJlYSkgfHwgX2lzUG9pbnRJbkFyZWEoe3g6IHJpZ2h0LCB5OiBib3R0b219LCBhcmVhKTtcbiAgcmV0dXJuICFhcGV4ZXNJbkFyZWE7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGNvbnN0IHZhbHVlQ291bnQgPSBzY2FsZS5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICBjb25zdCBvcHRzID0gc2NhbGUub3B0aW9ucztcbiAgY29uc3Qge2NlbnRlclBvaW50TGFiZWxzLCBkaXNwbGF5fSA9IG9wdHMucG9pbnRMYWJlbHM7XG4gIGNvbnN0IGl0ZW1PcHRzID0ge1xuICAgIGV4dHJhOiBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cykgLyAyLFxuICAgIGFkZGl0aW9uYWxBbmdsZTogY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwXG4gIH07XG4gIGxldCBhcmVhO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgaXRlbU9wdHMucGFkZGluZyA9IHBhZGRpbmdbaV07XG4gICAgaXRlbU9wdHMuc2l6ZSA9IGxhYmVsU2l6ZXNbaV07XG5cbiAgICBjb25zdCBpdGVtID0gY3JlYXRlUG9pbnRMYWJlbEl0ZW0oc2NhbGUsIGksIGl0ZW1PcHRzKTtcbiAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgIGlmIChkaXNwbGF5ID09PSAnYXV0bycpIHtcbiAgICAgIGl0ZW0udmlzaWJsZSA9IGlzTm90T3ZlcmxhcHBlZChpdGVtLCBhcmVhKTtcbiAgICAgIGlmIChpdGVtLnZpc2libGUpIHtcbiAgICAgICAgYXJlYSA9IGl0ZW07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpdGVtcztcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpIHtcbiAgaWYgKGFuZ2xlID09PSAwIHx8IGFuZ2xlID09PSAxODApIHtcbiAgICByZXR1cm4gJ2NlbnRlcic7XG4gIH0gZWxzZSBpZiAoYW5nbGUgPCAxODApIHtcbiAgICByZXR1cm4gJ2xlZnQnO1xuICB9XG5cbiAgcmV0dXJuICdyaWdodCc7XG59XG5cbmZ1bmN0aW9uIGxlZnRGb3JUZXh0QWxpZ24oeCwgdywgYWxpZ24pIHtcbiAgaWYgKGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3O1xuICB9IGVsc2UgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gKHcgLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24geUZvckFuZ2xlKHksIGgsIGFuZ2xlKSB7XG4gIGlmIChhbmdsZSA9PT0gOTAgfHwgYW5nbGUgPT09IDI3MCkge1xuICAgIHkgLT0gKGggLyAyKTtcbiAgfSBlbHNlIGlmIChhbmdsZSA+IDI3MCB8fCBhbmdsZSA8IDkwKSB7XG4gICAgeSAtPSBoO1xuICB9XG4gIHJldHVybiB5O1xufVxuXG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbEJveChjdHgsIG9wdHMsIGl0ZW0pIHtcbiAgY29uc3Qge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSBpdGVtO1xuICBjb25zdCB7YmFja2Ryb3BDb2xvcn0gPSBvcHRzO1xuXG4gIGlmICghaXNOdWxsT3JVbmRlZihiYWNrZHJvcENvbG9yKSkge1xuICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMob3B0cy5ib3JkZXJSYWRpdXMpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0cy5iYWNrZHJvcFBhZGRpbmcpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZHJvcENvbG9yO1xuXG4gICAgY29uc3QgYmFja2Ryb3BMZWZ0ID0gbGVmdCAtIHBhZGRpbmcubGVmdDtcbiAgICBjb25zdCBiYWNrZHJvcFRvcCA9IHRvcCAtIHBhZGRpbmcudG9wO1xuICAgIGNvbnN0IGJhY2tkcm9wV2lkdGggPSByaWdodCAtIGxlZnQgKyBwYWRkaW5nLndpZHRoO1xuICAgIGNvbnN0IGJhY2tkcm9wSGVpZ2h0ID0gYm90dG9tIC0gdG9wICsgcGFkZGluZy5oZWlnaHQ7XG5cbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICB4OiBiYWNrZHJvcExlZnQsXG4gICAgICAgIHk6IGJhY2tkcm9wVG9wLFxuICAgICAgICB3OiBiYWNrZHJvcFdpZHRoLFxuICAgICAgICBoOiBiYWNrZHJvcEhlaWdodCxcbiAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICB9KTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5maWxsUmVjdChiYWNrZHJvcExlZnQsIGJhY2tkcm9wVG9wLCBiYWNrZHJvcFdpZHRoLCBiYWNrZHJvcEhlaWdodCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVscyhzY2FsZSwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9pbnRMYWJlbHN9fSA9IHNjYWxlO1xuXG4gIGZvciAobGV0IGkgPSBsYWJlbENvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBpdGVtID0gc2NhbGUuX3BvaW50TGFiZWxJdGVtc1tpXTtcbiAgICBpZiAoIWl0ZW0udmlzaWJsZSkge1xuICAgICAgLy8gb3ZlcmxhcHBpbmdcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBvcHRzQXRJbmRleCA9IHBvaW50TGFiZWxzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgIGRyYXdQb2ludExhYmVsQm94KGN0eCwgb3B0c0F0SW5kZXgsIGl0ZW0pO1xuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzQXRJbmRleC5mb250KTtcbiAgICBjb25zdCB7eCwgeSwgdGV4dEFsaWdufSA9IGl0ZW07XG5cbiAgICByZW5kZXJUZXh0KFxuICAgICAgY3R4LFxuICAgICAgc2NhbGUuX3BvaW50TGFiZWxzW2ldLFxuICAgICAgeCxcbiAgICAgIHkgKyAocGxGb250LmxpbmVIZWlnaHQgLyAyKSxcbiAgICAgIHBsRm9udCxcbiAgICAgIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJ1xuICAgICAgfVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpIHtcbiAgY29uc3Qge2N0eH0gPSBzY2FsZTtcbiAgaWYgKGNpcmN1bGFyKSB7XG4gICAgLy8gRHJhdyBjaXJjdWxhciBhcmNzIGJldHdlZW4gdGhlIHBvaW50c1xuICAgIGN0eC5hcmMoc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlciwgcmFkaXVzLCAwLCBUQVUpO1xuICB9IGVsc2Uge1xuICAgIC8vIERyYXcgc3RyYWlnaHQgbGluZXMgY29ubmVjdGluZyBlYWNoIGluZGV4XG4gICAgbGV0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKDAsIHJhZGl1cyk7XG4gICAgY3R4Lm1vdmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhYmVsQ291bnQ7IGkrKykge1xuICAgICAgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgcmFkaXVzKTtcbiAgICAgIGN0eC5saW5lVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3UmFkaXVzTGluZShzY2FsZSwgZ3JpZExpbmVPcHRzLCByYWRpdXMsIGxhYmVsQ291bnQsIGJvcmRlck9wdHMpIHtcbiAgY29uc3QgY3R4ID0gc2NhbGUuY3R4O1xuICBjb25zdCBjaXJjdWxhciA9IGdyaWRMaW5lT3B0cy5jaXJjdWxhcjtcblxuICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBncmlkTGluZU9wdHM7XG5cbiAgaWYgKCghY2lyY3VsYXIgJiYgIWxhYmVsQ291bnQpIHx8ICFjb2xvciB8fCAhbGluZVdpZHRoIHx8IHJhZGl1cyA8IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHguc2F2ZSgpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgY3R4LnNldExpbmVEYXNoKGJvcmRlck9wdHMuZGFzaCk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IGJvcmRlck9wdHMuZGFzaE9mZnNldDtcblxuICBjdHguYmVnaW5QYXRoKCk7XG4gIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguc3Ryb2tlKCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHBhcmVudCwgaW5kZXgsIGxhYmVsKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIGxhYmVsLFxuICAgIGluZGV4LFxuICAgIHR5cGU6ICdwb2ludExhYmVsJ1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkaWFsTGluZWFyU2NhbGUgZXh0ZW5kcyBMaW5lYXJTY2FsZUJhc2Uge1xuXG4gIHN0YXRpYyBpZCA9ICdyYWRpYWxMaW5lYXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRpc3BsYXk6IHRydWUsXG5cbiAgICAvLyBCb29sZWFuIC0gV2hldGhlciB0byBhbmltYXRlIHNjYWxpbmcgdGhlIGNoYXJ0IGZyb20gdGhlIGNlbnRyZVxuICAgIGFuaW1hdGU6IHRydWUsXG4gICAgcG9zaXRpb246ICdjaGFydEFyZWEnLFxuXG4gICAgYW5nbGVMaW5lczoge1xuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgIGJvcmRlckRhc2g6IFtdLFxuICAgICAgYm9yZGVyRGFzaE9mZnNldDogMC4wXG4gICAgfSxcblxuICAgIGdyaWQ6IHtcbiAgICAgIGNpcmN1bGFyOiBmYWxzZVxuICAgIH0sXG5cbiAgICBzdGFydEFuZ2xlOiAwLFxuXG4gICAgLy8gbGFiZWwgc2V0dGluZ3NcbiAgICB0aWNrczoge1xuICAgICAgLy8gQm9vbGVhbiAtIFNob3cgYSBiYWNrZHJvcCB0byB0aGUgc2NhbGUgbGFiZWxcbiAgICAgIHNob3dMYWJlbEJhY2tkcm9wOiB0cnVlLFxuXG4gICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gICAgfSxcblxuICAgIHBvaW50TGFiZWxzOiB7XG4gICAgICBiYWNrZHJvcENvbG9yOiB1bmRlZmluZWQsXG5cbiAgICAgIC8vIE51bWJlciAtIFRoZSBiYWNrZHJvcCBwYWRkaW5nIGFib3ZlICYgYmVsb3cgdGhlIGxhYmVsIGluIHBpeGVsc1xuICAgICAgYmFja2Ryb3BQYWRkaW5nOiAyLFxuXG4gICAgICAvLyBCb29sZWFuIC0gaWYgdHJ1ZSwgc2hvdyBwb2ludCBsYWJlbHNcbiAgICAgIGRpc3BsYXk6IHRydWUsXG5cbiAgICAgIC8vIE51bWJlciAtIFBvaW50IGxhYmVsIGZvbnQgc2l6ZSBpbiBwaXhlbHNcbiAgICAgIGZvbnQ6IHtcbiAgICAgICAgc2l6ZTogMTBcbiAgICAgIH0sXG5cbiAgICAgIC8vIEZ1bmN0aW9uIC0gVXNlZCB0byBjb252ZXJ0IHBvaW50IGxhYmVsc1xuICAgICAgY2FsbGJhY2sobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgfSxcblxuICAgICAgLy8gTnVtYmVyIC0gQWRkaXRpb25sIHBhZGRpbmcgYmV0d2VlbiBzY2FsZSBhbmQgcG9pbnRMYWJlbFxuICAgICAgcGFkZGluZzogNSxcblxuICAgICAgLy8gQm9vbGVhbiAtIGlmIHRydWUsIGNlbnRlciBwb2ludCBsYWJlbHMgdG8gc2xpY2VzIGluIHBvbGFyIGNoYXJ0XG4gICAgICBjZW50ZXJQb2ludExhYmVsczogZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgJ2FuZ2xlTGluZXMuY29sb3InOiAnYm9yZGVyQ29sb3InLFxuICAgICdwb2ludExhYmVscy5jb2xvcic6ICdjb2xvcicsXG4gICAgJ3RpY2tzLmNvbG9yJzogJ2NvbG9yJ1xuICB9O1xuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBhbmdsZUxpbmVzOiB7XG4gICAgICBfZmFsbGJhY2s6ICdncmlkJ1xuICAgIH1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy54Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMueUNlbnRlciA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmRyYXdpbmdBcmVhID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG4gICAgdGhpcy5fcG9pbnRMYWJlbHMgPSBbXTtcbiAgICB0aGlzLl9wb2ludExhYmVsSXRlbXMgPSBbXTtcbiAgfVxuXG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgLy8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSAvIDIpO1xuICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aCAtIHBhZGRpbmcud2lkdGg7XG4gICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBwYWRkaW5nLmhlaWdodDtcbiAgICB0aGlzLnhDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMubGVmdCArIHcgLyAyICsgcGFkZGluZy5sZWZ0KTtcbiAgICB0aGlzLnlDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMudG9wICsgaCAvIDIgKyBwYWRkaW5nLnRvcCk7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IE1hdGguZmxvb3IoTWF0aC5taW4odywgaCkgLyAyKTtcbiAgfVxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KGZhbHNlKTtcblxuICAgIHRoaXMubWluID0gaXNGaW5pdGUobWluKSAmJiAhaXNOYU4obWluKSA/IG1pbiA6IDA7XG4gICAgdGhpcy5tYXggPSBpc0Zpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogMDtcblxuICAgIC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSBtaW4sIG1heCwgYmVnaW5BdFplcm9cbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyBiYXNlZCBvbiB0aGUgc2NhbGUgZGltZW5zaW9uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmRyYXdpbmdBcmVhIC8gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykpO1xuICB9XG5cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5nZW5lcmF0ZVRpY2tMYWJlbHMuY2FsbCh0aGlzLCB0aWNrcyk7XG5cbiAgICAvLyBQb2ludCBsYWJlbHNcbiAgICB0aGlzLl9wb2ludExhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKClcbiAgICAgIC5tYXAoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGNhbGxDYWxsYmFjayh0aGlzLm9wdGlvbnMucG9pbnRMYWJlbHMuY2FsbGJhY2ssIFt2YWx1ZSwgaW5kZXhdLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGxhYmVsIHx8IGxhYmVsID09PSAwID8gbGFiZWwgOiAnJztcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKCh2LCBpKSA9PiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpKTtcbiAgfVxuXG4gIGZpdCgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKG9wdHMuZGlzcGxheSAmJiBvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcbiAgICAgIGZpdFdpdGhQb2ludExhYmVscyh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDZW50ZXJQb2ludCgwLCAwLCAwLCAwKTtcbiAgICB9XG4gIH1cblxuICBzZXRDZW50ZXJQb2ludChsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkge1xuICAgIHRoaXMueENlbnRlciArPSBNYXRoLmZsb29yKChsZWZ0TW92ZW1lbnQgLSByaWdodE1vdmVtZW50KSAvIDIpO1xuICAgIHRoaXMueUNlbnRlciArPSBNYXRoLmZsb29yKCh0b3BNb3ZlbWVudCAtIGJvdHRvbU1vdmVtZW50KSAvIDIpO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgLT0gTWF0aC5taW4odGhpcy5kcmF3aW5nQXJlYSAvIDIsIE1hdGgubWF4KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSk7XG4gIH1cblxuICBnZXRJbmRleEFuZ2xlKGluZGV4KSB7XG4gICAgY29uc3QgYW5nbGVNdWx0aXBsaWVyID0gVEFVIC8gKHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aCB8fCAxKTtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5vcHRpb25zLnN0YXJ0QW5nbGUgfHwgMDtcblxuICAgIHJldHVybiBfbm9ybWFsaXplQW5nbGUoaW5kZXggKiBhbmdsZU11bHRpcGxpZXIgKyB0b1JhZGlhbnMoc3RhcnRBbmdsZSkpO1xuICB9XG5cbiAgZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgLy8gVGFrZSBpbnRvIGFjY291bnQgaGFsZiBmb250IHNpemUgKyB0aGUgeVBhZGRpbmcgb2YgdGhlIHRvcCB2YWx1ZVxuICAgIGNvbnN0IHNjYWxpbmdGYWN0b3IgPSB0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgcmV0dXJuICh0aGlzLm1heCAtIHZhbHVlKSAqIHNjYWxpbmdGYWN0b3I7XG4gICAgfVxuICAgIHJldHVybiAodmFsdWUgLSB0aGlzLm1pbikgKiBzY2FsaW5nRmFjdG9yO1xuICB9XG5cbiAgZ2V0VmFsdWVGb3JEaXN0YW5jZUZyb21DZW50ZXIoZGlzdGFuY2UpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihkaXN0YW5jZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgY29uc3Qgc2NhbGVkRGlzdGFuY2UgPSBkaXN0YW5jZSAvICh0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pKTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJldmVyc2UgPyB0aGlzLm1heCAtIHNjYWxlZERpc3RhbmNlIDogdGhpcy5taW4gKyBzY2FsZWREaXN0YW5jZTtcbiAgfVxuXG4gIGdldFBvaW50TGFiZWxDb250ZXh0KGluZGV4KSB7XG4gICAgY29uc3QgcG9pbnRMYWJlbHMgPSB0aGlzLl9wb2ludExhYmVscyB8fCBbXTtcblxuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgcG9pbnRMYWJlbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwb2ludExhYmVsID0gcG9pbnRMYWJlbHNbaW5kZXhdO1xuICAgICAgcmV0dXJuIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgcG9pbnRMYWJlbCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgZGlzdGFuY2VGcm9tQ2VudGVyLCBhZGRpdGlvbmFsQW5nbGUgPSAwKSB7XG4gICAgY29uc3QgYW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoaW5kZXgpIC0gSEFMRl9QSSArIGFkZGl0aW9uYWxBbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5jb3MoYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy54Q2VudGVyLFxuICAgICAgeTogTWF0aC5zaW4oYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy55Q2VudGVyLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG5cbiAgZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpKTtcbiAgfVxuXG4gIGdldEJhc2VQb3NpdGlvbihpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCB8fCAwLCB0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuXG4gIGdldFBvaW50TGFiZWxQb3NpdGlvbihpbmRleCkge1xuICAgIGNvbnN0IHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gdGhpcy5fcG9pbnRMYWJlbEl0ZW1zW2luZGV4XTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdCxcbiAgICAgIHRvcCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3Qge2JhY2tncm91bmRDb2xvciwgZ3JpZDoge2NpcmN1bGFyfX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgcGF0aFJhZGl1c0xpbmUodGhpcywgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLl9lbmRWYWx1ZSksIGNpcmN1bGFyLCB0aGlzLl9wb2ludExhYmVscy5sZW5ndGgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3R3JpZCgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHthbmdsZUxpbmVzLCBncmlkLCBib3JkZXJ9ID0gb3B0cztcbiAgICBjb25zdCBsYWJlbENvdW50ID0gdGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuXG4gICAgbGV0IGksIG9mZnNldCwgcG9zaXRpb247XG5cbiAgICBpZiAob3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICBkcmF3UG9pbnRMYWJlbHModGhpcywgbGFiZWxDb3VudCk7XG4gICAgfVxuXG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaW5kZXggIT09IDAgfHwgKGluZGV4ID09PSAwICYmIHRoaXMubWluIDwgMCkpIHtcbiAgICAgICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRpY2sudmFsdWUpO1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldENvbnRleHQoaW5kZXgpO1xuICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4Qm9yZGVyID0gYm9yZGVyLnNldENvbnRleHQoY29udGV4dCk7XG5cbiAgICAgICAgICBkcmF3UmFkaXVzTGluZSh0aGlzLCBvcHRzQXRJbmRleCwgb2Zmc2V0LCBsYWJlbENvdW50LCBvcHRzQXRJbmRleEJvcmRlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhbmdsZUxpbmVzLmRpc3BsYXkpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgIGZvciAoaSA9IGxhYmVsQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGFuZ2xlTGluZXMuc2V0Q29udGV4dCh0aGlzLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICAgICAgY29uc3Qge2NvbG9yLCBsaW5lV2lkdGh9ID0gb3B0c0F0SW5kZXg7XG5cbiAgICAgICAgaWYgKCFsaW5lV2lkdGggfHwgIWNvbG9yKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcblxuICAgICAgICBjdHguc2V0TGluZURhc2gob3B0c0F0SW5kZXguYm9yZGVyRGFzaCk7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LmJvcmRlckRhc2hPZmZzZXQ7XG5cbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShvcHRzLnRpY2tzLnJldmVyc2UgPyB0aGlzLm1pbiA6IHRoaXMubWF4KTtcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50UG9zaXRpb24oaSwgb2Zmc2V0KTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3Qm9yZGVyKCkge31cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0xhYmVscygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuICAgIGlmICghdGlja09wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoMCk7XG4gICAgbGV0IG9mZnNldCwgd2lkdGg7XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2xhdGUodGhpcy54Q2VudGVyLCB0aGlzLnlDZW50ZXIpO1xuICAgIGN0eC5yb3RhdGUoc3RhcnRBbmdsZSk7XG4gICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgIHRoaXMudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpID0+IHtcbiAgICAgIGlmICgoaW5kZXggPT09IDAgJiYgdGhpcy5taW4gPj0gMCkgJiYgIW9wdHMucmV2ZXJzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gdGlja09wdHMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLnRpY2tzW2luZGV4XS52YWx1ZSk7XG5cbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjdHguZm9udCA9IHRpY2tGb250LnN0cmluZztcbiAgICAgICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGljay5sYWJlbCkud2lkdGg7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yO1xuXG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgIC13aWR0aCAvIDIgLSBwYWRkaW5nLmxlZnQsXG4gICAgICAgICAgLW9mZnNldCAtIHRpY2tGb250LnNpemUgLyAyIC0gcGFkZGluZy50b3AsXG4gICAgICAgICAgd2lkdGggKyBwYWRkaW5nLndpZHRoLFxuICAgICAgICAgIHRpY2tGb250LnNpemUgKyBwYWRkaW5nLmhlaWdodFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZW5kZXJUZXh0KGN0eCwgdGljay5sYWJlbCwgMCwgLW9mZnNldCwgdGlja0ZvbnQsIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgICBzdHJva2VDb2xvcjogb3B0c0F0SW5kZXgudGV4dFN0cm9rZUNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogb3B0c0F0SW5kZXgudGV4dFN0cm9rZVdpZHRoLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdUaXRsZSgpIHt9XG59XG4iLCAiaW1wb3J0IGFkYXB0ZXJzIGZyb20gJy4uL2NvcmUvY29yZS5hZGFwdGVycy5qcyc7XG5pbXBvcnQge2NhbGxiYWNrIGFzIGNhbGwsIGlzRmluaXRlLCBpc051bGxPclVuZGVmLCBtZXJnZUlmLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b1JhZGlhbnMsIGlzTnVtYmVyLCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4uL2NvcmUvY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQge19hcnJheVVuaXF1ZSwgX2ZpbHRlckJldHdlZW4sIF9sb29rdXB9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xsZWN0aW9uLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmFkYXB0ZXJzLmpzJykuVGltZVVuaXQgfSBVbml0XG4gKiBAdHlwZWRlZiB7e2NvbW1vbjogYm9vbGVhbiwgc2l6ZTogbnVtYmVyLCBzdGVwcz86IG51bWJlcn19IEludGVydmFsXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmFkYXB0ZXJzLmpzJykuRGF0ZUFkYXB0ZXIgfSBEYXRlQWRhcHRlclxuICovXG5cbi8qKlxuICogQHR5cGUge09iamVjdDxVbml0LCBJbnRlcnZhbD59XG4gKi9cbmNvbnN0IElOVEVSVkFMUyA9IHtcbiAgbWlsbGlzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEsIHN0ZXBzOiAxMDAwfSxcbiAgc2Vjb25kOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAxMDAwLCBzdGVwczogNjB9LFxuICBtaW51dGU6IHtjb21tb246IHRydWUsIHNpemU6IDYwMDAwLCBzdGVwczogNjB9LFxuICBob3VyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzNjAwMDAwLCBzdGVwczogMjR9LFxuICBkYXk6IHtjb21tb246IHRydWUsIHNpemU6IDg2NDAwMDAwLCBzdGVwczogMzB9LFxuICB3ZWVrOiB7Y29tbW9uOiBmYWxzZSwgc2l6ZTogNjA0ODAwMDAwLCBzdGVwczogNH0sXG4gIG1vbnRoOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAyLjYyOGU5LCBzdGVwczogMTJ9LFxuICBxdWFydGVyOiB7Y29tbW9uOiBmYWxzZSwgc2l6ZTogNy44ODRlOSwgc3RlcHM6IDR9LFxuICB5ZWFyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzLjE1NGUxMH1cbn07XG5cbi8qKlxuICogQHR5cGUge1VuaXRbXX1cbiAqL1xuY29uc3QgVU5JVFMgPSAvKiogQHR5cGUgVW5pdFtdICovIC8qICNfX1BVUkVfXyAqLyAoT2JqZWN0LmtleXMoSU5URVJWQUxTKSk7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKi9cbmZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG4gIHJldHVybiBhIC0gYjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbWVTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7Kn0gaW5wdXRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gcGFyc2Uoc2NhbGUsIGlucHV0KSB7XG4gIGlmIChpc051bGxPclVuZGVmKGlucHV0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuICBjb25zdCB7cGFyc2VyLCByb3VuZCwgaXNvV2Vla2RheX0gPSBzY2FsZS5fcGFyc2VPcHRzO1xuICBsZXQgdmFsdWUgPSBpbnB1dDtcblxuICBpZiAodHlwZW9mIHBhcnNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE9ubHkgcGFyc2UgaWYgaXQncyBub3QgYSB0aW1lc3RhbXAgYWxyZWFkeVxuICBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdHlwZW9mIHBhcnNlciA9PT0gJ3N0cmluZydcbiAgICAgID8gYWRhcHRlci5wYXJzZSh2YWx1ZSwgLyoqIEB0eXBlIHtVbml0fSAqLyAocGFyc2VyKSlcbiAgICAgIDogYWRhcHRlci5wYXJzZSh2YWx1ZSk7XG4gIH1cblxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChyb3VuZCkge1xuICAgIHZhbHVlID0gcm91bmQgPT09ICd3ZWVrJyAmJiAoaXNOdW1iZXIoaXNvV2Vla2RheSkgfHwgaXNvV2Vla2RheSA9PT0gdHJ1ZSlcbiAgICAgID8gYWRhcHRlci5zdGFydE9mKHZhbHVlLCAnaXNvV2VlaycsIGlzb1dlZWtkYXkpXG4gICAgICA6IGFkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgcm91bmQpO1xuICB9XG5cbiAgcmV0dXJuICt2YWx1ZTtcbn1cblxuLyoqXG4gKiBGaWd1cmVzIG91dCB3aGF0IHVuaXQgcmVzdWx0cyBpbiBhbiBhcHByb3ByaWF0ZSBudW1iZXIgb2YgYXV0by1nZW5lcmF0ZWQgdGlja3NcbiAqIEBwYXJhbSB7VW5pdH0gbWluVW5pdFxuICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICogQHBhcmFtIHtudW1iZXJ9IGNhcGFjaXR5XG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JBdXRvVGlja3MobWluVW5pdCwgbWluLCBtYXgsIGNhcGFjaXR5KSB7XG4gIGNvbnN0IGlsZW4gPSBVTklUUy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGkgPCBpbGVuIC0gMTsgKytpKSB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBJTlRFUlZBTFNbVU5JVFNbaV1dO1xuICAgIGNvbnN0IGZhY3RvciA9IGludGVydmFsLnN0ZXBzID8gaW50ZXJ2YWwuc3RlcHMgOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcblxuICAgIGlmIChpbnRlcnZhbC5jb21tb24gJiYgTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKGZhY3RvciAqIGludGVydmFsLnNpemUpKSA8PSBjYXBhY2l0eSkge1xuICAgICAgcmV0dXJuIFVOSVRTW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBVTklUU1tpbGVuIC0gMV07XG59XG5cbi8qKlxuICogRmlndXJlcyBvdXQgd2hhdCB1bml0IHRvIGZvcm1hdCBhIHNldCBvZiB0aWNrcyB3aXRoXG4gKiBAcGFyYW0ge1RpbWVTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1UaWNrc1xuICogQHBhcmFtIHtVbml0fSBtaW5Vbml0XG4gKiBAcGFyYW0ge251bWJlcn0gbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gKiBAcmV0dXJuIHtVbml0fVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyhzY2FsZSwgbnVtVGlja3MsIG1pblVuaXQsIG1pbiwgbWF4KSB7XG4gIGZvciAobGV0IGkgPSBVTklUUy5sZW5ndGggLSAxOyBpID49IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGktLSkge1xuICAgIGNvbnN0IHVuaXQgPSBVTklUU1tpXTtcbiAgICBpZiAoSU5URVJWQUxTW3VuaXRdLmNvbW1vbiAmJiBzY2FsZS5fYWRhcHRlci5kaWZmKG1heCwgbWluLCB1bml0KSA+PSBudW1UaWNrcyAtIDEpIHtcbiAgICAgIHJldHVybiB1bml0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBVTklUU1ttaW5Vbml0ID8gVU5JVFMuaW5kZXhPZihtaW5Vbml0KSA6IDBdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VW5pdH0gdW5pdFxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVNYWpvclVuaXQodW5pdCkge1xuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZih1bml0KSArIDEsIGlsZW4gPSBVTklUUy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpZiAoSU5URVJWQUxTW1VOSVRTW2ldXS5jb21tb24pIHtcbiAgICAgIHJldHVybiBVTklUU1tpXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gdGlja3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lXG4gKiBAcGFyYW0ge251bWJlcltdfSBbdGltZXN0YW1wc10gLSBpZiBkZWZpbmVkLCBzbmFwIHRvIHRoZXNlIHRpbWVzdGFtcHNcbiAqL1xuZnVuY3Rpb24gYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcykge1xuICBpZiAoIXRpbWVzdGFtcHMpIHtcbiAgICB0aWNrc1t0aW1lXSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICBjb25zdCB7bG8sIGhpfSA9IF9sb29rdXAodGltZXN0YW1wcywgdGltZSk7XG4gICAgY29uc3QgdGltZXN0YW1wID0gdGltZXN0YW1wc1tsb10gPj0gdGltZSA/IHRpbWVzdGFtcHNbbG9dIDogdGltZXN0YW1wc1toaV07XG4gICAgdGlja3NbdGltZXN0YW1wXSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbWVTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7b2JqZWN0W119IHRpY2tzXG4gKiBAcGFyYW0ge29iamVjdH0gbWFwXG4gKiBAcGFyYW0ge1VuaXR9IG1ham9yVW5pdFxuICogQHJldHVybiB7b2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIHNldE1ham9yVGlja3Moc2NhbGUsIHRpY2tzLCBtYXAsIG1ham9yVW5pdCkge1xuICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG4gIGNvbnN0IGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZih0aWNrc1swXS52YWx1ZSwgbWFqb3JVbml0KTtcbiAgY29uc3QgbGFzdCA9IHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlO1xuICBsZXQgbWFqb3IsIGluZGV4O1xuXG4gIGZvciAobWFqb3IgPSBmaXJzdDsgbWFqb3IgPD0gbGFzdDsgbWFqb3IgPSArYWRhcHRlci5hZGQobWFqb3IsIDEsIG1ham9yVW5pdCkpIHtcbiAgICBpbmRleCA9IG1hcFttYWpvcl07XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRpY2tzW2luZGV4XS5tYWpvciA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aWNrcztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbWVTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7bnVtYmVyW119IHZhbHVlc1xuICogQHBhcmFtIHtVbml0fHVuZGVmaW5lZH0gW21ham9yVW5pdF1cbiAqIEByZXR1cm4ge29iamVjdFtdfVxuICovXG5mdW5jdGlvbiB0aWNrc0Zyb21UaW1lc3RhbXBzKHNjYWxlLCB2YWx1ZXMsIG1ham9yVW5pdCkge1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICAvKiogQHR5cGUge09iamVjdDxudW1iZXIsb2JqZWN0Pn0gKi9cbiAgY29uc3QgbWFwID0ge307XG4gIGNvbnN0IGlsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICBsZXQgaSwgdmFsdWU7XG5cbiAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgIG1hcFt2YWx1ZV0gPSBpO1xuXG4gICAgdGlja3MucHVzaCh7XG4gICAgICB2YWx1ZSxcbiAgICAgIG1ham9yOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgLy8gV2Ugc2V0IHRoZSBtYWpvciB0aWNrcyBzZXBhcmF0ZWx5IGZyb20gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSBjYWxsaW5nIHN0YXJ0T2YgZm9yIGV2ZXJ5IHRpY2tcbiAgLy8gaXMgZXhwZW5zaXZlIHdoZW4gdGhlcmUgaXMgYSBsYXJnZSBudW1iZXIgb2YgdGlja3NcbiAgcmV0dXJuIChpbGVuID09PSAwIHx8ICFtYWpvclVuaXQpID8gdGlja3MgOiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lU2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG5cbiAgc3RhdGljIGlkID0gJ3RpbWUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIFNjYWxlIGJvdW5kYXJ5IHN0cmF0ZWd5IChieXBhc3NlZCBieSBtaW4vbWF4IHRpbWUgb3B0aW9ucylcbiAgICAgKiAtIGBkYXRhYDogbWFrZSBzdXJlIGRhdGEgYXJlIGZ1bGx5IHZpc2libGUsIHRpY2tzIG91dHNpZGUgYXJlIHJlbW92ZWRcbiAgICAgKiAtIGB0aWNrc2A6IG1ha2Ugc3VyZSB0aWNrcyBhcmUgZnVsbHkgdmlzaWJsZSwgZGF0YSBvdXRzaWRlIGFyZSB0cnVuY2F0ZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU1NlxuICAgICAqIEBzaW5jZSAyLjcuMFxuICAgICAqL1xuICAgIGJvdW5kczogJ2RhdGEnLFxuXG4gICAgYWRhcHRlcnM6IHt9LFxuICAgIHRpbWU6IHtcbiAgICAgIHBhcnNlcjogZmFsc2UsIC8vIGZhbHNlID09IGEgcGF0dGVybiBzdHJpbmcgZnJvbSBvciBhIGN1c3RvbSBjYWxsYmFjayB0aGF0IGNvbnZlcnRzIGl0cyBhcmd1bWVudCB0byBhIHRpbWVzdGFtcFxuICAgICAgdW5pdDogZmFsc2UsIC8vIGZhbHNlID09IGF1dG9tYXRpYyBvciBvdmVycmlkZSB3aXRoIHdlZWssIG1vbnRoLCB5ZWFyLCBldGMuXG4gICAgICByb3VuZDogZmFsc2UsIC8vIG5vbmUsIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cbiAgICAgIGlzb1dlZWtkYXk6IGZhbHNlLCAvLyBvdmVycmlkZSB3ZWVrIHN0YXJ0IGRheVxuICAgICAgbWluVW5pdDogJ21pbGxpc2Vjb25kJyxcbiAgICAgIGRpc3BsYXlGb3JtYXRzOiB7fVxuICAgIH0sXG4gICAgdGlja3M6IHtcbiAgICAgIC8qKlxuICAgICAgICogVGlja3MgZ2VuZXJhdGlvbiBpbnB1dCB2YWx1ZXM6XG4gICAgICAgKiAtICdhdXRvJzogZ2VuZXJhdGVzIFwib3B0aW1hbFwiIHRpY2tzIGJhc2VkIG9uIHNjYWxlIHNpemUgYW5kIHRpbWUgb3B0aW9ucy5cbiAgICAgICAqIC0gJ2RhdGEnOiBnZW5lcmF0ZXMgdGlja3MgZnJvbSBkYXRhIChpbmNsdWRpbmcgbGFiZWxzIGZyb20gZGF0YSB7dHx4fHl9IG9iamVjdHMpLlxuICAgICAgICogLSAnbGFiZWxzJzogZ2VuZXJhdGVzIHRpY2tzIGZyb20gdXNlciBnaXZlbiBgZGF0YS5sYWJlbHNgIHZhbHVlcyBPTkxZLlxuICAgICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1MDdcbiAgICAgICAqIEBzaW5jZSAyLjcuMFxuICAgICAgICovXG4gICAgICBzb3VyY2U6ICdhdXRvJyxcblxuICAgICAgY2FsbGJhY2s6IGZhbHNlLFxuXG4gICAgICBtYWpvcjoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcblx0ICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIC8qKiBAdHlwZSB7e2RhdGE6IG51bWJlcltdLCBsYWJlbHM6IG51bWJlcltdLCBhbGw6IG51bWJlcltdfX0gKi9cbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIGFsbDogW11cbiAgICB9O1xuXG4gICAgLyoqIEB0eXBlIHtVbml0fSAqL1xuICAgIHRoaXMuX3VuaXQgPSAnZGF5JztcbiAgICAvKiogQHR5cGUge1VuaXQ9fSAqL1xuICAgIHRoaXMuX21ham9yVW5pdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vZmZzZXRzID0ge307XG4gICAgdGhpcy5fbm9ybWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BhcnNlT3B0cyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGluaXQoc2NhbGVPcHRzLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCB0aW1lID0gc2NhbGVPcHRzLnRpbWUgfHwgKHNjYWxlT3B0cy50aW1lID0ge30pO1xuICAgIC8qKiBAdHlwZSB7RGF0ZUFkYXB0ZXJ9ICovXG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXIgPSBuZXcgYWRhcHRlcnMuX2RhdGUoc2NhbGVPcHRzLmFkYXB0ZXJzLmRhdGUpO1xuXG4gICAgYWRhcHRlci5pbml0KG9wdHMpO1xuXG4gICAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eTogYmVmb3JlIGludHJvZHVjaW5nIGFkYXB0ZXIsIGBkaXNwbGF5Rm9ybWF0c2Agd2FzXG4gICAgLy8gc3VwcG9zZWQgdG8gY29udGFpbiAqYWxsKiB1bml0L3N0cmluZyBwYWlycyBidXQgdGhpcyBjYW4ndCBiZSByZXNvbHZlZFxuICAgIC8vIHdoZW4gbG9hZGluZyB0aGUgc2NhbGUgKGFkYXB0ZXJzIGFyZSBsb2FkZWQgYWZ0ZXJ3YXJkKSwgc28gbGV0J3MgcG9wdWxhdGVcbiAgICAvLyBtaXNzaW5nIGZvcm1hdHMgb24gdXBkYXRlXG4gICAgbWVyZ2VJZih0aW1lLmRpc3BsYXlGb3JtYXRzLCBhZGFwdGVyLmZvcm1hdHMoKSk7XG5cbiAgICB0aGlzLl9wYXJzZU9wdHMgPSB7XG4gICAgICBwYXJzZXI6IHRpbWUucGFyc2VyLFxuICAgICAgcm91bmQ6IHRpbWUucm91bmQsXG4gICAgICBpc29XZWVrZGF5OiB0aW1lLmlzb1dlZWtkYXlcbiAgICB9O1xuXG4gICAgc3VwZXIuaW5pdChzY2FsZU9wdHMpO1xuXG4gICAgdGhpcy5fbm9ybWFsaXplZCA9IG9wdHMubm9ybWFsaXplZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0geyp9IHJhd1xuXHQgKiBAcGFyYW0ge251bWJlcj99IFtpbmRleF1cblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgcGFyc2UocmF3LCBpbmRleCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgaWYgKHJhdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlKHRoaXMsIHJhdyk7XG4gIH1cblxuICBiZWZvcmVMYXlvdXQoKSB7XG4gICAgc3VwZXIuYmVmb3JlTGF5b3V0KCk7XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIGxhYmVsczogW10sXG4gICAgICBhbGw6IFtdXG4gICAgfTtcbiAgfVxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCB1bml0ID0gb3B0aW9ucy50aW1lLnVuaXQgfHwgJ2RheSc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGxldCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG5cbiAgICAvKipcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gYm91bmRzXG5cdFx0ICovXG4gICAgZnVuY3Rpb24gX2FwcGx5Qm91bmRzKGJvdW5kcykge1xuICAgICAgaWYgKCFtaW5EZWZpbmVkICYmICFpc05hTihib3VuZHMubWluKSkge1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGJvdW5kcy5taW4pO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkICYmICFpc05hTihib3VuZHMubWF4KSkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGJvdW5kcy5tYXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgdXNlciBwcm92aWRlZCBgbWluYCBhbmQgYG1heGAgbGFiZWxzIC8gZGF0YSBib3VuZHMgY2FuIGJlIGlnbm9yZWRcbiAgICBpZiAoIW1pbkRlZmluZWQgfHwgIW1heERlZmluZWQpIHtcbiAgICAgIC8vIExhYmVscyBhcmUgYWx3YXlzIGNvbnNpZGVyZWQsIHdoZW4gdXNlciBkaWQgbm90IGZvcmNlIGJvdW5kc1xuICAgICAgX2FwcGx5Qm91bmRzKHRoaXMuX2dldExhYmVsQm91bmRzKCkpO1xuXG4gICAgICAvLyBJZiBgYm91bmRzYCBpcyBgJ3RpY2tzJ2AgYW5kIGB0aWNrcy5zb3VyY2VgIGlzIGAnbGFiZWxzJ2AsXG4gICAgICAvLyBkYXRhIGJvdW5kcyBhcmUgaWdub3JlZCAoYW5kIGRvbid0IG5lZWQgdG8gYmUgZGV0ZXJtaW5lZClcbiAgICAgIGlmIChvcHRpb25zLmJvdW5kcyAhPT0gJ3RpY2tzJyB8fCBvcHRpb25zLnRpY2tzLnNvdXJjZSAhPT0gJ2xhYmVscycpIHtcbiAgICAgICAgX2FwcGx5Qm91bmRzKHRoaXMuZ2V0TWluTWF4KGZhbHNlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWluID0gaXNGaW5pdGUobWluKSAmJiAhaXNOYU4obWluKSA/IG1pbiA6ICthZGFwdGVyLnN0YXJ0T2YoRGF0ZS5ub3coKSwgdW5pdCk7XG4gICAgbWF4ID0gaXNGaW5pdGUobWF4KSAmJiAhaXNOYU4obWF4KSA/IG1heCA6ICthZGFwdGVyLmVuZE9mKERhdGUubm93KCksIHVuaXQpICsgMTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IG1heCBpcyBzdHJpY3RseSBoaWdoZXIgdGhhbiBtaW4gKHJlcXVpcmVkIGJ5IHRoZSB0aW1lc2VyaWVzIGxvb2t1cCB0YWJsZSlcbiAgICB0aGlzLm1pbiA9IE1hdGgubWluKG1pbiwgbWF4IC0gMSk7XG4gICAgdGhpcy5tYXggPSBNYXRoLm1heChtaW4gKyAxLCBtYXgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGFiZWxCb3VuZHMoKSB7XG4gICAgY29uc3QgYXJyID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICBsZXQgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cbiAgICBpZiAoYXJyLmxlbmd0aCkge1xuICAgICAgbWluID0gYXJyWzBdO1xuICAgICAgbWF4ID0gYXJyW2Fyci5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHttaW4sIG1heH07XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7b2JqZWN0W119XG5cdCAqL1xuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aWNrT3B0cy5zb3VyY2UgPT09ICdsYWJlbHMnID8gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKSA6IHRoaXMuX2dlbmVyYXRlKCk7XG5cbiAgICBpZiAob3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubWluID0gdGhpcy5fdXNlck1pbiB8fCB0aW1lc3RhbXBzWzBdO1xuICAgICAgdGhpcy5tYXggPSB0aGlzLl91c2VyTWF4IHx8IHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcblxuICAgIGNvbnN0IHRpY2tzID0gX2ZpbHRlckJldHdlZW4odGltZXN0YW1wcywgbWluLCBtYXgpO1xuXG4gICAgLy8gUFJJVkFURVxuICAgIC8vIGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nIHJlbGllcyBvbiB0aGUgbnVtYmVyIG9mIHRpY2tzIHNvIHdlIGRvbid0IHVzZSBpdCB3aGVuXG4gICAgLy8gYXV0b1NraXAgaXMgZW5hYmxlZCBiZWNhdXNlIHdlIGRvbid0IHlldCBrbm93IHdoYXQgdGhlIGZpbmFsIG51bWJlciBvZiB0aWNrcyB3aWxsIGJlXG4gICAgdGhpcy5fdW5pdCA9IHRpbWVPcHRzLnVuaXQgfHwgKHRpY2tPcHRzLmF1dG9Ta2lwXG4gICAgICA/IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgdGhpcy5taW4sIHRoaXMubWF4LCB0aGlzLl9nZXRMYWJlbENhcGFjaXR5KG1pbikpXG4gICAgICA6IGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHRoaXMsIHRpY2tzLmxlbmd0aCwgdGltZU9wdHMubWluVW5pdCwgdGhpcy5taW4sIHRoaXMubWF4KSk7XG4gICAgdGhpcy5fbWFqb3JVbml0ID0gIXRpY2tPcHRzLm1ham9yLmVuYWJsZWQgfHwgdGhpcy5fdW5pdCA9PT0gJ3llYXInID8gdW5kZWZpbmVkXG4gICAgICA6IGRldGVybWluZU1ham9yVW5pdCh0aGlzLl91bml0KTtcbiAgICB0aGlzLmluaXRPZmZzZXRzKHRpbWVzdGFtcHMpO1xuXG4gICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIHRpY2tzLCB0aGlzLl9tYWpvclVuaXQpO1xuICB9XG5cbiAgYWZ0ZXJBdXRvU2tpcCgpIHtcbiAgICAvLyBPZmZzZXRzIGZvciBiYXIgY2hhcnRzIG5lZWQgdG8gYmUgaGFuZGxlZCB3aXRoIHRoZSBhdXRvIHNraXBwZWRcbiAgICAvLyB0aWNrcy4gT25jZSB0aWNrcyBoYXZlIGJlZW4gc2tpcHBlZCwgd2UgcmUtY29tcHV0ZSB0aGUgb2Zmc2V0cy5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldEFmdGVyQXV0b3NraXApIHtcbiAgICAgIHRoaXMuaW5pdE9mZnNldHModGhpcy50aWNrcy5tYXAodGljayA9PiArdGljay52YWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdGFydCBhbmQgZW5kIG9mZnNldHMgZnJvbSBlZGdlcyBpbiB0aGUgZm9ybSBvZiB7c3RhcnQsIGVuZH1cblx0ICogd2hlcmUgZWFjaCB2YWx1ZSBpcyBhIHJlbGF0aXZlIHdpZHRoIHRvIHRoZSBzY2FsZSBhbmQgcmFuZ2VzIGJldHdlZW4gMCBhbmQgMS5cblx0ICogVGhleSBhZGQgZXh0cmEgbWFyZ2lucyBvbiB0aGUgYm90aCBzaWRlcyBieSBzY2FsaW5nIGRvd24gdGhlIG9yaWdpbmFsIHNjYWxlLlxuXHQgKiBPZmZzZXRzIGFyZSBhZGRlZCB3aGVuIHRoZSBgb2Zmc2V0YCBvcHRpb24gaXMgdHJ1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJbXX0gdGltZXN0YW1wc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBpbml0T2Zmc2V0cyh0aW1lc3RhbXBzID0gW10pIHtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSAwO1xuICAgIGxldCBmaXJzdCwgbGFzdDtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0ICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICBmaXJzdCA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbMF0pO1xuICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0YXJ0ID0gMSAtIGZpcnN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSAodGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1sxXSkgLSBmaXJzdCkgLyAyO1xuICAgICAgfVxuICAgICAgbGFzdCA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXSk7XG4gICAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZW5kID0gbGFzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IChsYXN0IC0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDJdKSkgLyAyO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsaW1pdCA9IHRpbWVzdGFtcHMubGVuZ3RoIDwgMyA/IDAuNSA6IDAuMjU7XG4gICAgc3RhcnQgPSBfbGltaXRWYWx1ZShzdGFydCwgMCwgbGltaXQpO1xuICAgIGVuZCA9IF9saW1pdFZhbHVlKGVuZCwgMCwgbGltaXQpO1xuXG4gICAgdGhpcy5fb2Zmc2V0cyA9IHtzdGFydCwgZW5kLCBmYWN0b3I6IDEgLyAoc3RhcnQgKyAxICsgZW5kKX07XG4gIH1cblxuICAvKipcblx0ICogR2VuZXJhdGVzIGEgbWF4aW11bSBvZiBgY2FwYWNpdHlgIHRpbWVzdGFtcHMgYmV0d2VlbiBtaW4gYW5kIG1heCwgcm91bmRlZCB0byB0aGVcblx0ICogYG1pbm9yYCB1bml0IHVzaW5nIHRoZSBnaXZlbiBzY2FsZSB0aW1lIGBvcHRpb25zYC5cblx0ICogSW1wb3J0YW50OiB0aGlzIG1ldGhvZCBjYW4gcmV0dXJuIHRpY2tzIG91dHNpZGUgdGhlIG1pbiBhbmQgbWF4IHJhbmdlLCBpdCdzIHRoZVxuXHQgKiByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGluZyBjb2RlIHRvIGNsYW1wIHZhbHVlcyBpZiBuZWVkZWQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIF9nZW5lcmF0ZSgpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gb3B0aW9ucy50aW1lO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBtaW5vciA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCBtaW4sIG1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKTtcbiAgICBjb25zdCBzdGVwU2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMudGlja3Muc3RlcFNpemUsIDEpO1xuICAgIGNvbnN0IHdlZWtkYXkgPSBtaW5vciA9PT0gJ3dlZWsnID8gdGltZU9wdHMuaXNvV2Vla2RheSA6IGZhbHNlO1xuICAgIGNvbnN0IGhhc1dlZWtkYXkgPSBpc051bWJlcih3ZWVrZGF5KSB8fCB3ZWVrZGF5ID09PSB0cnVlO1xuICAgIGNvbnN0IHRpY2tzID0ge307XG4gICAgbGV0IGZpcnN0ID0gbWluO1xuICAgIGxldCB0aW1lLCBjb3VudDtcblxuICAgIC8vIEZvciAnd2VlaycgdW5pdCwgaGFuZGxlIHRoZSBmaXJzdCBkYXkgb2Ygd2VlayBvcHRpb25cbiAgICBpZiAoaGFzV2Vla2RheSkge1xuICAgICAgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCAnaXNvV2VlaycsIHdlZWtkYXkpO1xuICAgIH1cblxuICAgIC8vIEFsaWduIGZpcnN0IHRpY2tzIG9uIHVuaXRcbiAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsIGhhc1dlZWtkYXkgPyAnZGF5JyA6IG1pbm9yKTtcblxuICAgIC8vIFByZXZlbnQgYnJvd3NlciBmcm9tIGZyZWV6aW5nIGluIGNhc2UgdXNlciBvcHRpb25zIHJlcXVlc3QgbWlsbGlvbnMgb2YgbWlsbGlzZWNvbmRzXG4gICAgaWYgKGFkYXB0ZXIuZGlmZihtYXgsIG1pbiwgbWlub3IpID4gMTAwMDAwICogc3RlcFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtaW4gKyAnIGFuZCAnICsgbWF4ICsgJyBhcmUgdG9vIGZhciBhcGFydCB3aXRoIHN0ZXBTaXplIG9mICcgKyBzdGVwU2l6ZSArICcgJyArIG1pbm9yKTtcbiAgICB9XG5cbiAgICBjb25zdCB0aW1lc3RhbXBzID0gb3B0aW9ucy50aWNrcy5zb3VyY2UgPT09ICdkYXRhJyAmJiB0aGlzLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgZm9yICh0aW1lID0gZmlyc3QsIGNvdW50ID0gMDsgdGltZSA8IG1heDsgdGltZSA9ICthZGFwdGVyLmFkZCh0aW1lLCBzdGVwU2l6ZSwgbWlub3IpLCBjb3VudCsrKSB7XG4gICAgICBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKTtcbiAgICB9XG5cbiAgICBpZiAodGltZSA9PT0gbWF4IHx8IG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnIHx8IGNvdW50ID09PSAxKSB7XG4gICAgICBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKTtcbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRpY2tzKS5zb3J0KHNvcnRlcikubWFwKHggPT4gK3gpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgdGltZU9wdHMgPSB0aGlzLm9wdGlvbnMudGltZTtcblxuICAgIGlmICh0aW1lT3B0cy50b29sdGlwRm9ybWF0KSB7XG4gICAgICByZXR1cm4gYWRhcHRlci5mb3JtYXQodmFsdWUsIHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpO1xuICAgIH1cbiAgICByZXR1cm4gYWRhcHRlci5mb3JtYXQodmFsdWUsIHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzLmRhdGV0aW1lKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcblx0ICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBmb3JtYXRcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZm9ybWF0KHZhbHVlLCBmb3JtYXQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGZvcm1hdHMgPSBvcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHM7XG4gICAgY29uc3QgdW5pdCA9IHRoaXMuX3VuaXQ7XG4gICAgY29uc3QgZm10ID0gZm9ybWF0IHx8IGZvcm1hdHNbdW5pdF07XG4gICAgcmV0dXJuIHRoaXMuX2FkYXB0ZXIuZm9ybWF0KHZhbHVlLCBmbXQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEZ1bmN0aW9uIHRvIGZvcm1hdCBhbiBpbmRpdmlkdWFsIHRpY2sgbWFya1xuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHBhcmFtIHtvYmplY3RbXX0gdGlja3Ncblx0ICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBbZm9ybWF0XVxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdGlja0Zvcm1hdEZ1bmN0aW9uKHRpbWUsIGluZGV4LCB0aWNrcywgZm9ybWF0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBvcHRpb25zLnRpY2tzLmNhbGxiYWNrO1xuXG4gICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgcmV0dXJuIGNhbGwoZm9ybWF0dGVyLCBbdGltZSwgaW5kZXgsIHRpY2tzXSwgdGhpcyk7XG4gICAgfVxuXG4gICAgY29uc3QgZm9ybWF0cyA9IG9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cztcbiAgICBjb25zdCB1bml0ID0gdGhpcy5fdW5pdDtcbiAgICBjb25zdCBtYWpvclVuaXQgPSB0aGlzLl9tYWpvclVuaXQ7XG4gICAgY29uc3QgbWlub3JGb3JtYXQgPSB1bml0ICYmIGZvcm1hdHNbdW5pdF07XG4gICAgY29uc3QgbWFqb3JGb3JtYXQgPSBtYWpvclVuaXQgJiYgZm9ybWF0c1ttYWpvclVuaXRdO1xuICAgIGNvbnN0IHRpY2sgPSB0aWNrc1tpbmRleF07XG4gICAgY29uc3QgbWFqb3IgPSBtYWpvclVuaXQgJiYgbWFqb3JGb3JtYXQgJiYgdGljayAmJiB0aWNrLm1ham9yO1xuXG4gICAgcmV0dXJuIHRoaXMuX2FkYXB0ZXIuZm9ybWF0KHRpbWUsIGZvcm1hdCB8fCAobWFqb3IgPyBtYWpvckZvcm1hdCA6IG1pbm9yRm9ybWF0KSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtvYmplY3RbXX0gdGlja3Ncblx0ICovXG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIGxldCBpLCBpbGVuLCB0aWNrO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgdGljay5sYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbih0aWNrLnZhbHVlLCBpLCB0aWNrcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIE1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiAodmFsdWUgLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gTWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKChvZmZzZXRzLnN0YXJ0ICsgcG9zKSAqIG9mZnNldHMuZmFjdG9yKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XG4gICAgcmV0dXJuIHRoaXMubWluICsgcG9zICogKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbFxuXHQgKiBAcmV0dXJuIHt7dzpudW1iZXIsIGg6bnVtYmVyfX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRMYWJlbFNpemUobGFiZWwpIHtcbiAgICBjb25zdCB0aWNrc09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgdGlja0xhYmVsV2lkdGggPSB0aGlzLmN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG4gICAgY29uc3QgYW5nbGUgPSB0b1JhZGlhbnModGhpcy5pc0hvcml6b250YWwoKSA/IHRpY2tzT3B0cy5tYXhSb3RhdGlvbiA6IHRpY2tzT3B0cy5taW5Sb3RhdGlvbik7XG4gICAgY29uc3QgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgY29uc3Qgc2luUm90YXRpb24gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgY29uc3QgdGlja0ZvbnRTaXplID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKS5zaXplO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHc6ICh0aWNrTGFiZWxXaWR0aCAqIGNvc1JvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBzaW5Sb3RhdGlvbiksXG4gICAgICBoOiAodGlja0xhYmVsV2lkdGggKiBzaW5Sb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogY29zUm90YXRpb24pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZXhhbXBsZVRpbWVcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExhYmVsQ2FwYWNpdHkoZXhhbXBsZVRpbWUpIHtcbiAgICBjb25zdCB0aW1lT3B0cyA9IHRoaXMub3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IGRpc3BsYXlGb3JtYXRzID0gdGltZU9wdHMuZGlzcGxheUZvcm1hdHM7XG5cbiAgICAvLyBwaWNrIHRoZSBsb25nZXN0IGZvcm1hdCAobWlsbGlzZWNvbmRzKSBmb3IgZ3Vlc3N0aW1hdGlvblxuICAgIGNvbnN0IGZvcm1hdCA9IGRpc3BsYXlGb3JtYXRzW3RpbWVPcHRzLnVuaXRdIHx8IGRpc3BsYXlGb3JtYXRzLm1pbGxpc2Vjb25kO1xuICAgIGNvbnN0IGV4YW1wbGVMYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbihleGFtcGxlVGltZSwgMCwgdGlja3NGcm9tVGltZXN0YW1wcyh0aGlzLCBbZXhhbXBsZVRpbWVdLCB0aGlzLl9tYWpvclVuaXQpLCBmb3JtYXQpO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLl9nZXRMYWJlbFNpemUoZXhhbXBsZUxhYmVsKTtcbiAgICAvLyBzdWJ0cmFjdCAxIC0gaWYgb2Zmc2V0IHRoZW4gdGhlcmUncyBvbmUgbGVzcyBsYWJlbCB0aGFuIHRpY2tcbiAgICAvLyBpZiBub3Qgb2Zmc2V0IHRoZW4gb25lIGhhbGYgbGFiZWwgcGFkZGluZyBpcyBhZGRlZCB0byBlYWNoIGVuZCBsZWF2aW5nIHJvb20gZm9yIG9uZSBsZXNzIGxhYmVsXG4gICAgY29uc3QgY2FwYWNpdHkgPSBNYXRoLmZsb29yKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoIC8gc2l6ZS53IDogdGhpcy5oZWlnaHQgLyBzaXplLmgpIC0gMTtcbiAgICByZXR1cm4gY2FwYWNpdHkgPiAwID8gY2FwYWNpdHkgOiAxO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldERhdGFUaW1lc3RhbXBzKCkge1xuICAgIGxldCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuZGF0YSB8fCBbXTtcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG5cbiAgICBpZiAodGhpcy5fbm9ybWFsaXplZCAmJiBtZXRhcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAodGhpcy5fY2FjaGUuZGF0YSA9IG1ldGFzWzBdLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aW1lc3RhbXBzID0gdGltZXN0YW1wcy5jb25jYXQobWV0YXNbaV0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcykpO1xuICAgIH1cblxuICAgIHJldHVybiAodGhpcy5fY2FjaGUuZGF0YSA9IHRoaXMubm9ybWFsaXplKHRpbWVzdGFtcHMpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbFRpbWVzdGFtcHMoKSB7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmxhYmVscyB8fCBbXTtcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGltZXN0YW1wcy5wdXNoKHBhcnNlKHRoaXMsIGxhYmVsc1tpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiAodGhpcy5fY2FjaGUubGFiZWxzID0gdGhpcy5fbm9ybWFsaXplZCA/IHRpbWVzdGFtcHMgOiB0aGlzLm5vcm1hbGl6ZSh0aW1lc3RhbXBzKSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gdmFsdWVzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIG5vcm1hbGl6ZSh2YWx1ZXMpIHtcbiAgICAvLyBJdCBzZWVtcyB0byBiZSBzb21ld2hhdCBmYXN0ZXIgdG8gZG8gc29ydGluZyBmaXJzdFxuICAgIHJldHVybiBfYXJyYXlVbmlxdWUodmFsdWVzLnNvcnQoc29ydGVyKSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgVGltZVNjYWxlIGZyb20gJy4vc2NhbGUudGltZS5qcyc7XG5pbXBvcnQge19sb29rdXBCeUtleX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuXG4vKipcbiAqIExpbmVhcmx5IGludGVycG9sYXRlcyB0aGUgZ2l2ZW4gc291cmNlIGB2YWxgIHVzaW5nIHRoZSB0YWJsZS4gSWYgdmFsdWUgaXMgb3V0IG9mIGJvdW5kcywgdmFsdWVzXG4gKiBhdCBlZGdlcyBhcmUgdXNlZCBmb3IgdGhlIGludGVycG9sYXRpb24uXG4gKiBAcGFyYW0ge29iamVjdH0gdGFibGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldmVyc2VdIGxvb2t1cCB0aW1lIGJhc2VkIG9uIHBvc2l0aW9uIGluc3RlYWQgb2YgdmljZSB2ZXJzYVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh0YWJsZSwgdmFsLCByZXZlcnNlKSB7XG4gIGxldCBsbyA9IDA7XG4gIGxldCBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XG4gIGxldCBwcmV2U291cmNlLCBuZXh0U291cmNlLCBwcmV2VGFyZ2V0LCBuZXh0VGFyZ2V0O1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnBvcyAmJiB2YWwgPD0gdGFibGVbaGldLnBvcykge1xuICAgICAgKHtsbywgaGl9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAncG9zJywgdmFsKSk7XG4gICAgfVxuICAgICh7cG9zOiBwcmV2U291cmNlLCB0aW1lOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XG4gICAgKHtwb3M6IG5leHRTb3VyY2UsIHRpbWU6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsID49IHRhYmxlW2xvXS50aW1lICYmIHZhbCA8PSB0YWJsZVtoaV0udGltZSkge1xuICAgICAgKHtsbywgaGl9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAndGltZScsIHZhbCkpO1xuICAgIH1cbiAgICAoe3RpbWU6IHByZXZTb3VyY2UsIHBvczogcHJldlRhcmdldH0gPSB0YWJsZVtsb10pO1xuICAgICh7dGltZTogbmV4dFNvdXJjZSwgcG9zOiBuZXh0VGFyZ2V0fSA9IHRhYmxlW2hpXSk7XG4gIH1cblxuICBjb25zdCBzcGFuID0gbmV4dFNvdXJjZSAtIHByZXZTb3VyY2U7XG4gIHJldHVybiBzcGFuID8gcHJldlRhcmdldCArIChuZXh0VGFyZ2V0IC0gcHJldlRhcmdldCkgKiAodmFsIC0gcHJldlNvdXJjZSkgLyBzcGFuIDogcHJldlRhcmdldDtcbn1cblxuY2xhc3MgVGltZVNlcmllc1NjYWxlIGV4dGVuZHMgVGltZVNjYWxlIHtcblxuICBzdGF0aWMgaWQgPSAndGltZXNlcmllcyc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSBUaW1lU2NhbGUuZGVmYXVsdHM7XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuXHQgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAvKiogQHR5cGUge29iamVjdFtdfSAqL1xuICAgIHRoaXMuX3RhYmxlID0gW107XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fbWluUG9zID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3RhYmxlUmFuZ2UgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgaW5pdE9mZnNldHMoKSB7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpO1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5fdGFibGUgPSB0aGlzLmJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcyk7XG4gICAgdGhpcy5fbWluUG9zID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWluKTtcbiAgICB0aGlzLl90YWJsZVJhbmdlID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWF4KSAtIHRoaXMuX21pblBvcztcbiAgICBzdXBlci5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHt0aW1lLCBwb3N9IG9iamVjdHMgdXNlZCB0byBpbnRlcnBvbGF0ZSBhIHNwZWNpZmljIGB0aW1lYCBvciBwb3NpdGlvblxuXHQgKiAoYHBvc2ApIG9uIHRoZSBzY2FsZSwgYnkgc2VhcmNoaW5nIGVudHJpZXMgYmVmb3JlIGFuZCBhZnRlciB0aGUgcmVxdWVzdGVkIHZhbHVlLiBgcG9zYCBpc1xuXHQgKiBhIGRlY2ltYWwgYmV0d2VlbiAwIGFuZCAxOiAwIGJlaW5nIHRoZSBzdGFydCBvZiB0aGUgc2NhbGUgKGxlZnQgb3IgdG9wKSBhbmQgMSB0aGUgb3RoZXJcblx0ICogZXh0cmVtaXR5IChsZWZ0ICsgd2lkdGggb3IgdG9wICsgaGVpZ2h0KS4gTm90ZSB0aGF0IGl0IHdvdWxkIGJlIG1vcmUgb3B0aW1pemVkIHRvIGRpcmVjdGx5XG5cdCAqIHN0b3JlIHByZS1jb21wdXRlZCBwaXhlbHMsIGJ1dCB0aGUgc2NhbGUgZGltZW5zaW9ucyBhcmUgbm90IGd1YXJhbnRlZWQgYXQgdGhlIHRpbWUgd2UgbmVlZFxuXHQgKiB0byBjcmVhdGUgdGhlIGxvb2t1cCB0YWJsZS4gVGhlIHRhYmxlIEFMV0FZUyBjb250YWlucyBhdCBsZWFzdCB0d28gaXRlbXM6IG1pbiBhbmQgbWF4LlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSB0aW1lc3RhbXBzXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBidWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcztcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IHRhYmxlID0gW107XG4gICAgbGV0IGksIGlsZW4sIHByZXYsIGN1cnIsIG5leHQ7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGltZXN0YW1wcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGN1cnIgPSB0aW1lc3RhbXBzW2ldO1xuICAgICAgaWYgKGN1cnIgPj0gbWluICYmIGN1cnIgPD0gbWF4KSB7XG4gICAgICAgIGl0ZW1zLnB1c2goY3Vycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDIpIHtcbiAgICAgIC8vIEluIGNhc2UgdGhlcmUgaXMgbGVzcyB0aGF0IDIgdGltZXN0YW1wcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LCB0aGUgc2NhbGUgaXMgZGVmaW5lZCBieSBtaW4gYW5kIG1heFxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3RpbWU6IG1pbiwgcG9zOiAwfSxcbiAgICAgICAge3RpbWU6IG1heCwgcG9zOiAxfVxuICAgICAgXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBuZXh0ID0gaXRlbXNbaSArIDFdO1xuICAgICAgcHJldiA9IGl0ZW1zW2kgLSAxXTtcbiAgICAgIGN1cnIgPSBpdGVtc1tpXTtcblxuICAgICAgLy8gb25seSBhZGQgcG9pbnRzIHRoYXQgYnJlYWtzIHRoZSBzY2FsZSBsaW5lYXJpdHlcbiAgICAgIGlmIChNYXRoLnJvdW5kKChuZXh0ICsgcHJldikgLyAyKSAhPT0gY3Vycikge1xuICAgICAgICB0YWJsZS5wdXNoKHt0aW1lOiBjdXJyLCBwb3M6IGkgLyAoaWxlbiAtIDEpfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWJsZTtcbiAgfVxuXG4gIC8qKlxuICAgICogR2VuZXJhdGVzIGFsbCB0aW1lc3RhbXBzIGRlZmluZWQgaW4gdGhlIGRhdGEuXG4gICAgKiBJbXBvcnRhbnQ6IHRoaXMgbWV0aG9kIGNhbiByZXR1cm4gdGlja3Mgb3V0c2lkZSB0aGUgbWluIGFuZCBtYXggcmFuZ2UsIGl0J3MgdGhlXG4gICAgKiByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGluZyBjb2RlIHRvIGNsYW1wIHZhbHVlcyBpZiBuZWVkZWQuXG4gICAgKiBAcHJvdGVjdGVkXG4gICAgKi9cbiAgX2dlbmVyYXRlKCkge1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGxldCB0aW1lc3RhbXBzID0gc3VwZXIuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBpZiAoIXRpbWVzdGFtcHMuaW5jbHVkZXMobWluKSB8fCAhdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHRpbWVzdGFtcHMuc3BsaWNlKDAsIDAsIG1pbik7XG4gICAgfVxuICAgIGlmICghdGltZXN0YW1wcy5pbmNsdWRlcyhtYXgpIHx8IHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aW1lc3RhbXBzLnB1c2gobWF4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVzdGFtcHMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYWxsIHRpbWVzdGFtcHNcblx0ICogQHJldHVybiB7bnVtYmVyW119XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCkge1xuICAgIGxldCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuYWxsIHx8IFtdO1xuXG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggJiYgbGFiZWwubGVuZ3RoKSB7XG4gICAgICAvLyBJZiBjb21iaW5pbmcgbGFiZWxzIGFuZCBkYXRhIChkYXRhIG1pZ2h0IG5vdCBjb250YWluIGFsbCBsYWJlbHMpLFxuICAgICAgLy8gd2UgbmVlZCB0byByZWNoZWNrIHVuaXF1ZW5lc3MgYW5kIHNvcnRcbiAgICAgIHRpbWVzdGFtcHMgPSB0aGlzLm5vcm1hbGl6ZShkYXRhLmNvbmNhdChsYWJlbCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lc3RhbXBzID0gZGF0YS5sZW5ndGggPyBkYXRhIDogbGFiZWw7XG4gICAgfVxuICAgIHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgPSB0aW1lc3RhbXBzO1xuXG4gICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gTWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaW50ZXJwb2xhdGUodGhpcy5fdGFibGUsIHZhbHVlKSAtIHRoaXMuX21pblBvcykgLyB0aGlzLl90YWJsZVJhbmdlO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgZGVjaW1hbCA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XG4gICAgcmV0dXJuIGludGVycG9sYXRlKHRoaXMuX3RhYmxlLCBkZWNpbWFsICogdGhpcy5fdGFibGVSYW5nZSArIHRoaXMuX21pblBvcywgdHJ1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGltZVNlcmllc1NjYWxlO1xuIiwgImV4cG9ydCAqIGZyb20gJy4vY29udHJvbGxlcnMvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZWxlbWVudHMvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3BsdWdpbnMvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9zY2FsZXMvaW5kZXguanMnO1xuXG5pbXBvcnQgKiBhcyBjb250cm9sbGVycyBmcm9tICcuL2NvbnRyb2xsZXJzL2luZGV4LmpzJztcbmltcG9ydCAqIGFzIGVsZW1lbnRzIGZyb20gJy4vZWxlbWVudHMvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgcGx1Z2lucyBmcm9tICcuL3BsdWdpbnMvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgc2NhbGVzIGZyb20gJy4vc2NhbGVzL2luZGV4LmpzJztcblxuZXhwb3J0IHtcbiAgY29udHJvbGxlcnMsXG4gIGVsZW1lbnRzLFxuICBwbHVnaW5zLFxuICBzY2FsZXMsXG59O1xuXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJhYmxlcyA9IFtcbiAgY29udHJvbGxlcnMsXG4gIGVsZW1lbnRzLFxuICBwbHVnaW5zLFxuICBzY2FsZXMsXG5dO1xuIiwgImltcG9ydCB7Q2hhcnQsIHJlZ2lzdGVyYWJsZXN9IGZyb20gJy4uL2Rpc3QvY2hhcnQuanMnO1xuXG5DaGFydC5yZWdpc3RlciguLi5yZWdpc3RlcmFibGVzKTtcblxuZXhwb3J0ICogZnJvbSAnLi4vZGlzdC9jaGFydC5qcyc7XG5leHBvcnQgZGVmYXVsdCBDaGFydDtcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBTUEsT0FBQyxTQUFVQSxTQUFRQyxXQUFVO0FBQzNCO0FBR0EsU0FBQyxXQUFZO0FBQ1gsY0FBSSxXQUFXO0FBQ2YsY0FBSSxVQUFVLENBQUMsTUFBTSxPQUFPLFVBQVUsR0FBRztBQUN6QyxtQkFBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLFVBQVUsQ0FBQ0QsUUFBTyx1QkFBdUIsRUFBRSxHQUFHO0FBQ3hFLFlBQUFBLFFBQU8sd0JBQ0xBLFFBQU8sUUFBUSxDQUFDLElBQUksdUJBQXVCO0FBQzdDLFlBQUFBLFFBQU8sdUJBQ0xBLFFBQU8sUUFBUSxDQUFDLElBQUksc0JBQXNCLEtBQzFDQSxRQUFPLFFBQVEsQ0FBQyxJQUFJLDZCQUE2QjtBQUFBLFVBQ3JEO0FBQ0EsY0FB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QUFNLE9BQU8sT0FBTyxJQUFJLEVBQUUsQ0FBQyxPQUNuQyxPQUFPLE1BQU0sT0FBTztBQUFBLEVBQzFCO0FBRUEsTUFBTSxNQUFNO0FBQUEsSUFDVixHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsRUFDTDtBQUNBLE1BQU0sVUFBVTtBQUFBLElBQ2QsUUFBUTtBQUFBLElBQ1IsYUFBYTtBQUFBLElBQ2IsTUFBTTtBQUFBLElBQ04sV0FBVztBQUFBLElBQ1gsTUFBTTtBQUFBLElBQ04sT0FBTztBQUFBLElBQ1AsUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsY0FBYztBQUFBLElBQ2QsSUFBSTtBQUFBLElBQ0osU0FBUztBQUFBLElBQ1QsTUFBTTtBQUFBLElBQ04sV0FBVztBQUFBLElBQ1gsUUFBUTtBQUFBLElBQ1IsVUFBVTtBQUFBLElBQ1YsU0FBUztBQUFBLElBQ1QsS0FBSztBQUFBLElBQ0wsYUFBYTtBQUFBLElBQ2IsU0FBUztBQUFBLElBQ1QsU0FBUztBQUFBLElBQ1QsTUFBTTtBQUFBLElBQ04sS0FBSztBQUFBLElBQ0wsT0FBTztBQUFBLElBQ1AsU0FBUztBQUFBLElBQ1QsTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLElBQ04sUUFBUTtBQUFBLElBQ1IsU0FBUztBQUFBLElBQ1QsVUFBVTtBQUFBLElBQ1YsUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsS0FBSztBQUFBLElBQ0wsUUFBUTtBQUFBLElBQ1IsUUFBUTtBQUFBLElBQ1IsTUFBTTtBQUFBLElBQ04sT0FBTztBQUFBLElBQ1AsT0FBTztBQUFBLElBQ1AsS0FBSztBQUFBLElBQ0wsUUFBUTtBQUFBLElBQ1IsUUFBUTtBQUFBLElBQ1IsVUFBVTtBQUFBLElBQ1YsUUFBUTtBQUFBLElBQ1IsUUFBUTtBQUFBLElBQ1IsVUFBVTtBQUFBLElBQ1YsVUFBVTtBQUFBLElBQ1YsVUFBVTtBQUFBLElBQ1YsVUFBVTtBQUFBLElBQ1YsUUFBUTtBQUFBLElBQ1IsU0FBUztBQUFBLElBQ1QsV0FBVztBQUFBLElBQ1gsS0FBSztBQUFBLElBQ0wsUUFBUTtBQUFBLElBQ1IsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsT0FBTztBQUFBLElBQ1AsS0FBSztBQUFBLElBQ0wsU0FBUztBQUFBLElBQ1QsUUFBUTtBQUFBLElBQ1IsU0FBUztBQUFBLElBQ1QsT0FBTztBQUFBLElBQ1AsTUFBTTtBQUFBLElBQ04sT0FBTztBQUFBLElBQ1AsUUFBUTtBQUFBLElBQ1IsV0FBVztBQUFBLElBQ1gsU0FBUztBQUFBLElBQ1QsWUFBWTtBQUFBLElBQ1osS0FBSztBQUFBLElBQ0wsTUFBTTtBQUFBLElBQ04sT0FBTztBQUFBLElBQ1AsV0FBVztBQUFBLElBQ1gsTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLElBQ04sUUFBUTtBQUFBLElBQ1IsUUFBUTtBQUFBLElBQ1IsUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsT0FBTztBQUFBLElBQ1AsU0FBUztBQUFBLElBQ1QsS0FBSztBQUFBLElBQ0wsTUFBTTtBQUFBLElBQ04sU0FBUztBQUFBLElBQ1QsS0FBSztBQUFBLElBQ0wsUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsWUFBWTtBQUFBLElBQ1osS0FBSztBQUFBLElBQ0wsT0FBTztBQUFBLElBQ1AsUUFBUTtBQUFBLElBQ1IsUUFBUTtBQUFBLElBQ1IsTUFBTTtBQUFBLElBQ04sV0FBVztBQUFBLElBQ1gsS0FBSztBQUFBLElBQ0wsVUFBVTtBQUFBLElBQ1YsWUFBWTtBQUFBLElBQ1osU0FBUztBQUFBLElBQ1QsVUFBVTtBQUFBLElBQ1YsU0FBUztBQUFBLElBQ1QsWUFBWTtBQUFBLElBQ1osTUFBTTtBQUFBLElBQ04sUUFBUTtBQUFBLElBQ1IsTUFBTTtBQUFBLElBQ04sU0FBUztBQUFBLElBQ1QsT0FBTztBQUFBLElBQ1AsU0FBUztBQUFBLElBQ1QsTUFBTTtBQUFBLElBQ04sV0FBVztBQUFBLElBQ1gsUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsWUFBWTtBQUFBLElBQ1osV0FBVztBQUFBLElBQ1gsU0FBUztBQUFBLElBQ1QsTUFBTTtBQUFBLElBQ04sS0FBSztBQUFBLElBQ0wsTUFBTTtBQUFBLElBQ04sU0FBUztBQUFBLElBQ1QsT0FBTztBQUFBLElBQ1AsYUFBYTtBQUFBLElBQ2IsSUFBSTtBQUFBLElBQ0osVUFBVTtBQUFBLElBQ1YsT0FBTztBQUFBLElBQ1AsV0FBVztBQUFBLElBQ1gsT0FBTztBQUFBLElBQ1AsV0FBVztBQUFBLElBQ1gsT0FBTztBQUFBLElBQ1AsU0FBUztBQUFBLElBQ1QsT0FBTztBQUFBLElBQ1AsUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsS0FBSztBQUFBLElBQ0wsTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLElBQ04sVUFBVTtBQUFBLElBQ1YsUUFBUTtBQUFBLElBQ1IsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsT0FBTztBQUFBLElBQ1AsUUFBUTtBQUFBLElBQ1IsSUFBSTtBQUFBLElBQ0osT0FBTztBQUFBLElBQ1AsS0FBSztBQUFBLElBQ0wsTUFBTTtBQUFBLElBQ04sV0FBVztBQUFB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QUFhLEVBQUUsVUFBVSxNQUFNLEtBQUssVUFBVSxLQUFLLEdBQUcsRUFBRTtBQUNoRixlQUFTLGVBQWUsYUFBYSxFQUFFLFVBQVUsTUFBTSxLQUFLLFVBQVUsS0FBSyxHQUFHLEVBQUU7QUFBQSxJQUNsRjtBQUFBLEVBQ0Y7QUFFQSxNQUFJLFlBQVksU0FBUyxjQUFjLHlCQUF5QixFQUFFLGFBQWEsU0FBUztBQUN4RixNQUFJLGFBQWEsSUFBSSxXQUFXLFNBQVMsUUFBUTtBQUFBLElBQy9DLG9CQUFvQjtBQUFBLElBQ3BCO0FBQUEsSUFDQSxRQUFRLEVBQUMsYUFBYSxVQUFTO0FBQUEsRUFDakMsQ0FBQztBQUdELGdCQUFBMDNELFFBQU8sT0FBTyxFQUFDLFdBQVcsRUFBQyxHQUFHLE9BQU0sR0FBRyxhQUFhLG9CQUFtQixDQUFDO0FBQ3hFLFNBQU8saUJBQWlCLDBCQUEwQixXQUFTLGNBQUFBLFFBQU8sS0FBSyxHQUFHLENBQUM7QUFDM0UsU0FBTyxpQkFBaUIseUJBQXlCLFdBQVMsY0FBQUEsUUFBTyxLQUFLLENBQUM7QUFHdkUsYUFBVyxRQUFRO0FBTW5CLFNBQU8sYUFBYTsiLAogICJuYW1lcyI6IFsid2luZG93IiwgImRvY3VtZW50IiwgImNhbGxiYWNrIiwgInRvcGJhciIsICJ0byIsICJDdXN0b21FdmVudCIsICJ0byIsICJjbG9zdXJlIiwgImNhbGxiYWNrIiwgImNhbGxiYWNrIiwgImxpdmVTb2NrZXQiLCAiY2xvc3VyZSIsICJjYWxsYmFjayIsICJ0byIsICJkZWZhdWx0cyIsICJuYW1lcyIsICJkZWJvdW5jZSIsICJmcm9tIiwgInNraXAiLCAiZWxlbWVudHMiLCAiaG9va3MiLCAicmFuZ2UiLCAiY2xvbmUiLCAiY29sb3IiLCAibm9vcCIsICJ1aWQiLCAiaWQiLCAiaXNOdWxsT3JVbmRlZiIsICJ2YWx1ZSIsICJpc0FycmF5IiwgIkFycmF5IiwgInR5cGUiLCAiT2JqZWN0IiwgInByb3RvdHlwZSIsICJ0b1N0cmluZyIsICJjYWxsIiwgInNsaWNlIiwgImlzT2JqZWN0IiwgImlzTnVtYmVyRmluaXRlIiwgIk51bWJlciIsICJpc0Zpbml0ZSIsICJmaW5pdGVPckRlZmF1bHQiLCAiZGVmYXVsdFZhbHVlIiwgInZhbHVlT3JEZWZhdWx0IiwgInRvUGVyY2VudGFnZSIsICJkaW1lbnNpb24iLCAiZW5kc1dpdGgiLCAicGFyc2VGbG9hdCIsICJ0b0RpbWVuc2lvbiIsICJjYWxsYmFjayIsICJmbiIsICJhcmdzIiwgInRoaXNBcmciLCAiYXBwbHkiLCAiZWFjaCIsICJsb29wYWJsZSIsICJyZXZlcnNlIiwgImkiLCAibGVuIiwgImtleXMiLCAibGVuZ3RoIiwgIl9lbGVtZW50c0VxdWFsIiwgImEwIiwgImExIiwgImlsZW4iLCAidjAiLCAidjEiLCAiZGF0YXNldEluZGV4IiwgImluZGV4IiwgImNsb25lIiwgInNvdXJjZSIsICJtYXAiLCAidGFyZ2V0IiwgImNyZWF0ZSIsICJrbGVuIiwgImsiLCAiaXNWYWxpZEtleSIsICJrZXkiLCAiaW5kZXhPZiIsICJfbWVyZ2VyIiwgIm9wdGlvbnMiLCAidHZhbCIsICJzdmFsIiwgIm1lcmdlIiwgInNvdXJjZXMiLCAibWVyZ2VyIiwgImN1cnJlbnQiLCAibWVyZ2VJZiIsICJfbWVyZ2VySWYiLCAiaGFzT3duUHJvcGVydHkiLCAia2V5UmVzb2x2ZXJzIiwgInYiLCAieCIsICJvIiwgInkiLCAiX3NwbGl0S2V5IiwgImtleSIsICJwYXJ0cyIsICJzcGxpdCIsICJrZXlzIiwgInRtcCIsICJwYXJ0IiwgImVuZHNXaXRoIiwgInNsaWNlIiwgInB1c2giLCAiX2dldEtleVJlc29sdmVyIiwgIm9iaiIsICJrIiwgInJlc29sdmVPYmplY3RLZXkiLCAicmVzb2x2ZXIiLCAiX2NhcGl0YWxpemUiLCAic3RyIiwgImNoYXJBdCIsICJ0b1VwcGVyQ2FzZSIsICJkZWZpbmVkIiwgInZhbHVlIiwgImlzRnVuY3Rpb24iLCAic2V0c0VxdWFsIiwgImEiLCAiYiIsICJzaXplIiwgIml0ZW0iLCAiaGFzIiwgIl9pc0NsaWNrRXZlbnQiLCAiZSIsICJ0eXBlIiwgIlBJIiwgIk1hdGgiLCAiVEFVIiwgIlBJVEFVIiwgIklORklOSVRZIiwgIk51bWJlciIsICJQT1NJVElWRV9JTkZJTklUWSIsICJSQURfUEVSX0RFRyIsICJIQUxGX1BJIiwgIlFVQVJURVJfUEkiLCAiVFdPX1RISVJEU19QSSIsICJsb2cxMCIsICJzaWduIiwgImFsbW9zdEVxdWFscyIsICJlcHNpbG9uIiwgImFicyIsICJuaWNlTnVtIiwgInJhbmdlIiwgInJvdW5kZWRSYW5nZSIsICJyb3VuZCIsICJuaWNlUmFuZ2UiLCAicG93IiwgImZsb29yIiwgImZyYWN0aW9uIiwgIm5pY2VGcmFjdGlvbiIsICJfZmFjdG9yaXplIiwgInJlc3VsdCIsICJzcXJ0IiwgImkiLCAic29ydCIsICJwb3AiLCAiaXNOdW1iZXIiLCAibiIsICJpc05hTiIsICJwYXJzZUZsb2F0IiwgImlzRmluaXRlIiwgImFsbW9zdFdob2xlIiwgInJvdW5kZWQiLCAiX3NldE1pbkFuZE1heEJ5S2V5IiwgImFycmF5IiwgInRhcmdldCIsICJwcm9wZXJ0eSIsICJpbGVuIiwgImxlbmd0aCIsICJtaW4iLCAibWF4IiwgInRvUmFkaWFucyIsICJkZWdyZWVzIiwgInRvRGVncmVlcyIsICJyYWRpYW5zIiwgIl9kZWNpbWFsUGxhY2VzIiwgImlzRmluaXRlTnVtYmVyIiwgInAiLCAiZ2V0QW5nbGVGcm9tUG9pbnQiLCAiY2VudHJlUG9pbnQiLCAiYW5nbGVQb2ludCIsICJkaXN0YW5jZUZyb21YQ2VudGVyIiwgImRpc3RhbmNlRnJvbVlDZW50ZXIiLCAicmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyIiwgImFuZ2xlIiwgImF0YW4yIiwgImRpc3RhbmNlIiwgImRpc3RhbmNlQmV0d2VlblBvaW50cyIsICJwdDEiLCAicHQyIiwgIl9hbmdsZURpZmYiLCAiX25vcm1hbGl6ZUFuZ2xlIiwgIl9hbmdsZUJldHdlZW4iLCAic3RhcnQiLCAiZW5kIiwgInNhbWVBbmdsZUlzRnVsbENpcmNsZSIsICJzIiwgImFuZ2xlVG9TdGFydCIsICJhbmdsZVRvRW5kIiwgInN0YXJ0VG9BbmdsZSIsICJlbmRUb0FuZ2xlIiwgIl9saW1pdFZhbHVlIiwgIl9pbnQxNlJhbmdlIiwgIl9pc0JldHdlZW4iLCAiX2xvb2t1cCIsICJ0YWJsZSIsICJjbXAiLCAiaW5kZXgiLCAiaGkiLCAibG8iLCAibWlkIiwgIl9sb29rdXBCeUtleSIsICJsYXN0IiwgInRpIiwgIl9ybG9va3VwQnlLZXkiLCAiX2ZpbHRlckJldHdlZW4iLCAidmFsdWVzIiwgImFycmF5RXZlbnRzIiwgImxpc3RlbkFycmF5RXZlbnRzIiwgImxpc3RlbmVyIiwgIl9jaGFydGpzIiwgImxpc3RlbmVycyIsICJPYmplY3QiLCAiZGVmaW5lUHJvcGVydHkiLCAiY29uZmlndXJhYmxlIiwgImVudW1lcmFibGUiLCAiZm9yRWFjaCIsICJtZXRob2QiLCAiYmFzZSIsICJhcmdzIiwgInJlcyIsICJhcHBseSIsICJvYmplY3QiLCAidW5saXN0ZW5BcnJheUV2ZW50cyIsICJzdHViIiwgImluZGV4T2YiLCAic3BsaWNlIiwgIl9hcnJheVVuaXF1ZSIsICJpdGVtcyIsICJzZXQiLCAiU2V0IiwgIkFycmF5IiwgImZyb20iLCAicmVxdWVzdEFuaW1GcmFtZSIsICJ3aW5kb3ciLCAiY2FsbGJhY2siLCAicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwgInRocm90dGxlZCIsICJmbiIsICJ0aGlzQXJnIiwgImFyZ3NUb1VzZSIsICJ0aWNraW5nIiwgImFyZ3MiLCAiY2FsbCIsICJhcHBseSIsICJkZWJvdW5jZSIsICJkZWxheSIsICJ0aW1lb3V0IiwgImNsZWFyVGltZW91dCIsICJzZXRUaW1lb3V0IiwgIl90b0xlZnRSaWdodENlbnRlciIsICJhbGlnbiIsICJfYWxpZ25TdGFydEVuZCIsICJzdGFydCIsICJlbmQiLCAiX3RleHRYIiwgImxlZnQiLCAicmlnaHQiLCAicnRsIiwgImNoZWNrIiwgIl9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzIiwgIm1ldGEiLCAicG9pbnRzIiwgImFuaW1hdGlvbnNEaXNhYmxlZCIsICJwb2ludENvdW50IiwgImxlbmd0aCIsICJjb3VudCIsICJfc29ydGVkIiwgImlTY2FsZSIsICJfcGFyc2VkIiwgImF4aXMiLCAibWluIiwgIm1heCIsICJtaW5EZWZpbmVkIiwgIm1heERlZmluZWQiLCAiZ2V0VXNlckJvdW5kcyIsICJfbGltaXRWYWx1ZSIsICJNYXRoIiwgIl9sb29rdXBCeUtleSIsICJsbyIsICJnZXRQaXhlbEZvclZhbHVlIiwgImhpIiwgIl9zY2FsZVJhbmdlc0NoYW5nZWQiLCAieFNjYWxlIiwgInlTY2FsZSIsICJfc2NhbGVSYW5nZXMiLCAibmV3UmFuZ2VzIiwgInhtaW4iLCAieG1heCIsICJ5bWluIiwgInltYXgiLCAiY2hhbmdlZCIsICJPYmplY3QiLCAiYXNzaWduIiwgImF0RWRnZSIsICJ0IiwgImVsYXN0aWNJbiIsICJzIiwgInAiLCAicG93IiwgInNpbiIsICJUQVUiLCAiZWxhc3RpY091dCIsICJlZmZlY3RzIiwgImxpbmVhciIsICJlYXNlSW5RdWFkIiwgImVhc2VPdXRRdWFkIiwgImVhc2VJbk91dFF1YWQiLCAiZWFzZUluQ3ViaWMiLCAiZWFzZU91dEN1YmljIiwgImVhc2VJbk91dEN1YmljIiwgImVhc2VJblF1YXJ0IiwgImVhc2VPdXRRdWFydCIsICJlYXNlSW5PdXRRdWFydCIsICJlYXNlSW5RdWludCIsICJlYXNlT3V0UXVpbnQiLCAiZWFzZUluT3V0UXVpbnQiLCAiZWFzZUluU2luZSIsICJjb3MiLCAiSEFMRl9QSSIsICJlYXNlT3V0U2luZSIsICJlYXNlSW5PdXRTaW5lIiwgIlBJIiwgImVhc2VJbkV4cG8iLCAiZWFzZU91dEV4cG8iLCAiZWFzZUluT3V0RXhwbyIsICJlYXNlSW5DaXJjIiwgInNxcnQiLCAiZWFzZU91dENpcmMiLCAiZWFzZUluT3V0Q2lyYyIsICJlYXNlSW5FbGFzdGljIiwgImVhc2VPdXRFbGFzdGljIiwgImVhc2VJbk91dEVsYXN0aWMiLCAiZWFzZUluQmFjayIsICJlYXNlT3V0QmFjayIsICJlYXNlSW5PdXRCYWNrIiwgImVhc2VJbkJvdW5jZSIsICJlYXNlT3V0Qm91bmNlIiwgIm0iLCAiZCIsICJlYXNlSW5PdXRCb3VuY2UiLCAiaXNQYXR0ZXJuT3JHcmFkaWVudCIsICJ2YWx1ZSIsICJ0eXBlIiwgInRvU3RyaW5nIiwgImNvbG9yIiwgIkNvbG9yIiwgImdldEhvdmVyQ29sb3IiLCAic2F0dXJhdGUiLCAiZGFya2VuIiwgImhleFN0cmluZyIsICJudW1iZXJzIiwgImNvbG9ycyIsICJhcHBseUFuaW1hdGlvbnNEZWZhdWx0cyIsICJkZWZhdWx0cyIsICJzZXQiLCAidW5kZWZpbmVkIiwgImR1cmF0aW9uIiwgImVhc2luZyIsICJmcm9tIiwgImxvb3AiLCAidG8iLCAiZGVzY3JpYmUiLCAiX2ZhbGxiYWNrIiwgIl9pbmRleGFibGUiLCAiX3NjcmlwdGFibGUiLCAibmFtZSIsICJwcm9wZXJ0aWVzIiwgImFjdGl2ZSIsICJhbmltYXRpb24iLCAicmVzaXplIiwgInNob3ciLCAiYW5pbWF0aW9ucyIsICJ2aXNpYmxlIiwgImhpZGUiLCAidiIsICJhcHBseUxheW91dHNEZWZhdWx0cyIsICJhdXRvUGFkZGluZyIsICJwYWRkaW5nIiwgInRvcCIsICJib3R0b20iLCAiaW50bENhY2hlIiwgIk1hcCIsICJnZXROdW1iZXJGb3JtYXQiLCAibG9jYWxlIiwgIm9wdGlvbnMiLCAiY2FjaGVLZXkiLCAiSlNPTiIsICJzdHJpbmdpZnkiLCAiZm9ybWF0dGVyIiwgImdldCIsICJJbnRsIiwgIk51bWJlckZvcm1hdCIsICJmb3JtYXROdW1iZXIiLCAibnVtIiwgImZvcm1hdCIsICJmb3JtYXR0ZXJzIiwgInZhbHVlcyIsICJpc0FycmF5IiwgIm51bWVyaWMiLCAidGlja1ZhbHVlIiwgImluZGV4IiwgInRpY2tzIiwgImNoYXJ0IiwgIm5vdGF0aW9uIiwgImRlbHRhIiwgIm1heFRpY2siLCAiYWJzIiwgImNhbGN1bGF0ZURlbHRhIiwgImxvZ0RlbHRhIiwgImxvZzEwIiwgIm51bURlY2ltYWwiLCAiaXNOYU4iLCAiZmxvb3IiLCAibWluaW11bUZyYWN0aW9uRGlnaXRzIiwgIm1heGltdW1GcmFjdGlvbkRpZ2l0cyIsICJsb2dhcml0aG1pYyIsICJyZW1haW4iLCAic2lnbmlmaWNhbmQiLCAiaW5jbHVkZXMiLCAiYXBwbHlTY2FsZURlZmF1bHRzIiwgImRpc3BsYXkiLCAib2Zmc2V0IiwgInJldmVyc2UiLCAiYmVnaW5BdFplcm8iLCAiYm91bmRzIiwgImNsaXAiLCAiZ3JhY2UiLCAiZ3JpZCIsICJsaW5lV2lkdGgiLCAiZHJhd09uQ2hhcnRBcmVhIiwgImRyYXdUaWNrcyIsICJ0aWNrTGVuZ3RoIiwgInRpY2tXaWR0aCIsICJfY3R4IiwgInRpY2tDb2xvciIsICJib3JkZXIiLCAiZGFzaCIsICJkYXNoT2Zmc2V0IiwgIndpZHRoIiwgInRpdGxlIiwgInRleHQiLCAibWluUm90YXRpb24iLCAibWF4Um90YXRpb24iLCAibWlycm9yIiwgInRleHRTdHJva2VXaWR0aCIsICJ0ZXh0U3Ryb2tlQ29sb3IiLCAiYXV0b1NraXAiLCAiYXV0b1NraXBQYWRkaW5nIiwgImxhYmVsT2Zmc2V0IiwgIlRpY2tzIiwgIm1pbm9yIiwgIm1ham9yIiwgImNyb3NzQWxpZ24iLCAic2hvd0xhYmVsQmFja2Ryb3AiLCAiYmFja2Ryb3BDb2xvciIsICJiYWNrZHJvcFBhZGRpbmciLCAicm91dGUiLCAic3RhcnRzV2l0aCIsICJvdmVycmlkZXMiLCAiY3JlYXRlIiwgImRlc2NyaXB0b3JzIiwgImdldFNjb3BlIiwgIm5vZGUiLCAia2V5IiwgImtleXMiLCAic3BsaXQiLCAiaSIsICJuIiwgImsiLCAicm9vdCIsICJzY29wZSIsICJtZXJnZSIsICJEZWZhdWx0cyIsICJjb25zdHJ1Y3RvciIsICJfZGVzY3JpcHRvcnMiLCAiX2FwcGxpZXJzIiwgImJhY2tncm91bmRDb2xvciIsICJib3JkZXJDb2xvciIsICJkYXRhc2V0cyIsICJkZXZpY2VQaXhlbFJhdGlvIiwgImNvbnRleHQiLCAicGxhdGZvcm0iLCAiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsICJlbGVtZW50cyIsICJldmVudHMiLCAiZm9udCIsICJmYW1pbHkiLCAic2l6ZSIsICJzdHlsZSIsICJsaW5lSGVpZ2h0IiwgIndlaWdodCIsICJob3ZlciIsICJob3ZlckJhY2tncm91bmRDb2xvciIsICJjdHgiLCAiaG92ZXJCb3JkZXJDb2xvciIsICJob3ZlckNvbG9yIiwgImluZGV4QXhpcyIsICJpbnRlcmFjdGlvbiIsICJtb2RlIiwgImludGVyc2VjdCIsICJpbmNsdWRlSW52aXNpYmxlIiwgIm1haW50YWluQXNwZWN0UmF0aW8iLCAib25Ib3ZlciIsICJvbkNsaWNrIiwgInBhcnNpbmciLCAicGx1Z2lucyIsICJyZXNwb25zaXZlIiwgInNjYWxlIiwgInNjYWxlcyIsICJzaG93TGluZSIsICJkcmF3QWN0aXZlRWxlbWVudHNPblRvcCIsICJvdmVycmlkZSIsICJ0YXJnZXRTY29wZSIsICJ0YXJnZXROYW1lIiwgInNjb3BlT2JqZWN0IiwgInRhcmdldFNjb3BlT2JqZWN0IiwgInByaXZhdGVOYW1lIiwgImRlZmluZVByb3BlcnRpZXMiLCAid3JpdGFibGUiLCAiZW51bWVyYWJsZSIsICJsb2NhbCIsICJ0YXJnZXQiLCAiaXNPYmplY3QiLCAidmFsdWVPckRlZmF1bHQiLCAiYXBwbGllcnMiLCAiZm9yRWFjaCIsICJ0b0ZvbnRTdHJpbmciLCAiaXNOdWxsT3JVbmRlZiIsICJfbWVhc3VyZVRleHQiLCAiZGF0YSIsICJnYyIsICJsb25nZXN0IiwgInN0cmluZyIsICJ0ZXh0V2lkdGgiLCAibWVhc3VyZVRleHQiLCAicHVzaCIsICJfbG9uZ2VzdFRleHQiLCAiYXJyYXlPZlRoaW5ncyIsICJjYWNoZSIsICJnYXJiYWdlQ29sbGVjdCIsICJzYXZlIiwgImlsZW4iLCAiaiIsICJqbGVuIiwgInRoaW5nIiwgIm5lc3RlZFRoaW5nIiwgInJlc3RvcmUiLCAiZ2NMZW4iLCAic3BsaWNlIiwgIl9hbGlnblBpeGVsIiwgInBpeGVsIiwgImN1cnJlbnREZXZpY2VQaXhlbFJhdGlvIiwgImhhbGZXaWR0aCIsICJyb3VuZCIsICJjbGVhckNhbnZhcyIsICJjYW52YXMiLCAiZ2V0Q29udGV4dCIsICJyZXNldFRyYW5zZm9ybSIsICJjbGVhclJlY3QiLCAiaGVpZ2h0IiwgImRyYXdQb2ludCIsICJ4IiwgInkiLCAiZHJhd1BvaW50TGVnZW5kIiwgInciLCAieE9mZnNldCIsICJ5T2Zmc2V0IiwgImNvcm5lclJhZGl1cyIsICJ4T2Zmc2V0VyIsICJ5T2Zmc2V0VyIsICJwb2ludFN0eWxlIiwgInJvdGF0aW9uIiwgInJhZGl1cyIsICJyYWQiLCAiUkFEX1BFUl9ERUciLCAidHJhbnNsYXRlIiwgInJvdGF0ZSIsICJkcmF3SW1hZ2UiLCAiYmVnaW5QYXRoIiwgImVsbGlwc2UiLCAiYXJjIiwgImNsb3NlUGF0aCIsICJtb3ZlVG8iLCAiVFdPX1RISVJEU19QSSIsICJsaW5lVG8iLCAiUVVBUlRFUl9QSSIsICJTUVJUMV8yIiwgInJlY3QiLCAiZmlsbCIsICJib3JkZXJXaWR0aCIsICJzdHJva2UiLCAiX2lzUG9pbnRJbkFyZWEiLCAicG9pbnQiLCAiYXJlYSIsICJtYXJnaW4iLCAiY2xpcEFyZWEiLCAidW5jbGlwQXJlYSIsICJfc3RlcHBlZExpbmVUbyIsICJwcmV2aW91cyIsICJmbGlwIiwgIm1pZHBvaW50IiwgIl9iZXppZXJDdXJ2ZVRvIiwgImJlemllckN1cnZlVG8iLCAiY3AxeCIsICJjcDJ4IiwgImNwMXkiLCAiY3AyeSIsICJzZXRSZW5kZXJPcHRzIiwgIm9wdHMiLCAidHJhbnNsYXRpb24iLCAiZmlsbFN0eWxlIiwgInRleHRBbGlnbiIsICJ0ZXh0QmFzZWxpbmUiLCAiZGVjb3JhdGVUZXh0IiwgImxpbmUiLCAic3RyaWtldGhyb3VnaCIsICJ1bmRlcmxpbmUiLCAibWV0cmljcyIsICJhY3R1YWxCb3VuZGluZ0JveExlZnQiLCAiYWN0dWFsQm91bmRpbmdCb3hSaWdodCIsICJhY3R1YWxCb3VuZGluZ0JveEFzY2VudCIsICJhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQiLCAieURlY29yYXRpb24iLCAic3Ryb2tlU3R5bGUiLCAiZGVjb3JhdGlvbldpZHRoIiwgImRyYXdCYWNrZHJvcCIsICJvbGRDb2xvciIsICJmaWxsUmVjdCIsICJyZW5kZXJUZXh0IiwgImxpbmVzIiwgInN0cm9rZVdpZHRoIiwgInN0cm9rZUNvbG9yIiwgImJhY2tkcm9wIiwgInN0cm9rZVRleHQiLCAibWF4V2lkdGgiLCAiZmlsbFRleHQiLCAiTnVtYmVyIiwgImFkZFJvdW5kZWRSZWN0UGF0aCIsICJoIiwgInRvcExlZnQiLCAiYm90dG9tTGVmdCIsICJib3R0b21SaWdodCIsICJ0b3BSaWdodCIsICJMSU5FX0hFSUdIVCIsICJGT05UX1NUWUxFIiwgInRvTGluZUhlaWdodCIsICJtYXRjaGVzIiwgIm1hdGNoIiwgIm51bWJlck9yWmVybyIsICJfcmVhZFZhbHVlVG9Qcm9wcyIsICJwcm9wcyIsICJyZXQiLCAib2JqUHJvcHMiLCAicmVhZCIsICJwcm9wIiwgInRvVFJCTCIsICJ0b1RSQkxDb3JuZXJzIiwgInRvUGFkZGluZyIsICJvYmoiLCAidG9Gb250IiwgImZhbGxiYWNrIiwgInBhcnNlSW50IiwgImNvbnNvbGUiLCAid2FybiIsICJyZXNvbHZlIiwgImlucHV0cyIsICJpbmZvIiwgImNhY2hlYWJsZSIsICJfYWRkR3JhY2UiLCAibWlubWF4IiwgImNoYW5nZSIsICJ0b0RpbWVuc2lvbiIsICJrZWVwWmVybyIsICJhZGQiLCAiY3JlYXRlQ29udGV4dCIsICJwYXJlbnRDb250ZXh0IiwgIl9jcmVhdGVSZXNvbHZlciIsICJzY29wZXMiLCAicHJlZml4ZXMiLCAicm9vdFNjb3BlcyIsICJnZXRUYXJnZXQiLCAiZmluYWxSb290U2NvcGVzIiwgIl9yZXNvbHZlIiwgIlN5bWJvbCIsICJ0b1N0cmluZ1RhZyIsICJfY2FjaGVhYmxlIiwgIl9zY29wZXMiLCAiX3Jvb3RTY29wZXMiLCAiX2dldFRhcmdldCIsICJQcm94eSIsICJkZWxldGVQcm9wZXJ0eSIsICJfa2V5cyIsICJfY2FjaGVkIiwgIl9yZXNvbHZlV2l0aFByZWZpeGVzIiwgImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsICJSZWZsZWN0IiwgImdldFByb3RvdHlwZU9mIiwgImhhcyIsICJnZXRLZXlzRnJvbUFsbFNjb3BlcyIsICJvd25LZXlzIiwgInN0b3JhZ2UiLCAiX3N0b3JhZ2UiLCAiX2F0dGFjaENvbnRleHQiLCAicHJveHkiLCAic3ViUHJveHkiLCAiZGVzY3JpcHRvckRlZmF1bHRzIiwgIl9wcm94eSIsICJfY29udGV4dCIsICJfc3ViUHJveHkiLCAiX3N0YWNrIiwgIlNldCIsICJzZXRDb250ZXh0IiwgInJlY2VpdmVyIiwgIl9yZXNvbHZlV2l0aENvbnRleHQiLCAiYWxsS2V5cyIsICJjb25maWd1cmFibGUiLCAic2NyaXB0YWJsZSIsICJpbmRleGFibGUiLCAiX2FsbEtleXMiLCAiaXNTY3JpcHRhYmxlIiwgImlzRnVuY3Rpb24iLCAiaXNJbmRleGFibGUiLCAicmVhZEtleSIsICJwcmVmaXgiLCAiX2NhcGl0YWxpemUiLCAibmVlZHNTdWJSZXNvbHZlciIsICJwcm90b3R5cGUiLCAiaGFzT3duUHJvcGVydHkiLCAiX3Jlc29sdmVTY3JpcHRhYmxlIiwgIl9yZXNvbHZlQXJyYXkiLCAiZ2V0VmFsdWUiLCAiRXJyb3IiLCAiQXJyYXkiLCAiam9pbiIsICJkZWxldGUiLCAiY3JlYXRlU3ViUmVzb2x2ZXIiLCAiYXJyIiwgImZpbHRlciIsICJpdGVtIiwgInJlc29sdmVyIiwgInJlc29sdmVGYWxsYmFjayIsICJwYXJlbnQiLCAicmVzb2x2ZU9iamVjdEtleSIsICJhZGRTY29wZXMiLCAicGFyZW50U2NvcGVzIiwgInBhcmVudEZhbGxiYWNrIiwgImFsbFNjb3BlcyIsICJhZGRTY29wZXNGcm9tS2V5IiwgInN1YkdldFRhcmdldCIsICJyZXNvbHZlS2V5c0Zyb21BbGxTY29wZXMiLCAiX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlIiwgIl9wYXJzaW5nIiwgInBhcnNlZCIsICJyIiwgInBhcnNlIiwgIkVQU0lMT04iLCAiZ2V0UG9pbnQiLCAic2tpcCIsICJnZXRWYWx1ZUF4aXMiLCAic3BsaW5lQ3VydmUiLCAiZmlyc3RQb2ludCIsICJtaWRkbGVQb2ludCIsICJhZnRlclBvaW50IiwgImN1cnJlbnQiLCAibmV4dCIsICJkMDEiLCAiZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIiwgImQxMiIsICJzMDEiLCAiczEyIiwgImZhIiwgImZiIiwgIm1vbm90b25lQWRqdXN0IiwgImRlbHRhSyIsICJtSyIsICJwb2ludHNMZW4iLCAiYWxwaGFLIiwgImJldGFLIiwgInRhdUsiLCAic3F1YXJlZE1hZ25pdHVkZSIsICJwb2ludEN1cnJlbnQiLCAicG9pbnRBZnRlciIsICJhbG1vc3RFcXVhbHMiLCAibW9ub3RvbmVDb21wdXRlIiwgInZhbHVlQXhpcyIsICJwb2ludEJlZm9yZSIsICJpUGl4ZWwiLCAidlBpeGVsIiwgInNwbGluZUN1cnZlTW9ub3RvbmUiLCAic2xvcGVEZWx0YSIsICJzaWduIiwgImNhcENvbnRyb2xQb2ludCIsICJwdCIsICJjYXBCZXppZXJQb2ludHMiLCAiaW5BcmVhIiwgImluQXJlYVByZXYiLCAiaW5BcmVhTmV4dCIsICJfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyIsICJjb250cm9sUG9pbnRzIiwgInNwYW5HYXBzIiwgImN1YmljSW50ZXJwb2xhdGlvbk1vZGUiLCAicHJldiIsICJ0ZW5zaW9uIiwgIl9pc0RvbVN1cHBvcnRlZCIsICJkb2N1bWVudCIsICJfZ2V0UGFyZW50Tm9kZSIsICJkb21Ob2RlIiwgInBhcmVudE5vZGUiLCAiaG9zdCIsICJwYXJzZU1heFN0eWxlIiwgInN0eWxlVmFsdWUiLCAicGFyZW50UHJvcGVydHkiLCAidmFsdWVJblBpeGVscyIsICJpbmRleE9mIiwgImdldENvbXB1dGVkU3R5bGUiLCAiZWxlbWVudCIsICJvd25lckRvY3VtZW50IiwgImRlZmF1bHRWaWV3IiwgImdldFN0eWxlIiwgImVsIiwgInByb3BlcnR5IiwgImdldFByb3BlcnR5VmFsdWUiLCAicG9zaXRpb25zIiwgImdldFBvc2l0aW9uZWRTdHlsZSIsICJzdHlsZXMiLCAic3VmZml4IiwgInJlc3VsdCIsICJwb3MiLCAicGFyc2VGbG9hdCIsICJ1c2VPZmZzZXRQb3MiLCAic2hhZG93Um9vdCIsICJnZXRDYW52YXNQb3NpdGlvbiIsICJlIiwgInRvdWNoZXMiLCAic291cmNlIiwgIm9mZnNldFgiLCAib2Zmc2V0WSIsICJib3giLCAiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwgImNsaWVudFgiLCAiY2xpZW50WSIsICJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwgImV2ZW50IiwgImJvcmRlckJveCIsICJib3hTaXppbmciLCAicGFkZGluZ3MiLCAiYm9yZGVycyIsICJnZXRDb250YWluZXJTaXplIiwgIm1heEhlaWdodCIsICJjb250YWluZXIiLCAiY2xpZW50V2lkdGgiLCAiY2xpZW50SGVpZ2h0IiwgImNvbnRhaW5lclN0eWxlIiwgImNvbnRhaW5lckJvcmRlciIsICJjb250YWluZXJQYWRkaW5nIiwgIklORklOSVRZIiwgInJvdW5kMSIsICJnZXRNYXhpbXVtU2l6ZSIsICJiYldpZHRoIiwgImJiSGVpZ2h0IiwgImFzcGVjdFJhdGlvIiwgIm1hcmdpbnMiLCAiY29udGFpbmVyU2l6ZSIsICJtYWludGFpbkhlaWdodCIsICJyZXRpbmFTY2FsZSIsICJmb3JjZVJhdGlvIiwgImZvcmNlU3R5bGUiLCAicGl4ZWxSYXRpbyIsICJkZXZpY2VIZWlnaHQiLCAiZGV2aWNlV2lkdGgiLCAic2V0VHJhbnNmb3JtIiwgInN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMiLCAicGFzc2l2ZVN1cHBvcnRlZCIsICJwYXNzaXZlIiwgImFkZEV2ZW50TGlzdGVuZXIiLCAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsICJyZWFkVXNlZFNpemUiLCAiX3BvaW50SW5MaW5lIiwgInAxIiwgInAyIiwgIl9zdGVwcGVkSW50ZXJwb2xhdGlvbiIsICJfYmV6aWVySW50ZXJwb2xhdGlvbiIsICJjcDEiLCAiY3AyIiwgImEiLCAiYiIsICJjIiwgImdldFJpZ2h0VG9MZWZ0QWRhcHRlciIsICJyZWN0WCIsICJzZXRXaWR0aCIsICJ4UGx1cyIsICJsZWZ0Rm9yTHRyIiwgIml0ZW1XaWR0aCIsICJnZXRMZWZ0VG9SaWdodEFkYXB0ZXIiLCAiX2l0ZW1XaWR0aCIsICJnZXRSdGxBZGFwdGVyIiwgIm92ZXJyaWRlVGV4dERpcmVjdGlvbiIsICJkaXJlY3Rpb24iLCAib3JpZ2luYWwiLCAiZ2V0UHJvcGVydHlQcmlvcml0eSIsICJzZXRQcm9wZXJ0eSIsICJwcmV2VGV4dERpcmVjdGlvbiIsICJyZXN0b3JlVGV4dERpcmVjdGlvbiIsICJwcm9wZXJ0eUZuIiwgImJldHdlZW4iLCAiX2FuZ2xlQmV0d2VlbiIsICJjb21wYXJlIiwgIl9hbmdsZURpZmYiLCAibm9ybWFsaXplIiwgIl9ub3JtYWxpemVBbmdsZSIsICJfaXNCZXR3ZWVuIiwgIm5vcm1hbGl6ZVNlZ21lbnQiLCAiZ2V0U2VnbWVudCIsICJzZWdtZW50IiwgInN0YXJ0Qm91bmQiLCAiZW5kQm91bmQiLCAiX2JvdW5kU2VnbWVudCIsICJpbnNpZGUiLCAic3ViU3RhcnQiLCAicHJldlZhbHVlIiwgInN0YXJ0SXNCZWZvcmUiLCAiZW5kSXNCZWZvcmUiLCAic2hvdWxkU3RhcnQiLCAic2hvdWxkU3RvcCIsICJfYm91bmRTZWdtZW50cyIsICJzZWdtZW50cyIsICJzdWIiLCAiZmluZFN0YXJ0QW5kRW5kIiwgInNvbGlkU2VnbWVudHMiLCAibGFzdCIsICJjdXIiLCAic3RvcCIsICJfY29tcHV0ZVNlZ21lbnRzIiwgInNlZ21lbnRPcHRpb25zIiwgIl9sb29wIiwgInNwbGl0QnlTdHlsZXMiLCAiY29tcGxldGVMb29wIiwgIl9mdWxsTG9vcCIsICJkb1NwbGl0QnlTdHlsZXMiLCAiY2hhcnRDb250ZXh0IiwgIl9jaGFydCIsICJiYXNlU3R5bGUiLCAicmVhZFN0eWxlIiwgIl9kYXRhc2V0SW5kZXgiLCAiZGF0YXNldEluZGV4IiwgInByZXZTdHlsZSIsICJhZGRTdHlsZSIsICJsIiwgInN0IiwgImRpciIsICJwMCIsICJwMERhdGFJbmRleCIsICJwMURhdGFJbmRleCIsICJzdHlsZUNoYW5nZWQiLCAiYm9yZGVyQ2FwU3R5bGUiLCAiYm9yZGVyRGFzaCIsICJib3JkZXJEYXNoT2Zmc2V0IiwgImJvcmRlckpvaW5TdHlsZSIsICJyZXBsYWNlciIsICJBbmltYXRvciIsICJjb25zdHJ1Y3RvciIsICJfcmVxdWVzdCIsICJfY2hhcnRzIiwgIk1hcCIsICJfcnVubmluZyIsICJfbGFzdERhdGUiLCAidW5kZWZpbmVkIiwgIl9ub3RpZnkiLCAiY2hhcnQiLCAiYW5pbXMiLCAiZGF0ZSIsICJ0eXBlIiwgImNhbGxiYWNrcyIsICJsaXN0ZW5lcnMiLCAibnVtU3RlcHMiLCAiZHVyYXRpb24iLCAiZm9yRWFjaCIsICJmbiIsICJpbml0aWFsIiwgImN1cnJlbnRTdGVwIiwgIk1hdGgiLCAibWluIiwgInN0YXJ0IiwgIl9yZWZyZXNoIiwgInJlcXVlc3RBbmltRnJhbWUiLCAiY2FsbCIsICJ3aW5kb3ciLCAiX3VwZGF0ZSIsICJEYXRlIiwgIm5vdyIsICJyZW1haW5pbmciLCAicnVubmluZyIsICJpdGVtcyIsICJsZW5ndGgiLCAiaSIsICJkcmF3IiwgIml0ZW0iLCAiX2FjdGl2ZSIsICJfdG90YWwiLCAidGljayIsICJwb3AiLCAiX2dldEFuaW1zIiwgImNoYXJ0cyIsICJnZXQiLCAiY29tcGxldGUiLCAicHJvZ3Jlc3MiLCAic2V0IiwgImxpc3RlbiIsICJldmVudCIsICJjYiIsICJwdXNoIiwgImFkZCIsICJoYXMiLCAicmVkdWNlIiwgImFjYyIsICJjdXIiLCAibWF4IiwgIl9kdXJhdGlvbiIsICJzdG9wIiwgImNhbmNlbCIsICJyZW1vdmUiLCAiZGVsZXRlIiwgInRyYW5zcGFyZW50IiwgImludGVycG9sYXRvcnMiLCAiYm9vbGVhbiIsICJmcm9tIiwgInRvIiwgImZhY3RvciIsICJjb2xvciIsICJjMCIsICJoZWxwZXJzQ29sb3IiLCAiYzEiLCAidmFsaWQiLCAibWl4IiwgImhleFN0cmluZyIsICJudW1iZXIiLCAiQW5pbWF0aW9uIiwgImNmZyIsICJ0YXJnZXQiLCAicHJvcCIsICJjdXJyZW50VmFsdWUiLCAicmVzb2x2ZSIsICJfZm4iLCAiX2Vhc2luZyIsICJlZmZlY3RzIiwgImVhc2luZyIsICJsaW5lYXIiLCAiX3N0YXJ0IiwgImZsb29yIiwgImRlbGF5IiwgIl9sb29wIiwgImxvb3AiLCAiX3RhcmdldCIsICJfcHJvcCIsICJfZnJvbSIsICJfdG8iLCAiX3Byb21pc2VzIiwgImFjdGl2ZSIsICJ1cGRhdGUiLCAiZWxhcHNlZCIsICJyZW1haW4iLCAid2FpdCIsICJwcm9taXNlcyIsICJQcm9taXNlIiwgInJlcyIsICJyZWoiLCAicmVzb2x2ZWQiLCAibWV0aG9kIiwgIkFuaW1hdGlvbnMiLCAiY29uZmlnIiwgIl9jaGFydCIsICJfcHJvcGVydGllcyIsICJjb25maWd1cmUiLCAiaXNPYmplY3QiLCAiYW5pbWF0aW9uT3B0aW9ucyIsICJPYmplY3QiLCAia2V5cyIsICJkZWZhdWx0cyIsICJhbmltYXRpb24iLCAiYW5pbWF0ZWRQcm9wcyIsICJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwgImtleSIsICJvcHRpb24iLCAiaXNBcnJheSIsICJwcm9wZXJ0aWVzIiwgIl9hbmltYXRlT3B0aW9ucyIsICJ2YWx1ZXMiLCAibmV3T3B0aW9ucyIsICJvcHRpb25zIiwgInJlc29sdmVUYXJnZXRPcHRpb25zIiwgImFuaW1hdGlvbnMiLCAiX2NyZWF0ZUFuaW1hdGlvbnMiLCAiJHNoYXJlZCIsICJhd2FpdEFsbCIsICIkYW5pbWF0aW9ucyIsICJ0aGVuIiwgInByb3BzIiwgImNoYXJBdCIsICJ2YWx1ZSIsICJzaXplIiwgImFzc2lnbiIsICJhbmltYXRvciIsICJhbmltIiwgImFsbCIsICJzY2FsZUNsaXAiLCAic2NhbGUiLCAiYWxsb3dlZE92ZXJmbG93IiwgIm9wdHMiLCAicmV2ZXJzZSIsICJlbmQiLCAiZGVmYXVsdENsaXAiLCAieFNjYWxlIiwgInlTY2FsZSIsICJ4IiwgInkiLCAidG9wIiwgInJpZ2h0IiwgImJvdHRvbSIsICJsZWZ0IiwgInRvQ2xpcCIsICJ0IiwgInIiLCAiYiIsICJsIiwgImRpc2FibGVkIiwgImdldFNvcnRlZERhdGFzZXRJbmRpY2VzIiwgImZpbHRlclZpc2libGUiLCAibWV0YXNldHMiLCAiX2dldFNvcnRlZERhdGFzZXRNZXRhcyIsICJpbGVuIiwgImluZGV4IiwgImFwcGx5U3RhY2siLCAic3RhY2siLCAiZHNJbmRleCIsICJzaW5nbGVNb2RlIiwgIm1vZGUiLCAiZGF0YXNldEluZGV4IiwgIm90aGVyVmFsdWUiLCAiaXNGaW5pdGUiLCAic2lnbiIsICJjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkiLCAiZGF0YSIsICJhZGF0YSIsICJBcnJheSIsICJpc1N0YWNrZWQiLCAibWV0YSIsICJzdGFja2VkIiwgImdldFN0YWNrS2V5IiwgImluZGV4U2NhbGUiLCAidmFsdWVTY2FsZSIsICJpZCIsICJnZXRVc2VyQm91bmRzIiwgIm1pbkRlZmluZWQiLCAibWF4RGVmaW5lZCIsICJOdW1iZXIiLCAiTkVHQVRJVkVfSU5GSU5JVFkiLCAiUE9TSVRJVkVfSU5GSU5JVFkiLCAiZ2V0T3JDcmVhdGVTdGFjayIsICJzdGFja3MiLCAic3RhY2tLZXkiLCAiaW5kZXhWYWx1ZSIsICJzdWJTdGFjayIsICJnZXRMYXN0SW5kZXhJblN0YWNrIiwgInZTY2FsZSIsICJwb3NpdGl2ZSIsICJnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyIsICJ1cGRhdGVTdGFja3MiLCAiY29udHJvbGxlciIsICJwYXJzZWQiLCAiX2NhY2hlZE1ldGEiLCAiX3N0YWNrcyIsICJpU2NhbGUiLCAiaUF4aXMiLCAiYXhpcyIsICJ2QXhpcyIsICJpdGVtU3RhY2tzIiwgIl90b3AiLCAiX2JvdHRvbSIsICJ2aXN1YWxWYWx1ZXMiLCAiX3Zpc3VhbFZhbHVlcyIsICJnZXRGaXJzdFNjYWxlSWQiLCAic2NhbGVzIiwgImZpbHRlciIsICJzaGlmdCIsICJjcmVhdGVEYXRhc2V0Q29udGV4dCIsICJwYXJlbnQiLCAiY3JlYXRlQ29udGV4dCIsICJkYXRhc2V0IiwgImNyZWF0ZURhdGFDb250ZXh0IiwgImVsZW1lbnQiLCAiZGF0YUluZGV4IiwgInJhdyIsICJjbGVhclN0YWNrcyIsICJfcGFyc2VkIiwgImlzRGlyZWN0VXBkYXRlTW9kZSIsICJjbG9uZUlmTm90U2hhcmVkIiwgImNhY2hlZCIsICJzaGFyZWQiLCAiY3JlYXRlU3RhY2siLCAiY2FuU3RhY2siLCAiaGlkZGVuIiwgIl9zdGFja2VkIiwgIkRhdGFzZXRDb250cm9sbGVyIiwgIl9jdHgiLCAiY3R4IiwgIl9jYWNoZWREYXRhT3B0cyIsICJnZXRNZXRhIiwgIl90eXBlIiwgIl9wYXJzaW5nIiwgIl9kYXRhIiwgIl9vYmplY3REYXRhIiwgIl9zaGFyZWRPcHRpb25zIiwgIl9kcmF3U3RhcnQiLCAiX2RyYXdDb3VudCIsICJlbmFibGVPcHRpb25TaGFyaW5nIiwgInN1cHBvcnRzRGVjaW1hdGlvbiIsICIkY29udGV4dCIsICJfc3luY0xpc3QiLCAiZGF0YXNldEVsZW1lbnRUeXBlIiwgImRhdGFFbGVtZW50VHlwZSIsICJpbml0aWFsaXplIiwgImxpbmtTY2FsZXMiLCAiYWRkRWxlbWVudHMiLCAiZmlsbCIsICJpc1BsdWdpbkVuYWJsZWQiLCAiY29uc29sZSIsICJ3YXJuIiwgInVwZGF0ZUluZGV4IiwgImdldERhdGFzZXQiLCAiY2hvb3NlSWQiLCAieGlkIiwgInhBeGlzSUQiLCAidmFsdWVPckRlZmF1bHQiLCAieWlkIiwgInlBeGlzSUQiLCAicmlkIiwgInJBeGlzSUQiLCAiaW5kZXhBeGlzIiwgImlpZCIsICJpQXhpc0lEIiwgInZpZCIsICJ2QXhpc0lEIiwgImdldFNjYWxlRm9ySWQiLCAiclNjYWxlIiwgImRhdGFzZXRzIiwgImdldERhdGFzZXRNZXRhIiwgInNjYWxlSUQiLCAiX2dldE90aGVyU2NhbGUiLCAicmVzZXQiLCAiX2Rlc3Ryb3kiLCAidW5saXN0ZW5BcnJheUV2ZW50cyIsICJfZGF0YUNoZWNrIiwgImlzRXh0ZW5zaWJsZSIsICJsaXN0ZW5BcnJheUV2ZW50cyIsICJidWlsZE9yVXBkYXRlRWxlbWVudHMiLCAicmVzZXROZXdFbGVtZW50cyIsICJzdGFja0NoYW5nZWQiLCAib2xkU3RhY2tlZCIsICJfcmVzeW5jRWxlbWVudHMiLCAic2NvcGVLZXlzIiwgImRhdGFzZXRTY29wZUtleXMiLCAic2NvcGVzIiwgImdldE9wdGlvblNjb3BlcyIsICJjcmVhdGVSZXNvbHZlciIsICJnZXRDb250ZXh0IiwgInBhcnNpbmciLCAicGFyc2UiLCAiY291bnQiLCAic29ydGVkIiwgIl9zb3J0ZWQiLCAicHJldiIsICJwYXJzZUFycmF5RGF0YSIsICJwYXJzZU9iamVjdERhdGEiLCAicGFyc2VQcmltaXRpdmVEYXRhIiwgImlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2IiwgImxhYmVscyIsICJnZXRMYWJlbHMiLCAic2luZ2xlU2NhbGUiLCAieEF4aXNLZXkiLCAieUF4aXNLZXkiLCAicmVzb2x2ZU9iamVjdEtleSIsICJnZXRQYXJzZWQiLCAiZ2V0RGF0YUVsZW1lbnQiLCAidXBkYXRlUmFuZ2VGcm9tUGFyc2VkIiwgInJhbmdlIiwgInBhcnNlZFZhbHVlIiwgIk5hTiIsICJnZXRNaW5NYXgiLCAib3RoZXJTY2FsZSIsICJvdGhlck1pbiIsICJvdGhlck1heCIsICJfc2tpcCIsICJnZXRBbGxQYXJzZWRWYWx1ZXMiLCAiZ2V0TWF4T3ZlcmZsb3ciLCAiZ2V0TGFiZWxBbmRWYWx1ZSIsICJsYWJlbCIsICJnZXRMYWJlbEZvclZhbHVlIiwgIl9jbGlwIiwgImNsaXAiLCAiZWxlbWVudHMiLCAiYXJlYSIsICJjaGFydEFyZWEiLCAiZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AiLCAiZ2V0U3R5bGUiLCAicmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyIsICJyZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zIiwgImNvbnRleHQiLCAiX3Jlc29sdmVFbGVtZW50T3B0aW9ucyIsICJlbGVtZW50VHlwZSIsICJjYWNoZSIsICJjYWNoZUtleSIsICJzaGFyaW5nIiwgImRlZmluZWQiLCAiZGF0YXNldEVsZW1lbnRTY29wZUtleXMiLCAicHJlZml4ZXMiLCAibmFtZXMiLCAicmVzb2x2ZU5hbWVkT3B0aW9ucyIsICJmcmVlemUiLCAiX3Jlc29sdmVBbmltYXRpb25zIiwgInRyYW5zaXRpb24iLCAiZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyIsICJfY2FjaGVhYmxlIiwgImdldFNoYXJlZE9wdGlvbnMiLCAiaW5jbHVkZU9wdGlvbnMiLCAic2hhcmVkT3B0aW9ucyIsICJfYW5pbWF0aW9uc0Rpc2FibGVkIiwgIl9nZXRTaGFyZWRPcHRpb25zIiwgImZpcnN0T3B0cyIsICJwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyIsICJ1cGRhdGVTaGFyZWRPcHRpb25zIiwgInVwZGF0ZUVsZW1lbnQiLCAiX3NldFN0eWxlIiwgInJlbW92ZUhvdmVyU3R5bGUiLCAic2V0SG92ZXJTdHlsZSIsICJfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGUiLCAiX3NldERhdGFzZXRIb3ZlclN0eWxlIiwgImFyZzEiLCAiYXJnMiIsICJudW1NZXRhIiwgIm51bURhdGEiLCAiX2luc2VydEVsZW1lbnRzIiwgIl9yZW1vdmVFbGVtZW50cyIsICJtb3ZlIiwgImFyciIsICJ1cGRhdGVFbGVtZW50cyIsICJyZW1vdmVkIiwgInNwbGljZSIsICJfc3luYyIsICJhcmdzIiwgIl9kYXRhQ2hhbmdlcyIsICJfb25EYXRhUHVzaCIsICJhcmd1bWVudHMiLCAiX29uRGF0YVBvcCIsICJfb25EYXRhU2hpZnQiLCAiX29uRGF0YVNwbGljZSIsICJuZXdDb3VudCIsICJfb25EYXRhVW5zaGlmdCIsICJnZXRBbGxTY2FsZVZhbHVlcyIsICJfY2FjaGUiLCAiJGJhciIsICJ2aXNpYmxlTWV0YXMiLCAiY29uY2F0IiwgIl9hcnJheVVuaXF1ZSIsICJzb3J0IiwgImEiLCAiY29tcHV0ZU1pblNhbXBsZVNpemUiLCAiX2xlbmd0aCIsICJjdXJyIiwgInVwZGF0ZU1pbkFuZFByZXYiLCAiYWJzIiwgImdldFBpeGVsRm9yVmFsdWUiLCAidGlja3MiLCAiZ2V0UGl4ZWxGb3JUaWNrIiwgImNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyIsICJydWxlciIsICJzdGFja0NvdW50IiwgInRoaWNrbmVzcyIsICJiYXJUaGlja25lc3MiLCAicmF0aW8iLCAiaXNOdWxsT3JVbmRlZiIsICJjYXRlZ29yeVBlcmNlbnRhZ2UiLCAiYmFyUGVyY2VudGFnZSIsICJjaHVuayIsICJwaXhlbHMiLCAiY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyIsICJuZXh0IiwgInBlcmNlbnQiLCAicGFyc2VGbG9hdEJhciIsICJlbnRyeSIsICJzdGFydFZhbHVlIiwgImVuZFZhbHVlIiwgImJhclN0YXJ0IiwgImJhckVuZCIsICJfY3VzdG9tIiwgInBhcnNlVmFsdWUiLCAicGFyc2VBcnJheU9yUHJpbWl0aXZlIiwgImlzRmxvYXRCYXIiLCAiY3VzdG9tIiwgImJhclNpZ24iLCAiYWN0dWFsQmFzZSIsICJpc0hvcml6b250YWwiLCAiYm9yZGVyUHJvcHMiLCAiaG9yaXpvbnRhbCIsICJiYXNlIiwgInNldEJvcmRlclNraXBwZWQiLCAiZWRnZSIsICJib3JkZXJTa2lwcGVkIiwgImVuYWJsZUJvcmRlclJhZGl1cyIsICJwYXJzZUVkZ2UiLCAic3dhcCIsICJzdGFydEVuZCIsICJvcmlnIiwgInYxIiwgInYyIiwgInYiLCAic2V0SW5mbGF0ZUFtb3VudCIsICJpbmZsYXRlQW1vdW50IiwgIkJhckNvbnRyb2xsZXIiLCAiaUF4aXNLZXkiLCAidkF4aXNLZXkiLCAib2JqIiwgImJhcnMiLCAiZ2V0QmFzZVBpeGVsIiwgIl9nZXRSdWxlciIsICJ2cGl4ZWxzIiwgImhlYWQiLCAiX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzIiwgImlwaXhlbHMiLCAiX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzIiwgImNlbnRlciIsICJoZWlnaHQiLCAid2lkdGgiLCAiX2dldFN0YWNrcyIsICJsYXN0IiwgImdyb3VwZWQiLCAic2tpcE51bGwiLCAidmFsIiwgImlzTmFOIiwgImluZGV4T2YiLCAiX2dldFN0YWNrQ291bnQiLCAiX2dldFN0YWNrSW5kZXgiLCAibmFtZSIsICJfc3RhcnRQaXhlbCIsICJfZW5kUGl4ZWwiLCAiYmFzZVZhbHVlIiwgIm1pbkJhckxlbmd0aCIsICJmbG9hdGluZyIsICJnZXREYXRhVmlzaWJpbGl0eSIsICJzdGFydFBpeGVsIiwgImdldFBpeGVsRm9yRGVjaW1hbCIsICJlbmRQaXhlbCIsICJnZXRWYWx1ZUZvclBpeGVsIiwgImhhbGZHcmlkIiwgImdldExpbmVXaWR0aEZvclZhbHVlIiwgIm1heEJhclRoaWNrbmVzcyIsICJJbmZpbml0eSIsICJzdGFja0luZGV4IiwgInJlY3RzIiwgIm51bWJlcnMiLCAib3ZlcnJpZGVzIiwgIl9pbmRleF8iLCAib2Zmc2V0IiwgImdyaWQiLCAiX3ZhbHVlXyIsICJiZWdpbkF0WmVybyIsICJCdWJibGVDb250cm9sbGVyIiwgInJhZGl1cyIsICJwb2ludHMiLCAicG9pbnQiLCAiaVBpeGVsIiwgInZQaXhlbCIsICJza2lwIiwgImdldFJhdGlvQW5kT2Zmc2V0IiwgInJvdGF0aW9uIiwgImNpcmN1bWZlcmVuY2UiLCAiY3V0b3V0IiwgInJhdGlvWCIsICJyYXRpb1kiLCAib2Zmc2V0WCIsICJvZmZzZXRZIiwgIlRBVSIsICJzdGFydEFuZ2xlIiwgImVuZEFuZ2xlIiwgInN0YXJ0WCIsICJjb3MiLCAic3RhcnRZIiwgInNpbiIsICJlbmRYIiwgImVuZFkiLCAiY2FsY01heCIsICJhbmdsZSIsICJfYW5nbGVCZXR3ZWVuIiwgImNhbGNNaW4iLCAibWF4WCIsICJtYXhZIiwgIkhBTEZfUEkiLCAibWluWCIsICJQSSIsICJtaW5ZIiwgIkRvdWdobnV0Q29udHJvbGxlciIsICJpbm5lclJhZGl1cyIsICJvdXRlclJhZGl1cyIsICJnZXR0ZXIiLCAiX2dldFJvdGF0aW9uIiwgInRvUmFkaWFucyIsICJfZ2V0Q2lyY3VtZmVyZW5jZSIsICJfZ2V0Um90YXRpb25FeHRlbnRzIiwgImlzRGF0YXNldFZpc2libGUiLCAiYXJjcyIsICJzcGFjaW5nIiwgImdldE1heEJvcmRlcldpZHRoIiwgImdldE1heE9mZnNldCIsICJtYXhTaXplIiwgInRvUGVyY2VudGFnZSIsICJjaGFydFdlaWdodCIsICJfZ2V0UmluZ1dlaWdodCIsICJtYXhXaWR0aCIsICJtYXhIZWlnaHQiLCAibWF4UmFkaXVzIiwgInRvRGltZW5zaW9uIiwgInJhZGl1c0xlbmd0aCIsICJfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCIsICJ0b3RhbCIsICJjYWxjdWxhdGVUb3RhbCIsICJfZ2V0UmluZ1dlaWdodE9mZnNldCIsICJfY2lyY3VtZmVyZW5jZSIsICJhbmltYXRlUm90YXRlIiwgImNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UiLCAiYW5pbWF0aW9uT3B0cyIsICJjZW50ZXJYIiwgImNlbnRlclkiLCAiYW5pbWF0ZVNjYWxlIiwgImFyYyIsICJtZXRhRGF0YSIsICJmb3JtYXROdW1iZXIiLCAibG9jYWxlIiwgImJvcmRlckFsaWduIiwgImJvcmRlcldpZHRoIiwgImhvdmVyQm9yZGVyV2lkdGgiLCAiaG92ZXJPZmZzZXQiLCAicmluZ1dlaWdodE9mZnNldCIsICJ3ZWlnaHQiLCAiZGVzY3JpcHRvcnMiLCAiX3NjcmlwdGFibGUiLCAiX2luZGV4YWJsZSIsICJzdGFydHNXaXRoIiwgImFzcGVjdFJhdGlvIiwgInBsdWdpbnMiLCAibGVnZW5kIiwgImdlbmVyYXRlTGFiZWxzIiwgInBvaW50U3R5bGUiLCAibWFwIiwgInN0eWxlIiwgInRleHQiLCAiZmlsbFN0eWxlIiwgImJhY2tncm91bmRDb2xvciIsICJzdHJva2VTdHlsZSIsICJib3JkZXJDb2xvciIsICJmb250Q29sb3IiLCAibGluZVdpZHRoIiwgIm9uQ2xpY2siLCAiZSIsICJsZWdlbmRJdGVtIiwgInRvZ2dsZURhdGFWaXNpYmlsaXR5IiwgIkxpbmVDb250cm9sbGVyIiwgImxpbmUiLCAiX2RhdGFzZXQiLCAiYW5pbWF0aW9uc0Rpc2FibGVkIiwgIl9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzIiwgIl9zY2FsZVJhbmdlc0NoYW5nZWQiLCAiX2RhdGFzZXRJbmRleCIsICJfZGVjaW1hdGVkIiwgInNob3dMaW5lIiwgInNlZ21lbnQiLCAiYW5pbWF0ZWQiLCAic3BhbkdhcHMiLCAibWF4R2FwTGVuZ3RoIiwgImlzTnVtYmVyIiwgImRpcmVjdFVwZGF0ZSIsICJwb2ludHNDb3VudCIsICJwcmV2UGFyc2VkIiwgIm51bGxEYXRhIiwgImJvcmRlciIsICJmaXJzdFBvaW50IiwgImxhc3RQb2ludCIsICJ1cGRhdGVDb250cm9sUG9pbnRzIiwgIlBvbGFyQXJlYUNvbnRyb2xsZXIiLCAiX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlIiwgImJpbmQiLCAiX3VwZGF0ZVJhZGl1cyIsICJtaW5TaXplIiwgImN1dG91dFBlcmNlbnRhZ2UiLCAiZ2V0VmlzaWJsZURhdGFzZXRDb3VudCIsICJ4Q2VudGVyIiwgInlDZW50ZXIiLCAiZGF0YXNldFN0YXJ0QW5nbGUiLCAiZ2V0SW5kZXhBbmdsZSIsICJkZWZhdWx0QW5nbGUiLCAiY291bnRWaXNpYmxlRWxlbWVudHMiLCAiX2NvbXB1dGVBbmdsZSIsICJnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSIsICJhbmdsZUxpbmVzIiwgImRpc3BsYXkiLCAiY2lyY3VsYXIiLCAicG9pbnRMYWJlbHMiLCAiUGllQ29udHJvbGxlciIsICJSYWRhckNvbnRyb2xsZXIiLCAiX2Z1bGxMb29wIiwgInBvaW50UG9zaXRpb24iLCAiZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlIiwgIlNjYXR0ZXJDb250cm9sbGVyIiwgInJlZ2lzdHJ5IiwgImdldEVsZW1lbnQiLCAiaW50ZXJhY3Rpb24iLCAiYWJzdHJhY3QiLCAiRXJyb3IiLCAiRGF0ZUFkYXB0ZXJCYXNlIiwgIm92ZXJyaWRlIiwgIm1lbWJlcnMiLCAicHJvdG90eXBlIiwgImluaXQiLCAiZm9ybWF0cyIsICJmb3JtYXQiLCAiZGlmZiIsICJzdGFydE9mIiwgImVuZE9mIiwgIl9kYXRlIiwgImJpbmFyeVNlYXJjaCIsICJtZXRhc2V0IiwgImludGVyc2VjdCIsICJsb29rdXBNZXRob2QiLCAiX3JldmVyc2VQaXhlbHMiLCAiX3Jsb29rdXBCeUtleSIsICJfbG9va3VwQnlLZXkiLCAiZWwiLCAiZ2V0UmFuZ2UiLCAibG8iLCAiaGkiLCAiZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zIiwgInBvc2l0aW9uIiwgImhhbmRsZXIiLCAiZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcyIsICJqIiwgImdldERpc3RhbmNlTWV0cmljRm9yQXhpcyIsICJ1c2VYIiwgInVzZVkiLCAicHQxIiwgInB0MiIsICJkZWx0YVgiLCAiZGVsdGFZIiwgInNxcnQiLCAicG93IiwgImdldEludGVyc2VjdEl0ZW1zIiwgInVzZUZpbmFsUG9zaXRpb24iLCAiaW5jbHVkZUludmlzaWJsZSIsICJpc1BvaW50SW5BcmVhIiwgImV2YWx1YXRpb25GdW5jIiwgIl9pc1BvaW50SW5BcmVhIiwgImluUmFuZ2UiLCAiZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zIiwgImdldFByb3BzIiwgImdldEFuZ2xlRnJvbVBvaW50IiwgImdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyIsICJkaXN0YW5jZU1ldHJpYyIsICJtaW5EaXN0YW5jZSIsICJnZXRDZW50ZXJQb2ludCIsICJwb2ludEluQXJlYSIsICJkaXN0YW5jZSIsICJnZXROZWFyZXN0SXRlbXMiLCAiZ2V0QXhpc0l0ZW1zIiwgInJhbmdlTWV0aG9kIiwgImludGVyc2VjdHNJdGVtIiwgIm1vZGVzIiwgImdldFJlbGF0aXZlUG9zaXRpb24iLCAibmVhcmVzdCIsICJTVEFUSUNfUE9TSVRJT05TIiwgImZpbHRlckJ5UG9zaXRpb24iLCAiYXJyYXkiLCAicG9zIiwgImZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyIsICJib3giLCAic29ydEJ5V2VpZ2h0IiwgInYwIiwgIndyYXBCb3hlcyIsICJib3hlcyIsICJsYXlvdXRCb3hlcyIsICJzdGFja1dlaWdodCIsICJidWlsZFN0YWNrcyIsICJsYXlvdXRzIiwgIndyYXAiLCAiaW5jbHVkZXMiLCAiX3N0YWNrIiwgInBsYWNlZCIsICJzZXRMYXlvdXREaW1zIiwgInBhcmFtcyIsICJ2Qm94TWF4V2lkdGgiLCAiaEJveE1heEhlaWdodCIsICJsYXlvdXQiLCAiZnVsbFNpemUiLCAiYXZhaWxhYmxlV2lkdGgiLCAiYXZhaWxhYmxlSGVpZ2h0IiwgImJ1aWxkTGF5b3V0Qm94ZXMiLCAiY2VudGVySG9yaXpvbnRhbCIsICJjZW50ZXJWZXJ0aWNhbCIsICJsZWZ0QW5kVG9wIiwgInJpZ2h0QW5kQm90dG9tIiwgInZlcnRpY2FsIiwgImdldENvbWJpbmVkTWF4IiwgIm1heFBhZGRpbmciLCAidXBkYXRlTWF4UGFkZGluZyIsICJib3hQYWRkaW5nIiwgInVwZGF0ZURpbXMiLCAiZ2V0UGFkZGluZyIsICJuZXdXaWR0aCIsICJvdXRlcldpZHRoIiwgIm5ld0hlaWdodCIsICJvdXRlckhlaWdodCIsICJ3aWR0aENoYW5nZWQiLCAidyIsICJoZWlnaHRDaGFuZ2VkIiwgImgiLCAic2FtZSIsICJvdGhlciIsICJoYW5kbGVNYXhQYWRkaW5nIiwgInVwZGF0ZVBvcyIsICJjaGFuZ2UiLCAiZ2V0TWFyZ2lucyIsICJtYXJnaW5Gb3JQb3NpdGlvbnMiLCAicG9zaXRpb25zIiwgIm1hcmdpbiIsICJmaXRCb3hlcyIsICJyZWZpdEJveGVzIiwgInJlZml0IiwgImNoYW5nZWQiLCAic2V0Qm94RGltcyIsICJwbGFjZUJveGVzIiwgInVzZXJQYWRkaW5nIiwgInBhZGRpbmciLCAiYWRkQm94IiwgIl9sYXllcnMiLCAieiIsICJyZW1vdmVCb3giLCAibGF5b3V0SXRlbSIsICJtaW5QYWRkaW5nIiwgInRvUGFkZGluZyIsICJ2ZXJ0aWNhbEJveGVzIiwgImhvcml6b250YWxCb3hlcyIsICJlYWNoIiwgImJlZm9yZUxheW91dCIsICJ2aXNpYmxlVmVydGljYWxCb3hDb3VudCIsICJCYXNlUGxhdGZvcm0iLCAiYWNxdWlyZUNvbnRleHQiLCAiY2FudmFzIiwgInJlbGVhc2VDb250ZXh0IiwgImFkZEV2ZW50TGlzdGVuZXIiLCAibGlzdGVuZXIiLCAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsICJnZXREZXZpY2VQaXhlbFJhdGlvIiwgImdldE1heGltdW1TaXplIiwgImlzQXR0YWNoZWQiLCAidXBkYXRlQ29uZmlnIiwgIkJhc2ljUGxhdGZvcm0iLCAiRVhQQU5ET19LRVkiLCAiRVZFTlRfVFlQRVMiLCAidG91Y2hzdGFydCIsICJ0b3VjaG1vdmUiLCAidG91Y2hlbmQiLCAicG9pbnRlcmVudGVyIiwgInBvaW50ZXJkb3duIiwgInBvaW50ZXJtb3ZlIiwgInBvaW50ZXJ1cCIsICJwb2ludGVybGVhdmUiLCAicG9pbnRlcm91dCIsICJpc051bGxPckVtcHR5IiwgImluaXRDYW52YXMiLCAicmVuZGVySGVpZ2h0IiwgImdldEF0dHJpYnV0ZSIsICJyZW5kZXJXaWR0aCIsICJib3hTaXppbmciLCAiZGlzcGxheVdpZHRoIiwgInJlYWRVc2VkU2l6ZSIsICJkaXNwbGF5SGVpZ2h0IiwgImV2ZW50TGlzdGVuZXJPcHRpb25zIiwgInN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMiLCAicGFzc2l2ZSIsICJhZGRMaXN0ZW5lciIsICJub2RlIiwgInJlbW92ZUxpc3RlbmVyIiwgImZyb21OYXRpdmVFdmVudCIsICJuYXRpdmUiLCAibm9kZUxpc3RDb250YWlucyIsICJub2RlTGlzdCIsICJjb250YWlucyIsICJjcmVhdGVBdHRhY2hPYnNlcnZlciIsICJvYnNlcnZlciIsICJNdXRhdGlvbk9ic2VydmVyIiwgImVudHJpZXMiLCAidHJpZ2dlciIsICJhZGRlZE5vZGVzIiwgInJlbW92ZWROb2RlcyIsICJvYnNlcnZlIiwgImRvY3VtZW50IiwgImNoaWxkTGlzdCIsICJzdWJ0cmVlIiwgImNyZWF0ZURldGFjaE9ic2VydmVyIiwgImRycExpc3RlbmluZ0NoYXJ0cyIsICJvbGREZXZpY2VQaXhlbFJhdGlvIiwgIm9uV2luZG93UmVzaXplIiwgImRwciIsICJkZXZpY2VQaXhlbFJhdGlvIiwgInJlc2l6ZSIsICJjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyIsICJsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyIsICJ1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzIiwgImNyZWF0ZVJlc2l6ZU9ic2VydmVyIiwgImNvbnRhaW5lciIsICJfZ2V0UGFyZW50Tm9kZSIsICJ0aHJvdHRsZWQiLCAiY2xpZW50V2lkdGgiLCAiUmVzaXplT2JzZXJ2ZXIiLCAiY29udGVudFJlY3QiLCAicmVsZWFzZU9ic2VydmVyIiwgImRpc2Nvbm5lY3QiLCAiY3JlYXRlUHJveHlBbmRMaXN0ZW4iLCAicHJveHkiLCAiRG9tUGxhdGZvcm0iLCAicmVtb3ZlQXR0cmlidXRlIiwgInNldEF0dHJpYnV0ZSIsICJwcm94aWVzIiwgIiRwcm94aWVzIiwgImhhbmRsZXJzIiwgImF0dGFjaCIsICJkZXRhY2giLCAiaXNDb25uZWN0ZWQiLCAiX2RldGVjdFBsYXRmb3JtIiwgIl9pc0RvbVN1cHBvcnRlZCIsICJPZmZzY3JlZW5DYW52YXMiLCAiRWxlbWVudCIsICJ0b29sdGlwUG9zaXRpb24iLCAiaGFzVmFsdWUiLCAiZmluYWwiLCAicmV0IiwgImRlZmF1bHRSb3V0ZXMiLCAiYXV0b1NraXAiLCAidGlja09wdHMiLCAiZGV0ZXJtaW5lZE1heFRpY2tzIiwgImRldGVybWluZU1heFRpY2tzIiwgInRpY2tzTGltaXQiLCAibWF4VGlja3NMaW1pdCIsICJtYWpvckluZGljZXMiLCAibWFqb3IiLCAiZW5hYmxlZCIsICJnZXRNYWpvckluZGljZXMiLCAibnVtTWFqb3JJbmRpY2VzIiwgImZpcnN0IiwgIm5ld1RpY2tzIiwgInNraXBNYWpvcnMiLCAiY2FsY3VsYXRlU3BhY2luZyIsICJhdmdNYWpvclNwYWNpbmciLCAicm91bmQiLCAidGlja0xlbmd0aCIsICJfdGlja1NpemUiLCAibWF4U2NhbGUiLCAibWF4Q2hhcnQiLCAiX21heExlbmd0aCIsICJldmVuTWFqb3JTcGFjaW5nIiwgImdldEV2ZW5TcGFjaW5nIiwgImZhY3RvcnMiLCAiX2ZhY3Rvcml6ZSIsICJyZXN1bHQiLCAiY2VpbCIsICJtYWpvclN0YXJ0IiwgIm1ham9yRW5kIiwgImxlbiIsICJyZXZlcnNlQWxpZ24iLCAiYWxpZ24iLCAib2Zmc2V0RnJvbUVkZ2UiLCAiZ2V0VGlja3NMaW1pdCIsICJ0aWNrc0xlbmd0aCIsICJzYW1wbGUiLCAibnVtSXRlbXMiLCAiaW5jcmVtZW50IiwgImdldFBpeGVsRm9yR3JpZExpbmUiLCAib2Zmc2V0R3JpZExpbmVzIiwgInZhbGlkSW5kZXgiLCAiZXBzaWxvbiIsICJsaW5lVmFsdWUiLCAiZ2FyYmFnZUNvbGxlY3QiLCAiY2FjaGVzIiwgImdjIiwgImdjTGVuIiwgImdldFRpY2tNYXJrTGVuZ3RoIiwgImRyYXdUaWNrcyIsICJnZXRUaXRsZUhlaWdodCIsICJmYWxsYmFjayIsICJmb250IiwgInRvRm9udCIsICJsaW5lcyIsICJsaW5lSGVpZ2h0IiwgImNyZWF0ZVNjYWxlQ29udGV4dCIsICJjcmVhdGVUaWNrQ29udGV4dCIsICJ0aXRsZUFsaWduIiwgIl90b0xlZnRSaWdodENlbnRlciIsICJ0aXRsZUFyZ3MiLCAidGl0bGVYIiwgInRpdGxlWSIsICJfYWxpZ25TdGFydEVuZCIsICJwb3NpdGlvbkF4aXNJRCIsICJTY2FsZSIsICJfbWFyZ2lucyIsICJwYWRkaW5nVG9wIiwgInBhZGRpbmdCb3R0b20iLCAicGFkZGluZ0xlZnQiLCAicGFkZGluZ1JpZ2h0IiwgImxhYmVsUm90YXRpb24iLCAiX3JhbmdlIiwgIl9ncmlkTGluZUl0ZW1zIiwgIl9sYWJlbEl0ZW1zIiwgIl9sYWJlbFNpemVzIiwgIl9sb25nZXN0VGV4dENhY2hlIiwgIl91c2VyTWF4IiwgIl91c2VyTWluIiwgIl9zdWdnZXN0ZWRNYXgiLCAiX3N1Z2dlc3RlZE1pbiIsICJfdGlja3NMZW5ndGgiLCAiX2JvcmRlclZhbHVlIiwgIl9kYXRhTGltaXRzQ2FjaGVkIiwgInNldENvbnRleHQiLCAic3VnZ2VzdGVkTWluIiwgInN1Z2dlc3RlZE1heCIsICJmaW5pdGVPckRlZmF1bHQiLCAibWV0YXMiLCAiZ2V0VGlja3MiLCAieExhYmVscyIsICJ5TGFiZWxzIiwgImdldExhYmVsSXRlbXMiLCAiX2NvbXB1dGVMYWJlbEl0ZW1zIiwgImJlZm9yZVVwZGF0ZSIsICJtYXJnaW5zIiwgImdyYWNlIiwgInNhbXBsZVNpemUiLCAiYmVmb3JlU2V0RGltZW5zaW9ucyIsICJzZXREaW1lbnNpb25zIiwgImFmdGVyU2V0RGltZW5zaW9ucyIsICJiZWZvcmVEYXRhTGltaXRzIiwgImRldGVybWluZURhdGFMaW1pdHMiLCAiYWZ0ZXJEYXRhTGltaXRzIiwgIl9hZGRHcmFjZSIsICJiZWZvcmVCdWlsZFRpY2tzIiwgImJ1aWxkVGlja3MiLCAiYWZ0ZXJCdWlsZFRpY2tzIiwgInNhbXBsaW5nRW5hYmxlZCIsICJfY29udmVydFRpY2tzVG9MYWJlbHMiLCAiYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsICJjYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwgImFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsICJzb3VyY2UiLCAiYWZ0ZXJBdXRvU2tpcCIsICJiZWZvcmVGaXQiLCAiZml0IiwgImFmdGVyRml0IiwgImFmdGVyVXBkYXRlIiwgInJldmVyc2VQaXhlbHMiLCAiX2FsaWduVG9QaXhlbHMiLCAiYWxpZ25Ub1BpeGVscyIsICJfY2FsbEhvb2tzIiwgIm5vdGlmeVBsdWdpbnMiLCAiYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uIiwgImdlbmVyYXRlVGlja0xhYmVscyIsICJjYWxsYmFjayIsICJhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiIsICJudW1UaWNrcyIsICJtaW5Sb3RhdGlvbiIsICJtYXhSb3RhdGlvbiIsICJ0aWNrV2lkdGgiLCAibWF4TGFiZWxEaWFnb25hbCIsICJfaXNWaXNpYmxlIiwgImxhYmVsU2l6ZXMiLCAiX2dldExhYmVsU2l6ZXMiLCAibWF4TGFiZWxXaWR0aCIsICJ3aWRlc3QiLCAibWF4TGFiZWxIZWlnaHQiLCAiaGlnaGVzdCIsICJfbGltaXRWYWx1ZSIsICJ0aXRsZSIsICJ0b0RlZ3JlZXMiLCAiYXNpbiIsICJ0aXRsZU9wdHMiLCAiZ3JpZE9wdHMiLCAidGl0bGVIZWlnaHQiLCAidGlja1BhZGRpbmciLCAiYW5nbGVSYWRpYW5zIiwgImxhYmVsSGVpZ2h0IiwgIm1pcnJvciIsICJsYWJlbFdpZHRoIiwgIl9jYWxjdWxhdGVQYWRkaW5nIiwgIl9oYW5kbGVNYXJnaW5zIiwgImlzUm90YXRlZCIsICJsYWJlbHNCZWxvd1RpY2tzIiwgIm9mZnNldExlZnQiLCAib2Zmc2V0UmlnaHQiLCAiaXNGdWxsU2l6ZSIsICJfY29tcHV0ZUxhYmVsU2l6ZXMiLCAid2lkdGhzIiwgImhlaWdodHMiLCAid2lkZXN0TGFiZWxTaXplIiwgImhpZ2hlc3RMYWJlbFNpemUiLCAiamxlbiIsICJ0aWNrRm9udCIsICJmb250U3RyaW5nIiwgIm5lc3RlZExhYmVsIiwgIl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zIiwgInN0cmluZyIsICJfbWVhc3VyZVRleHQiLCAidmFsdWVBdCIsICJpZHgiLCAicGl4ZWwiLCAiZGVjaW1hbCIsICJfaW50MTZSYW5nZSIsICJfYWxpZ25QaXhlbCIsICJnZXREZWNpbWFsRm9yUGl4ZWwiLCAiZ2V0QmFzZVZhbHVlIiwgIm9wdGlvblRpY2tzIiwgInJvdCIsICJhdXRvU2tpcFBhZGRpbmciLCAiX2NvbXB1dGVHcmlkTGluZUl0ZW1zIiwgInRsIiwgImJvcmRlck9wdHMiLCAiYXhpc1dpZHRoIiwgImF4aXNIYWxmV2lkdGgiLCAiYWxpZ25Cb3JkZXJWYWx1ZSIsICJib3JkZXJWYWx1ZSIsICJhbGlnbmVkTGluZVZhbHVlIiwgInR4MSIsICJ0eTEiLCAidHgyIiwgInR5MiIsICJ4MSIsICJ5MSIsICJ4MiIsICJ5MiIsICJsaW1pdCIsICJzdGVwIiwgIm9wdHNBdEluZGV4IiwgIm9wdHNBdEluZGV4Qm9yZGVyIiwgImxpbmVDb2xvciIsICJib3JkZXJEYXNoIiwgImRhc2giLCAiYm9yZGVyRGFzaE9mZnNldCIsICJkYXNoT2Zmc2V0IiwgInRpY2tDb2xvciIsICJ0aWNrQm9yZGVyRGFzaCIsICJ0aWNrQm9yZGVyRGFzaE9mZnNldCIsICJjcm9zc0FsaWduIiwgInRpY2tBbmRQYWRkaW5nIiwgImhUaWNrQW5kUGFkZGluZyIsICJ0ZXh0QWxpZ24iLCAibGluZUNvdW50IiwgInRleHRPZmZzZXQiLCAidGV4dEJhc2VsaW5lIiwgIl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50IiwgIl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50IiwgImxhYmVsT2Zmc2V0IiwgImhhbGZDb3VudCIsICJzdHJva2VDb2xvciIsICJ0ZXh0U3Ryb2tlQ29sb3IiLCAic3Ryb2tlV2lkdGgiLCAidGV4dFN0cm9rZVdpZHRoIiwgInRpY2tUZXh0QWxpZ24iLCAic2hvd0xhYmVsQmFja2Ryb3AiLCAiYmFja2Ryb3AiLCAibGFiZWxQYWRkaW5nIiwgImJhY2tkcm9wUGFkZGluZyIsICJiYWNrZHJvcENvbG9yIiwgInRyYW5zbGF0aW9uIiwgIl9jb21wdXRlTGFiZWxBcmVhIiwgImRyYXdCYWNrZ3JvdW5kIiwgInNhdmUiLCAiZmlsbFJlY3QiLCAicmVzdG9yZSIsICJmaW5kSW5kZXgiLCAiZHJhd0dyaWQiLCAiZHJhd0xpbmUiLCAicDEiLCAicDIiLCAic2V0TGluZURhc2giLCAibGluZURhc2hPZmZzZXQiLCAiYmVnaW5QYXRoIiwgIm1vdmVUbyIsICJsaW5lVG8iLCAic3Ryb2tlIiwgImRyYXdPbkNoYXJ0QXJlYSIsICJkcmF3Qm9yZGVyIiwgImxhc3RMaW5lV2lkdGgiLCAiZHJhd0xhYmVscyIsICJjbGlwQXJlYSIsICJyZW5kZXJUZXh0T3B0aW9ucyIsICJyZW5kZXJUZXh0IiwgInVuY2xpcEFyZWEiLCAiZHJhd1RpdGxlIiwgInR6IiwgImd6IiwgImJ6IiwgImF4aXNJRCIsICJfbWF4RGlnaXRzIiwgImZvbnRTaXplIiwgIlR5cGVkUmVnaXN0cnkiLCAic2NvcGUiLCAiY3JlYXRlIiwgImlzRm9yVHlwZSIsICJpc1Byb3RvdHlwZU9mIiwgInJlZ2lzdGVyIiwgInByb3RvIiwgImdldFByb3RvdHlwZU9mIiwgInBhcmVudFNjb3BlIiwgImlzSUNoYXJ0Q29tcG9uZW50IiwgInJlZ2lzdGVyRGVmYXVsdHMiLCAidW5yZWdpc3RlciIsICJpdGVtRGVmYXVsdHMiLCAibWVyZ2UiLCAicm91dGVEZWZhdWx0cyIsICJkZXNjcmliZSIsICJyb3V0ZXMiLCAicHJvcGVydHkiLCAicHJvcGVydHlQYXJ0cyIsICJzcGxpdCIsICJzb3VyY2VOYW1lIiwgInNvdXJjZVNjb3BlIiwgImpvaW4iLCAicGFydHMiLCAidGFyZ2V0TmFtZSIsICJ0YXJnZXRTY29wZSIsICJyb3V0ZSIsICJSZWdpc3RyeSIsICJjb250cm9sbGVycyIsICJfdHlwZWRSZWdpc3RyaWVzIiwgIl9lYWNoIiwgImFkZENvbnRyb2xsZXJzIiwgImFkZFBsdWdpbnMiLCAiYWRkU2NhbGVzIiwgImdldENvbnRyb2xsZXIiLCAiX2dldCIsICJnZXRQbHVnaW4iLCAiZ2V0U2NhbGUiLCAicmVtb3ZlQ29udHJvbGxlcnMiLCAicmVtb3ZlRWxlbWVudHMiLCAicmVtb3ZlUGx1Z2lucyIsICJyZW1vdmVTY2FsZXMiLCAidHlwZWRSZWdpc3RyeSIsICJhcmciLCAicmVnIiwgIl9nZXRSZWdpc3RyeUZvclR5cGUiLCAiX2V4ZWMiLCAiaXRlbVJlZyIsICJjb21wb25lbnQiLCAiY2FtZWxNZXRob2QiLCAiX2NhcGl0YWxpemUiLCAiUGx1Z2luU2VydmljZSIsICJfaW5pdCIsICJub3RpZnkiLCAiaG9vayIsICJfY3JlYXRlRGVzY3JpcHRvcnMiLCAiX2Rlc2NyaXB0b3JzIiwgImRlc2NyaXB0b3IiLCAicGx1Z2luIiwgImNhbGxDYWxsYmFjayIsICJjYW5jZWxhYmxlIiwgImludmFsaWRhdGUiLCAiX29sZENhY2hlIiwgIl9ub3RpZnlTdGF0ZUNoYW5nZXMiLCAiYWxsUGx1Z2lucyIsICJjcmVhdGVEZXNjcmlwdG9ycyIsICJwcmV2aW91c0Rlc2NyaXB0b3JzIiwgInNvbWUiLCAibG9jYWxJZHMiLCAibG9jYWwiLCAiZ2V0T3B0cyIsICJwbHVnaW5PcHRzIiwgInBsdWdpblNjb3BlS2V5cyIsICJzY3JpcHRhYmxlIiwgImluZGV4YWJsZSIsICJhbGxLZXlzIiwgImdldEluZGV4QXhpcyIsICJkYXRhc2V0RGVmYXVsdHMiLCAiZGF0YXNldE9wdGlvbnMiLCAiZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRCIsICJnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzIiwgImlkTWF0Y2hlc0F4aXMiLCAiYXhpc0Zyb21Qb3NpdGlvbiIsICJkZXRlcm1pbmVBeGlzIiwgInNjYWxlT3B0aW9ucyIsICJ0b0xvd2VyQ2FzZSIsICJnZXRBeGlzRnJvbURhdGFzZXQiLCAicmV0cmlldmVBeGlzRnJvbURhdGFzZXRzIiwgImJvdW5kRHMiLCAiZCIsICJtZXJnZVNjYWxlQ29uZmlnIiwgImNoYXJ0RGVmYXVsdHMiLCAiY29uZmlnU2NhbGVzIiwgImNoYXJ0SW5kZXhBeGlzIiwgInNjYWxlQ29uZiIsICJlcnJvciIsICJfcHJveHkiLCAiZGVmYXVsdElkIiwgImRlZmF1bHRTY2FsZU9wdGlvbnMiLCAibWVyZ2VJZiIsICJkZWZhdWx0SUQiLCAiaW5pdE9wdGlvbnMiLCAiaW5pdERhdGEiLCAiaW5pdENvbmZpZyIsICJrZXlDYWNoZSIsICJrZXlzQ2FjaGVkIiwgIlNldCIsICJjYWNoZWRLZXlzIiwgImdlbmVyYXRlIiwgImFkZElmRm91bmQiLCAiQ29uZmlnIiwgIl9jb25maWciLCAiX3Njb3BlQ2FjaGUiLCAiX3Jlc29sdmVyQ2FjaGUiLCAicGxhdGZvcm0iLCAiY2xlYXJDYWNoZSIsICJjbGVhciIsICJkYXRhc2V0VHlwZSIsICJhZGRpdGlvbmFsT3B0aW9uU2NvcGVzIiwgIl9jYWNoZWRTY29wZXMiLCAibWFpblNjb3BlIiwgInJlc2V0Q2FjaGUiLCAia2V5TGlzdHMiLCAiY2hhcnRPcHRpb25TY29wZXMiLCAicmVzb2x2ZXIiLCAic3ViUHJlZml4ZXMiLCAiZ2V0UmVzb2x2ZXIiLCAibmVlZENvbnRleHQiLCAiaXNGdW5jdGlvbiIsICJzdWJSZXNvbHZlciIsICJfYXR0YWNoQ29udGV4dCIsICJkZXNjcmlwdG9yRGVmYXVsdHMiLCAicmVzb2x2ZXJDYWNoZSIsICJfY3JlYXRlUmVzb2x2ZXIiLCAicCIsICJoYXNGdW5jdGlvbiIsICJpc1NjcmlwdGFibGUiLCAiaXNJbmRleGFibGUiLCAiS05PV05fUE9TSVRJT05TIiwgInBvc2l0aW9uSXNIb3Jpem9udGFsIiwgImNvbXBhcmUyTGV2ZWwiLCAibDEiLCAibDIiLCAib25BbmltYXRpb25zQ29tcGxldGUiLCAib25Db21wbGV0ZSIsICJvbkFuaW1hdGlvblByb2dyZXNzIiwgIm9uUHJvZ3Jlc3MiLCAiZ2V0Q2FudmFzIiwgImdldEVsZW1lbnRCeUlkIiwgImluc3RhbmNlcyIsICJnZXRDaGFydCIsICJjIiwgIm1vdmVOdW1lcmljS2V5cyIsICJpbnRLZXkiLCAiZGV0ZXJtaW5lTGFzdEV2ZW50IiwgImxhc3RFdmVudCIsICJpbkNoYXJ0QXJlYSIsICJpc0NsaWNrIiwgImdldFNpemVGb3JBcmVhIiwgImZpZWxkIiwgImdldERhdGFzZXRBcmVhIiwgIkNoYXJ0IiwgImludmFsaWRhdGVQbHVnaW5zIiwgInVzZXJDb25maWciLCAiaW5pdGlhbENhbnZhcyIsICJleGlzdGluZ0NoYXJ0IiwgInVpZCIsICJfb3B0aW9ucyIsICJfYXNwZWN0UmF0aW8iLCAiX21ldGFzZXRzIiwgIl9sYXN0RXZlbnQiLCAiX2xpc3RlbmVycyIsICJfcmVzcG9uc2l2ZUxpc3RlbmVycyIsICJfc29ydGVkTWV0YXNldHMiLCAiX3BsdWdpbnMiLCAiX2hpZGRlbkluZGljZXMiLCAiYXR0YWNoZWQiLCAiX2RvUmVzaXplIiwgImRlYm91bmNlIiwgInJlc2l6ZURlbGF5IiwgIl9pbml0aWFsaXplIiwgIm1haW50YWluQXNwZWN0UmF0aW8iLCAicmVzcG9uc2l2ZSIsICJyZXRpbmFTY2FsZSIsICJiaW5kRXZlbnRzIiwgImNsZWFyQ2FudmFzIiwgIl9yZXNpemUiLCAiX3Jlc2l6ZUJlZm9yZURyYXciLCAibmV3U2l6ZSIsICJuZXdSYXRpbyIsICJvblJlc2l6ZSIsICJyZW5kZXIiLCAiZW5zdXJlU2NhbGVzSGF2ZUlEcyIsICJzY2FsZXNPcHRpb25zIiwgImF4aXNPcHRpb25zIiwgImJ1aWxkT3JVcGRhdGVTY2FsZXMiLCAic2NhbGVPcHRzIiwgInVwZGF0ZWQiLCAiaXNSYWRpYWwiLCAiZHBvc2l0aW9uIiwgImR0eXBlIiwgInNjYWxlVHlwZSIsICJzY2FsZUNsYXNzIiwgImhhc1VwZGF0ZWQiLCAiX3VwZGF0ZU1ldGFzZXRzIiwgIl9kZXN0cm95RGF0YXNldE1ldGEiLCAic2xpY2UiLCAiX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzIiwgImJ1aWxkT3JVcGRhdGVDb250cm9sbGVycyIsICJuZXdDb250cm9sbGVycyIsICJvcmRlciIsICJ2aXNpYmxlIiwgIkNvbnRyb2xsZXJDbGFzcyIsICJfcmVzZXRFbGVtZW50cyIsICJhbmltc0Rpc2FibGVkIiwgIl91cGRhdGVTY2FsZXMiLCAiX2NoZWNrRXZlbnRCaW5kaW5ncyIsICJfdXBkYXRlSGlkZGVuSW5kaWNlcyIsICJfbWluUGFkZGluZyIsICJhdXRvUGFkZGluZyIsICJfdXBkYXRlTGF5b3V0IiwgIl91cGRhdGVEYXRhc2V0cyIsICJfZXZlbnRIYW5kbGVyIiwgIl91cGRhdGVIb3ZlclN0eWxlcyIsICJleGlzdGluZ0V2ZW50cyIsICJuZXdFdmVudHMiLCAiZXZlbnRzIiwgInNldHNFcXVhbCIsICJ1bmJpbmRFdmVudHMiLCAiY2hhbmdlcyIsICJfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzIiwgImRhdGFzZXRDb3VudCIsICJtYWtlU2V0IiwgImNoYW5nZVNldCIsICJub0FyZWEiLCAiX2lkeCIsICJfdXBkYXRlRGF0YXNldCIsICJsYXllcnMiLCAiX2RyYXdEYXRhc2V0cyIsICJfZHJhd0RhdGFzZXQiLCAidXNlQ2xpcCIsICJnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlIiwgIkludGVyYWN0aW9uIiwgInNldERhdGFzZXRWaXNpYmlsaXR5IiwgIl91cGRhdGVWaXNpYmlsaXR5IiwgImhpZGUiLCAic2hvdyIsICJfc3RvcCIsICJkZXN0cm95IiwgInRvQmFzZTY0SW1hZ2UiLCAidG9EYXRhVVJMIiwgImJpbmRVc2VyRXZlbnRzIiwgImJpbmRSZXNwb25zaXZlRXZlbnRzIiwgIl9hZGQiLCAiX3JlbW92ZSIsICJkZXRhY2hlZCIsICJ1cGRhdGVIb3ZlclN0eWxlIiwgInByZWZpeCIsICJnZXRBY3RpdmVFbGVtZW50cyIsICJzZXRBY3RpdmVFbGVtZW50cyIsICJhY3RpdmVFbGVtZW50cyIsICJsYXN0QWN0aXZlIiwgIl9lbGVtZW50c0VxdWFsIiwgInBsdWdpbklkIiwgInJlcGxheSIsICJob3Zlck9wdGlvbnMiLCAiaG92ZXIiLCAiZGVhY3RpdmF0ZWQiLCAiYWN0aXZhdGVkIiwgImV2ZW50RmlsdGVyIiwgIl9oYW5kbGVFdmVudCIsICJfZ2V0QWN0aXZlRWxlbWVudHMiLCAiX2lzQ2xpY2tFdmVudCIsICJvbkhvdmVyIiwgInZlcnNpb24iLCAiY2xpcEFyYyIsICJwaXhlbE1hcmdpbiIsICJhbmdsZU1hcmdpbiIsICJjbG9zZVBhdGgiLCAidG9SYWRpdXNDb3JuZXJzIiwgIl9yZWFkVmFsdWVUb1Byb3BzIiwgInBhcnNlQm9yZGVyUmFkaXVzIiwgImFuZ2xlRGVsdGEiLCAibyIsICJib3JkZXJSYWRpdXMiLCAiaGFsZlRoaWNrbmVzcyIsICJpbm5lckxpbWl0IiwgImNvbXB1dGVPdXRlckxpbWl0IiwgIm91dGVyQXJjTGltaXQiLCAib3V0ZXJTdGFydCIsICJvdXRlckVuZCIsICJpbm5lclN0YXJ0IiwgImlubmVyRW5kIiwgInJUaGV0YVRvWFkiLCAidGhldGEiLCAicGF0aEFyYyIsICJpbm5lclIiLCAic3BhY2luZ09mZnNldCIsICJhbHBoYSIsICJub1NwYWNpbmdJbm5lclJhZGl1cyIsICJub1NwYWNpbmdPdXRlclJhZGl1cyIsICJhdk5vZ1NwYWNpbmdSYWRpdXMiLCAiYWRqdXN0ZWRBbmdsZSIsICJiZXRhIiwgImFuZ2xlT2Zmc2V0IiwgIm91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cyIsICJvdXRlckVuZEFkanVzdGVkUmFkaXVzIiwgIm91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlIiwgIm91dGVyRW5kQWRqdXN0ZWRBbmdsZSIsICJpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMiLCAiaW5uZXJFbmRBZGp1c3RlZFJhZGl1cyIsICJpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSIsICJpbm5lckVuZEFkanVzdGVkQW5nbGUiLCAib3V0ZXJNaWRBZGp1c3RlZEFuZ2xlIiwgInBDZW50ZXIiLCAicDQiLCAiaW5uZXJNaWRBZGp1c3RlZEFuZ2xlIiwgInA4IiwgIm91dGVyU3RhcnRYIiwgIm91dGVyU3RhcnRZIiwgIm91dGVyRW5kWCIsICJvdXRlckVuZFkiLCAiZHJhd0FyYyIsICJmdWxsQ2lyY2xlcyIsICJib3JkZXJKb2luU3R5bGUiLCAiaW5uZXIiLCAibGluZUpvaW4iLCAiQXJjRWxlbWVudCIsICJjaGFydFgiLCAiY2hhcnRZIiwgInJBZGp1c3QiLCAiYmV0d2VlbkFuZ2xlcyIsICJ3aXRoaW5SYWRpdXMiLCAiX2lzQmV0d2VlbiIsICJoYWxmQW5nbGUiLCAiaGFsZlJhZGl1cyIsICJ0cmFuc2xhdGUiLCAiZml4IiwgInJhZGl1c09mZnNldCIsICJzZXRTdHlsZSIsICJsaW5lQ2FwIiwgImJvcmRlckNhcFN0eWxlIiwgInByZXZpb3VzIiwgImdldExpbmVNZXRob2QiLCAic3RlcHBlZCIsICJfc3RlcHBlZExpbmVUbyIsICJ0ZW5zaW9uIiwgImN1YmljSW50ZXJwb2xhdGlvbk1vZGUiLCAiX2JlemllckN1cnZlVG8iLCAicGF0aFZhcnMiLCAicGFyYW1zU3RhcnQiLCAicGFyYW1zRW5kIiwgInNlZ21lbnRTdGFydCIsICJzZWdtZW50RW5kIiwgIm91dHNpZGUiLCAicGF0aFNlZ21lbnQiLCAibGluZU1ldGhvZCIsICJmYXN0UGF0aFNlZ21lbnQiLCAiYXZnWCIsICJjb3VudFgiLCAicHJldlgiLCAibGFzdFkiLCAicG9pbnRJbmRleCIsICJkcmF3WCIsICJ0cnVuY1giLCAiX2dldFNlZ21lbnRNZXRob2QiLCAidXNlRmFzdFBhdGgiLCAiX2dldEludGVycG9sYXRpb25NZXRob2QiLCAiX3N0ZXBwZWRJbnRlcnBvbGF0aW9uIiwgIl9iZXppZXJJbnRlcnBvbGF0aW9uIiwgIl9wb2ludEluTGluZSIsICJzdHJva2VQYXRoV2l0aENhY2hlIiwgInBhdGgiLCAiX3BhdGgiLCAiUGF0aDJEIiwgInN0cm9rZVBhdGhEaXJlY3QiLCAic2VnbWVudHMiLCAic2VnbWVudE1ldGhvZCIsICJ1c2VQYXRoMkQiLCAiTGluZUVsZW1lbnQiLCAiX3BvaW50cyIsICJfc2VnbWVudHMiLCAiX3BvaW50c1VwZGF0ZWQiLCAiX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMiLCAiX2NvbXB1dGVTZWdtZW50cyIsICJpbnRlcnBvbGF0ZSIsICJfYm91bmRTZWdtZW50cyIsICJfaW50ZXJwb2xhdGUiLCAiaW50ZXJwb2xhdGVkIiwgImNhcEJlemllclBvaW50cyIsICJoaXRSYWRpdXMiLCAiUG9pbnRFbGVtZW50IiwgIm1vdXNlWCIsICJtb3VzZVkiLCAiaW5YUmFuZ2UiLCAiaW5ZUmFuZ2UiLCAiaG92ZXJSYWRpdXMiLCAiZHJhd1BvaW50IiwgImdldEJhckJvdW5kcyIsICJiYXIiLCAiaGFsZiIsICJza2lwT3JMaW1pdCIsICJwYXJzZUJvcmRlcldpZHRoIiwgIm1heFciLCAibWF4SCIsICJ0b1RSQkwiLCAidG9UUkJMQ29ybmVycyIsICJtYXhSIiwgImVuYWJsZUJvcmRlciIsICJ0b3BMZWZ0IiwgInRvcFJpZ2h0IiwgImJvdHRvbUxlZnQiLCAiYm90dG9tUmlnaHQiLCAiYm91bmRpbmdSZWN0cyIsICJib3VuZHMiLCAib3V0ZXIiLCAic2tpcFgiLCAic2tpcFkiLCAic2tpcEJvdGgiLCAiaGFzUmFkaXVzIiwgImFkZE5vcm1hbFJlY3RQYXRoIiwgInJlY3QiLCAiaW5mbGF0ZVJlY3QiLCAiYW1vdW50IiwgInJlZlJlY3QiLCAiQmFyRWxlbWVudCIsICJhZGRSZWN0UGF0aCIsICJhZGRSb3VuZGVkUmVjdFBhdGgiLCAiQk9SREVSX0NPTE9SUyIsICJCQUNLR1JPVU5EX0NPTE9SUyIsICJyZXBsYWNlIiwgImdldEJvcmRlckNvbG9yIiwgImdldEJhY2tncm91bmRDb2xvciIsICJjb2xvcml6ZURlZmF1bHREYXRhc2V0IiwgImNvbG9yaXplRG91Z2hudXREYXRhc2V0IiwgImNvbG9yaXplUG9sYXJBcmVhRGF0YXNldCIsICJnZXRDb2xvcml6ZXIiLCAiY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyIsICJrIiwgImNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbiIsICJmb3JjZU92ZXJyaWRlIiwgIl9hcmdzIiwgImNoYXJ0T3B0aW9ucyIsICJjb2xvcml6ZXIiLCAibHR0YkRlY2ltYXRpb24iLCAic2FtcGxlcyIsICJkZWNpbWF0ZWQiLCAiYnVja2V0V2lkdGgiLCAic2FtcGxlZEluZGV4IiwgImVuZEluZGV4IiwgIm1heEFyZWFQb2ludCIsICJtYXhBcmVhIiwgIm5leHRBIiwgImF2Z1kiLCAiYXZnUmFuZ2VTdGFydCIsICJhdmdSYW5nZUVuZCIsICJhdmdSYW5nZUxlbmd0aCIsICJyYW5nZU9mZnMiLCAicmFuZ2VUbyIsICJwb2ludEF4IiwgInBvaW50QXkiLCAibWluTWF4RGVjaW1hdGlvbiIsICJtaW5JbmRleCIsICJtYXhJbmRleCIsICJzdGFydEluZGV4IiwgInhNaW4iLCAieE1heCIsICJkeCIsICJsYXN0SW5kZXgiLCAiaW50ZXJtZWRpYXRlSW5kZXgxIiwgImludGVybWVkaWF0ZUluZGV4MiIsICJjbGVhbkRlY2ltYXRlZERhdGFzZXQiLCAiZGVmaW5lUHJvcGVydHkiLCAiY29uZmlndXJhYmxlIiwgImVudW1lcmFibGUiLCAid3JpdGFibGUiLCAiY2xlYW5EZWNpbWF0ZWREYXRhIiwgImdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkIiwgInBvaW50Q291bnQiLCAiYWxnb3JpdGhtIiwgImJlZm9yZUVsZW1lbnRzVXBkYXRlIiwgInhBeGlzIiwgInRocmVzaG9sZCIsICJ0cG9pbnRzIiwgIl9maW5kU2VnbWVudEVuZCIsICJfZ2V0Qm91bmRzIiwgInRhcmdldFNlZ21lbnRzIiwgInRndCIsICJzdWJCb3VuZHMiLCAiZmlsbFNvdXJjZXMiLCAiX2JvdW5kU2VnbWVudCIsICJmaWxsU291cmNlIiwgIl9nZXRFZGdlIiwgIl9ub3JtYWxpemVBbmdsZSIsICJfcG9pbnRzRnJvbVNlZ21lbnRzIiwgImJvdW5kYXJ5IiwgImxpbmVQb2ludHMiLCAiX2NyZWF0ZUJvdW5kYXJ5TGluZSIsICJfc2hvdWxkQXBwbHlGaWxsIiwgIl9yZXNvbHZlVGFyZ2V0IiwgInNvdXJjZXMiLCAicHJvcGFnYXRlIiwgInZpc2l0ZWQiLCAiX2RlY29kZUZpbGwiLCAicGFyc2VGaWxsT3B0aW9uIiwgInBhcnNlRmxvYXQiLCAiZGVjb2RlVGFyZ2V0SW5kZXgiLCAiZmlyc3RDaCIsICJfZ2V0VGFyZ2V0UGl4ZWwiLCAiX2dldFRhcmdldFZhbHVlIiwgImZpbGxPcHRpb24iLCAiX2J1aWxkU3RhY2tMaW5lIiwgInNvdXJjZVBvaW50cyIsICJsaW5lc0JlbG93IiwgImdldExpbmVzQmVsb3ciLCAiYWRkUG9pbnRzQmVsb3ciLCAiYmVsb3ciLCAidW5zaGlmdCIsICJzb3VyY2VQb2ludCIsICJwb3N0cG9uZWQiLCAiZmluZFBvaW50IiwgInBvaW50VmFsdWUiLCAiZmlyc3RWYWx1ZSIsICJsYXN0VmFsdWUiLCAic2ltcGxlQXJjIiwgIl9nZXRUYXJnZXQiLCAiZ2V0TGluZUJ5SW5kZXgiLCAiY29tcHV0ZUJvdW5kYXJ5IiwgImNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5IiwgImNvbXB1dGVMaW5lYXJCb3VuZGFyeSIsICJfZHJhd2ZpbGwiLCAibGluZU9wdHMiLCAiYWJvdmUiLCAiZG9GaWxsIiwgImNsaXBWZXJ0aWNhbCIsICJjbGlwWSIsICJsaW5lTG9vcCIsICJzcmMiLCAibm90U2hhcGUiLCAiY2xpcEJvdW5kcyIsICJpbnRlcnBvbGF0ZWRMaW5lVG8iLCAidGFyZ2V0TG9vcCIsICJpbnRlcnBvbGF0ZWRQb2ludCIsICJhZnRlckRhdGFzZXRzVXBkYXRlIiwgIiRmaWxsZXIiLCAiYmVmb3JlRHJhdyIsICJkcmF3VGltZSIsICJiZWZvcmVEYXRhc2V0c0RyYXciLCAiYmVmb3JlRGF0YXNldERyYXciLCAiZ2V0Qm94U2l6ZSIsICJsYWJlbE9wdHMiLCAiYm94SGVpZ2h0IiwgImJveFdpZHRoIiwgInVzZVBvaW50U3R5bGUiLCAicG9pbnRTdHlsZVdpZHRoIiwgIml0ZW1IZWlnaHQiLCAiaXRlbXNFcXVhbCIsICJMZWdlbmQiLCAiX2FkZGVkIiwgImxlZ2VuZEhpdEJveGVzIiwgIl9ob3ZlcmVkSXRlbSIsICJkb3VnaG51dE1vZGUiLCAibGVnZW5kSXRlbXMiLCAiY29sdW1uU2l6ZXMiLCAibGluZVdpZHRocyIsICJidWlsZExhYmVscyIsICJsYWJlbEZvbnQiLCAiX2NvbXB1dGVUaXRsZUhlaWdodCIsICJfZml0Um93cyIsICJfZml0Q29scyIsICJoaXRib3hlcyIsICJ0b3RhbEhlaWdodCIsICJyb3ciLCAiaXRlbVdpZHRoIiwgIm1lYXN1cmVUZXh0IiwgIl9pdGVtSGVpZ2h0IiwgImhlaWdodExpbWl0IiwgInRvdGFsV2lkdGgiLCAiY3VycmVudENvbFdpZHRoIiwgImN1cnJlbnRDb2xIZWlnaHQiLCAiY29sIiwgImNhbGN1bGF0ZUl0ZW1TaXplIiwgImFkanVzdEhpdEJveGVzIiwgInJ0bCIsICJydGxIZWxwZXIiLCAiZ2V0UnRsQWRhcHRlciIsICJoaXRib3giLCAibGVmdEZvckx0ciIsICJfZHJhdyIsICJkZWZhdWx0Q29sb3IiLCAiaGFsZkZvbnRTaXplIiwgImN1cnNvciIsICJkcmF3TGVnZW5kQm94IiwgImxpbmVEYXNoIiwgImRyYXdPcHRpb25zIiwgIlNRUlQyIiwgInhQbHVzIiwgImRyYXdQb2ludExlZ2VuZCIsICJ5Qm94VG9wIiwgInhCb3hMZWZ0IiwgImZpbGxUZXh0IiwgInN0cmlrZXRocm91Z2giLCAib3ZlcnJpZGVUZXh0RGlyZWN0aW9uIiwgInRleHREaXJlY3Rpb24iLCAidGV4dFdpZHRoIiwgInNldFdpZHRoIiwgInJlYWxYIiwgIl90ZXh0WCIsICJmb250TGluZUhlaWdodCIsICJjYWxjdWxhdGVMZWdlbmRJdGVtSGVpZ2h0IiwgInJlc3RvcmVUZXh0RGlyZWN0aW9uIiwgInRpdGxlRm9udCIsICJ0aXRsZVBhZGRpbmciLCAidG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUiLCAiX2dldExlZ2VuZEl0ZW1BdCIsICJoaXRCb3giLCAibGgiLCAiaGFuZGxlRXZlbnQiLCAiaXNMaXN0ZW5lZCIsICJob3ZlcmVkSXRlbSIsICJzYW1lSXRlbSIsICJvbkxlYXZlIiwgImNhbGN1bGF0ZUl0ZW1XaWR0aCIsICJjYWxjdWxhdGVJdGVtSGVpZ2h0IiwgImxlZ2VuZEl0ZW1UZXh0IiwgIl9lbGVtZW50IiwgImFmdGVyRXZlbnQiLCAiY2kiLCAidXNlQm9yZGVyUmFkaXVzIiwgIlRpdGxlIiwgIl9wYWRkaW5nIiwgInRleHRTaXplIiwgIl9kcmF3QXJncyIsICJmb250T3B0cyIsICJjcmVhdGVUaXRsZSIsICJ0aXRsZUJsb2NrIiwgIldlYWtNYXAiLCAicG9zaXRpb25lcnMiLCAiYXZlcmFnZSIsICJ4U2V0IiwgInhBdmVyYWdlIiwgImV2ZW50UG9zaXRpb24iLCAibmVhcmVzdEVsZW1lbnQiLCAiZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIiwgInRwIiwgInB1c2hPckNvbmNhdCIsICJ0b1B1c2giLCAiYXBwbHkiLCAic3BsaXROZXdsaW5lcyIsICJzdHIiLCAiU3RyaW5nIiwgImNyZWF0ZVRvb2x0aXBJdGVtIiwgImZvcm1hdHRlZFZhbHVlIiwgImdldFRvb2x0aXBTaXplIiwgInRvb2x0aXAiLCAiYm9keSIsICJmb290ZXIiLCAiYm9keUZvbnQiLCAiZm9vdGVyRm9udCIsICJ0aXRsZUxpbmVDb3VudCIsICJmb290ZXJMaW5lQ291bnQiLCAiYm9keUxpbmVJdGVtQ291bnQiLCAiY29tYmluZWRCb2R5TGVuZ3RoIiwgImJvZHlJdGVtIiwgImJlZm9yZSIsICJhZnRlciIsICJiZWZvcmVCb2R5IiwgImFmdGVyQm9keSIsICJ0aXRsZVNwYWNpbmciLCAidGl0bGVNYXJnaW5Cb3R0b20iLCAiYm9keUxpbmVIZWlnaHQiLCAiZGlzcGxheUNvbG9ycyIsICJib2R5U3BhY2luZyIsICJmb290ZXJNYXJnaW5Ub3AiLCAiZm9vdGVyU3BhY2luZyIsICJ3aWR0aFBhZGRpbmciLCAibWF4TGluZVdpZHRoIiwgImRldGVybWluZVlBbGlnbiIsICJkb2VzTm90Rml0V2l0aEFsaWduIiwgInhBbGlnbiIsICJjYXJldCIsICJjYXJldFNpemUiLCAiY2FyZXRQYWRkaW5nIiwgImRldGVybWluZVhBbGlnbiIsICJ5QWxpZ24iLCAiY2hhcnRXaWR0aCIsICJkZXRlcm1pbmVBbGlnbm1lbnQiLCAiYWxpZ25YIiwgImFsaWduWSIsICJwYWRkaW5nQW5kU2l6ZSIsICJnZXRCYWNrZ3JvdW5kUG9pbnQiLCAiYWxpZ25tZW50IiwgImNvcm5lclJhZGl1cyIsICJnZXRBbGlnbmVkWCIsICJnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyIsICJjcmVhdGVUb29sdGlwQ29udGV4dCIsICJ0b29sdGlwSXRlbXMiLCAib3ZlcnJpZGVDYWxsYmFja3MiLCAiZGVmYXVsdENhbGxiYWNrcyIsICJiZWZvcmVUaXRsZSIsICJub29wIiwgImxhYmVsQ291bnQiLCAiYWZ0ZXJUaXRsZSIsICJiZWZvcmVMYWJlbCIsICJ0b29sdGlwSXRlbSIsICJsYWJlbENvbG9yIiwgImxhYmVsVGV4dENvbG9yIiwgImJvZHlDb2xvciIsICJsYWJlbFBvaW50U3R5bGUiLCAiYWZ0ZXJMYWJlbCIsICJiZWZvcmVGb290ZXIiLCAiYWZ0ZXJGb290ZXIiLCAiaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2siLCAiVG9vbHRpcCIsICJvcGFjaXR5IiwgIl9ldmVudFBvc2l0aW9uIiwgIl9zaXplIiwgIl9jYWNoZWRBbmltYXRpb25zIiwgIl90b29sdGlwSXRlbXMiLCAiZGF0YVBvaW50cyIsICJjYXJldFgiLCAiY2FyZXRZIiwgImxhYmVsQ29sb3JzIiwgImxhYmVsUG9pbnRTdHlsZXMiLCAibGFiZWxUZXh0Q29sb3JzIiwgImdldFRpdGxlIiwgImdldEJlZm9yZUJvZHkiLCAiZ2V0Qm9keSIsICJib2R5SXRlbXMiLCAic2NvcGVkIiwgImdldEFmdGVyQm9keSIsICJnZXRGb290ZXIiLCAiX2NyZWF0ZUl0ZW1zIiwgIml0ZW1Tb3J0IiwgInBvc2l0aW9uQW5kU2l6ZSIsICJiYWNrZ3JvdW5kUG9pbnQiLCAiZXh0ZXJuYWwiLCAiZHJhd0NhcmV0IiwgInRvb2x0aXBQb2ludCIsICJjYXJldFBvc2l0aW9uIiwgImdldENhcmV0UG9zaXRpb24iLCAieDMiLCAieTMiLCAicHRYIiwgInB0WSIsICJwdCIsICJ0aXRsZUNvbG9yIiwgIl9kcmF3Q29sb3JCb3giLCAiY29sb3JYIiwgInJ0bENvbG9yWCIsICJ5T2ZmU2V0IiwgImNvbG9yWSIsICJtdWx0aUtleUJhY2tncm91bmQiLCAib3V0ZXJYIiwgImlubmVyWCIsICJzdHJva2VSZWN0IiwgImRyYXdCb2R5IiwgImJvZHlBbGlnbiIsICJ4TGluZVBhZGRpbmciLCAiZmlsbExpbmVPZlRleHQiLCAiYm9keUFsaWduRm9yQ2FsY3VsYXRpb24iLCAidGV4dENvbG9yIiwgImRyYXdGb290ZXIiLCAiZm9vdGVyQWxpZ24iLCAiZm9vdGVyQ29sb3IiLCAidG9vbHRpcFNpemUiLCAicXVhZHJhdGljQ3VydmVUbyIsICJfdXBkYXRlQW5pbWF0aW9uVGFyZ2V0IiwgImFuaW1YIiwgImFuaW1ZIiwgIl93aWxsUmVuZGVyIiwgImhhc1Rvb2x0aXBDb250ZW50IiwgImdsb2JhbEFscGhhIiwgInBvc2l0aW9uQ2hhbmdlZCIsICJfcG9zaXRpb25DaGFuZ2VkIiwgIl9pZ25vcmVSZXBsYXlFdmVudHMiLCAiYWZ0ZXJJbml0IiwgImFmdGVyRHJhdyIsICJfZmFsbGJhY2siLCAiYWRkSWZTdHJpbmciLCAiYWRkZWRMYWJlbHMiLCAiZmluZE9yQWRkTGFiZWwiLCAibGFzdEluZGV4T2YiLCAiX2dldExhYmVsRm9yVmFsdWUiLCAiQ2F0ZWdvcnlTY2FsZSIsICJfc3RhcnRWYWx1ZSIsICJfdmFsdWVSYW5nZSIsICJfYWRkZWRMYWJlbHMiLCAiYWRkZWQiLCAiZ2VuZXJhdGVUaWNrcyIsICJnZW5lcmF0aW9uT3B0aW9ucyIsICJkYXRhUmFuZ2UiLCAiTUlOX1NQQUNJTkciLCAicHJlY2lzaW9uIiwgIm1heFRpY2tzIiwgIm1heERpZ2l0cyIsICJpbmNsdWRlQm91bmRzIiwgInVuaXQiLCAibWF4U3BhY2VzIiwgInJtaW4iLCAicm1heCIsICJjb3VudERlZmluZWQiLCAibWluU3BhY2luZyIsICJuaWNlTnVtIiwgIm5pY2VNaW4iLCAibmljZU1heCIsICJudW1TcGFjZXMiLCAiYWxtb3N0V2hvbGUiLCAiYWxtb3N0RXF1YWxzIiwgImRlY2ltYWxQbGFjZXMiLCAiX2RlY2ltYWxQbGFjZXMiLCAicmVsYXRpdmVMYWJlbFNpemUiLCAidGlja1ZhbHVlIiwgInJhZCIsICJMaW5lYXJTY2FsZUJhc2UiLCAiX2VuZFZhbHVlIiwgImhhbmRsZVRpY2tSYW5nZU9wdGlvbnMiLCAic2V0TWluIiwgInNldE1heCIsICJtaW5TaWduIiwgIm1heFNpZ24iLCAiZ2V0VGlja0xpbWl0IiwgInN0ZXBTaXplIiwgImNvbXB1dGVUaWNrTGltaXQiLCAibnVtZXJpY0dlbmVyYXRvck9wdGlvbnMiLCAiX3NldE1pbkFuZE1heEJ5S2V5IiwgIkxpbmVhclNjYWxlIiwgIlRpY2tzIiwgImZvcm1hdHRlcnMiLCAibnVtZXJpYyIsICJsb2cxMEZsb29yIiwgImxvZzEwIiwgImNoYW5nZUV4cG9uZW50IiwgIm0iLCAiaXNNYWpvciIsICJ0aWNrVmFsIiwgInN0ZXBzIiwgInJhbmdlRXhwIiwgInJhbmdlU3RlcCIsICJzdGFydEV4cCIsICJtaW5FeHAiLCAiZXhwIiwgInNpZ25pZmljYW5kIiwgImxhc3RUaWNrIiwgIkxvZ2FyaXRobWljU2NhbGUiLCAiX3plcm8iLCAibG9nYXJpdGhtaWMiLCAiZ2V0VGlja0JhY2tkcm9wSGVpZ2h0IiwgIm1lYXN1cmVMYWJlbFNpemUiLCAiX2xvbmdlc3RUZXh0IiwgImRldGVybWluZUxpbWl0cyIsICJmaXRXaXRoUG9pbnRMYWJlbHMiLCAibGltaXRzIiwgInZhbHVlQ291bnQiLCAiX3BvaW50TGFiZWxzIiwgInBvaW50TGFiZWxPcHRzIiwgImFkZGl0aW9uYWxBbmdsZSIsICJjZW50ZXJQb2ludExhYmVscyIsICJnZXRQb2ludExhYmVsQ29udGV4dCIsICJnZXRQb2ludFBvc2l0aW9uIiwgImRyYXdpbmdBcmVhIiwgInBsRm9udCIsICJoTGltaXRzIiwgInZMaW1pdHMiLCAidXBkYXRlTGltaXRzIiwgInNldENlbnRlclBvaW50IiwgIl9wb2ludExhYmVsSXRlbXMiLCAiYnVpbGRQb2ludExhYmVsSXRlbXMiLCAiY3JlYXRlUG9pbnRMYWJlbEl0ZW0iLCAiaXRlbU9wdHMiLCAib3V0ZXJEaXN0YW5jZSIsICJleHRyYSIsICJwb2ludExhYmVsUG9zaXRpb24iLCAieUZvckFuZ2xlIiwgImdldFRleHRBbGlnbkZvckFuZ2xlIiwgImxlZnRGb3JUZXh0QWxpZ24iLCAiaXNOb3RPdmVybGFwcGVkIiwgImFwZXhlc0luQXJlYSIsICJkcmF3UG9pbnRMYWJlbEJveCIsICJiYWNrZHJvcExlZnQiLCAiYmFja2Ryb3BUb3AiLCAiYmFja2Ryb3BXaWR0aCIsICJiYWNrZHJvcEhlaWdodCIsICJkcmF3UG9pbnRMYWJlbHMiLCAicGF0aFJhZGl1c0xpbmUiLCAiZHJhd1JhZGl1c0xpbmUiLCAiZ3JpZExpbmVPcHRzIiwgImNyZWF0ZVBvaW50TGFiZWxDb250ZXh0IiwgIlJhZGlhbExpbmVhclNjYWxlIiwgImxlZnRNb3ZlbWVudCIsICJyaWdodE1vdmVtZW50IiwgInRvcE1vdmVtZW50IiwgImJvdHRvbU1vdmVtZW50IiwgImFuZ2xlTXVsdGlwbGllciIsICJzY2FsaW5nRmFjdG9yIiwgImdldFZhbHVlRm9yRGlzdGFuY2VGcm9tQ2VudGVyIiwgInNjYWxlZERpc3RhbmNlIiwgInBvaW50TGFiZWwiLCAiZGlzdGFuY2VGcm9tQ2VudGVyIiwgImdldEJhc2VQb3NpdGlvbiIsICJnZXRQb2ludExhYmVsUG9zaXRpb24iLCAicm90YXRlIiwgImFuaW1hdGUiLCAiSU5URVJWQUxTIiwgIm1pbGxpc2Vjb25kIiwgImNvbW1vbiIsICJzZWNvbmQiLCAibWludXRlIiwgImhvdXIiLCAiZGF5IiwgIndlZWsiLCAibW9udGgiLCAicXVhcnRlciIsICJ5ZWFyIiwgIlVOSVRTIiwgInNvcnRlciIsICJpbnB1dCIsICJhZGFwdGVyIiwgIl9hZGFwdGVyIiwgInBhcnNlciIsICJpc29XZWVrZGF5IiwgIl9wYXJzZU9wdHMiLCAiZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyIsICJtaW5Vbml0IiwgImNhcGFjaXR5IiwgImludGVydmFsIiwgIk1BWF9TQUZFX0lOVEVHRVIiLCAiZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmciLCAiZGV0ZXJtaW5lTWFqb3JVbml0IiwgImFkZFRpY2siLCAidGltZSIsICJ0aW1lc3RhbXBzIiwgIl9sb29rdXAiLCAidGltZXN0YW1wIiwgInNldE1ham9yVGlja3MiLCAibWFqb3JVbml0IiwgInRpY2tzRnJvbVRpbWVzdGFtcHMiLCAiVGltZVNjYWxlIiwgIl91bml0IiwgIl9tYWpvclVuaXQiLCAiX29mZnNldHMiLCAiX25vcm1hbGl6ZWQiLCAiYWRhcHRlcnMiLCAiZGlzcGxheUZvcm1hdHMiLCAibm9ybWFsaXplZCIsICJfYXBwbHlCb3VuZHMiLCAiX2dldExhYmVsQm91bmRzIiwgImdldExhYmVsVGltZXN0YW1wcyIsICJ0aW1lT3B0cyIsICJfZ2VuZXJhdGUiLCAiX2ZpbHRlckJldHdlZW4iLCAiX2dldExhYmVsQ2FwYWNpdHkiLCAiaW5pdE9mZnNldHMiLCAib2Zmc2V0QWZ0ZXJBdXRvc2tpcCIsICJnZXREZWNpbWFsRm9yVmFsdWUiLCAibWlub3IiLCAid2Vla2RheSIsICJoYXNXZWVrZGF5IiwgImdldERhdGFUaW1lc3RhbXBzIiwgInRvb2x0aXBGb3JtYXQiLCAiZGF0ZXRpbWUiLCAiZm10IiwgIl90aWNrRm9ybWF0RnVuY3Rpb24iLCAiZm9ybWF0dGVyIiwgIm1pbm9yRm9ybWF0IiwgIm1ham9yRm9ybWF0IiwgIm9mZnNldHMiLCAiX2dldExhYmVsU2l6ZSIsICJ0aWNrc09wdHMiLCAidGlja0xhYmVsV2lkdGgiLCAiY29zUm90YXRpb24iLCAic2luUm90YXRpb24iLCAidGlja0ZvbnRTaXplIiwgImV4YW1wbGVUaW1lIiwgImV4YW1wbGVMYWJlbCIsICJub3JtYWxpemUiLCAidGFibGUiLCAicHJldlNvdXJjZSIsICJuZXh0U291cmNlIiwgInByZXZUYXJnZXQiLCAibmV4dFRhcmdldCIsICJzcGFuIiwgIlRpbWVTZXJpZXNTY2FsZSIsICJfdGFibGUiLCAiX21pblBvcyIsICJfdGFibGVSYW5nZSIsICJfZ2V0VGltZXN0YW1wc0ZvclRhYmxlIiwgImJ1aWxkTG9va3VwVGFibGUiLCAicmVnaXN0ZXJhYmxlcyIsICJ0b3BiYXIiXQp9Cg==
